{"db":[{"meta":{"exported_on":1476885056523,"version":"004"},"data":{"posts":[{"id":1,"uuid":"7773c41c-7513-46d6-a5eb-a1256d0f73a2","title":"关于我","slug":"about","markdown":"一个热爱技术、爱看剧、爱看书的少年！\n\n自我介绍还没想好！\n\n- <a href=\"Mailto:chaochao@m2mbob.cn\">email</a>\n- [gitosc](http://git.oschina.net/m2mbob)\n- [github](https://github.com/xxn520)\n- [segmentfault](https://segmentfault.com/u/m2mbob)\n- [掘金](http://gold.xitu.io/user/57ba8052a34131005b0eac60)","html":"<p>一个热爱技术、爱看剧、爱看书的少年！</p>\n\n<p>自我介绍还没想好！</p>\n\n<ul>\n<li><a href=\"Mailto:chaochao@m2mbob.cn\">email</a></li>\n<li><a href=\"http://git.oschina.net/m2mbob\">gitosc</a></li>\n<li><a href=\"https://github.com/xxn520\">github</a></li>\n<li><a href=\"https://segmentfault.com/u/m2mbob\">segmentfault</a></li>\n<li><a href=\"http://gold.xitu.io/user/57ba8052a34131005b0eac60\">掘金</a></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1463567128012,"created_by":1,"updated_at":1475398238211,"updated_by":1,"published_at":1463567100000,"published_by":1},{"id":2,"uuid":"9a9d44c4-cfa6-45eb-85aa-0ad8e81d4389","title":"redux源码分析系列之compose.js","slug":"compose-js","markdown":"## compose.js\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=27566686&auto=1&height=66\"></iframe>\n\n听宝宝的话要早点睡，所以就先写最简单的一个哈😳！废话不多说先贴源码：\n\n```\nexport default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  } else {\n    const last = funcs[funcs.length - 1]\n    const rest = funcs.slice(0, -1)\n    return (...args) => rest.reduceRight((composed, f) => f(composed), last(...args))\n  }\n}\n```\n\n先来看看代码的意思，如果没有传入函数，则返回了一个接受参数并原样返回的函数；如果传入的函数数组长度大于0，则取出右边的函数为`last`，其余的为`rest`，然后返回一个函数。这个函数用`last(...args)`为高阶函数`reduceRight`迭代的初始值进行迭代，每次迭代的结果将被传入下一个函数充当参数。\n> 注：`reduceRight`为es5引入的方法，使用形式如下Array.reduceRight((prev,current,index,array) => (...), initialValue)，它会为数组中的元素从右向左执行回调方法。\n\n举例来说，有三个函数`a,b,c`，参数为args，`f=compose(a,b,c)`，`f(...args)`执行的效果就和`a(b(c(...args)))`一样，目的就是将多个函数组合起来。在redux中像`middleware`、`reducer`等多处使用到了compose。不早了，今天先到这哈😀！\n\n","html":"<h2 id=\"composejs\">compose.js</h2>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=27566686&auto=1&height=66\"></iframe>\n\n<p>听宝宝的话要早点睡，所以就先写最简单的一个哈😳！废话不多说先贴源码：</p>\n\n<pre><code>export default function compose(...funcs) {  \n  if (funcs.length === 0) {\n    return arg =&gt; arg\n  } else {\n    const last = funcs[funcs.length - 1]\n    const rest = funcs.slice(0, -1)\n    return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))\n  }\n}\n</code></pre>\n\n<p>先来看看代码的意思，如果没有传入函数，则返回了一个接受参数并原样返回的函数；如果传入的函数数组长度大于0，则取出右边的函数为<code>last</code>，其余的为<code>rest</code>，然后返回一个函数。这个函数用<code>last(...args)</code>为高阶函数<code>reduceRight</code>迭代的初始值进行迭代，每次迭代的结果将被传入下一个函数充当参数。</p>\n\n<blockquote>\n  <p>注：<code>reduceRight</code>为es5引入的方法，使用形式如下Array.reduceRight((prev,current,index,array) => (...), initialValue)，它会为数组中的元素从右向左执行回调方法。</p>\n</blockquote>\n\n<p>举例来说，有三个函数<code>a,b,c</code>，参数为args，<code>f=compose(a,b,c)</code>，<code>f(...args)</code>执行的效果就和<code>a(b(c(...args)))</code>一样，目的就是将多个函数组合起来。在redux中像<code>middleware</code>、<code>reducer</code>等多处使用到了compose。不早了，今天先到这哈😀！</p>","image":"/content/images/2016/05/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67-2.png","featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1463567445619,"created_by":1,"updated_at":1473918309062,"updated_by":1,"published_at":1463755965662,"published_by":1},{"id":3,"uuid":"4cfddac0-e27b-478d-a53e-21edf2583e73","title":"mac木有随意行的解决方案——实践篇","slug":"macmu-you-sui-yi-xing-de-jie-jue-fang-an-shi-jian-pian","markdown":"由于把旧的电脑带回家了，宝宝再也不能够在床上玩电脑了，可恶的是还要配置mac的网络。万恶的移动没有提供mac版的随意行，因此需要自己设置vpn，可怕！宝宝慌了，还好凭借宝宝的聪明脑瓜，把网络配置好了，先拿出来分享。至于其中原理，宝宝还要研究研究，下次分享哈！\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=26590186&auto=1&height=66\"></iframe>\n\n#### 第一步 买一个端口转换器\n\n> 注：附上我的购买链接[点我点我。](https://detail.tmall.com/item.htm?_u=l22095huca16&id=524667361946)不过这个上网网速还不如实验室2M小水管，建议大家上京东买正版，可恶的奎君周不早说😒！\n\n#### 第二步 连接网线、端口转换器、usb端口\n\n> 此时会自动产生如下图选中的Apple USB Ethernet Adapter。\n\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f776b73grwj31140vadl6.jpg)\n\n#### 第三步 选择此处的创建PPPoE服务\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f776e04d0qj31140vatf6.jpg)\n\n#### 第四步 设置PPPoE服务相关参数，也就是宽带连接的用户名密码\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f776bw1r5qj31140va44m.jpg)\n\n#### 第五步 创建vpn，选择IPSec上的L2TP\n\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f776eeuu5qj31140va44u.jpg)\n\n### 第六步 设置vpn相关参数，服务器地址和账户名，密码，并把高级设置里的通过VPN发送所有流量钩上\n\n![](https://ws4.sinaimg.cn/large/006bH5BKgw1f776eulgsgj31140va0yw.jpg)\n\n### 第七步 增加 /etc/ppp/options 配置文件，内容如下图\n\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f776fek55yj30vo0p2mz7.jpg)\n\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f776fqp7x6j30vo0p275d.jpg)\n","html":"<p>由于把旧的电脑带回家了，宝宝再也不能够在床上玩电脑了，可恶的是还要配置mac的网络。万恶的移动没有提供mac版的随意行，因此需要自己设置vpn，可怕！宝宝慌了，还好凭借宝宝的聪明脑瓜，把网络配置好了，先拿出来分享。至于其中原理，宝宝还要研究研究，下次分享哈！</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=26590186&auto=1&height=66\"></iframe>\n\n<h4 id=\"\">第一步 买一个端口转换器</h4>\n\n<blockquote>\n  <p>注：附上我的购买链接<a href=\"https://detail.tmall.com/item.htm?_u=l22095huca16&amp;id=524667361946\">点我点我。</a>不过这个上网网速还不如实验室2M小水管，建议大家上京东买正版，可恶的奎君周不早说😒！</p>\n</blockquote>\n\n<h4 id=\"usb\">第二步 连接网线、端口转换器、usb端口</h4>\n\n<blockquote>\n  <p>此时会自动产生如下图选中的Apple USB Ethernet Adapter。</p>\n</blockquote>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f776b73grwj31140vadl6.jpg\" alt=\"\" /></p>\n\n<h4 id=\"pppoe\">第三步 选择此处的创建PPPoE服务</h4>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f776e04d0qj31140vatf6.jpg\" alt=\"\" /></p>\n\n<h4 id=\"pppoe\">第四步 设置PPPoE服务相关参数，也就是宽带连接的用户名密码</h4>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f776bw1r5qj31140va44m.jpg\" alt=\"\" /></p>\n\n<h4 id=\"vpnipsecl2tp\">第五步 创建vpn，选择IPSec上的L2TP</h4>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f776eeuu5qj31140va44u.jpg\" alt=\"\" /></p>\n\n<h3 id=\"vpnvpn\">第六步 设置vpn相关参数，服务器地址和账户名，密码，并把高级设置里的通过VPN发送所有流量钩上</h3>\n\n<p><img src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f776eulgsgj31140va0yw.jpg\" alt=\"\" /></p>\n\n<h3 id=\"etcpppoptions\">第七步 增加 /etc/ppp/options 配置文件，内容如下图</h3>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f776fek55yj30vo0p2mz7.jpg\" alt=\"\" /></p>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f776fqp7x6j30vo0p275d.jpg\" alt=\"\" /></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1463834942922,"created_by":1,"updated_at":1473918298141,"updated_by":1,"published_at":1463837040160,"published_by":1},{"id":4,"uuid":"52d5cb6e-e34b-46a8-a91f-adda39d7e944","title":"mac安装mongodb","slug":"macan-zhuang-mongodb","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=41665696&auto=1&height=66\"></iframe>\n\n#### 安装Homebrew\n　　Homebrew是Mac OSX下一个包依赖管理工具，用它来安装软件非常的方便只需要brew install 软件名这一条命令就可以将你所需要的软件安装好，不用再操心安装过程中软件的依赖问题，这些问题Homebrew统统帮你搞定。Homebrew安装方法也很简单：打开终端，然后输入命令\n　　\n<!--bash-->\n\truby -e \"$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)\"\n\n#### 安装mongodb\n　　如果是之前就已经安装好的Homebrew，那先要更新一下库：\n　　\n<!--bash-->\n\tbrew update\n　　然后执行下面命令安装mongodb：\n　　\n<!--bash-->\n\tbrew install mongodb\n　　--with-openssl参数表示通过ssl源安装，--devel表示安装最新开发版。此时通过mongod --config /usr/local/etc/mongodb.conf命令已经可以启动。（3.0.7版本是如此。）\n\n#### 遇到的几个问题\n1.\t我第一次安装完以后，装了Robomongo，但是在连接时发现了bug，一直Authorization skip by you的错误。然后改dbpath、logpath等等操作，都不奏效，就把mongodb玩坏了。最后google得到Robomongo还不支持mongodb3，解决方案在此[http://http://liyanjie918.blog.163.com/blog/static/2022729020156261410274/](http://http://liyanjie918.blog.163.com/blog/static/2022729020156261410274/ \"使用Robomongo 连接MongoDB 3.x 报 Authorization failed 解决办法\")\n2.\t可能还会遇到找不到/data/db路径，这是mongdb在之前版本时默认的dbpath，如果安装的是2.*的版本可能就会遇到这个问题，就需要:mkdir -p /data/db\n另外，最后还会有一个权限问题，用sudo chmod R 当前用户名 /data 命令能够解决。\n3.\t大致问题如上，出现这些问题主要还是对mac系统文件和权限等不熟，已经太久没有动mongo，所以也有点生疏了。","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=41665696&auto=1&height=66\"></iframe>\n\n<h4 id=\"homebrew\">安装Homebrew</h4>\n\n　　Homebrew是Mac OSX下一个包依赖管理工具，用它来安装软件非常的方便只需要brew install 软件名这一条命令就可以将你所需要的软件安装好，不用再操心安装过程中软件的依赖问题，这些问题Homebrew统统帮你搞定。Homebrew安装方法也很简单：打开终端，然后输入命令\n　　\n<!--bash-->  \n\n<pre><code>ruby -e \"$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)\"\n</code></pre>\n\n<h4 id=\"mongodb\">安装mongodb</h4>\n\n　　如果是之前就已经安装好的Homebrew，那先要更新一下库：\n　　\n<!--bash-->  \n\n<pre><code>brew update\n</code></pre>\n\n　　然后执行下面命令安装mongodb：\n　　\n<!--bash-->  \n\n<pre><code>brew install mongodb\n</code></pre>\n\n<p>　　--with-openssl参数表示通过ssl源安装，--devel表示安装最新开发版。此时通过mongod --config /usr/local/etc/mongodb.conf命令已经可以启动。（3.0.7版本是如此。）</p>\n\n<h4 id=\"\">遇到的几个问题</h4>\n\n<ol>\n<li>我第一次安装完以后，装了Robomongo，但是在连接时发现了bug，一直Authorization skip by you的错误。然后改dbpath、logpath等等操作，都不奏效，就把mongodb玩坏了。最后google得到Robomongo还不支持mongodb3，解决方案在此<a href=\"http://http://liyanjie918.blog.163.com/blog/static/2022729020156261410274/\" title=\"使用Robomongo 连接MongoDB 3.x 报 Authorization failed 解决办法\">http://http://liyanjie918.blog.163.com/blog/static/2022729020156261410274/</a>  </li>\n<li>可能还会遇到找不到/data/db路径，这是mongdb在之前版本时默认的dbpath，如果安装的是2.*的版本可能就会遇到这个问题，就需要:mkdir -p /data/db <br />\n另外，最后还会有一个权限问题，用sudo chmod R 当前用户名 /data 命令能够解决。</li>\n<li>大致问题如上，出现这些问题主要还是对mac系统文件和权限等不熟，已经太久没有动mongo，所以也有点生疏了。</li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1463838003388,"created_by":1,"updated_at":1473918271679,"updated_by":1,"published_at":1463838208563,"published_by":1},{"id":5,"uuid":"2b51ebd5-cda4-4792-b84e-5874f72d42a2","title":"koa1源码分析之Application","slug":"koa1yuan-ma-fen-xi-zhi-application","markdown":"##Application\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=32507038&auto=1&height=66\"></iframe>\n\n原来写的文章，迁移过来，还是koa1的，koa2也出了，待更新。\n\n###依赖\n\n-    debug：debug源码分析；\n-    compose_es7：与co.wrap相似，不过能够接受 async/await 函数；\n-    onFinished：捕捉finish或error事件，并根据第二个参数执行回调；\n-    compose：compose_es7的简化版，只接受generator；\n-    isJSON：顾名思义，判断传入参数是否为JSON；\n-    statuses：将http码分为三类，redirect、empty以及retry，然后根据传入的http来判断属于哪一类；\n-    accepts：根据req的内容判断（content negotiation）字段，如accept,Accept-Encoding,Accept-Language等字段对这些字段进行格式化，方便后续处理；\n-    only：只返回在传入参数里所包含的字段；\n-    co：co源码解析\n\n###构造器源码\n\n<!--javascript-->\n\t/**\n\t * Initialize a new `Application`.\n\t *\n\t * @api public\n\t */\n\tfunction Application() {\n\t  if (!(this instanceof Application)) return new Application;\n\t  this.env = process.env.NODE_ENV || 'development';\n\t  this.subdomainOffset = 2;\n\t  this.middleware = [];\n\t  this.proxy = false;\n\t  this.context = Object.create(context);\n\t  this.request = Object.create(request);\n\t  this.response = Object.create(response);\n\t}\n\n上面koa的Application的构造函数，可以看到在创建Application时有初始化如下属性：\n\n1.    env表示是开发环境还是生产环境，通过process.env.NODE_ENV读取环境变量中的参数设置，如果没有设置默认为开发环境\n2.    subdomainOffset，表示子域名的偏移，默认为2\n3.    proxy如果为true，则解析 \"Host\" 的 header 域，并支持X-Forwarded-Host，默认为false。\n4.    context上下文\n5.    request请求对象\n6.  response响应对象\n\n#### 有哪些方法\n\n#### app.listen\n\n<!--javascript-->\n\t/**\n\t * Shorthand for:\n\t *\n\t *    http.createServer(app.callback()).listen(...)\n\t *\n\t * @param {Mixed} ...\n\t * @return {Server}\n\t * @api public\n\t */\n\tapp.listen = function(){\n\t  debug('listen');\n\t  var server = http.createServer(this.callback());\n\t  return server.listen.apply(server, arguments);\n\t};\n\n　　这个方法调用了node原生的http模块创建了一个server，要关注的是传入的这个callback。\n\n\n\n#### app.callback\n<!--javascript-->\n\n\t/**\t\n\t * Return a request handler callback\n\t * for node's native http server.\n\t *\n\t * @return {Function}\n\t * @api public\n\t */\n\tapp.callback = function(){\n\t  var fn = this.experimental\n\t    ? compose_es7(this.middleware)\n\t    : co.wrap(compose(this.middleware));\n\t  var self = this;\n\t  if (!this.listeners('error').length) this.on('error', this.onerror);\n\t  return function(req, res){\n\t    res.statusCode = 404;\n\t    var ctx = self.createContext(req, res);\n\t    onFinished(res, ctx.onerror);\n\t    fn.call(ctx).then(function () {\n\t      respond.call(ctx);\n\t    }).catch(ctx.onerror);\n\t  }\n\t};\n\n　　返回一个适合 http.createServer() 方法的回调函数用来处理请求。 您也可以使用这个回调函数将您的app挂载在 Connect/Express 应用上。一点点看下来，this.middleware是中间件的一个数组，用co.wrap或者compose_es7进行包装，co是tj大神的一个用来包装执行generator函数的库，而compose_es7应该是es7可能会引入的相似功能的特性，不同的是后者支持es7的async/await。后面一句处理错误，最后是返回一个请求处理函数。在函数中会调用createContext创建上下文，用onFinished模块捕捉finish或error事件，并根据第二个参数执行回调。然后调用co包装返回的promise对象进行中间件的调用，调用就由co来进行。调用成功后执行调用respond函数。\n\n#### 最后就来看看respond函数\n\n<!--javascript-->\n\n\t/**\t\n\t * Response helper.\n\t */\n\tfunction respond() {\n\t  // allow bypassing koa\n\t  if (false === this.respond) return;\n\t  var res = this.res;\n\t  if (res.headersSent || !this.writable) return;\n\t  var body = this.body;\n\t  var code = this.status;\n\t  // ignore body\n\t  if (statuses.empty[code]) {\n\t    // strip headers\n\t    this.body = null;\n\t    return res.end();\n\t  }\n\t  if ('HEAD' == this.method) {\n\t    if (isJSON(body)) this.length = Buffer.byteLength(JSON.stringify(body));\n\t    return res.end();\n\t  }\n\t  // status body\n\t  if (null == body) {\n\t    this.type = 'text';\n\t    body = this.message || String(code);\n\t    this.length = Buffer.byteLength(body);\n\t    return res.end(body);\n\t  }\n\t  // responses\n\t  if (Buffer.isBuffer(body)) return res.end(body);\n\t  if ('string' == typeof body) return res.end(body);\n\t  if (body instanceof Stream) return body.pipe(res);\n\t  // body: json\n\t  body = JSON.stringify(body);\n\t  this.length = Buffer.byteLength(body);\n\t  res.end(body);\n\t}\n\n　　在1.0.0版本中respond函数第一行就是yield *next，也就是一开始不执行，到所有中间件执行完后对res进行处理。但co进入4.*以后，用promise代替了thunk函数的实现，返回一个promise，因此当前1.1.2版本中的respond函数的调用写在了co返回的promise的第一个回调中。\n\n#### 其它\n\n-    app.use向中间件数组中添加中间件\n-    app.createContext创建请求上下文\n-    app.inspect/toJSON返回配置的参数subdomainOffset、proxy和env。","html":"<h2 id=\"application\">Application</h2>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=32507038&auto=1&height=66\"></iframe>\n\n<p>原来写的文章，迁移过来，还是koa1的，koa2也出了，待更新。</p>\n\n<h3 id=\"\">依赖</h3>\n\n<ul>\n<li>debug：debug源码分析；</li>\n<li>compose_es7：与co.wrap相似，不过能够接受 async/await 函数；</li>\n<li>onFinished：捕捉finish或error事件，并根据第二个参数执行回调；</li>\n<li>compose：compose_es7的简化版，只接受generator；</li>\n<li>isJSON：顾名思义，判断传入参数是否为JSON；</li>\n<li>statuses：将http码分为三类，redirect、empty以及retry，然后根据传入的http来判断属于哪一类；</li>\n<li>accepts：根据req的内容判断（content negotiation）字段，如accept,Accept-Encoding,Accept-Language等字段对这些字段进行格式化，方便后续处理；</li>\n<li>only：只返回在传入参数里所包含的字段；</li>\n<li>co：co源码解析</li>\n</ul>\n\n<h3 id=\"\">构造器源码</h3>\n\n<!--javascript-->  \n\n<pre><code>/**\n * Initialize a new `Application`.\n *\n * @api public\n */\nfunction Application() {\n  if (!(this instanceof Application)) return new Application;\n  this.env = process.env.NODE_ENV || 'development';\n  this.subdomainOffset = 2;\n  this.middleware = [];\n  this.proxy = false;\n  this.context = Object.create(context);\n  this.request = Object.create(request);\n  this.response = Object.create(response);\n}\n</code></pre>\n\n<p>上面koa的Application的构造函数，可以看到在创建Application时有初始化如下属性：</p>\n\n<ol>\n<li>env表示是开发环境还是生产环境，通过process.env.NODE_ENV读取环境变量中的参数设置，如果没有设置默认为开发环境  </li>\n<li>subdomainOffset，表示子域名的偏移，默认为2  </li>\n<li>proxy如果为true，则解析 \"Host\" 的 header 域，并支持X-Forwarded-Host，默认为false。  </li>\n<li>context上下文  </li>\n<li>request请求对象  </li>\n<li>response响应对象</li>\n</ol>\n\n<h4 id=\"\">有哪些方法</h4>\n\n<h4 id=\"applisten\">app.listen</h4>\n\n<!--javascript-->  \n\n<pre><code>/**\n * Shorthand for:\n *\n *    http.createServer(app.callback()).listen(...)\n *\n * @param {Mixed} ...\n * @return {Server}\n * @api public\n */\napp.listen = function(){\n  debug('listen');\n  var server = http.createServer(this.callback());\n  return server.listen.apply(server, arguments);\n};\n</code></pre>\n\n<p>　　这个方法调用了node原生的http模块创建了一个server，要关注的是传入的这个callback。</p>\n\n<h4 id=\"appcallback\">app.callback</h4>\n\n<!--javascript-->\n\n<pre><code>/** \n * Return a request handler callback\n * for node's native http server.\n *\n * @return {Function}\n * @api public\n */\napp.callback = function(){\n  var fn = this.experimental\n    ? compose_es7(this.middleware)\n    : co.wrap(compose(this.middleware));\n  var self = this;\n  if (!this.listeners('error').length) this.on('error', this.onerror);\n  return function(req, res){\n    res.statusCode = 404;\n    var ctx = self.createContext(req, res);\n    onFinished(res, ctx.onerror);\n    fn.call(ctx).then(function () {\n      respond.call(ctx);\n    }).catch(ctx.onerror);\n  }\n};\n</code></pre>\n\n<p>　　返回一个适合 http.createServer() 方法的回调函数用来处理请求。 您也可以使用这个回调函数将您的app挂载在 Connect/Express 应用上。一点点看下来，this.middleware是中间件的一个数组，用co.wrap或者compose<em>es7进行包装，co是tj大神的一个用来包装执行generator函数的库，而compose</em>es7应该是es7可能会引入的相似功能的特性，不同的是后者支持es7的async/await。后面一句处理错误，最后是返回一个请求处理函数。在函数中会调用createContext创建上下文，用onFinished模块捕捉finish或error事件，并根据第二个参数执行回调。然后调用co包装返回的promise对象进行中间件的调用，调用就由co来进行。调用成功后执行调用respond函数。</p>\n\n<h4 id=\"respond\">最后就来看看respond函数</h4>\n\n<!--javascript-->\n\n<pre><code>/** \n * Response helper.\n */\nfunction respond() {\n  // allow bypassing koa\n  if (false === this.respond) return;\n  var res = this.res;\n  if (res.headersSent || !this.writable) return;\n  var body = this.body;\n  var code = this.status;\n  // ignore body\n  if (statuses.empty[code]) {\n    // strip headers\n    this.body = null;\n    return res.end();\n  }\n  if ('HEAD' == this.method) {\n    if (isJSON(body)) this.length = Buffer.byteLength(JSON.stringify(body));\n    return res.end();\n  }\n  // status body\n  if (null == body) {\n    this.type = 'text';\n    body = this.message || String(code);\n    this.length = Buffer.byteLength(body);\n    return res.end(body);\n  }\n  // responses\n  if (Buffer.isBuffer(body)) return res.end(body);\n  if ('string' == typeof body) return res.end(body);\n  if (body instanceof Stream) return body.pipe(res);\n  // body: json\n  body = JSON.stringify(body);\n  this.length = Buffer.byteLength(body);\n  res.end(body);\n}\n</code></pre>\n\n<p>　　在1.0.0版本中respond函数第一行就是yield <em>next，也就是一开始不执行，到所有中间件执行完后对res进行处理。但co进入4.</em>以后，用promise代替了thunk函数的实现，返回一个promise，因此当前1.1.2版本中的respond函数的调用写在了co返回的promise的第一个回调中。</p>\n\n<h4 id=\"\">其它</h4>\n\n<ul>\n<li>app.use向中间件数组中添加中间件</li>\n<li>app.createContext创建请求上下文</li>\n<li>app.inspect/toJSON返回配置的参数subdomainOffset、proxy和env。</li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1463838292023,"created_by":1,"updated_at":1473918260244,"updated_by":1,"published_at":1463838479996,"published_by":1},{"id":6,"uuid":"9a4be2b6-a671-4302-99fe-d0a54af86417","title":"Yesterday's","slug":"yesterday","markdown":"T团20周年的开场曲，晚上写作业时又拿出来循环播放，听完又是元气满满的一天呀！歌词很棒，拿出来分享分享！\n看到网易云音乐的评论里，一个考研党在2015年9月24日23点33发了一句“正在考研的我听着每一句都是泪”，到4月13日他又评论了一句“我考上了”，中间没有任何别的回复，但多了4个赞。我看到这莫名地就释然了，点了个赞，继续写作业去了，很奇妙的感受，我叫它感同身受！\n20周年那一版因为版权无法生成外链，只有下面这个版本了，不过也很不错！\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=22690729&auto=1&height=66\"></iframe>\n\n風の無い夜の公園で 動かないブランコ達は<br>\n在无风的夜晚公园里 不会摇晃的秋千们<br>\n与此刻的自己 有着可怕的相似<br>\n恐い位似てるんだよ 今の僕自身に<br>\n欲しい物は山ほどある<br>\n想要的东西如山般高<br>\n但手中却什么也没有<br>\nだけど欠片(かけら)も手にできず<br>\n無くしてきた 色んな夢を探してる<br>\n只是搜寻着 那些消逝的梦想<br>\n弱さは人の運命(さだめ)だと<br>\n命运两字是人生的无奈<br>\nなんとなく気付いてるけど<br>\n似乎我也注意到了<br>\n「支えられたい、支えてみたい」忙しく思うよ<br>\n却不停的想着「能撑得，在撑撑看」<br>\n強がる事に不器用で<br>\n就算是徒费力气<br>\n空回りしてもいいから<br>\n硬撑也无所谓<br>\n我只是想不断追寻 那变化多端的未来<br>\n追い続けたい 色んな形の未来を<br>\n觉得容易的事情却意外地<br>\n容易(たやす)く思える事が意外に結構<br>\n无法简单得手<br>\n手に入れるのが難しく思える<br>\n这难道不是跟盯着自己的脚步<br>\nそれってもしかして自分の足元を<br>\n見つめてみればきっと転がってんじゃない<br>\n就会摔跤是一样的道理吗<br>\n激しい雨が降った後にはきれいな花が咲く<br>\n在倾盆大雨过后 娇艳的花儿即将绽放<br>\nあきらめたりしない 届くはずさ想いは<br>\n千万不要放弃 因为梦想即将到达<br>\nそしていっそ昨日までの自分を捨て去ろう<br>\n然后索性忘却到昨天为止的自己吧<br>\n静けさを引き裂くように 空き缶を強く蹴り飛ばす<br>\n仿佛是要将寂静撕裂 狠狠的将罐子踢飞<br>\n胸に秘めた 色んな迷いを詰め込んで<br>\n深藏在内心的 是满满的各种迷茫<br>\n結果だけにしがみついていたよずっと<br>\n一直以来总是只紧抓住结果不放<br>\nプロセスなんか馬鹿らしく思えて<br>\n觉得过程什么的都不重要<br>\n残缺的月 带着勇敢的微笑<br>\n満ち欠ける月のけなげな微笑み<br>\n看吧 太阳一定依旧在你眼前升起<br>\n日はまた昇るきっと目の前にほら<br>\n頬を伝ったどんな涙も大きな価値がある<br>\n脸颊上滑落的 是无价眼泪带来的讯息<br>\n二度とない時を負けないように進むよ<br>\n怀着仅此一次绝不认输的心情前进<br>\n激しい雨が降った後にはきれいな花が咲く<br>\n在大雨倾盆过后 娇艳的花儿即将绽放<br>\nあきらめたりしない 届くはずさ願いは<br>\n千万不要放弃 因为梦想即将到达<br>\nそしていっそ昨日までの自分を捨て去ろう<br>\n然后索性忘却到昨天为止的自己吧<br>\n遠くない近くない捉えずらいホントにいつもやっかいもんは自分<br>\n最难琢磨的是那忽远忽近难以搞定的真实的自己<br>\nそれでも向き合って生きていかなきゃダメさ<br>\n但是不好好奋斗下去是不行的<br>\nだから「昨日までの自分を捨て去ろう」って唄おう<br>\n所以 就让我们唱着「忘却到昨天为止的自己吧」<br>\nいつかはどんな部分(こころ)も愛せる気がするよ<br>\n无论何时 无论何地都感受到爱<br>\n何が起こっても構わない荒波に打たれても<br>\n无论发生任何事 就算是再大的风浪<br>\n僕は信じている最終形の自分を<br>\n我始终相信着最真实的自己<br>\nどれ位こうしてたんだろう<br>\n到底这样过了多久<br>\n街は息を吹き返した<br>\n整个街道重新开始呼吸<br>\n不思議なんだ僕の胸に光がともってく<br>\n不可思议的是我的心也渐渐亮了起来<br>\nそよぎはじめていた風が淋しさを全部連れ去り<br>\n徐徐吹起的微风将一切寂寞带走<br>\n踊りだしたブランコ達も笑ってる<br>\n跳起舞来的秋千们也露出笑意<br>","html":"<p>T团20周年的开场曲，晚上写作业时又拿出来循环播放，听完又是元气满满的一天呀！歌词很棒，拿出来分享分享！ <br />\n看到网易云音乐的评论里，一个考研党在2015年9月24日23点33发了一句“正在考研的我听着每一句都是泪”，到4月13日他又评论了一句“我考上了”，中间没有任何别的回复，但多了4个赞。我看到这莫名地就释然了，点了个赞，继续写作业去了，很奇妙的感受，我叫它感同身受！\n20周年那一版因为版权无法生成外链，只有下面这个版本了，不过也很不错！</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=22690729&auto=1&height=66\"></iframe>\n\n<p>風の無い夜の公園で 動かないブランコ達は<br>\n在无风的夜晚公园里 不会摇晃的秋千们<br>\n与此刻的自己 有着可怕的相似<br>\n恐い位似てるんだよ 今の僕自身に<br>\n欲しい物は山ほどある<br>\n想要的东西如山般高<br>\n但手中却什么也没有<br>\nだけど欠片(かけら)も手にできず<br>\n無くしてきた 色んな夢を探してる<br>\n只是搜寻着 那些消逝的梦想<br>\n弱さは人の運命(さだめ)だと<br>\n命运两字是人生的无奈<br>\nなんとなく気付いてるけど<br>\n似乎我也注意到了<br>\n「支えられたい、支えてみたい」忙しく思うよ<br>\n却不停的想着「能撑得，在撑撑看」<br>\n強がる事に不器用で<br>\n就算是徒费力气<br>\n空回りしてもいいから<br>\n硬撑也无所谓<br>\n我只是想不断追寻 那变化多端的未来<br>\n追い続けたい 色んな形の未来を<br>\n觉得容易的事情却意外地<br>\n容易(たやす)く思える事が意外に結構<br>\n无法简单得手<br>\n手に入れるのが難しく思える<br>\n这难道不是跟盯着自己的脚步<br>\nそれってもしかして自分の足元を<br>\n見つめてみればきっと転がってんじゃない<br>\n就会摔跤是一样的道理吗<br>\n激しい雨が降った後にはきれいな花が咲く<br>\n在倾盆大雨过后 娇艳的花儿即将绽放<br>\nあきらめたりしない 届くはずさ想いは<br>\n千万不要放弃 因为梦想即将到达<br>\nそしていっそ昨日までの自分を捨て去ろう<br>\n然后索性忘却到昨天为止的自己吧<br>\n静けさを引き裂くように 空き缶を強く蹴り飛ばす<br>\n仿佛是要将寂静撕裂 狠狠的将罐子踢飞<br>\n胸に秘めた 色んな迷いを詰め込んで<br>\n深藏在内心的 是满满的各种迷茫<br>\n結果だけにしがみついていたよずっと<br>\n一直以来总是只紧抓住结果不放<br>\nプロセスなんか馬鹿らしく思えて<br>\n觉得过程什么的都不重要<br>\n残缺的月 带着勇敢的微笑<br>\n満ち欠ける月のけなげな微笑み<br>\n看吧 太阳一定依旧在你眼前升起<br>\n日はまた昇るきっと目の前にほら<br>\n頬を伝ったどんな涙も大きな価値がある<br>\n脸颊上滑落的 是无价眼泪带来的讯息<br>\n二度とない時を負けないように進むよ<br>\n怀着仅此一次绝不认输的心情前进<br>\n激しい雨が降った後にはきれいな花が咲く<br>\n在大雨倾盆过后 娇艳的花儿即将绽放<br>\nあきらめたりしない 届くはずさ願いは<br>\n千万不要放弃 因为梦想即将到达<br>\nそしていっそ昨日までの自分を捨て去ろう<br>\n然后索性忘却到昨天为止的自己吧<br>\n遠くない近くない捉えずらいホントにいつもやっかいもんは自分<br>\n最难琢磨的是那忽远忽近难以搞定的真实的自己<br>\nそれでも向き合って生きていかなきゃダメさ<br>\n但是不好好奋斗下去是不行的<br>\nだから「昨日までの自分を捨て去ろう」って唄おう<br>\n所以 就让我们唱着「忘却到昨天为止的自己吧」<br>\nいつかはどんな部分(こころ)も愛せる気がするよ<br>\n无论何时 无论何地都感受到爱<br>\n何が起こっても構わない荒波に打たれても<br>\n无论发生任何事 就算是再大的风浪<br>\n僕は信じている最終形の自分を<br>\n我始终相信着最真实的自己<br>\nどれ位こうしてたんだろう<br>\n到底这样过了多久<br>\n街は息を吹き返した<br>\n整个街道重新开始呼吸<br>\n不思議なんだ僕の胸に光がともってく<br>\n不可思议的是我的心也渐渐亮了起来<br>\nそよぎはじめていた風が淋しさを全部連れ去り<br>\n徐徐吹起的微风将一切寂寞带走<br>\n踊りだしたブランコ達も笑ってる<br>\n跳起舞来的秋千们也露出笑意<br></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1463918607786,"created_by":1,"updated_at":1473918251634,"updated_by":1,"published_at":1463919661601,"published_by":1},{"id":7,"uuid":"d4620769-971a-4d03-b3f7-dac29ab33ead","title":"Fetch API 异常处理","slug":"liu-lan-qi-xia-zai-google-playde-apk","markdown":"江边跑了几公里，有点累🙄，不过今天的风儿真喧嚣啊！发现江边有个地方和动漫里还挺像，就在那块草坪上坐了坐🤗。好了不费话了，写完还要洗澡！\n\n继之前服务端 Jersey 的异常处理之后，这篇要谈谈我在 react native 客户端 Fetch API 中进行异常处理遇到的一些问题！总所周知，Fetch 是使用 Promise 进行异步的编写的，所以这个问题其实也就是 Promise 的异常处理了！\n\n`Promise.prototype.catch` 这个方法就是用来捕获调用链上的异常的，但是在使用中还是有比较多的坑的。首先，这个方法是 `.then(null, rejection)` 的别名，或者说语法糖应该也可以吧！\n\n几个注意点：\n\n1. 如果 Promise 状态已经变成 Resolved ，再抛出错误是无效的；\n2. Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。\n3. 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。\n4. *需要注意的是，catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。*\n\n这是 ES6 入门中，阮一峰老师提到的几个比较重要的点。然后我来讲讲我总结的 Fetch 中使用 catch 捕获异常的最佳实践，也是我目前的做法：\n\n1. 首先建议使用 catch 而不是 Promise 的第二个参数，由 catch 统一处理调用链上的异常；\n2. 第二注意 catch 返回的是一个新的 Promise，因此如果想要在封装的 Rest 类中统一 catch 处理异常是不行的，因为此处处理了异常后，后面的业务逻辑还是会执行，就可能导致一些意外的错误。即使在此处统一抛出一个新的异常，那么在后面调用时还是需要再 catch，这是得不偿失的。所以建议还是统一在每个调用后面单独处理；\n3. 当然，单独处理的逻辑可以提取公共的，减少下一次维护的成本和代码量。\n\n因为探讨的是我所在 app 的场景，而我又自己封装了 Fetch，因此可能上面的说法存在一些难懂的地方。但是原则是一致的，用 catch 不用 reject，单独处理，抽取公共逻辑。","html":"<p>江边跑了几公里，有点累🙄，不过今天的风儿真喧嚣啊！发现江边有个地方和动漫里还挺像，就在那块草坪上坐了坐🤗。好了不费话了，写完还要洗澡！</p>\n\n<p>继之前服务端 Jersey 的异常处理之后，这篇要谈谈我在 react native 客户端 Fetch API 中进行异常处理遇到的一些问题！总所周知，Fetch 是使用 Promise 进行异步的编写的，所以这个问题其实也就是 Promise 的异常处理了！</p>\n\n<p><code>Promise.prototype.catch</code> 这个方法就是用来捕获调用链上的异常的，但是在使用中还是有比较多的坑的。首先，这个方法是 <code>.then(null, rejection)</code> 的别名，或者说语法糖应该也可以吧！</p>\n\n<p>几个注意点：</p>\n\n<ol>\n<li>如果 Promise 状态已经变成 Resolved ，再抛出错误是无效的；  </li>\n<li>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。  </li>\n<li>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。  </li>\n<li><em>需要注意的是，catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。</em></li>\n</ol>\n\n<p>这是 ES6 入门中，阮一峰老师提到的几个比较重要的点。然后我来讲讲我总结的 Fetch 中使用 catch 捕获异常的最佳实践，也是我目前的做法：</p>\n\n<ol>\n<li>首先建议使用 catch 而不是 Promise 的第二个参数，由 catch 统一处理调用链上的异常；  </li>\n<li>第二注意 catch 返回的是一个新的 Promise，因此如果想要在封装的 Rest 类中统一 catch 处理异常是不行的，因为此处处理了异常后，后面的业务逻辑还是会执行，就可能导致一些意外的错误。即使在此处统一抛出一个新的异常，那么在后面调用时还是需要再 catch，这是得不偿失的。所以建议还是统一在每个调用后面单独处理；  </li>\n<li>当然，单独处理的逻辑可以提取公共的，减少下一次维护的成本和代码量。</li>\n</ol>\n\n<p>因为探讨的是我所在 app 的场景，而我又自己封装了 Fetch，因此可能上面的说法存在一些难懂的地方。但是原则是一致的，用 catch 不用 reject，单独处理，抽取公共逻辑。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1464107300210,"created_by":1,"updated_at":1471011841046,"updated_by":1,"published_at":1471011841047,"published_by":1},{"id":8,"uuid":"b8b11fe7-0536-434c-ab84-10bfa539d770","title":"转：Reactjs 的 PropTypes 使用方法","slug":"zhuan-reactjs-de-proptypes-shi-yong-fang-fa","markdown":"### Reactjs 的 PropTypes 使用方法\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=35528482&auto=1&height=66\"></iframe>\n\npropTypes 使用来规范组件Props的类型\n\n```\n var Test = React.createClass({\n  propTypes: {\n    // required\n    requiredFunc: React.PropTypes.func.isRequired,\n    requiredAny: React.PropTypes.any.isRequired,\n\n    // primitives, optional by default\n    bool: React.PropTypes.bool,\n    func: React.PropTypes.func,\n    number: React.PropTypes.number,\n    string: React.PropTypes.string,\n  },\n  render:function(){\n  return <div/>\n  }\n});\n\nvar component = React.render(\n        <Test requiredFunc=\"bar\" bool=\"true\" requiredAny=\"a\"/>, \n    document.body\n);\n```\n\n若没有按照规范，会显示警告。\n\n```\nReact.PropTypes 的种类\nReact.PropTypes.array           // 数组\nReact.PropTypes.bool.isRequired // Boolean 且必要。\nReact.PropTypes.func            // 函数\nReact.PropTypes.number          // 数字\nReact.PropTypes.object          // 对象\nReact.PropTypes.string          // 字符串\nReact.PropTypes.any            // 任何类型的: numbers, strings, elements等\nReact.PropTypes.element         // React 元素\nReact.PropTypes.instanceOf(XXX) // 某种XXX类型的实体\nReact.PropTypes.oneOf(['foo', 'bar']) // 其中一个字符串\nReact.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.array]) // 其中一种类型\nReact.PropTypes.arrayOf(React.PropTypes.string)  // 某种类型的数组\nReact.PropTypes.objectOf(React.PropTypes.string) // 某种类型的对象\nReact.PropTypes.shape({                          // 是否符合指定的格式\n  color: React.PropTypes.string,\n  fontSize: React.PropTypes.number\n});\nReact.PropTypes.any.isRequired  // 可以是任何格式，且必要。\n\n// 自定义格式(当不符合的时候，会显示Error) \n// 不要用`console.warn` 或者 throw, 因为它在`oneOfType` 的情况下无效。\ncustomPropType: function(props, propName, componentName) {\n  if (!/^[0-9]/.test(props[propName])) {\n    return new Error('Validation failed!');\n  }\n}\n```\n\ngetDefaultProps\n\n当父组件没有提供props的属性时，可以采用getDefaultProps，预设props属性的方式，让元件使用预设的值，确保有props带入。\n\n```\n var ComponentWithDefaultProps = React.createClass({ \n    getDefaultProps : function () { \n        return {\n                value : 'default value' \n              }; \n    }, \n    /* ... */ \n});\n```\n\nPosted by James Yang March 19, 2015   ReactJS","html":"<h3 id=\"reactjsproptypes\">Reactjs 的 PropTypes 使用方法</h3>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=35528482&auto=1&height=66\"></iframe>\n\n<p>propTypes 使用来规范组件Props的类型</p>\n\n<pre><code> var Test = React.createClass({\n  propTypes: {\n    // required\n    requiredFunc: React.PropTypes.func.isRequired,\n    requiredAny: React.PropTypes.any.isRequired,\n\n    // primitives, optional by default\n    bool: React.PropTypes.bool,\n    func: React.PropTypes.func,\n    number: React.PropTypes.number,\n    string: React.PropTypes.string,\n  },\n  render:function(){\n  return &lt;div/&gt;\n  }\n});\n\nvar component = React.render(  \n        &lt;Test requiredFunc=\"bar\" bool=\"true\" requiredAny=\"a\"/&gt;, \n    document.body\n);\n</code></pre>\n\n<p>若没有按照规范，会显示警告。</p>\n\n<pre><code>React.PropTypes 的种类  \nReact.PropTypes.array           // 数组  \nReact.PropTypes.bool.isRequired // Boolean 且必要。  \nReact.PropTypes.func            // 函数  \nReact.PropTypes.number          // 数字  \nReact.PropTypes.object          // 对象  \nReact.PropTypes.string          // 字符串  \nReact.PropTypes.any            // 任何类型的: numbers, strings, elements等  \nReact.PropTypes.element         // React 元素  \nReact.PropTypes.instanceOf(XXX) // 某种XXX类型的实体  \nReact.PropTypes.oneOf(['foo', 'bar']) // 其中一个字符串  \nReact.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.array]) // 其中一种类型  \nReact.PropTypes.arrayOf(React.PropTypes.string)  // 某种类型的数组  \nReact.PropTypes.objectOf(React.PropTypes.string) // 某种类型的对象  \nReact.PropTypes.shape({                          // 是否符合指定的格式  \n  color: React.PropTypes.string,\n  fontSize: React.PropTypes.number\n});\nReact.PropTypes.any.isRequired  // 可以是任何格式，且必要。\n\n// 自定义格式(当不符合的时候，会显示Error) \n// 不要用`console.warn` 或者 throw, 因为它在`oneOfType` 的情况下无效。\ncustomPropType: function(props, propName, componentName) {  \n  if (!/^[0-9]/.test(props[propName])) {\n    return new Error('Validation failed!');\n  }\n}\n</code></pre>\n\n<p>getDefaultProps</p>\n\n<p>当父组件没有提供props的属性时，可以采用getDefaultProps，预设props属性的方式，让元件使用预设的值，确保有props带入。</p>\n\n<pre><code> var ComponentWithDefaultProps = React.createClass({ \n    getDefaultProps : function () { \n        return {\n                value : 'default value' \n              }; \n    }, \n    /* ... */ \n});\n</code></pre>\n\n<p>Posted by James Yang March 19, 2015   ReactJS</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1464234823225,"created_by":1,"updated_at":1473918230619,"updated_by":1,"published_at":1464247836046,"published_by":1},{"id":9,"uuid":"727848e2-4e25-4943-bb82-5a6f2bba13b5","title":"什么是视差滚动","slug":"shi-yao-shi-shi-chai-gun-dong","markdown":"下午在研究facebook今年f8大会上开源的基于react native的f8app的时候看到一个ParallaxBackground组件，不明觉厉啊！于是查了一下单词Parallax，意思为视差，所以ParallaxBackground其实是一个视差的背景，最后我把目光落到了视差滚动。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=385757&auto=1&height=66\"></iframe>\n\n视差滚动是近些年国外web design中的一种潮流，它能够提高网页的立体性。它是如何运作的呢！上百度百科。\n> 视差效果，原本是一个天文学术语，当我们观察星空时，离我们远的星星移动速度较慢，离我们近的星星移动速度则较快。当我们坐在车上向车窗外 看时，也会有这样的感觉，远处的群山似乎没有在动，而近处的稻田却在飞速掠过。许多游戏中都使用视差效果来增加场景的立体感。说的简单点就是网页内的元素在滚动屏幕时发生的位置的变化，然而各个不同的元素位置变化的速度不同，导致网页内的元素有层次错落的错觉，这和我们人体的眼球效果很像。我看到多家产品商用视差滚动效果来展示产品，从不同的空间角度和用户体验，起到了非常不错的效果。 目前这种视差滚动效果被越来越多的国外网站所应用， 成为网页设计的热点趋势。 通过一个很长的网页页面，其中利用一些令人惊叹的插图和图形，并使用视差滚动（Parallax Scrolling）效果，让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。完美的展示了一个复杂的过程，让你犹如置身其中。\n\n百度百科看了还是木有很深刻的认识，那看看下面这个例子你一定会说“噢，来是这样”。[点我点我](http://hotdot.pro/#)\n\n在我看来视差滚动其实是通过页面多层次不同速度的滚动来达到一种视觉上的落差，使人感到页面有一种立体感！","html":"<p>下午在研究facebook今年f8大会上开源的基于react native的f8app的时候看到一个ParallaxBackground组件，不明觉厉啊！于是查了一下单词Parallax，意思为视差，所以ParallaxBackground其实是一个视差的背景，最后我把目光落到了视差滚动。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=385757&auto=1&height=66\"></iframe>\n\n<p>视差滚动是近些年国外web design中的一种潮流，它能够提高网页的立体性。它是如何运作的呢！上百度百科。</p>\n\n<blockquote>\n  <p>视差效果，原本是一个天文学术语，当我们观察星空时，离我们远的星星移动速度较慢，离我们近的星星移动速度则较快。当我们坐在车上向车窗外 看时，也会有这样的感觉，远处的群山似乎没有在动，而近处的稻田却在飞速掠过。许多游戏中都使用视差效果来增加场景的立体感。说的简单点就是网页内的元素在滚动屏幕时发生的位置的变化，然而各个不同的元素位置变化的速度不同，导致网页内的元素有层次错落的错觉，这和我们人体的眼球效果很像。我看到多家产品商用视差滚动效果来展示产品，从不同的空间角度和用户体验，起到了非常不错的效果。 目前这种视差滚动效果被越来越多的国外网站所应用， 成为网页设计的热点趋势。 通过一个很长的网页页面，其中利用一些令人惊叹的插图和图形，并使用视差滚动（Parallax Scrolling）效果，让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。完美的展示了一个复杂的过程，让你犹如置身其中。</p>\n</blockquote>\n\n<p>百度百科看了还是木有很深刻的认识，那看看下面这个例子你一定会说“噢，来是这样”。<a href=\"http://hotdot.pro/#\">点我点我</a></p>\n\n<p>在我看来视差滚动其实是通过页面多层次不同速度的滚动来达到一种视觉上的落差，使人感到页面有一种立体感！</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1464244796501,"created_by":1,"updated_at":1473918240474,"updated_by":1,"published_at":1464245322285,"published_by":1},{"id":10,"uuid":"5995d7ae-ad04-4a41-9710-a30426873cf3","title":"一脸懵逼：git大小写不敏感","slug":"gitda-xiao-xie-bu-min-gan","markdown":"用了这么久git，今天第一次遇到文件大小写不区分的问题，因为node找依赖模块时区分大小写，项目就跑不起来了！！！\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=188647&auto=1&height=66\"></iframe>\n\n只能找办法解决：首先修改git的配置，使其大小写敏感\n```\ngit config core.ignorecase false\n```\n其次需要删除本地文件重新add和commit\n```\ngit rm -f filename\n\ngit add filename\n\ngit commit -m \"message\"\n```","html":"<p>用了这么久git，今天第一次遇到文件大小写不区分的问题，因为node找依赖模块时区分大小写，项目就跑不起来了！！！</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=188647&auto=1&height=66\"></iframe>\n\n<p>只能找办法解决：首先修改git的配置，使其大小写敏感</p>\n\n<pre><code>git config core.ignorecase false  \n</code></pre>\n\n<p>其次需要删除本地文件重新add和commit</p>\n\n<pre><code>git rm -f filename\n\ngit add filename\n\ngit commit -m \"message\"  \n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1464334877736,"created_by":1,"updated_at":1473918221706,"updated_by":1,"published_at":1464335179180,"published_by":1},{"id":11,"uuid":"203b9723-2d0c-4d53-8634-98ad9d8087f4","title":"一口老血：ESLint配置文档翻译","slug":"pei-zhi-eslint-2","markdown":"## 配置ESLint\nESLint 被设计为完全可配置的，这意味着你可以关闭任意规则，仅仅运行基础的句法检查，或混合和匹配捆绑的规则和你习惯的规则来最适合你的项目。这有两种主要的方式来配置 ESLint 。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=308353&auto=1&height=66\"></iframe>\n\n1. 配置注释 - 直接把配置信息通过 JavaScript 注释的方式写入文件\n2. 配置文件 - 使用一个 JavaScript ，JSON or YAML 文件来具体说明整个文件夹和所有它的子文件夹的配置信息。它可以在一个 `.eslintrc.*` 文件或在 `package.json` 文件的 `eslintConfig` 字段，ESLint 将会自动寻找并读取它们，或者你可以通过命令行具体制定配置文件。\n\n有以下几块信息是可以被配置的：\n\n* Environments - 你的脚本被设计运行在什么环境。每个环境将会带有一组预定义的全局变量。\n* Globals - 你的脚本执行期间所需的额外的全局变量。\n* Rules - 将打开的规则，以及它的错误级别。\n\nESLint 所有这些选项使你你有了对你的代码细力度的控制力。\n\n## 制定解析器选项\nESLint 允许你去指定你想要支持的 JavaScript 语言选项。默认，ESLint 支持 ES5 的句法。你可以通过覆盖解析器选项的设置去启用 ES6 和 ES7 甚至JSX的支持。\n\n请注意支持 JSX 句法不等同于支持 React 。React 应用了 ESLint 无法识别的更具体的语法。如果你在使用 React 并想要支持 React 语法，我们推荐你使用 `eslint-plugin-react` 。\n\n解析器选项在你的 `.eslintrc.*` 文件的 `parserOptions` 属性中被指定。这个可用的选项如下：\n\n* ecmaVersion - 设置你想要使用的 ECMAScript 的具体版本，可以为3、5（默认）、6或者7。\n* sourceType - 设置 **\"script\"** （默认），如果你的代码 ECMAScript 模块当中则使用 **\"module\"** 。\n* ecmaFeatures - 一个指示你所想要使用的语言特性的对象：\n    * globalReturn - 允许 return 表达式在全局作用域当中\n    * impliedStrict - 开启严格模式（如果 ecmaVersion 大于等于5）\n    * jsx - 启用 JSX\n    * experimentalObjectRestSpread -启用对于实验性的对象剩余/展开参数的支持。（重要：这是一个实验特性，将来可能会出现显著的变化。建议你不要写依赖于这一功能的规则，除非你已经愿意去维护其改变时所引起的问题。）\n\n这有一个例子 `.eslintrc.json` 文件:\n\n```\n{\n    \"parserOptions\": {\n        \"ecmaVersion\": 6,\n        \"sourceType\": \"module\",\n        \"ecmaFeatures\": {\n            \"jsx\": true\n        }\n    },\n    \"rules\": {\n        \"semi\": 2\n    }\n}\n```\n\n设置解析器选项帮助 ESLint 决定什么是一个解析错误。所有语言选项默认是 false 。\n\n## 指定解析器\nESLint 默认使用 `Espree` 作为它的解析器。你可以在你的配置文件当中可选的指定一个不同的解析器，只要它满足以下的要求：\n\n1. 它必须是一个本地安装的npm模块。\n2. 它必须有一个 Esprima 兼容接口（它必须导出一个 `parse()` 方法）。\n3. 它必须产出 Esprima 兼容的抽象语法树和表意的对象。\n\n注意甚至有了这些兼容性，我们不保证一个外部的解析器将和 ESLint 正确地工作，ESLint将不会解决这些由其他解析器不兼容造成的问题。\n\n你需要使用 `.eslintrc` 文件中的 `parser` 选项来指定一个npm模块作为你的解析器。例如，下面指定使用 Esprima 来代替 Espree ：\n\n```\n{\n    \"parser\": \"esprima\",\n    \"rules\": {\n        \"semi\": \"error\"\n    }\n}\n```\n\n下列解析器是兼容 ESLint 的：\n* Esprima\n* Babel-ESLint - 一个 Babel 解析器的包装，使其兼容 ESLint 。\n\n注意当你使用一个习惯的解析器时， `parserOptions` 配置属性仍然是 ESLint 在非默认的ES5环境工作所必须的。解析器通过了所有的 `parserOptions` ，可以也可以不使用它们去决定启用的特性。\n\n## 指定环境\n一个环境预定义了全局变量。可用的环境如下：\n\n* browser - 浏览器全局变量。\n* node - Node.js 全局变量和 Node.js 作用域。\n* commonjs - CommonJS 全局变量和 CommonJS 作用域（只有在使用 Browserify或WebPack产生的浏览器代码中使用）。\n* shared-node-browser - Node and Browser公共的全局变量。\n* es6 - 启用所有的 ES6 module 所需要的特性。\n* worker - web workers 全局变量.\n* amd - defines require() and define() as global variables as per the amd spec.\n* mocha - 加入 Mocha 测试的所有全局变量。\n* jasmine - 加入 Jasmine 测试的所有全局变量，针对1.3和2.0版本。\n* jest - Jest 全局变量。\n* phantomjs - PhantomJS 全局变量。\n* protractor - Protractor 全局变量。\n* qunit - QUnit 全局变量。\n* jquery - jQuery 全局变量。\n* prototypejs - Prototype.js 全局变量。\n* shelljs - ShellJS 全局变量。\n* meteor - Meteor 全局变量。\n* mongo - MongoDB 全局变量。\n* applescript - AppleScript 全局变量。\n* nashorn - Java 8 Nashorn 引擎全局变量。\n* serviceworker - Service Worker 全局变量。\n* atomtest - Atom 测试 helper 变量。\n* embertest - Ember 测试 helper 变量。\n* webextensions - WebExtensions 变量。\n* greasemonkey - GreaseMonkey 变量。\n\n这些环境不相互影响，所以你可以同时定义超过一个环境。\n\nEnvironments 能够在文件当中，在配置文件中或使用命令行的 `--env` 参数指定。\n\n在你的 JavaScript 中使用注释指定环境，使用下面的格式：\n\n```\n/*eslint-env node, mocha */\n```\n\n他启用了 Node.js 和 Mocha 的环境。\n\n在配置文件当中指定环境，使用 `env` 键并把你需要启用的环境的属性设为 `true` 。例如，下面例子启用了 brower 和 Node.js 环境：\n\n```\n{\n    \"env\": {\n        \"browser\": true,\n        \"node\": true\n    }\n}\n```\n\n或者在 `package.json` 文件\n\n```\n{\n    \"name\": \"mypackage\",\n    \"version\": \"0.0.1\",\n    \"eslintConfig\": {\n        \"env\": {\n            \"browser\": true,\n            \"node\": true\n        }\n    }\n}\n```\n\n在 YAML 文件中：\n\n```\n---\n  env:\n    browser: true\n    node: true\n```\n\n如果你想去使用一个来自插件的环境，确保指定了插件名在 `plugins` 数组，然后使用不带前缀的插件名，其次是斜杠，再其次是环境名。举例来说：\n\n```\n{\n    \"plugins\": [\"example\"],\n    \"env\": {\n        \"example/custom\": true\n    }\n}\n```\n\n在一个 `package.json` 文件中\n\n```\n{\n    \"name\": \"mypackage\",\n    \"version\": \"0.0.1\",\n    \"eslintConfig\": {\n        \"plugins\": [\"example\"],\n        \"env\": {\n            \"example/custom\": true\n        }\n    }\n}\n```\n\nYAML 文件：\n\n```\n---\n  plugins:\n    - example\n  env:\n    example/custom: true\n```\n\n## 指定全局变量\nno-undef 规则将会警告将要访问的为定义的变量。如果你使用全局变量在一个文件中，它将是值得的去定义 globals 以至于 ESLint 将不会警告它们的使用。你可以定义全局变量使用文件中的注释或者配置文件。\n\n在你的 JavaScript 文件中指定全局变量，使用下面的格式：\n\n```\n/* global var1, var2 */\n```\n\n定义两个全局变量， `var1` 和 `var2` 。如果你想要去可选的制定这些全局变量不应当被修改（只读），你可以设置每个全局变量一个 false 标记：\n\n```\n/* global var1:false, var2:false */\n```\n\n在配置文件中配置全局变量，使用 `globals` 键并指出你想要使用的全局变量。设置全局变量为 `true` 来使其可以被覆盖或制定 `false` 使其只读。举例：\n\n```\n{\n    \"globals\": {\n        \"var1\": true,\n        \"var2\": false\n    }\n}\n```\n\nYAML中：\n\n```\n---\n  globals:\n    var1: true\n    var2: false\n```\n\n这个例子允许 `var1` 可以在代码中覆盖，但 `var2` 不允许。\n\n## 配置插件\nESLint 支持使用第三方的插件。在使用插件前，需要用 npm 将它安装。\n\n在配置文件中配置插件，使用 `plugins` 键，它包含一个插件名的列表。 `eslint-plugin-` 的前缀可以从插件名中省略。\n\n```\n{\n    \"plugins\": [\n        \"plugin1\",\n        \"eslint-plugin-plugin2\"\n    ]\n}\n```\n\nYAML中：\n```\n---\n  plugins:\n    - plugin1\n    - eslint-plugin-plugin2\n```\n\n注意：一个全局安装的 ESLint 只能改使用全局安装的 ESLint 插件。本地安装的 ESLint 能够使用本地和全局的 ESLint 插件。\n\n## 配置规则\nESlint 自带了大量的规则。你能够通过注释和配置文件的方式修改你项目中的规则。修改一个规则的设置，你必须设置 rule ID 为下列中的一个值：\n\n* `\"off\"` 或 `0` - 关闭规则\n* `\"warn\"` 或 `1` - 打开规则起提醒作用（不退出代码执行）\n* `\"error\"` 或 `2` - 打开规则起报错作用（将触发退出代码）\n\n在文件中使用注释配置，使用下面的格式：\n\n```\n/* eslint eqeqeq: \"off\", curly: \"error\" */\n```\n\n在这个例子中 `eqeqeq` 被关闭， `curly` 被打开 error 级别。你也可以使用等价的数字表示规则的级别：\n\n```\n/* eslint eqeqeq: 0, curly: 2 */\n```\n\n这个例子和上一个例子相同，只是它使用数字编号代替了字符串值。`eqeqeq` 被关闭， `curly` 被打开 error 级别。\n\n如果一个规则有可选的选项，你可以使用数组字面量设置它们，例如：\n\n```\n/* eslint quotes: [\"error\", \"double\"], curly: 2 */\n```\n\n这个注释为 `quotes` 规则指定了两个选项。数组的第一项总是严重的规则（数字或字符串）。\n\n在配置文件配置规则，使用 `rules` 键跟着一个 error 级别和任何选项你想要使用的。例如：\n\n```\n{\n    \"rules\": {\n        \"eqeqeq\": \"off\",\n        \"curly\": \"error\",\n        \"quotes\": [\"error\", \"double\"]\n    }\n}\n```\n\nYAML 文件中：\n\n```\n---\nrules:\n  eqeqeq: off\n  curly: error\n  quotes:\n    - error\n    - double\n```\n\n配置一个在插件中定义的规则，你必须为 rule ID 加上插件名作为前缀，以及 `/`。举例来说：\n\n```\n{\n    \"plugins\": [\n        \"plugin1\"\n    ],\n    \"rules\": {\n        \"eqeqeq\": \"off\",\n        \"curly\": \"error\",\n        \"quotes\": [\"error\", \"double\"],\n        \"plugin1/rule1\": \"error\"\n    }\n}\n```\n\nYAML 文件中：\n\n```\n---\nplugins:\n  - plugin1\nrules:\n  eqeqeq: 0\n  curly: error\n  quotes:\n    - error\n    - \"double\"\n  plugin1/rule1: error\n```\n\n在这个配置文件中，规则 `plugin1/rule1` 来自插件 `plugin1` 。你也能够使用如下格式配置注释的方式，例如：\n\n```\n/* eslint \"plugin1/rule1\": \"error\" */\n```\n\n注意：当指定来自插件的规则，确保省略 `eslint-plugin-` 。ESLint 只使用无前缀的名字来定位内部规则。\n\n## 使用行内注释来禁用规则\n使用如下的格式来临时地禁用文件中规则的警告：\n\n```\n/* eslint-disable */\n\n// Disables all rules between comments\nalert('foo');\n\n/* eslint-enable */\n```\n\n你也可以禁用或启用指定的规则：\n\n```\n/* eslint-disable no-alert, no-console */\n\n// Disables no-alert and no-console warnings between comments\nalert('foo');\nconsole.log('bar');\n\n/* eslint-enable no-alert, no-console */\n```\n\n在整个文件中禁用规则警告，把 `/* eslint-disable */` 放到文件顶部：\n\n```\n/* eslint-disable */\n\n// Disables all rules for the rest of the file\nalert('foo');\n```\n\n你也可以在整个文件禁用指定的规则：\n\n```\n/* eslint-disable no-alert */\n\n// Disables no-alert for the rest of the file\nalert('foo');\n```\n\n在指定行禁用所有规则：\n\n```\nalert('foo'); // eslint-disable-line\n\n// eslint-disable-next-line\nalert('foo');\n```\n\n在指定行禁用指定的规则：\n\n```\nalert('foo'); // eslint-disable-line no-alert\n\n// eslint-disable-next-line no-alert\nalert('foo');\n```\n\n指定行禁用多个规则：\n\n```\nalert('foo'); // eslint-disable-line no-alert, quotes, semi\n\n// eslint-disable-next-line no-alert, quotes, semi\nalert('foo');\n```\n\n注意：注释仅仅是禁用了一部分警告，告诉 ESlint 不要报告这部分代码违规。 ESlint 解析整个文件，所以禁用的代码仍然需要符合合法的 JavaScript 语法。\n\n## 添加共享的设置\nESlint 支持向配置文件中添加共享的配置。你能够添加 `settings` 对象到 ESLint 配置文件中，它将会提供给每一个将要执行的规则。这也许是有用的如果你添加了习惯的规则并想要它们能够访问相同的信息并轻松配置。\n\n在 JSON 中：\n\n```\n{\n    \"settings\": {\n        \"sharedData\": \"Hello\"\n    }\n}\n```\n\n在 YAML 文件中：\n\n```\n---\n  settings:\n    sharedData: \"Hello\"\n```\n\n## 使用配置文件\n这有两种方式去使用配置文件。第一种是保存文件到你喜欢的地方，然后传递它的地址到 CLI 使用 `-c` 选项，例如：\n\n```\neslint -c myconfig.json myfiletotest.js\n```\n\n第二种方式是去使用配置文件通过 `.eslintrc.*` 或 `package.json` 文件。ESLint 将会自动在目录中寻找它们，从连续的父目录一路找到文件系统根目录。这个选项时有用的当你想要对项目的不同部分使用不同的配置，或者当你想要别的直接去使用 ESLint 而不需要记住它在配置文件中传递。\n\n两种方式，配置文件的设置都将会覆盖默认的配置。\n\n## 配置文件格式\nESLint 支持各种格式的配置文件：\n\n* **JavaScript** - 使用 `.eslintrc.js` 并导出一个包含你配置信息的对象。\n* **YAML** - 使用 `.eslintrc.yaml` 或 `.eslintrc.yml` 来定义配置结构。\n* **JSON** - 使用 `.eslintrc.json` 来定义配置结构。 ESLint's JSON 文件也支持 JavaScript 风格的注释。\n* **Deprecated** - 使用 `eslintrc`，过时的，可以是 JSON 或 YAML。\n* **package.json** - 创建一个 `eslintConfig` 属性在你的 `package.json`文件并在这里定义你的配置。\n\n如果有多种配置文件在同一个目录，ESLint将会使用一个。它们的优先级如下：\n\n1. `.eslintrc.js`\n2. `.eslintrc.yaml`\n3. `.eslintrc.yml`\n4. `.eslintrc.json`\n5. `.eslintrc`\n6. `package.json`\n\n## 配置及联和层次结构\n当使用 `.eslintrc.*` 和 `package.json` 文件来配置，你可以利用配置级联的优势。举例来说，假设你有下列的目录结构：\n\n```\nyour-project\n├── .eslintrc\n├── lib\n│ └── source.js\n└─┬ tests\n  ├── .eslintrc\n  └── test.js\n```\n\n配置级联将会使用最近的 `.eslintrc` 文件作为最高优先级，然后是任何父级目录的配置文件等。当你在项目中运行 ESLint ，所有 `lib/` 目录下的文件将会使用根目录下的 `.eslintrc` 文件作为它们的配置。如果 ESLint 进入 `test/` 目录，它将会使用 `your-project/tests/.eslintrc` 而不是 `your-project/.eslintrc` 。所以 `your-project/tests/test.js` 的检测是基于目录层次结构中的两个 `.eslintrc` 文件的组合的，近的拥有更高的优先级。这样的方式，你可以拥有项目级别的 ESLint 设置，并可以用目录层次的配置来覆盖它。\n\n相同的方式，在 `package.json` 文件中也可行。根目录中 `package.json` 的 `eslintConfig` 字段将在其所有子目录生效，但是在 tests 目录的 `.eslintrc` 文件将会覆盖所有冲突的配置。\n\n```\nyour-project\n├── package.json\n├── lib\n│ └── source.js\n└─┬ tests\n  ├── .eslintrc\n  └── test.js\n```\n\n如果在一个目录中，同时找到了 `.eslintrc` 和 `package.json` 文件，`eslintrc` 文件将有更高的优先级， `package.json` 文件将不被使用。\n\n注意：如果你又一个个人的配置文件在你的用户目录（ `~/.eslintrc` ），它将会仅仅在没有别的配置文件没发现的情况下使用。它将会对你所有用户目录下的文件生效，包括第三方的代码，因此在运行 ESLint 很可能会产生问题。\n\n默认地， ESLint 将会在所有父目录直到根目录寻找配置文件。这将是有用的，如果你想要所有你的项目去跟随某个约定，但是有时候会导致意想不到的结果。限制 ESLint 在一个指定的项目，把 `\"root\": true` 加到 `package.json` 的 `eslintConfig` 字段或者 `.eslintrc.*` 文件，在你的根目录。 ESLint 将会停止寻找父目录当它找到了 `\"root\": true` 的配置。\n\n```\n{\n    \"root\": true\n}\n```\nYAML 文件中：\n\n```\n---\n  root: true\n```\n\n举例来说， 这个例子当中 `main.js` 将会使用 `lib/` 中的配置，而不会使用 `productA` 目录下的 `.eslintrc` 文件的配置，因为在 `lib/` 中的 `.eslintrc`  有 `\"root\": true` 的设置。\n\n```\nhome\n└── user\n    ├── .eslintrc <- Always skipped if other configs present\n    └── projectA\n        ├── .eslintrc  <- Not used\n        └── lib\n            ├── .eslintrc  <- { \"root\": true }\n            └── main.js\n```\n\n完整的配置层次，从高到低如下：\n\n1. 行内配置\n    1. `/*eslint-disable*/` and `/*eslint-enable*/`\n    2. `/*global*/`\n    3. `/*eslint*/`\n    4. `/*eslint-env*/`\n2. 命令行配置\n    1. `--global`\n    2. `--rule`\n    3. `--env`\n    4. `-c, --config`\n3. 项目级别配置\n    1. `.eslintrc.*` 或 `package.json` 文件\n    2. 祖先目录中寻找，除非有 `\"root\": true` 将不会向上寻找\n    3. 个人某人的配置在 `~/.eslintrc`\n\n## 扩展配置文件\n如果你想要扩展一个指定的配置文件，你可以使用 `extends` 属性，并制定路径。可以是相对的或是绝对的路径。\n\n配置能够被如下文件扩展：\n\n1. YAML 文件\n2. JSON 文件\n3. JS 文件\n4. 共享的配置包\n\n扩展配置提供了基础的规则，并可以覆盖。举例：\n\n```\n{\n    \"extends\": \"./node_modules/coding-standard/.eslintrc\",\n\n    \"rules\": {\n        // Override any settings from the \"parent\" configuration\n        \"eqeqeq\": 1\n    }\n}\n```\n\n配置也许也可以以数组的方式提供，后面的会覆盖前面的相同的规则的配置。举例：\n\n```\n{\n    \"extends\": [\n        \"./node_modules/coding-standard/eslintDefaults.js\",\n        // Override eslintDefaults.js\n        \"./node_modules/coding-standard/.eslintrc-es6\",\n        // Override .eslintrc-es6\n        \"./node_modules/coding-standard/.eslintrc-jsx\",\n    ],\n\n    \"rules\": {\n        // Override any settings from the \"parent\" configuration\n        \"eqeqeq\": \"warn\"\n    }\n}\n```\n\n扩展配置能够包涵它们自己的 `extends` ，导致循环的引用。\n\n你也可以使用共享的配置包。你需要使用 npm 去安装它们，例如：\n\n```\n{\n    \"extends\": \"eslint-config-myrules\",\n\n    \"rules\": {\n        // Override any settings from the \"parent\" configuration\n        \"eqeqeq\": \"warn\"\n    }\n}\n```\n\n在这个例子， `eslint-config-myrules` 包将会加载为一个对象并作为这个配置的父配置。\n\n注意：你可以省略 `eslint-config-` 前缀， ESLint 将会自动为你添加，和插件工作相似。\n\nESlint 也支持插件提供的扩展配置：\n\n```\n{\n    \"extends\": \"plugin:eslint-plugin-myplugin/myConfig\",\n\n    \"rules\": {\n        // Override any settings from the \"parent\" configuration\n        \"eqeqeq\": \"warn\"\n    }\n}\n```\n\n在这个例子， `eslint-plugin-myplugin` 包包含了名为 `default` 的配置。\n\n**十分重要**：使用插件中的配置时，必须要加上 `plugin:` 前缀来指明哈。但你可以可选地省略 `eslint-plugin` 前缀。\n\n注意：对于根目录或者其它父目录， `extends` 处理路径会用当前工作目录，而不是文件自身。\n\n## 配置文件中的注释\nJSON 和 YAML 配置文件都支持注释， `package.json` 不能包括注释。你可以使用 JAVAScript 风格的注释或 YAML 风格的注释， ESLint 将安全地忽略它们。这可以允许你的配置文件跟友好。举例：\n\n```\n{\n    \"env\": {\n        \"browser\": true\n    },\n    \"rules\": {\n        // Override our default settings just for this directory\n        \"eqeqeq\": \"warn\",\n        \"strict\": \"off\"\n    }\n}\n```\n\n## 指定需要检测的文件后缀\n当前指定后缀需要在命令行选项 `--ext` 后，添加用空格分开的后缀名列表。\n\n## 忽略文件或目录\n\n\n你可以告诉 ESLint 去忽略指定的文件或目录，通过一个 `.eslintignore` 文件在你的根目录。 `.eslintignore` 文件是一个普通文本文件，每一行定义了要被忽略的文件或目录。举例：下列表达式将会省略所有 JavaScript 文件：\n\n```\n**/*.js\n```\n\n当 ESLint 运行的时候，它会寻找当前工作目录的 `.eslintignore` 文件在它决定监测之前。如果找到了文件，这里面的配置将会生效。 `.eslintignore` 只会被使用一次，因此目录中其他的 `.eslintignore` 将不会被使用。\n\n* #好开头将会被认为是注释\n* 相对于 `.eslintignore` 文件路径或当前工作目录的路径\n* 忽略规则参照 `.gitignore` 规范\n* !用来取消前面的忽略的匹配\n\n`/node_modules/*` 和 `/bower_components/*` 将默认被忽略。\n\n举例，把下面的 `.eslintignore` 文件放倒工作目录下将会忽略`/node_modules/*` 和 `/bower_components/*` 目录，任何扩展名为 `.ts.js` 或 `.coffee.js` 可能被转换，任何在 `build/*` 目录除了 `build/index.js` 将被忽略：\n\n```\n# /node_modules/* and /bower_components/* ignored by default\n\n# Ignore built files except build/index.js\nbuild/*\n!build/index.js\n```\n\n## 使用替换的文件\n如果你喜欢去使用别的文件而不是 `.eslintignore` 来工作，你在命令行中可以指定 `--ignore-path` 选项。举例来说，你可以使用 `.jshintignore` ，因为两者的配置相同：\n\n```\neslint --ignore-path .jshintignore file.js\n```\n\n你也可以使用 `.gitignore` 文件：\n\n```\neslint --ignore-path .gitignore file.js\n```\n\n任何标准的 ignore 文件可以被使用。\n\n## 忽略文件警告\n当你 eslint 一个被忽略的文件或目录时，会发出警告，你可以使用 `--no-ignore` 来进行省略。\n","html":"<h2 id=\"eslint\">配置ESLint</h2>\n\n<p>ESLint 被设计为完全可配置的，这意味着你可以关闭任意规则，仅仅运行基础的句法检查，或混合和匹配捆绑的规则和你习惯的规则来最适合你的项目。这有两种主要的方式来配置 ESLint 。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=308353&auto=1&height=66\"></iframe>\n\n<ol>\n<li>配置注释 - 直接把配置信息通过 JavaScript 注释的方式写入文件  </li>\n<li>配置文件 - 使用一个 JavaScript ，JSON or YAML 文件来具体说明整个文件夹和所有它的子文件夹的配置信息。它可以在一个 <code>.eslintrc.*</code> 文件或在 <code>package.json</code> 文件的 <code>eslintConfig</code> 字段，ESLint 将会自动寻找并读取它们，或者你可以通过命令行具体制定配置文件。</li>\n</ol>\n\n<p>有以下几块信息是可以被配置的：</p>\n\n<ul>\n<li>Environments - 你的脚本被设计运行在什么环境。每个环境将会带有一组预定义的全局变量。</li>\n<li>Globals - 你的脚本执行期间所需的额外的全局变量。</li>\n<li>Rules - 将打开的规则，以及它的错误级别。</li>\n</ul>\n\n<p>ESLint 所有这些选项使你你有了对你的代码细力度的控制力。</p>\n\n<h2 id=\"\">制定解析器选项</h2>\n\n<p>ESLint 允许你去指定你想要支持的 JavaScript 语言选项。默认，ESLint 支持 ES5 的句法。你可以通过覆盖解析器选项的设置去启用 ES6 和 ES7 甚至JSX的支持。</p>\n\n<p>请注意支持 JSX 句法不等同于支持 React 。React 应用了 ESLint 无法识别的更具体的语法。如果你在使用 React 并想要支持 React 语法，我们推荐你使用 <code>eslint-plugin-react</code> 。</p>\n\n<p>解析器选项在你的 <code>.eslintrc.*</code> 文件的 <code>parserOptions</code> 属性中被指定。这个可用的选项如下：</p>\n\n<ul>\n<li>ecmaVersion - 设置你想要使用的 ECMAScript 的具体版本，可以为3、5（默认）、6或者7。</li>\n<li>sourceType - 设置 <strong>\"script\"</strong> （默认），如果你的代码 ECMAScript 模块当中则使用 <strong>\"module\"</strong> 。</li>\n<li>ecmaFeatures - 一个指示你所想要使用的语言特性的对象：\n<ul><li>globalReturn - 允许 return 表达式在全局作用域当中</li>\n<li>impliedStrict - 开启严格模式（如果 ecmaVersion 大于等于5）</li>\n<li>jsx - 启用 JSX</li>\n<li>experimentalObjectRestSpread -启用对于实验性的对象剩余/展开参数的支持。（重要：这是一个实验特性，将来可能会出现显著的变化。建议你不要写依赖于这一功能的规则，除非你已经愿意去维护其改变时所引起的问题。）</li></ul></li>\n</ul>\n\n<p>这有一个例子 <code>.eslintrc.json</code> 文件:</p>\n\n<pre><code>{\n    \"parserOptions\": {\n        \"ecmaVersion\": 6,\n        \"sourceType\": \"module\",\n        \"ecmaFeatures\": {\n            \"jsx\": true\n        }\n    },\n    \"rules\": {\n        \"semi\": 2\n    }\n}\n</code></pre>\n\n<p>设置解析器选项帮助 ESLint 决定什么是一个解析错误。所有语言选项默认是 false 。</p>\n\n<h2 id=\"\">指定解析器</h2>\n\n<p>ESLint 默认使用 <code>Espree</code> 作为它的解析器。你可以在你的配置文件当中可选的指定一个不同的解析器，只要它满足以下的要求：</p>\n\n<ol>\n<li>它必须是一个本地安装的npm模块。  </li>\n<li>它必须有一个 Esprima 兼容接口（它必须导出一个 <code>parse()</code> 方法）。  </li>\n<li>它必须产出 Esprima 兼容的抽象语法树和表意的对象。</li>\n</ol>\n\n<p>注意甚至有了这些兼容性，我们不保证一个外部的解析器将和 ESLint 正确地工作，ESLint将不会解决这些由其他解析器不兼容造成的问题。</p>\n\n<p>你需要使用 <code>.eslintrc</code> 文件中的 <code>parser</code> 选项来指定一个npm模块作为你的解析器。例如，下面指定使用 Esprima 来代替 Espree ：</p>\n\n<pre><code>{\n    \"parser\": \"esprima\",\n    \"rules\": {\n        \"semi\": \"error\"\n    }\n}\n</code></pre>\n\n<p>下列解析器是兼容 ESLint 的：\n* Esprima\n* Babel-ESLint - 一个 Babel 解析器的包装，使其兼容 ESLint 。</p>\n\n<p>注意当你使用一个习惯的解析器时， <code>parserOptions</code> 配置属性仍然是 ESLint 在非默认的ES5环境工作所必须的。解析器通过了所有的 <code>parserOptions</code> ，可以也可以不使用它们去决定启用的特性。</p>\n\n<h2 id=\"\">指定环境</h2>\n\n<p>一个环境预定义了全局变量。可用的环境如下：</p>\n\n<ul>\n<li>browser - 浏览器全局变量。</li>\n<li>node - Node.js 全局变量和 Node.js 作用域。</li>\n<li>commonjs - CommonJS 全局变量和 CommonJS 作用域（只有在使用 Browserify或WebPack产生的浏览器代码中使用）。</li>\n<li>shared-node-browser - Node and Browser公共的全局变量。</li>\n<li>es6 - 启用所有的 ES6 module 所需要的特性。</li>\n<li>worker - web workers 全局变量.</li>\n<li>amd - defines require() and define() as global variables as per the amd spec.</li>\n<li>mocha - 加入 Mocha 测试的所有全局变量。</li>\n<li>jasmine - 加入 Jasmine 测试的所有全局变量，针对1.3和2.0版本。</li>\n<li>jest - Jest 全局变量。</li>\n<li>phantomjs - PhantomJS 全局变量。</li>\n<li>protractor - Protractor 全局变量。</li>\n<li>qunit - QUnit 全局变量。</li>\n<li>jquery - jQuery 全局变量。</li>\n<li>prototypejs - Prototype.js 全局变量。</li>\n<li>shelljs - ShellJS 全局变量。</li>\n<li>meteor - Meteor 全局变量。</li>\n<li>mongo - MongoDB 全局变量。</li>\n<li>applescript - AppleScript 全局变量。</li>\n<li>nashorn - Java 8 Nashorn 引擎全局变量。</li>\n<li>serviceworker - Service Worker 全局变量。</li>\n<li>atomtest - Atom 测试 helper 变量。</li>\n<li>embertest - Ember 测试 helper 变量。</li>\n<li>webextensions - WebExtensions 变量。</li>\n<li>greasemonkey - GreaseMonkey 变量。</li>\n</ul>\n\n<p>这些环境不相互影响，所以你可以同时定义超过一个环境。</p>\n\n<p>Environments 能够在文件当中，在配置文件中或使用命令行的 <code>--env</code> 参数指定。</p>\n\n<p>在你的 JavaScript 中使用注释指定环境，使用下面的格式：</p>\n\n<pre><code>/*eslint-env node, mocha */\n</code></pre>\n\n<p>他启用了 Node.js 和 Mocha 的环境。</p>\n\n<p>在配置文件当中指定环境，使用 <code>env</code> 键并把你需要启用的环境的属性设为 <code>true</code> 。例如，下面例子启用了 brower 和 Node.js 环境：</p>\n\n<pre><code>{\n    \"env\": {\n        \"browser\": true,\n        \"node\": true\n    }\n}\n</code></pre>\n\n<p>或者在 <code>package.json</code> 文件</p>\n\n<pre><code>{\n    \"name\": \"mypackage\",\n    \"version\": \"0.0.1\",\n    \"eslintConfig\": {\n        \"env\": {\n            \"browser\": true,\n            \"node\": true\n        }\n    }\n}\n</code></pre>\n\n<p>在 YAML 文件中：</p>\n\n<pre><code>---\n  env:\n    browser: true\n    node: true\n</code></pre>\n\n<p>如果你想去使用一个来自插件的环境，确保指定了插件名在 <code>plugins</code> 数组，然后使用不带前缀的插件名，其次是斜杠，再其次是环境名。举例来说：</p>\n\n<pre><code>{\n    \"plugins\": [\"example\"],\n    \"env\": {\n        \"example/custom\": true\n    }\n}\n</code></pre>\n\n<p>在一个 <code>package.json</code> 文件中</p>\n\n<pre><code>{\n    \"name\": \"mypackage\",\n    \"version\": \"0.0.1\",\n    \"eslintConfig\": {\n        \"plugins\": [\"example\"],\n        \"env\": {\n            \"example/custom\": true\n        }\n    }\n}\n</code></pre>\n\n<p>YAML 文件：</p>\n\n<pre><code>---\n  plugins:\n    - example\n  env:\n    example/custom: true\n</code></pre>\n\n<h2 id=\"\">指定全局变量</h2>\n\n<p>no-undef 规则将会警告将要访问的为定义的变量。如果你使用全局变量在一个文件中，它将是值得的去定义 globals 以至于 ESLint 将不会警告它们的使用。你可以定义全局变量使用文件中的注释或者配置文件。</p>\n\n<p>在你的 JavaScript 文件中指定全局变量，使用下面的格式：</p>\n\n<pre><code>/* global var1, var2 */\n</code></pre>\n\n<p>定义两个全局变量， <code>var1</code> 和 <code>var2</code> 。如果你想要去可选的制定这些全局变量不应当被修改（只读），你可以设置每个全局变量一个 false 标记：</p>\n\n<pre><code>/* global var1:false, var2:false */\n</code></pre>\n\n<p>在配置文件中配置全局变量，使用 <code>globals</code> 键并指出你想要使用的全局变量。设置全局变量为 <code>true</code> 来使其可以被覆盖或制定 <code>false</code> 使其只读。举例：</p>\n\n<pre><code>{\n    \"globals\": {\n        \"var1\": true,\n        \"var2\": false\n    }\n}\n</code></pre>\n\n<p>YAML中：</p>\n\n<pre><code>---\n  globals:\n    var1: true\n    var2: false\n</code></pre>\n\n<p>这个例子允许 <code>var1</code> 可以在代码中覆盖，但 <code>var2</code> 不允许。</p>\n\n<h2 id=\"\">配置插件</h2>\n\n<p>ESLint 支持使用第三方的插件。在使用插件前，需要用 npm 将它安装。</p>\n\n<p>在配置文件中配置插件，使用 <code>plugins</code> 键，它包含一个插件名的列表。 <code>eslint-plugin-</code> 的前缀可以从插件名中省略。</p>\n\n<pre><code>{\n    \"plugins\": [\n        \"plugin1\",\n        \"eslint-plugin-plugin2\"\n    ]\n}\n</code></pre>\n\n<p>YAML中：  </p>\n\n<pre><code>---\n  plugins:\n    - plugin1\n    - eslint-plugin-plugin2\n</code></pre>\n\n<p>注意：一个全局安装的 ESLint 只能改使用全局安装的 ESLint 插件。本地安装的 ESLint 能够使用本地和全局的 ESLint 插件。</p>\n\n<h2 id=\"\">配置规则</h2>\n\n<p>ESlint 自带了大量的规则。你能够通过注释和配置文件的方式修改你项目中的规则。修改一个规则的设置，你必须设置 rule ID 为下列中的一个值：</p>\n\n<ul>\n<li><code>\"off\"</code> 或 <code>0</code> - 关闭规则</li>\n<li><code>\"warn\"</code> 或 <code>1</code> - 打开规则起提醒作用（不退出代码执行）</li>\n<li><code>\"error\"</code> 或 <code>2</code> - 打开规则起报错作用（将触发退出代码）</li>\n</ul>\n\n<p>在文件中使用注释配置，使用下面的格式：</p>\n\n<pre><code>/* eslint eqeqeq: \"off\", curly: \"error\" */\n</code></pre>\n\n<p>在这个例子中 <code>eqeqeq</code> 被关闭， <code>curly</code> 被打开 error 级别。你也可以使用等价的数字表示规则的级别：</p>\n\n<pre><code>/* eslint eqeqeq: 0, curly: 2 */\n</code></pre>\n\n<p>这个例子和上一个例子相同，只是它使用数字编号代替了字符串值。<code>eqeqeq</code> 被关闭， <code>curly</code> 被打开 error 级别。</p>\n\n<p>如果一个规则有可选的选项，你可以使用数组字面量设置它们，例如：</p>\n\n<pre><code>/* eslint quotes: [\"error\", \"double\"], curly: 2 */\n</code></pre>\n\n<p>这个注释为 <code>quotes</code> 规则指定了两个选项。数组的第一项总是严重的规则（数字或字符串）。</p>\n\n<p>在配置文件配置规则，使用 <code>rules</code> 键跟着一个 error 级别和任何选项你想要使用的。例如：</p>\n\n<pre><code>{\n    \"rules\": {\n        \"eqeqeq\": \"off\",\n        \"curly\": \"error\",\n        \"quotes\": [\"error\", \"double\"]\n    }\n}\n</code></pre>\n\n<p>YAML 文件中：</p>\n\n<pre><code>---\nrules:  \n  eqeqeq: off\n  curly: error\n  quotes:\n    - error\n    - double\n</code></pre>\n\n<p>配置一个在插件中定义的规则，你必须为 rule ID 加上插件名作为前缀，以及 <code>/</code>。举例来说：</p>\n\n<pre><code>{\n    \"plugins\": [\n        \"plugin1\"\n    ],\n    \"rules\": {\n        \"eqeqeq\": \"off\",\n        \"curly\": \"error\",\n        \"quotes\": [\"error\", \"double\"],\n        \"plugin1/rule1\": \"error\"\n    }\n}\n</code></pre>\n\n<p>YAML 文件中：</p>\n\n<pre><code>---\nplugins:  \n  - plugin1\nrules:  \n  eqeqeq: 0\n  curly: error\n  quotes:\n    - error\n    - \"double\"\n  plugin1/rule1: error\n</code></pre>\n\n<p>在这个配置文件中，规则 <code>plugin1/rule1</code> 来自插件 <code>plugin1</code> 。你也能够使用如下格式配置注释的方式，例如：</p>\n\n<pre><code>/* eslint \"plugin1/rule1\": \"error\" */\n</code></pre>\n\n<p>注意：当指定来自插件的规则，确保省略 <code>eslint-plugin-</code> 。ESLint 只使用无前缀的名字来定位内部规则。</p>\n\n<h2 id=\"\">使用行内注释来禁用规则</h2>\n\n<p>使用如下的格式来临时地禁用文件中规则的警告：</p>\n\n<pre><code>/* eslint-disable */\n\n// Disables all rules between comments\nalert('foo');\n\n/* eslint-enable */\n</code></pre>\n\n<p>你也可以禁用或启用指定的规则：</p>\n\n<pre><code>/* eslint-disable no-alert, no-console */\n\n// Disables no-alert and no-console warnings between comments\nalert('foo');  \nconsole.log('bar');\n\n/* eslint-enable no-alert, no-console */\n</code></pre>\n\n<p>在整个文件中禁用规则警告，把 <code>/* eslint-disable */</code> 放到文件顶部：</p>\n\n<pre><code>/* eslint-disable */\n\n// Disables all rules for the rest of the file\nalert('foo');  \n</code></pre>\n\n<p>你也可以在整个文件禁用指定的规则：</p>\n\n<pre><code>/* eslint-disable no-alert */\n\n// Disables no-alert for the rest of the file\nalert('foo');  \n</code></pre>\n\n<p>在指定行禁用所有规则：</p>\n\n<pre><code>alert('foo'); // eslint-disable-line\n\n// eslint-disable-next-line\nalert('foo');  \n</code></pre>\n\n<p>在指定行禁用指定的规则：</p>\n\n<pre><code>alert('foo'); // eslint-disable-line no-alert\n\n// eslint-disable-next-line no-alert\nalert('foo');  \n</code></pre>\n\n<p>指定行禁用多个规则：</p>\n\n<pre><code>alert('foo'); // eslint-disable-line no-alert, quotes, semi\n\n// eslint-disable-next-line no-alert, quotes, semi\nalert('foo');  \n</code></pre>\n\n<p>注意：注释仅仅是禁用了一部分警告，告诉 ESlint 不要报告这部分代码违规。 ESlint 解析整个文件，所以禁用的代码仍然需要符合合法的 JavaScript 语法。</p>\n\n<h2 id=\"\">添加共享的设置</h2>\n\n<p>ESlint 支持向配置文件中添加共享的配置。你能够添加 <code>settings</code> 对象到 ESLint 配置文件中，它将会提供给每一个将要执行的规则。这也许是有用的如果你添加了习惯的规则并想要它们能够访问相同的信息并轻松配置。</p>\n\n<p>在 JSON 中：</p>\n\n<pre><code>{\n    \"settings\": {\n        \"sharedData\": \"Hello\"\n    }\n}\n</code></pre>\n\n<p>在 YAML 文件中：</p>\n\n<pre><code>---\n  settings:\n    sharedData: \"Hello\"\n</code></pre>\n\n<h2 id=\"\">使用配置文件</h2>\n\n<p>这有两种方式去使用配置文件。第一种是保存文件到你喜欢的地方，然后传递它的地址到 CLI 使用 <code>-c</code> 选项，例如：</p>\n\n<pre><code>eslint -c myconfig.json myfiletotest.js  \n</code></pre>\n\n<p>第二种方式是去使用配置文件通过 <code>.eslintrc.*</code> 或 <code>package.json</code> 文件。ESLint 将会自动在目录中寻找它们，从连续的父目录一路找到文件系统根目录。这个选项时有用的当你想要对项目的不同部分使用不同的配置，或者当你想要别的直接去使用 ESLint 而不需要记住它在配置文件中传递。</p>\n\n<p>两种方式，配置文件的设置都将会覆盖默认的配置。</p>\n\n<h2 id=\"\">配置文件格式</h2>\n\n<p>ESLint 支持各种格式的配置文件：</p>\n\n<ul>\n<li><strong>JavaScript</strong> - 使用 <code>.eslintrc.js</code> 并导出一个包含你配置信息的对象。</li>\n<li><strong>YAML</strong> - 使用 <code>.eslintrc.yaml</code> 或 <code>.eslintrc.yml</code> 来定义配置结构。</li>\n<li><strong>JSON</strong> - 使用 <code>.eslintrc.json</code> 来定义配置结构。 ESLint's JSON 文件也支持 JavaScript 风格的注释。</li>\n<li><strong>Deprecated</strong> - 使用 <code>eslintrc</code>，过时的，可以是 JSON 或 YAML。</li>\n<li><strong>package.json</strong> - 创建一个 <code>eslintConfig</code> 属性在你的 <code>package.json</code>文件并在这里定义你的配置。</li>\n</ul>\n\n<p>如果有多种配置文件在同一个目录，ESLint将会使用一个。它们的优先级如下：</p>\n\n<ol>\n<li><code>.eslintrc.js</code>  </li>\n<li><code>.eslintrc.yaml</code>  </li>\n<li><code>.eslintrc.yml</code>  </li>\n<li><code>.eslintrc.json</code>  </li>\n<li><code>.eslintrc</code>  </li>\n<li><code>package.json</code></li>\n</ol>\n\n<h2 id=\"\">配置及联和层次结构</h2>\n\n<p>当使用 <code>.eslintrc.*</code> 和 <code>package.json</code> 文件来配置，你可以利用配置级联的优势。举例来说，假设你有下列的目录结构：</p>\n\n<pre><code>your-project  \n├── .eslintrc\n├── lib\n│ └── source.js\n└─┬ tests\n  ├── .eslintrc\n  └── test.js\n</code></pre>\n\n<p>配置级联将会使用最近的 <code>.eslintrc</code> 文件作为最高优先级，然后是任何父级目录的配置文件等。当你在项目中运行 ESLint ，所有 <code>lib/</code> 目录下的文件将会使用根目录下的 <code>.eslintrc</code> 文件作为它们的配置。如果 ESLint 进入 <code>test/</code> 目录，它将会使用 <code>your-project/tests/.eslintrc</code> 而不是 <code>your-project/.eslintrc</code> 。所以 <code>your-project/tests/test.js</code> 的检测是基于目录层次结构中的两个 <code>.eslintrc</code> 文件的组合的，近的拥有更高的优先级。这样的方式，你可以拥有项目级别的 ESLint 设置，并可以用目录层次的配置来覆盖它。</p>\n\n<p>相同的方式，在 <code>package.json</code> 文件中也可行。根目录中 <code>package.json</code> 的 <code>eslintConfig</code> 字段将在其所有子目录生效，但是在 tests 目录的 <code>.eslintrc</code> 文件将会覆盖所有冲突的配置。</p>\n\n<pre><code>your-project  \n├── package.json\n├── lib\n│ └── source.js\n└─┬ tests\n  ├── .eslintrc\n  └── test.js\n</code></pre>\n\n<p>如果在一个目录中，同时找到了 <code>.eslintrc</code> 和 <code>package.json</code> 文件，<code>eslintrc</code> 文件将有更高的优先级， <code>package.json</code> 文件将不被使用。</p>\n\n<p>注意：如果你又一个个人的配置文件在你的用户目录（ <code>~/.eslintrc</code> ），它将会仅仅在没有别的配置文件没发现的情况下使用。它将会对你所有用户目录下的文件生效，包括第三方的代码，因此在运行 ESLint 很可能会产生问题。</p>\n\n<p>默认地， ESLint 将会在所有父目录直到根目录寻找配置文件。这将是有用的，如果你想要所有你的项目去跟随某个约定，但是有时候会导致意想不到的结果。限制 ESLint 在一个指定的项目，把 <code>\"root\": true</code> 加到 <code>package.json</code> 的 <code>eslintConfig</code> 字段或者 <code>.eslintrc.*</code> 文件，在你的根目录。 ESLint 将会停止寻找父目录当它找到了 <code>\"root\": true</code> 的配置。</p>\n\n<pre><code>{\n    \"root\": true\n}\n</code></pre>\n\n<p>YAML 文件中：</p>\n\n<pre><code>---\n  root: true\n</code></pre>\n\n<p>举例来说， 这个例子当中 <code>main.js</code> 将会使用 <code>lib/</code> 中的配置，而不会使用 <code>productA</code> 目录下的 <code>.eslintrc</code> 文件的配置，因为在 <code>lib/</code> 中的 <code>.eslintrc</code>  有 <code>\"root\": true</code> 的设置。</p>\n\n<pre><code>home  \n└── user\n    ├── .eslintrc &lt;- Always skipped if other configs present\n    └── projectA\n        ├── .eslintrc  &lt;- Not used\n        └── lib\n            ├── .eslintrc  &lt;- { \"root\": true }\n            └── main.js\n</code></pre>\n\n<p>完整的配置层次，从高到低如下：</p>\n\n<ol>\n<li>行内配置 <br />\n<ol><li><code>/*eslint-disable*/</code> and <code>/*eslint-enable*/</code></li>\n<li><code>/*global*/</code></li>\n<li><code>/*eslint*/</code></li>\n<li><code>/*eslint-env*/</code></li></ol></li>\n<li>命令行配置 <br />\n<ol><li><code>--global</code></li>\n<li><code>--rule</code></li>\n<li><code>--env</code></li>\n<li><code>-c, --config</code></li></ol></li>\n<li>项目级别配置 <br />\n<ol><li><code>.eslintrc.*</code> 或 <code>package.json</code> 文件</li>\n<li>祖先目录中寻找，除非有 <code>\"root\": true</code> 将不会向上寻找</li>\n<li>个人某人的配置在 <code>~/.eslintrc</code></li></ol></li>\n</ol>\n\n<h2 id=\"\">扩展配置文件</h2>\n\n<p>如果你想要扩展一个指定的配置文件，你可以使用 <code>extends</code> 属性，并制定路径。可以是相对的或是绝对的路径。</p>\n\n<p>配置能够被如下文件扩展：</p>\n\n<ol>\n<li>YAML 文件  </li>\n<li>JSON 文件  </li>\n<li>JS 文件  </li>\n<li>共享的配置包</li>\n</ol>\n\n<p>扩展配置提供了基础的规则，并可以覆盖。举例：</p>\n\n<pre><code>{\n    \"extends\": \"./node_modules/coding-standard/.eslintrc\",\n\n    \"rules\": {\n        // Override any settings from the \"parent\" configuration\n        \"eqeqeq\": 1\n    }\n}\n</code></pre>\n\n<p>配置也许也可以以数组的方式提供，后面的会覆盖前面的相同的规则的配置。举例：</p>\n\n<pre><code>{\n    \"extends\": [\n        \"./node_modules/coding-standard/eslintDefaults.js\",\n        // Override eslintDefaults.js\n        \"./node_modules/coding-standard/.eslintrc-es6\",\n        // Override .eslintrc-es6\n        \"./node_modules/coding-standard/.eslintrc-jsx\",\n    ],\n\n    \"rules\": {\n        // Override any settings from the \"parent\" configuration\n        \"eqeqeq\": \"warn\"\n    }\n}\n</code></pre>\n\n<p>扩展配置能够包涵它们自己的 <code>extends</code> ，导致循环的引用。</p>\n\n<p>你也可以使用共享的配置包。你需要使用 npm 去安装它们，例如：</p>\n\n<pre><code>{\n    \"extends\": \"eslint-config-myrules\",\n\n    \"rules\": {\n        // Override any settings from the \"parent\" configuration\n        \"eqeqeq\": \"warn\"\n    }\n}\n</code></pre>\n\n<p>在这个例子， <code>eslint-config-myrules</code> 包将会加载为一个对象并作为这个配置的父配置。</p>\n\n<p>注意：你可以省略 <code>eslint-config-</code> 前缀， ESLint 将会自动为你添加，和插件工作相似。</p>\n\n<p>ESlint 也支持插件提供的扩展配置：</p>\n\n<pre><code>{\n    \"extends\": \"plugin:eslint-plugin-myplugin/myConfig\",\n\n    \"rules\": {\n        // Override any settings from the \"parent\" configuration\n        \"eqeqeq\": \"warn\"\n    }\n}\n</code></pre>\n\n<p>在这个例子， <code>eslint-plugin-myplugin</code> 包包含了名为 <code>default</code> 的配置。</p>\n\n<p><strong>十分重要</strong>：使用插件中的配置时，必须要加上 <code>plugin:</code> 前缀来指明哈。但你可以可选地省略 <code>eslint-plugin</code> 前缀。</p>\n\n<p>注意：对于根目录或者其它父目录， <code>extends</code> 处理路径会用当前工作目录，而不是文件自身。</p>\n\n<h2 id=\"\">配置文件中的注释</h2>\n\n<p>JSON 和 YAML 配置文件都支持注释， <code>package.json</code> 不能包括注释。你可以使用 JAVAScript 风格的注释或 YAML 风格的注释， ESLint 将安全地忽略它们。这可以允许你的配置文件跟友好。举例：</p>\n\n<pre><code>{\n    \"env\": {\n        \"browser\": true\n    },\n    \"rules\": {\n        // Override our default settings just for this directory\n        \"eqeqeq\": \"warn\",\n        \"strict\": \"off\"\n    }\n}\n</code></pre>\n\n<h2 id=\"\">指定需要检测的文件后缀</h2>\n\n<p>当前指定后缀需要在命令行选项 <code>--ext</code> 后，添加用空格分开的后缀名列表。</p>\n\n<h2 id=\"\">忽略文件或目录</h2>\n\n<p>你可以告诉 ESLint 去忽略指定的文件或目录，通过一个 <code>.eslintignore</code> 文件在你的根目录。 <code>.eslintignore</code> 文件是一个普通文本文件，每一行定义了要被忽略的文件或目录。举例：下列表达式将会省略所有 JavaScript 文件：</p>\n\n<pre><code>**/*.js\n</code></pre>\n\n<p>当 ESLint 运行的时候，它会寻找当前工作目录的 <code>.eslintignore</code> 文件在它决定监测之前。如果找到了文件，这里面的配置将会生效。 <code>.eslintignore</code> 只会被使用一次，因此目录中其他的 <code>.eslintignore</code> 将不会被使用。</p>\n\n<ul>\n<li>#好开头将会被认为是注释</li>\n<li>相对于 <code>.eslintignore</code> 文件路径或当前工作目录的路径</li>\n<li>忽略规则参照 <code>.gitignore</code> 规范</li>\n<li>!用来取消前面的忽略的匹配</li>\n</ul>\n\n<p><code>/node_modules/*</code> 和 <code>/bower_components/*</code> 将默认被忽略。</p>\n\n<p>举例，把下面的 <code>.eslintignore</code> 文件放倒工作目录下将会忽略<code>/node_modules/*</code> 和 <code>/bower_components/*</code> 目录，任何扩展名为 <code>.ts.js</code> 或 <code>.coffee.js</code> 可能被转换，任何在 <code>build/*</code> 目录除了 <code>build/index.js</code> 将被忽略：</p>\n\n<pre><code># /node_modules/* and /bower_components/* ignored by default\n\n# Ignore built files except build/index.js\nbuild/*  \n!build/index.js\n</code></pre>\n\n<h2 id=\"\">使用替换的文件</h2>\n\n<p>如果你喜欢去使用别的文件而不是 <code>.eslintignore</code> 来工作，你在命令行中可以指定 <code>--ignore-path</code> 选项。举例来说，你可以使用 <code>.jshintignore</code> ，因为两者的配置相同：</p>\n\n<pre><code>eslint --ignore-path .jshintignore file.js  \n</code></pre>\n\n<p>你也可以使用 <code>.gitignore</code> 文件：</p>\n\n<pre><code>eslint --ignore-path .gitignore file.js  \n</code></pre>\n\n<p>任何标准的 ignore 文件可以被使用。</p>\n\n<h2 id=\"\">忽略文件警告</h2>\n\n<p>当你 eslint 一个被忽略的文件或目录时，会发出警告，你可以使用 <code>--no-ignore</code> 来进行省略。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1464345663531,"created_by":1,"updated_at":1475408341798,"updated_by":1,"published_at":1464348992506,"published_by":1},{"id":12,"uuid":"d0ae47ae-bcbc-4333-93af-004ae853c2a2","title":"react 的虫洞 context（官方文档翻译）","slug":"react-de-chong-dong-context","markdown":"> 中文社区还停留在 0.14.7，文档上有不少落后了，比如 shadowEqual、context 等的知识，所以只能自己来了。\n\n#### Context\n\nReact 一个强大之处就是很容易去跟踪数据在组件中的流动。当你观察一个组件时，你能够容易地确切地看出什么 props 被传递，这使得你的 apps 能够容易地推导。\n\n偶尔，你想要去传递数据贯穿整个组件树，不想手动地一级级传递下去。React 的 \"context\" 特性帮助你做到这一点。（译外音：形象地描述就是像虫洞那样达到穿越效果，props 能够在自己共享，有点像全局变量）。\n\n> 注意： Context 是一个先进的、实验性的特性。这个 API 可能会在未来的发行版有所改变。\n\n> 大多数应用将不需要去使用 context。尤其如果你仅仅是初学 React ，你应当尽量不用 context。使用 context 将会试你的代码难以去理解，因为它使得数据的流动不清晰。它就像全局变量传递变量到整个应用。\n\n> 如果你不得不使用 context，请谨慎地使用。无论你是在在构建一个应用还是库，尝试去隔离 context 到一个小的区域和避免直接地使用 context API，这样可以在 API 改变时，方便地升级。\n\n#### 在组件树中自动地传递信息\n\n假定你有如下的结构：\n\n```\nclass Button extends React.Component {\n  render() {\n    return (\n      <button style={{background: this.props.color}}>\n        {this.props.children}\n      </button>\n    );\n  }\n}\n\nclass Message extends React.Component {\n  render() {\n    return (\n      <div>\n        {this.props.text} <Button color={this.props.color}>Delete</Button>\n      </div>\n    );\n  }\n}\n\nclass MessageList extends React.Component {\n  render() {\n    const color = \"purple\";\n    const children = this.props.messages.map((message) =>\n      <Message text={message.text} color={color} />\n    );\n    return <div>{children}</div>;\n  }\n}\n```\n\n在这个例子里，我们为了合适地设置 Button 和 Message 的样式，手动传递一个 color prop 。主题是一个好的例子，当你想要让整个子级可以访问一些信息片段（如：一个颜色）。 使用 context ，你可以传递这些自动地。\n\n```\nclass Button extends React.Component {\n  render() {\n    return (\n      <button style={{background: this.context.color}}>\n        {this.props.children}\n      </button>\n    );\n  }\n}\n\nButton.contextTypes = {\n  color: React.PropTypes.string\n};\n\nclass Message extends React.Component {\n  render() {\n    return (\n      <div>\n        {this.props.text} <Button>Delete</Button>\n      </div>\n    );\n  }\n}\n\nclass MessageList extends React.Component {\n  getChildContext() {\n    return {color: \"purple\"};\n  }\n\n  render() {\n    const children = this.props.messages.map((message) =>\n      <Message text={message.text} />\n    );\n    return <div>{children}</div>;\n  }\n}\n\nMessageList.childContextTypes = {\n  color: React.PropTypes.string\n};\n```\n\n通过在 MessageList（context的提供者） 添加 ` childContextTypes ` 和 ` getChildContext `, React 将会自动地传递信息下去，在所有的子组件中通过定义 ` contextTypes ` 就可以访问。\n\n如果 ` contextTypes ` 没有定义，context 会是一个空的对象。\n\n#### 父子耦合（这一段优点不明觉厉）\nContext 也能够让你创建一个 API 如下：\n\n```\n<Menu>\n  <MenuItem>aubergine</MenuItem>\n  <MenuItem>butternut squash</MenuItem>\n  <MenuItem>clementine</MenuItem>\n</Menu>\n```\n\n通过在 Menu 组件传递相关的信息，每一个 MenuItem 能够传回 Menu 容器。\n\n在你使用这个 API 构建组件之前，考虑是否有更干净的替代方案。我们盲目的传递 items 作为一个数组，如下：\n\n```\n<Menu items={['aubergine', 'butternut squash', 'clementine']} />\n```\n\n再次提醒，你能够在 props 中传递整个 React 组件如果你喜欢。\n\n#### 在生命周期方法引用 context \n\n如果 ` contextTypes ` 被定义在一个组件中，下列生命周期方法将会收到额外的参数：\n\n```\nvoid componentWillReceiveProps(\n  object nextProps, object nextContext\n)\n\nboolean shouldComponentUpdate(\n  object nextProps, object nextState, object nextContext\n)\n\nvoid componentWillUpdate(\n  object nextProps, object nextState, object nextContext\n)\n\nvoid componentDidUpdate(\n  object prevProps, object prevState, object prevContext\n)\n```\n\n#### 在无状态函数组件引用 context \n\n无状态函数组件也能够引用 context ，如果 ` contextTypes ` 被定义为函数的参数。下列代码显示了基于无状态函数的 Button 组件。\n\n```\nconst Button = ({children}, context) =>\n  <button style={{background: context.color}}>\n    {children}\n  </button>;\n\nButton.contextTypes = {color: React.PropTypes.string};\n```\n\n#### 更新 context\n当 state 或 props 改变， ` getChildContext ` 函数将被调用。为了更新 context 中的数据, 用 ` this.setState ` 触发一个本地的 state 的更新。这将会触发一个新的 context 然后子组件将会收到改变的 context。\n\n```\nclass MediaQuery extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {type:'desktop'};\n  }\n\n  getChildContext() {\n    return {type: this.state.type};\n  }\n\n  componentDidMount() {\n    const checkMediaQuery = () => {\n      const type = window.matchMedia(\"(min-width: 1025px)\").matches ? 'desktop' : 'mobile';\n      if (type !== this.state.type) {\n        this.setState({type});\n      }\n    };\n\n    window.addEventListener('resize', checkMediaQuery);\n    checkMediaQuery();\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\n\nMediaQuery.childContextTypes = {\n  type: React.PropTypes.string\n};\n```\n\n#### 什么时候不该使用 context \n\n在写干净的代码时，全局变量是最好要避免的，你应当避免使用 context 在那多数情况下。尤其是在使用它去节省代码和代替明确的传递 props 时，要思考再三。\n\n最好的方式对于 context 是绝对地向下传递 登录用户、当前语言或主题信息等。所有这些除了全局变量，context 推荐你把它们规定在一个单一的 React 组件树内。\n\n在组件中不要使用 context 去传递你的模型数据。在整个树上明确地传递你的数据是更加容易去理解的。使用 context 使你的组件更多的耦合和更少的复用性，因为它们的渲染因所处的环境而不同。\n\n#### 已知的限制\n\n如果一个 context 的值被组件的改变提供，当中间组件使用了` shouldComponentUpdate ` 并返回了 `false\n ` 那么后代的值将不会改变。详见 github issue [#2517](https://github.com/facebook/react/issues/2517)\n\n","html":"<blockquote>\n  <p>中文社区还停留在 0.14.7，文档上有不少落后了，比如 shadowEqual、context 等的知识，所以只能自己来了。</p>\n</blockquote>\n\n<h4 id=\"context\">Context</h4>\n\n<p>React 一个强大之处就是很容易去跟踪数据在组件中的流动。当你观察一个组件时，你能够容易地确切地看出什么 props 被传递，这使得你的 apps 能够容易地推导。</p>\n\n<p>偶尔，你想要去传递数据贯穿整个组件树，不想手动地一级级传递下去。React 的 \"context\" 特性帮助你做到这一点。（译外音：形象地描述就是像虫洞那样达到穿越效果，props 能够在自己共享，有点像全局变量）。</p>\n\n<blockquote>\n  <p>注意： Context 是一个先进的、实验性的特性。这个 API 可能会在未来的发行版有所改变。</p>\n  \n  <p>大多数应用将不需要去使用 context。尤其如果你仅仅是初学 React ，你应当尽量不用 context。使用 context 将会试你的代码难以去理解，因为它使得数据的流动不清晰。它就像全局变量传递变量到整个应用。</p>\n  \n  <p>如果你不得不使用 context，请谨慎地使用。无论你是在在构建一个应用还是库，尝试去隔离 context 到一个小的区域和避免直接地使用 context API，这样可以在 API 改变时，方便地升级。</p>\n</blockquote>\n\n<h4 id=\"\">在组件树中自动地传递信息</h4>\n\n<p>假定你有如下的结构：</p>\n\n<pre><code>class Button extends React.Component {  \n  render() {\n    return (\n      &lt;button style={{background: this.props.color}}&gt;\n        {this.props.children}\n      &lt;/button&gt;\n    );\n  }\n}\n\nclass Message extends React.Component {  \n  render() {\n    return (\n      &lt;div&gt;\n        {this.props.text} &lt;Button color={this.props.color}&gt;Delete&lt;/Button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nclass MessageList extends React.Component {  \n  render() {\n    const color = \"purple\";\n    const children = this.props.messages.map((message) =&gt;\n      &lt;Message text={message.text} color={color} /&gt;\n    );\n    return &lt;div&gt;{children}&lt;/div&gt;;\n  }\n}\n</code></pre>\n\n<p>在这个例子里，我们为了合适地设置 Button 和 Message 的样式，手动传递一个 color prop 。主题是一个好的例子，当你想要让整个子级可以访问一些信息片段（如：一个颜色）。 使用 context ，你可以传递这些自动地。</p>\n\n<pre><code>class Button extends React.Component {  \n  render() {\n    return (\n      &lt;button style={{background: this.context.color}}&gt;\n        {this.props.children}\n      &lt;/button&gt;\n    );\n  }\n}\n\nButton.contextTypes = {  \n  color: React.PropTypes.string\n};\n\nclass Message extends React.Component {  \n  render() {\n    return (\n      &lt;div&gt;\n        {this.props.text} &lt;Button&gt;Delete&lt;/Button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nclass MessageList extends React.Component {  \n  getChildContext() {\n    return {color: \"purple\"};\n  }\n\n  render() {\n    const children = this.props.messages.map((message) =&gt;\n      &lt;Message text={message.text} /&gt;\n    );\n    return &lt;div&gt;{children}&lt;/div&gt;;\n  }\n}\n\nMessageList.childContextTypes = {  \n  color: React.PropTypes.string\n};\n</code></pre>\n\n<p>通过在 MessageList（context的提供者） 添加 <code>childContextTypes</code> 和 <code>getChildContext</code>, React 将会自动地传递信息下去，在所有的子组件中通过定义 <code>contextTypes</code> 就可以访问。</p>\n\n<p>如果 <code>contextTypes</code> 没有定义，context 会是一个空的对象。</p>\n\n<h4 id=\"\">父子耦合（这一段优点不明觉厉）</h4>\n\n<p>Context 也能够让你创建一个 API 如下：</p>\n\n<pre><code>&lt;Menu&gt;  \n  &lt;MenuItem&gt;aubergine&lt;/MenuItem&gt;\n  &lt;MenuItem&gt;butternut squash&lt;/MenuItem&gt;\n  &lt;MenuItem&gt;clementine&lt;/MenuItem&gt;\n&lt;/Menu&gt;  \n</code></pre>\n\n<p>通过在 Menu 组件传递相关的信息，每一个 MenuItem 能够传回 Menu 容器。</p>\n\n<p>在你使用这个 API 构建组件之前，考虑是否有更干净的替代方案。我们盲目的传递 items 作为一个数组，如下：</p>\n\n<pre><code>&lt;Menu items={['aubergine', 'butternut squash', 'clementine']} /&gt;  \n</code></pre>\n\n<p>再次提醒，你能够在 props 中传递整个 React 组件如果你喜欢。</p>\n\n<h4 id=\"context\">在生命周期方法引用 context</h4>\n\n<p>如果 <code>contextTypes</code> 被定义在一个组件中，下列生命周期方法将会收到额外的参数：</p>\n\n<pre><code>void componentWillReceiveProps(  \n  object nextProps, object nextContext\n)\n\nboolean shouldComponentUpdate(  \n  object nextProps, object nextState, object nextContext\n)\n\nvoid componentWillUpdate(  \n  object nextProps, object nextState, object nextContext\n)\n\nvoid componentDidUpdate(  \n  object prevProps, object prevState, object prevContext\n)\n</code></pre>\n\n<h4 id=\"context\">在无状态函数组件引用 context</h4>\n\n<p>无状态函数组件也能够引用 context ，如果 <code>contextTypes</code> 被定义为函数的参数。下列代码显示了基于无状态函数的 Button 组件。</p>\n\n<pre><code>const Button = ({children}, context) =&gt;  \n  &lt;button style={{background: context.color}}&gt;\n    {children}\n  &lt;/button&gt;;\n\nButton.contextTypes = {color: React.PropTypes.string};  \n</code></pre>\n\n<h4 id=\"context\">更新 context</h4>\n\n<p>当 state 或 props 改变， <code>getChildContext</code> 函数将被调用。为了更新 context 中的数据, 用 <code>this.setState</code> 触发一个本地的 state 的更新。这将会触发一个新的 context 然后子组件将会收到改变的 context。</p>\n\n<pre><code>class MediaQuery extends React.Component {  \n  constructor(props) {\n    super(props);\n    this.state = {type:'desktop'};\n  }\n\n  getChildContext() {\n    return {type: this.state.type};\n  }\n\n  componentDidMount() {\n    const checkMediaQuery = () =&gt; {\n      const type = window.matchMedia(\"(min-width: 1025px)\").matches ? 'desktop' : 'mobile';\n      if (type !== this.state.type) {\n        this.setState({type});\n      }\n    };\n\n    window.addEventListener('resize', checkMediaQuery);\n    checkMediaQuery();\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\n\nMediaQuery.childContextTypes = {  \n  type: React.PropTypes.string\n};\n</code></pre>\n\n<h4 id=\"context\">什么时候不该使用 context</h4>\n\n<p>在写干净的代码时，全局变量是最好要避免的，你应当避免使用 context 在那多数情况下。尤其是在使用它去节省代码和代替明确的传递 props 时，要思考再三。</p>\n\n<p>最好的方式对于 context 是绝对地向下传递 登录用户、当前语言或主题信息等。所有这些除了全局变量，context 推荐你把它们规定在一个单一的 React 组件树内。</p>\n\n<p>在组件中不要使用 context 去传递你的模型数据。在整个树上明确地传递你的数据是更加容易去理解的。使用 context 使你的组件更多的耦合和更少的复用性，因为它们的渲染因所处的环境而不同。</p>\n\n<h4 id=\"\">已知的限制</h4>\n\n<p>如果一个 context 的值被组件的改变提供，当中间组件使用了<code>shouldComponentUpdate</code> 并返回了 <code>false\n</code> 那么后代的值将不会改变。详见 github issue <a href=\"https://github.com/facebook/react/issues/2517\">#2517</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1464684672461,"created_by":1,"updated_at":1467696306538,"updated_by":1,"published_at":1467685948549,"published_by":1},{"id":13,"uuid":"e38601e3-c8d0-4448-9fae-9f792e249b1a","title":"react native 踩坑实录","slug":"react-native-keng","markdown":"### 持续更新。。。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=26402069&auto=1&height=66\"></iframe>\n\n1、 [Android] StatusBar Translucent not working in Android 4.x.x after upgrading to react 0.23 [#6876](https://github.com/facebook/react-native/issues/6876)\n\n> solution: I changed the implementation of translucent and it only works on API 21+ now. Can you just not add top padding on Android 4.4- using Platform.Version < 21?\n\n2、 在使用pure-render相关的组件时，尽量不要使用箭头函数或者是行内的bind，因为这两种方式都是会返回一个新的实例，从而导致re－render。\n\n> solution: bind function in the constructor.\n\n3、 定时器在rn中使用还是比较广泛的，但是 timeMixin 暂时不支持在 es6 class 中的使用，于是去github看了下issue，官网也推荐使用 reactMixin 将 mixin 绑定到 es6 class ，并亲自测试了一下，通过。中文网也给出了手动 clear 的方案，相比之下复用性低，其实就是不用 mixin 的方案，但是依赖比较少，各有优势吧！\n\n```\nimport React, { Component } from 'react-native';\nimport TimerMixin from 'react-timer-mixin';\nimport reactMixin from 'react-mixin';\nclass MyClass extends Component {\n    componentDidMount() {\n      this.setTimeout(\n        () => { console.log('tick'); },\n        5000\n      );\n    }\n}\nreactMixin(MyClass.prototype, TimerMixin);\nmodule.exports = MyClass;\n```\n\n4、 这两天集成 redux 时，发现rn的 ListView 经常不更新，于是深入到了源码内一看了究竟。看看是什么时候 ListView 会更新row。[有点多，新开了一篇](http://m2mbob.cn:1314/listview-row-update/)\n\n5、 不知道哪个版本 ListView 引入了 ` enableEmptySections `属性，这个属性只能有一个值true，为true时，会渲染没有 ` row ` 的 ` section ` 。下面这段代码可以看到，这个属性将在之后的版本不被推荐使用，官方建议在传参数时把空的 ` section ` 过滤掉。不过在实践过程中发现空数组实际上也会构造一个 ` section ` ，导致 warning ，强迫症想把它去掉啊！😂 \n```\nif (rowIDs.length === 0) {\n        if (this.props.enableEmptySections === undefined) {\n          var warning = require('fbjs/lib/warning');\n          warning(false, 'In next release empty section headers will be rendered.'\n                  + ' In this release you can use \\'enableEmptySections\\' flag to render empty section headers.');\n          continue;\n        } else {\n          var invariant = require('fbjs/lib/invariant');\n          invariant(\n            this.props.enableEmptySections,\n            'In next release \\'enableEmptySections\\' flag will be deprecated, empty section headers will always be rendered.'\n            + ' If empty section headers are not desirable their indices should be excluded from sectionIDs object.'\n            + ' In this release \\'enableEmptySections\\' may only have value \\'true\\' to allow empty section headers rendering.');\n        }\n      }\n```\n\n6、 对于 TouchableHighlight 组件，会出现没有效果的情况，解决方案是在外面包一层背景。\n\n7、 ios 模拟器点击无效的解决方案，在模拟器的Debug菜单中，关掉Slow Animations就好了。关掉Slow Animations之后，模拟器响应的都快了，非常好用，建议模拟器这一项不要开着。\n\n8、 这个不是 react native 本身的问题，而是在使用 react-native-vector-icons 的 ToolBarAndroid 组件过程中遇到的问题。首先 actions 的 title字段是必须的，其次是在 react-native-vector-icons 当中不是使用 icon 而是使用 iconName， iconColor， iconSize 这三个参数！！ 😒\n\n9、 今天拿出自己的安卓机测流程时发现，文本在安卓上的 padding 不见了，然后去 github ，果然有道友提出了相同的问题[#7848](https://github.com/facebook/react-native/issues/7848#issuecomment-233517201)。不过 margin 是工作良好的，所以暂时先用 margin 替换了原来的 padding。\n\n10、 TouchableNativeFeedback 组件只支持 个人 View 作为子元素，其他元素将无法显示，多个元素则会报错。\n\n11、 WebSocket connection to 'ws://localhost:8081/debugger-proxy?role=debugger&name=Chrome' failed: Invalid frame header[6627](https://github.com/facebook/react-native/issues/6627) node 6.3 下面 rn 调试会出问题，建议先滚回 6.2，不过 rn 0.30 貌似解决了这个问题，但是暂时不升级 rn ，所以先记一下。","html":"<h3 id=\"\">持续更新。。。</h3>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=26402069&auto=1&height=66\"></iframe>\n\n<p>1、 [Android] StatusBar Translucent not working in Android 4.x.x after upgrading to react 0.23 <a href=\"https://github.com/facebook/react-native/issues/6876\">#6876</a></p>\n\n<blockquote>\n  <p>solution: I changed the implementation of translucent and it only works on API 21+ now. Can you just not add top padding on Android 4.4- using Platform.Version &lt; 21?</p>\n</blockquote>\n\n<p>2、 在使用pure-render相关的组件时，尽量不要使用箭头函数或者是行内的bind，因为这两种方式都是会返回一个新的实例，从而导致re－render。</p>\n\n<blockquote>\n  <p>solution: bind function in the constructor.</p>\n</blockquote>\n\n<p>3、 定时器在rn中使用还是比较广泛的，但是 timeMixin 暂时不支持在 es6 class 中的使用，于是去github看了下issue，官网也推荐使用 reactMixin 将 mixin 绑定到 es6 class ，并亲自测试了一下，通过。中文网也给出了手动 clear 的方案，相比之下复用性低，其实就是不用 mixin 的方案，但是依赖比较少，各有优势吧！</p>\n\n<pre><code>import React, { Component } from 'react-native';  \nimport TimerMixin from 'react-timer-mixin';  \nimport reactMixin from 'react-mixin';  \nclass MyClass extends Component {  \n    componentDidMount() {\n      this.setTimeout(\n        () =&gt; { console.log('tick'); },\n        5000\n      );\n    }\n}\nreactMixin(MyClass.prototype, TimerMixin);  \nmodule.exports = MyClass;  \n</code></pre>\n\n<p>4、 这两天集成 redux 时，发现rn的 ListView 经常不更新，于是深入到了源码内一看了究竟。看看是什么时候 ListView 会更新row。<a href=\"http://m2mbob.cn:1314/listview-row-update/\">有点多，新开了一篇</a></p>\n\n<p>5、 不知道哪个版本 ListView 引入了 <code>enableEmptySections</code>属性，这个属性只能有一个值true，为true时，会渲染没有 <code>row</code> 的 <code>section</code> 。下面这段代码可以看到，这个属性将在之后的版本不被推荐使用，官方建议在传参数时把空的 <code>section</code> 过滤掉。不过在实践过程中发现空数组实际上也会构造一个 <code>section</code> ，导致 warning ，强迫症想把它去掉啊！😂  </p>\n\n<pre><code>if (rowIDs.length === 0) {  \n        if (this.props.enableEmptySections === undefined) {\n          var warning = require('fbjs/lib/warning');\n          warning(false, 'In next release empty section headers will be rendered.'\n                  + ' In this release you can use \\'enableEmptySections\\' flag to render empty section headers.');\n          continue;\n        } else {\n          var invariant = require('fbjs/lib/invariant');\n          invariant(\n            this.props.enableEmptySections,\n            'In next release \\'enableEmptySections\\' flag will be deprecated, empty section headers will always be rendered.'\n            + ' If empty section headers are not desirable their indices should be excluded from sectionIDs object.'\n            + ' In this release \\'enableEmptySections\\' may only have value \\'true\\' to allow empty section headers rendering.');\n        }\n      }\n</code></pre>\n\n<p>6、 对于 TouchableHighlight 组件，会出现没有效果的情况，解决方案是在外面包一层背景。</p>\n\n<p>7、 ios 模拟器点击无效的解决方案，在模拟器的Debug菜单中，关掉Slow Animations就好了。关掉Slow Animations之后，模拟器响应的都快了，非常好用，建议模拟器这一项不要开着。</p>\n\n<p>8、 这个不是 react native 本身的问题，而是在使用 react-native-vector-icons 的 ToolBarAndroid 组件过程中遇到的问题。首先 actions 的 title字段是必须的，其次是在 react-native-vector-icons 当中不是使用 icon 而是使用 iconName， iconColor， iconSize 这三个参数！！ 😒</p>\n\n<p>9、 今天拿出自己的安卓机测流程时发现，文本在安卓上的 padding 不见了，然后去 github ，果然有道友提出了相同的问题<a href=\"https://github.com/facebook/react-native/issues/7848#issuecomment-233517201\">#7848</a>。不过 margin 是工作良好的，所以暂时先用 margin 替换了原来的 padding。</p>\n\n<p>10、 TouchableNativeFeedback 组件只支持 个人 View 作为子元素，其他元素将无法显示，多个元素则会报错。</p>\n\n<p>11、 WebSocket connection to 'ws://localhost:8081/debugger-proxy?role=debugger&amp;name=Chrome' failed: Invalid frame header<a href=\"https://github.com/facebook/react-native/issues/6627\">6627</a> node 6.3 下面 rn 调试会出问题，建议先滚回 6.2，不过 rn 0.30 貌似解决了这个问题，但是暂时不升级 rn ，所以先记一下。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1464770450231,"created_by":1,"updated_at":1474249886869,"updated_by":1,"published_at":1466558940000,"published_by":1},{"id":14,"uuid":"5b126970-3765-4b5e-9e06-920981bfd050","title":"Immutable.js 文档翻译（API部分）","slug":"immutable-js-wen-dang-fan-yi-apibu-fen","markdown":"不可变数据鼓励纯函数（相同的数据输入得到相同的输出），适用于更加简单的应用开发，并支持延迟计算等函数式编程的技术。\n\n当设计把这些强大的功能性概念带给 ` JavaScript ` 时，它提出了一个 ` JavaScript ` 工程师熟悉的面向对象的 API并十分接近地反映了 ` Array ` , ` Map\n ` 和 ` Set ` 等数据结构。它能够很容易并高效地与普通 ` JavaScript ` 基本类型转换。 \n\n注意：所有的例子用 [ES6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla)。为了在所有浏览器中运行，它们需要呗专为 ES3 。例如：\n\n```\n// ES6\nfoo.map(x => x * x);\n// ES3\nfoo.map(function (x) { return x * x; });\n```\n\n#### API\n\n[fromJS()](www.baidu.com)\n\n把普通的 JS 对象和数组深度转换为不可变的 Maps 和 Lists。\n\n[is()](www.baidu.com)\n\n比较直是否相等，类似于 ES6 新引入的 [Object.is](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) ，但是它把不可变的 [Iterable](www.baidu.com) 当作值，如果第二个 [Iterable](www.baidu.com) 包含相等的值就相等。\n\n[List](www.baidu.com)\n\nLists 是排序索引密集的集合，与 ` JavaScript ` 的 ` Array ` 十分相似。 \n\n[Map](www.baidu.com)\n\n不可变的 Map ，获取和设置的复杂度为 ` O(log32 N) ` 。 \n\n[OrderedMap](www.baidu.com)\n\n一种保证了内容顺序与 set() 顺序一致的 Map。 \n\n[Set](www.baidu.com)\n\n唯一值集合，添加和判断存在复杂度为 ` O(log32 N) ` 。 \n\n[OrderedSet](www.baidu.com)\n\n一种保证了内容顺序与 add() 顺序一致的 Set。\n\n[Stack](www.baidu.com)\n\n支持高效的添加和和删除的索引集合，栈。\n\n[Range()](www.baidu.com)","html":"<p>不可变数据鼓励纯函数（相同的数据输入得到相同的输出），适用于更加简单的应用开发，并支持延迟计算等函数式编程的技术。</p>\n\n<p>当设计把这些强大的功能性概念带给 <code>JavaScript</code> 时，它提出了一个 <code>JavaScript</code> 工程师熟悉的面向对象的 API并十分接近地反映了 <code>Array</code> , <code>Map\n</code> 和 <code>Set</code> 等数据结构。它能够很容易并高效地与普通 <code>JavaScript</code> 基本类型转换。 </p>\n\n<p>注意：所有的例子用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla\">ES6</a>。为了在所有浏览器中运行，它们需要呗专为 ES3 。例如：</p>\n\n<pre><code>// ES6\nfoo.map(x =&gt; x * x);  \n// ES3\nfoo.map(function (x) { return x * x; });  \n</code></pre>\n\n<h4 id=\"api\">API</h4>\n\n<p><a href=\"www.baidu.com\">fromJS()</a></p>\n\n<p>把普通的 JS 对象和数组深度转换为不可变的 Maps 和 Lists。</p>\n\n<p><a href=\"www.baidu.com\">is()</a></p>\n\n<p>比较直是否相等，类似于 ES6 新引入的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\">Object.is</a> ，但是它把不可变的 <a href=\"www.baidu.com\">Iterable</a> 当作值，如果第二个 <a href=\"www.baidu.com\">Iterable</a> 包含相等的值就相等。</p>\n\n<p><a href=\"www.baidu.com\">List</a></p>\n\n<p>Lists 是排序索引密集的集合，与 <code>JavaScript</code> 的 <code>Array</code> 十分相似。 </p>\n\n<p><a href=\"www.baidu.com\">Map</a></p>\n\n<p>不可变的 Map ，获取和设置的复杂度为 <code>O(log32 N)</code> 。 </p>\n\n<p><a href=\"www.baidu.com\">OrderedMap</a></p>\n\n<p>一种保证了内容顺序与 set() 顺序一致的 Map。 </p>\n\n<p><a href=\"www.baidu.com\">Set</a></p>\n\n<p>唯一值集合，添加和判断存在复杂度为 <code>O(log32 N)</code> 。 </p>\n\n<p><a href=\"www.baidu.com\">OrderedSet</a></p>\n\n<p>一种保证了内容顺序与 add() 顺序一致的 Set。</p>\n\n<p><a href=\"www.baidu.com\">Stack</a></p>\n\n<p>支持高效的添加和和删除的索引集合，栈。</p>\n\n<p><a href=\"www.baidu.com\">Range()</a></p>","image":null,"featured":0,"page":0,"status":"draft","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1466583064760,"created_by":1,"updated_at":1475805205485,"updated_by":1,"published_at":null,"published_by":null},{"id":15,"uuid":"d84b75b7-f57b-4d44-abee-7ba5a9c92cc3","title":"深入RN ListView源码，了解 row 更新机制","slug":"listview-row-update","markdown":"> version 0.25.1\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=31445772&auto=1&height=66\"></iframe>\n\n打开`/node_modules/react-native/Libraries/CustomComponents/ListView` 文件夹，下面有两个js，分别为 ` ListView ` 和 ` ListViewDataSource `。首先看 ` ListView ` 321 行：\n```\n  componentWillReceiveProps: function(nextProps) {\n     // 只有传入了新的dataSource或者initialListSize改变时才会重新渲染整个列表\n     if (this.props.dataSource !== nextProps.dataSource ||\n        this.props.initialListSize !== nextProps.initialListSize) {\n      this.setState((state, props) => {\n        // 同一个dataSource上一次以渲染的行数置为0\n        this._prevRenderedRowsCount = 0;\n        return {\n          // 第一次要渲染的行数\n          curRenderedRowsCount: Math.min(\n            Math.max(\n              state.curRenderedRowsCount,\n              props.initialListSize\n            ),\n            props.enableEmptySections ? props.dataSource.getRowAndSectionCount() : props.dataSource.getRowCount()\n          ),\n        };\n      }, () => this._renderMoreRowsIfNeeded());\n    }\n  },\n```\n其次是 `render` 函数：\n```\nfor (var rowIdx = 0; rowIdx < rowIDs.length; rowIdx++) {\n        var rowID = rowIDs[rowIdx];\n        var comboID = sectionID + '_' + rowID;\n        // 当前行数大于已经渲染的行数且dataSource.rowShouldUpdate为true才进行新的一行的渲染。\n        var shouldUpdateRow = rowCount >= this._prevRenderedRowsCount &&\n          dataSource.rowShouldUpdate(sectionIdx, rowIdx);\n        var row =\n          <StaticRenderer\n            key={'r_' + comboID}\n            shouldUpdate={!!shouldUpdateRow}\n            render={this.props.renderRow.bind(\n              null,\n              dataSource.getRowData(sectionIdx, rowIdx),\n              sectionID,\n              rowID,\n              this._onRowHighlighted\n            )}\n          />;\n        bodyComponents.push(row);\n        totalIndex++;\n```\n最后就要看看 ` dataSource.rowShouldUpdate ` 发生了什么，打开 ` ListViewDataSource ` 236行：\n```\nrowShouldUpdate(sectionIndex: number, rowIndex: number): bool {\n    // 尼玛_dirtyRows是啥\n    var needsUpdate = this._dirtyRows[sectionIndex][rowIndex];\n    warning(needsUpdate !== undefined,\n      'missing dirtyBit for section, row: ' + sectionIndex + ', ' + rowIndex);\n    return needsUpdate;\n  }\n```\n再到376行吧：\n```\n      this._dirtyRows[sIndex] = [];\n      for (var rIndex = 0; rIndex < this.rowIdentities[sIndex].length; rIndex++) {\n        var rowID = this.rowIdentities[sIndex][rIndex];\n        // 如果sectionID、rowID是新的或者调用我们定义的rowHasChanged返回是true的话就是脏的，就需要更新。\n        dirty =\n          !prevSectionsHash[sectionID] ||\n          !prevRowsHash[sectionID][rowID] ||\n          this._rowHasChanged(\n            this._getRowData(prevDataBlob, sectionID, rowID),\n            this._getRowData(this._dataBlob, sectionID, rowID)\n          );\n        this._dirtyRows[sIndex].push(!!dirty);\n      }\n```\n到这里我终于发现自己的 row 为何不更新了，我们平时写的 ` rowHasChanged `方法都是直接 `===` 比较的，如果内容变了引用没变比较返回的就是 ` true ` 。这就要追溯到我在 reselect 中的操作了，我只改变了 列表数据的引用，而没有改变其中每一项数据的引用，所以在 ` rowHasChanged ` 比较时出了问题。不过改变引用之后，新的问题又来了， ` rowHasChanged `无论如何返回的都是true，然后每次都会更新，这是无法接受的。临时解决方案是，使用 fbjs 中的 ` shadowEqual ` 进行比较，而不是简单的 ` === `。 `shadowEqual` 只会比较第一层的属性，还不是最好的方案，最好的方案我认为是引入 `immutablejs`。","html":"<blockquote>\n  <p>version 0.25.1</p>\n</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=31445772&auto=1&height=66\"></iframe>\n\n<p>打开<code>/node_modules/react-native/Libraries/CustomComponents/ListView</code> 文件夹，下面有两个js，分别为 <code>ListView</code> 和 <code>ListViewDataSource</code>。首先看 <code>ListView</code> 321 行：</p>\n\n<pre><code>  componentWillReceiveProps: function(nextProps) {\n     // 只有传入了新的dataSource或者initialListSize改变时才会重新渲染整个列表\n     if (this.props.dataSource !== nextProps.dataSource ||\n        this.props.initialListSize !== nextProps.initialListSize) {\n      this.setState((state, props) =&gt; {\n        // 同一个dataSource上一次以渲染的行数置为0\n        this._prevRenderedRowsCount = 0;\n        return {\n          // 第一次要渲染的行数\n          curRenderedRowsCount: Math.min(\n            Math.max(\n              state.curRenderedRowsCount,\n              props.initialListSize\n            ),\n            props.enableEmptySections ? props.dataSource.getRowAndSectionCount() : props.dataSource.getRowCount()\n          ),\n        };\n      }, () =&gt; this._renderMoreRowsIfNeeded());\n    }\n  },\n</code></pre>\n\n<p>其次是 <code>render</code> 函数：</p>\n\n<pre><code>for (var rowIdx = 0; rowIdx &lt; rowIDs.length; rowIdx++) {  \n        var rowID = rowIDs[rowIdx];\n        var comboID = sectionID + '_' + rowID;\n        // 当前行数大于已经渲染的行数且dataSource.rowShouldUpdate为true才进行新的一行的渲染。\n        var shouldUpdateRow = rowCount &gt;= this._prevRenderedRowsCount &amp;&amp;\n          dataSource.rowShouldUpdate(sectionIdx, rowIdx);\n        var row =\n          &lt;StaticRenderer\n            key={'r_' + comboID}\n            shouldUpdate={!!shouldUpdateRow}\n            render={this.props.renderRow.bind(\n              null,\n              dataSource.getRowData(sectionIdx, rowIdx),\n              sectionID,\n              rowID,\n              this._onRowHighlighted\n            )}\n          /&gt;;\n        bodyComponents.push(row);\n        totalIndex++;\n</code></pre>\n\n<p>最后就要看看 <code>dataSource.rowShouldUpdate</code> 发生了什么，打开 <code>ListViewDataSource</code> 236行：</p>\n\n<pre><code>rowShouldUpdate(sectionIndex: number, rowIndex: number): bool {  \n    // 尼玛_dirtyRows是啥\n    var needsUpdate = this._dirtyRows[sectionIndex][rowIndex];\n    warning(needsUpdate !== undefined,\n      'missing dirtyBit for section, row: ' + sectionIndex + ', ' + rowIndex);\n    return needsUpdate;\n  }\n</code></pre>\n\n<p>再到376行吧：</p>\n\n<pre><code>      this._dirtyRows[sIndex] = [];\n      for (var rIndex = 0; rIndex &lt; this.rowIdentities[sIndex].length; rIndex++) {\n        var rowID = this.rowIdentities[sIndex][rIndex];\n        // 如果sectionID、rowID是新的或者调用我们定义的rowHasChanged返回是true的话就是脏的，就需要更新。\n        dirty =\n          !prevSectionsHash[sectionID] ||\n          !prevRowsHash[sectionID][rowID] ||\n          this._rowHasChanged(\n            this._getRowData(prevDataBlob, sectionID, rowID),\n            this._getRowData(this._dataBlob, sectionID, rowID)\n          );\n        this._dirtyRows[sIndex].push(!!dirty);\n      }\n</code></pre>\n\n<p>到这里我终于发现自己的 row 为何不更新了，我们平时写的 <code>rowHasChanged</code>方法都是直接 <code>===</code> 比较的，如果内容变了引用没变比较返回的就是 <code>true</code> 。这就要追溯到我在 reselect 中的操作了，我只改变了 列表数据的引用，而没有改变其中每一项数据的引用，所以在 <code>rowHasChanged</code> 比较时出了问题。不过改变引用之后，新的问题又来了， <code>rowHasChanged</code>无论如何返回的都是true，然后每次都会更新，这是无法接受的。临时解决方案是，使用 fbjs 中的 <code>shadowEqual</code> 进行比较，而不是简单的 <code>===</code>。 <code>shadowEqual</code> 只会比较第一层的属性，还不是最好的方案，最好的方案我认为是引入 <code>immutablejs</code>。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1466662979518,"created_by":1,"updated_at":1473918178729,"updated_by":1,"published_at":1466843081339,"published_by":1},{"id":16,"uuid":"00f8ea34-3b29-434c-a49c-c4f0fab84839","title":"关于 ES 草案","slug":"guan-yu-es-cao-an","markdown":"babel6 模块化之后，使用 Presets 来引入 babel 转译时需要支持的特性，此时我们能够看到几个 stage-x 的 persets，一脸懵逼，于是就去了解了一下这是啥。\n\n这一切要从 ES 草案的制定说起。ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。\n\n任何人都可以向TC39提案，从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由TC39委员会批准。\n\n- Stage 0 - Strawman（展示阶段）\n- Stage 1 - Proposal（征求意见阶段）\n- Stage 2 - Draft（草案阶段）\n- Stage 3 - Candidate（候选人阶段）\n- Stage 4 - Finished（定案阶段） \n\n我们可以在 github 这个仓库查看各个阶段有哪些提案，[各阶段提案](https://github.com/tc39/proposals)。我们可以看到 ` Async Functions ` 已经进入 Stage 3 了呢，😬，这意味着离它进入 ES 规范的日子不远了，不过今年已经的新特性已经发布了哈哈，明年见。今年的规范更新了 ` Array.includes ` 和 指数两个特性。至于为什么今年相较于去年只更新了两个特性，可以看知乎这个回答，相当详细啊[如何评价 ECMAScript 2016（ES7）只新增2个特性？](http://www.zhihu.com/question/39993685)","html":"<p>babel6 模块化之后，使用 Presets 来引入 babel 转译时需要支持的特性，此时我们能够看到几个 stage-x 的 persets，一脸懵逼，于是就去了解了一下这是啥。</p>\n\n<p>这一切要从 ES 草案的制定说起。ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。</p>\n\n<p>任何人都可以向TC39提案，从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由TC39委员会批准。</p>\n\n<ul>\n<li>Stage 0 - Strawman（展示阶段）</li>\n<li>Stage 1 - Proposal（征求意见阶段）</li>\n<li>Stage 2 - Draft（草案阶段）</li>\n<li>Stage 3 - Candidate（候选人阶段）</li>\n<li>Stage 4 - Finished（定案阶段） </li>\n</ul>\n\n<p>我们可以在 github 这个仓库查看各个阶段有哪些提案，<a href=\"https://github.com/tc39/proposals\">各阶段提案</a>。我们可以看到 <code>Async Functions</code> 已经进入 Stage 3 了呢，😬，这意味着离它进入 ES 规范的日子不远了，不过今年已经的新特性已经发布了哈哈，明年见。今年的规范更新了 <code>Array.includes</code> 和 指数两个特性。至于为什么今年相较于去年只更新了两个特性，可以看知乎这个回答，相当详细啊<a href=\"http://www.zhihu.com/question/39993685\">如何评价 ECMAScript 2016（ES7）只新增2个特性？</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1466844324720,"created_by":1,"updated_at":1475058142093,"updated_by":1,"published_at":1466845477628,"published_by":1},{"id":19,"uuid":"3cdea6e0-1225-42e2-bf91-42bd5bf05cb1","title":"脑洞和感动","slug":"nao-dong-he-gan-dong","markdown":"<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"http://static.hdslb.com/miniloader.swf\" flashvars=\"aid=3138291&page=1\" pluginspage=\"http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed>","html":"<p><embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"http://static.hdslb.com/miniloader.swf\" flashvars=\"aid=3138291&amp;page=1\" pluginspage=\"http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1467110745929,"created_by":1,"updated_at":1467111347667,"updated_by":1,"published_at":1467111153989,"published_by":1},{"id":21,"uuid":"e2fa0f4a-0bcf-49de-9520-ee74d98f21f5","title":"关于色彩搭配（基础知识篇）","slug":"guan-yu-se-cai-da-pei","markdown":"App写得差不多了，感觉其中的色彩的运用比较乱，没有统一起来，于是花了一个下午，学习了一下色彩搭配相关的一些知识，准备统一一下App的配色。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=29431066&auto=1&height=66\"></iframe>\n\n###### 一个色环\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f7768iqi36j305k05kweo.jpg)\n伊顿12色环是由近代著名的瑞士色彩学大叔😳约翰内斯•伊顿先生设计的，如上图。他把红、黄蓝作为三原色，而有两种原色不同比例混合混合所得到的为二次色，也叫间色。而由两个间色或是三个三原色混合而得到的颜色为三次色，或者称为复色，包括了除了原色和间色以外的所有颜色。\n\n###### 两种混色\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f7768wt9q6j30dw05fq3b.jpg)\n色光三原色（加法混色）和色料三原色（减法混色），这两个让我不明觉历啊🤔。水好深啊！\n\n加法混合是指色光的混合，两种以上的光混合在一起，光亮度会提高，混合色的光的总亮度等于相混各色光亮度之和。色光混合中，三原色是朱红、翠绿、蓝紫。这三色光是不能用其它别的色光相混而产生的。\n\n白色光线透过有色滤光片之后，一部分光线被反射而吸收其余的光线，减少掉一部分辐射功率，最后透过的光是两次减光的结果，这样的色彩混合称为减法混合。一般说来，透明性强的染料，混合后具有明显的减光作用？？？减法混合的三原色是加法混合的三原色的补色，即：翠绿的补色红（品红）、蓝紫的补色黄（淡黄）、朱红的补色蓝（天蓝）。\n\n###### 三种要素\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f77699dmzhj30go0a5dgk.jpg)\n色相😍😍，即各类色彩的相貌称谓，如大红、普蓝、柠檬黄等。色相是色彩的首要特征，是区别各种不同色彩的最准确的标准。事实上任何黑白灰以外的颜色都有色相的属性，而色相也就是由原色、间色和复色来构成的。\n\n饱和度（纯度），饱和度是指色彩的鲜艳程度，也称色彩的纯度。饱和度取决于该色中含色成分和消色成分(灰色)的比例。含色成分越大，饱和度越大；消色成分越大，饱和度越小。\n\n明度可以简单理解为颜色的亮度，不同的颜色具有不同的明度，例如黄色就比蓝色的明度高。任何色彩都存在明暗变化。其中黄色明度最高，紫色明度最低，绿、红、蓝、橙的明度相近，为中间明度。另外在同一色相的明度中还存在深浅的变化。如绿色中由浅到深有粉绿、淡绿、翠绿等明度变化。 \n\n###### 六种关系\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f7769n991mj30go0apta8.jpg)\n接下来这个就比较重要啦，也就是各种颜色的关系，从图上我们可以看到，在伊顿12色环上，间隔180度或者两两相视的就是补色，间隔120度的是对比色，间隔90度的是中度色，间隔60度是类似色，间隔30度是相近色，0度就是同色啦，同色好像木有意义吧。\n\n未完待续。。。\n\n\n\n","html":"<p>App写得差不多了，感觉其中的色彩的运用比较乱，没有统一起来，于是花了一个下午，学习了一下色彩搭配相关的一些知识，准备统一一下App的配色。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=29431066&auto=1&height=66\"></iframe>\n\n<h6 id=\"\">一个色环</h6>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f7768iqi36j305k05kweo.jpg\" alt=\"\" />\n伊顿12色环是由近代著名的瑞士色彩学大叔😳约翰内斯•伊顿先生设计的，如上图。他把红、黄蓝作为三原色，而有两种原色不同比例混合混合所得到的为二次色，也叫间色。而由两个间色或是三个三原色混合而得到的颜色为三次色，或者称为复色，包括了除了原色和间色以外的所有颜色。</p>\n\n<h6 id=\"\">两种混色</h6>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f7768wt9q6j30dw05fq3b.jpg\" alt=\"\" />\n色光三原色（加法混色）和色料三原色（减法混色），这两个让我不明觉历啊🤔。水好深啊！</p>\n\n<p>加法混合是指色光的混合，两种以上的光混合在一起，光亮度会提高，混合色的光的总亮度等于相混各色光亮度之和。色光混合中，三原色是朱红、翠绿、蓝紫。这三色光是不能用其它别的色光相混而产生的。</p>\n\n<p>白色光线透过有色滤光片之后，一部分光线被反射而吸收其余的光线，减少掉一部分辐射功率，最后透过的光是两次减光的结果，这样的色彩混合称为减法混合。一般说来，透明性强的染料，混合后具有明显的减光作用？？？减法混合的三原色是加法混合的三原色的补色，即：翠绿的补色红（品红）、蓝紫的补色黄（淡黄）、朱红的补色蓝（天蓝）。</p>\n\n<h6 id=\"\">三种要素</h6>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f77699dmzhj30go0a5dgk.jpg\" alt=\"\" />\n色相😍😍，即各类色彩的相貌称谓，如大红、普蓝、柠檬黄等。色相是色彩的首要特征，是区别各种不同色彩的最准确的标准。事实上任何黑白灰以外的颜色都有色相的属性，而色相也就是由原色、间色和复色来构成的。</p>\n\n<p>饱和度（纯度），饱和度是指色彩的鲜艳程度，也称色彩的纯度。饱和度取决于该色中含色成分和消色成分(灰色)的比例。含色成分越大，饱和度越大；消色成分越大，饱和度越小。</p>\n\n<p>明度可以简单理解为颜色的亮度，不同的颜色具有不同的明度，例如黄色就比蓝色的明度高。任何色彩都存在明暗变化。其中黄色明度最高，紫色明度最低，绿、红、蓝、橙的明度相近，为中间明度。另外在同一色相的明度中还存在深浅的变化。如绿色中由浅到深有粉绿、淡绿、翠绿等明度变化。 </p>\n\n<h6 id=\"\">六种关系</h6>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f7769n991mj30go0apta8.jpg\" alt=\"\" />\n接下来这个就比较重要啦，也就是各种颜色的关系，从图上我们可以看到，在伊顿12色环上，间隔180度或者两两相视的就是补色，间隔120度的是对比色，间隔90度的是中度色，间隔60度是类似色，间隔30度是相近色，0度就是同色啦，同色好像木有意义吧。</p>\n\n<p>未完待续。。。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1467268894725,"created_by":1,"updated_at":1473918152221,"updated_by":1,"published_at":1467269256812,"published_by":1},{"id":22,"uuid":"ed8fba41-eab5-471c-b545-371e350cd4a9","title":"关于色彩搭配（实践篇）","slug":"guan-yu-se-cai-da-pei-shi-jian-pian","markdown":"先来简单介绍一下我要重构的 app 的色彩，主要包括以下几个方面，首先是主色调，例如滴滴的主色调是橙色；其次是背景色、字体颜色、图标颜色、边框颜色。相较于原来，本次需要做一个统一。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=247169&auto=1&height=66\"></iframe>\n\n主色调，主色调负责给整个应用一个整体的印象，而这个印象与每种色调所要表达的意思相关，各种颜色所能够表达的意思如下：\n\n- 红色：激情、爱情、愤怒。\n- 橙色：活力、快乐、生气。\n- 黄色：快乐、希望、虚伪。\n- 绿色：新生、富饶、自然\n- 蓝色：冷静、责任、忧伤。\n- 紫色：创造力、高贵、财富。\n- 黑色：神秘、优雅、邪恶。\n- 灰色：忧郁、保守、严谨。\n- 白色：纯洁、干净、贞洁。\n- 褐色：自然、健康、可靠。\n- 米黄色或茶色：保守、虔诚、无趣。\n- 奶油色或乳白色：平静、优雅、纯粹。  \n\n其次是背景色，背景色主要以白和灰色为主，虽然在传统的单色配色方案等中也有不同的选择，但是在 app 中，白色和灰色还更多的选择，在不同场景下也可能有别的选择，需要更多的实践。\n\n字体色，我选择了三种字体色，第一种是较深的，接近黑色，但又不那么浓黑；第二种是灰色；第三种是白色，白色字体主要使用在背景不是灰色或白色的场景，这样字能够比较突出；另外如果要增强色彩感，可以对于一些触发动作的字，使用主色调的颜色。\n\n图标颜色，暂时有三类情况，第一是两个寓意相反的图标情况，对比色能够比较好地表达；对于如尖头等图标，在一个没有色彩要求等场景中时，可以采用与字的颜色相近的色彩；第三种场景就是主色调的图标。\n\n边框：默认边框以灰色为主，而激活的边框则以主色调一致。\n\n以上是个人在简要学习了一些色彩搭配的知识后，对 app 的整体色彩进行了重构的内容。但是对于正规的项目，还是需要设计人员给出设计稿的，这样就省了开发很多的时间呢！不过作为一个有理想的开发，学习一下色彩搭配也是很有用的，比如美化一下自己的博客！\n\n未完待续。。。","html":"<p>先来简单介绍一下我要重构的 app 的色彩，主要包括以下几个方面，首先是主色调，例如滴滴的主色调是橙色；其次是背景色、字体颜色、图标颜色、边框颜色。相较于原来，本次需要做一个统一。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=247169&auto=1&height=66\"></iframe>\n\n<p>主色调，主色调负责给整个应用一个整体的印象，而这个印象与每种色调所要表达的意思相关，各种颜色所能够表达的意思如下：</p>\n\n<ul>\n<li>红色：激情、爱情、愤怒。</li>\n<li>橙色：活力、快乐、生气。</li>\n<li>黄色：快乐、希望、虚伪。</li>\n<li>绿色：新生、富饶、自然</li>\n<li>蓝色：冷静、责任、忧伤。</li>\n<li>紫色：创造力、高贵、财富。</li>\n<li>黑色：神秘、优雅、邪恶。</li>\n<li>灰色：忧郁、保守、严谨。</li>\n<li>白色：纯洁、干净、贞洁。</li>\n<li>褐色：自然、健康、可靠。</li>\n<li>米黄色或茶色：保守、虔诚、无趣。</li>\n<li>奶油色或乳白色：平静、优雅、纯粹。  </li>\n</ul>\n\n<p>其次是背景色，背景色主要以白和灰色为主，虽然在传统的单色配色方案等中也有不同的选择，但是在 app 中，白色和灰色还更多的选择，在不同场景下也可能有别的选择，需要更多的实践。</p>\n\n<p>字体色，我选择了三种字体色，第一种是较深的，接近黑色，但又不那么浓黑；第二种是灰色；第三种是白色，白色字体主要使用在背景不是灰色或白色的场景，这样字能够比较突出；另外如果要增强色彩感，可以对于一些触发动作的字，使用主色调的颜色。</p>\n\n<p>图标颜色，暂时有三类情况，第一是两个寓意相反的图标情况，对比色能够比较好地表达；对于如尖头等图标，在一个没有色彩要求等场景中时，可以采用与字的颜色相近的色彩；第三种场景就是主色调的图标。</p>\n\n<p>边框：默认边框以灰色为主，而激活的边框则以主色调一致。</p>\n\n<p>以上是个人在简要学习了一些色彩搭配的知识后，对 app 的整体色彩进行了重构的内容。但是对于正规的项目，还是需要设计人员给出设计稿的，这样就省了开发很多的时间呢！不过作为一个有理想的开发，学习一下色彩搭配也是很有用的，比如美化一下自己的博客！</p>\n\n<p>未完待续。。。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1467618067380,"created_by":1,"updated_at":1473918141096,"updated_by":1,"published_at":1467619563580,"published_by":1},{"id":23,"uuid":"f5668ae7-96d1-48ff-9a50-2a811539d22e","title":"react native 布局","slug":"react-native-bu-ju","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=27514453&auto=1&height=66\"></iframe>\n\n###### 尺寸单位\n\nreact native 使用的单位是 dp 。 dp 是设备独立像素，与 px 不同，他在像素密度不同的设备上能够拥有一致的表现。\n\n对于图片来说，我们获取图片时需要利用像素密度进行一下转换，如下：\n\n```\n var image = getImage({\n   width: 200 * PixelRatio.get(),\n   height: 100 * PixelRatio.get()\n });\n <Image source={image} style={{width: 200, height: 100}} />\n```\n\n这样基本就不用做太多屏幕适配的工作了。\n\n###### flex的布局\n\nreact native flex 布局默认的方向为竖直方向，使用 justifyContent 指定主轴方向的对其方式，alignItems 指定侧轴的对齐方式，因此垂直居中通过设置这两个参数就 ok 了。根节点下的view 宽度默认为 100% ，可设置宽度。\n\n###### 网格布局\n\n等分的网格\n\n```\n<View style={styles.flexContainer}>\n      <View style={styles.cell}>\n        <Text style={styles.welcome}>\n          cell1\n        </Text>\n      </View>\n      <View style={styles.cell}>\n        <Text style={styles.welcome}>\n          cell2\n        </Text>\n      </View>\n      <View style={styles.cell}>\n        <Text style={styles.welcome}>\n          cell3\n        </Text>\n      </View>\n    </View>\n\n    styles = {\n        flexContainer: {\n            // 容器需要添加direction才能变成让子元素flex\n            flexDirection: 'row'\n        },\n        cell: {\n            flex: 1,\n            height: 50,\n            backgroundColor: '#aaaaaa'\n        },\n        welcome: {\n            fontSize: 20,\n            textAlign: 'center',\n            margin: 10\n        },\n    }\n```\n\n左边固定， 右边固定，中间flex的布局\n\n```\n  <View style={styles.flexContainer}>\n      <View style={styles.cellfixed}>\n        <Text style={styles.welcome}>\n          fixed\n        </Text>\n      </View>\n      <View style={styles.cell}>\n        <Text style={styles.welcome}>\n          flex\n        </Text>\n      </View>\n      <View style={styles.cellfixed}>\n        <Text style={styles.welcome}>\n          fixed\n        </Text>\n      </View>\n    </View>\n\n    styles = {\n        flexContainer: {\n            // 容器需要添加direction才能变成让子元素flex\n            flexDirection: 'row'\n        },\n        cell: {\n            flex: 1,\n            height: 50,\n            backgroundColor: '#aaaaaa'\n        },\n        welcome: {\n            fontSize: 20,\n            textAlign: 'center',\n            margin: 10\n        },\n        cellfixed: {\n            height: 50,\n            width: 80,\n            backgroundColor: '#fefefe'\n        } \n    }\n```\n\n###### 绝对定位和相对定位\n\n和css的标准不同的是， 元素容器不用` position：'absolute|relative' ` 。另外测试下，不支持垂直居中的写法，只支持水平居中的写法。\n\n###### padding和margin\n\n在View上设置padding很顺利，没有任何问题， 但是如果在inline元素上设置padding， 发现会出现上面的错误， paddingTop和paddingBottom都被挤成marginBottom了。 按理说，不应该对Text做padding处理， 但是确实有这样的问题存在，所以可以将这个问题mark一下。\n\n我们知道，对于inline元素，设置margin-left和margin-right有效，top和bottom按理是不会生效的， 但是上图的结果可以看到，实际是生效了的。所以现在给我的感觉是Text元素更应该理解为一个不能设置padding的block。\n\n算了不要猜了， 我们看看官方文档怎么说Text，https://facebook.github.io/react-native/docs/text.html\n\n```\n  <Text>\n    <Text>First part and </Text>\n    <Text>second part</Text>\n  </Text>\n  // Text container: all the text flows as if it was one\n  // |First part |\n  // |and second |\n  // |part       |\n\n  <View>\n    <Text>First part and </Text>\n    <Text>second part</Text>\n  </View>\n  // View container: each text is its own block\n  // |First part |\n  // |and        |\n  // |second part|\n```\n\n也就是如果Text元素在Text里边，可以考虑为inline， 如果单独在View里边，那就是Block。 \n下面会专门研究一下文本相关的布局\n\n###### 文本元素\n\n在实践中，我主要定义三种大小的字体，12或13的小号字体，行高20；15-17的中号字体，行高23；24号左右的大号字体，行高27。\n\n字体选择默认的，如果自己引入字体那另当别论。\n\n样式继承最近的父元素的样式。\n\n支持的属性如下：\n\n```\n Attributes.style = {\n    color string\n    containerBackgroundColor string\n    fontFamily string\n    fontSize number\n    fontStyle enum('normal', 'italic')\n    fontWeight enum(\"normal\", 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900')\n    lineHeight number\n    textAlign enum(\"auto\", 'left', 'right', 'center')\n    writingDirection enum(\"auto\", 'ltr', 'rtl')\n  }\n```\n\n参考： https://segmentfault.com/a/1190000002658374","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=27514453&auto=1&height=66\"></iframe>\n\n<h6 id=\"\">尺寸单位</h6>\n\n<p>react native 使用的单位是 dp 。 dp 是设备独立像素，与 px 不同，他在像素密度不同的设备上能够拥有一致的表现。</p>\n\n<p>对于图片来说，我们获取图片时需要利用像素密度进行一下转换，如下：</p>\n\n<pre><code> var image = getImage({\n   width: 200 * PixelRatio.get(),\n   height: 100 * PixelRatio.get()\n });\n &lt;Image source={image} style={{width: 200, height: 100}} /&gt;\n</code></pre>\n\n<p>这样基本就不用做太多屏幕适配的工作了。</p>\n\n<h6 id=\"flex\">flex的布局</h6>\n\n<p>react native flex 布局默认的方向为竖直方向，使用 justifyContent 指定主轴方向的对其方式，alignItems 指定侧轴的对齐方式，因此垂直居中通过设置这两个参数就 ok 了。根节点下的view 宽度默认为 100% ，可设置宽度。</p>\n\n<h6 id=\"\">网格布局</h6>\n\n<p>等分的网格</p>\n\n<pre><code>&lt;View style={styles.flexContainer}&gt;  \n      &lt;View style={styles.cell}&gt;\n        &lt;Text style={styles.welcome}&gt;\n          cell1\n        &lt;/Text&gt;\n      &lt;/View&gt;\n      &lt;View style={styles.cell}&gt;\n        &lt;Text style={styles.welcome}&gt;\n          cell2\n        &lt;/Text&gt;\n      &lt;/View&gt;\n      &lt;View style={styles.cell}&gt;\n        &lt;Text style={styles.welcome}&gt;\n          cell3\n        &lt;/Text&gt;\n      &lt;/View&gt;\n    &lt;/View&gt;\n\n    styles = {\n        flexContainer: {\n            // 容器需要添加direction才能变成让子元素flex\n            flexDirection: 'row'\n        },\n        cell: {\n            flex: 1,\n            height: 50,\n            backgroundColor: '#aaaaaa'\n        },\n        welcome: {\n            fontSize: 20,\n            textAlign: 'center',\n            margin: 10\n        },\n    }\n</code></pre>\n\n<p>左边固定， 右边固定，中间flex的布局</p>\n\n<pre><code>  &lt;View style={styles.flexContainer}&gt;\n      &lt;View style={styles.cellfixed}&gt;\n        &lt;Text style={styles.welcome}&gt;\n          fixed\n        &lt;/Text&gt;\n      &lt;/View&gt;\n      &lt;View style={styles.cell}&gt;\n        &lt;Text style={styles.welcome}&gt;\n          flex\n        &lt;/Text&gt;\n      &lt;/View&gt;\n      &lt;View style={styles.cellfixed}&gt;\n        &lt;Text style={styles.welcome}&gt;\n          fixed\n        &lt;/Text&gt;\n      &lt;/View&gt;\n    &lt;/View&gt;\n\n    styles = {\n        flexContainer: {\n            // 容器需要添加direction才能变成让子元素flex\n            flexDirection: 'row'\n        },\n        cell: {\n            flex: 1,\n            height: 50,\n            backgroundColor: '#aaaaaa'\n        },\n        welcome: {\n            fontSize: 20,\n            textAlign: 'center',\n            margin: 10\n        },\n        cellfixed: {\n            height: 50,\n            width: 80,\n            backgroundColor: '#fefefe'\n        } \n    }\n</code></pre>\n\n<h6 id=\"\">绝对定位和相对定位</h6>\n\n<p>和css的标准不同的是， 元素容器不用<code>position：'absolute|relative'</code> 。另外测试下，不支持垂直居中的写法，只支持水平居中的写法。</p>\n\n<h6 id=\"paddingmargin\">padding和margin</h6>\n\n<p>在View上设置padding很顺利，没有任何问题， 但是如果在inline元素上设置padding， 发现会出现上面的错误， paddingTop和paddingBottom都被挤成marginBottom了。 按理说，不应该对Text做padding处理， 但是确实有这样的问题存在，所以可以将这个问题mark一下。</p>\n\n<p>我们知道，对于inline元素，设置margin-left和margin-right有效，top和bottom按理是不会生效的， 但是上图的结果可以看到，实际是生效了的。所以现在给我的感觉是Text元素更应该理解为一个不能设置padding的block。</p>\n\n<p>算了不要猜了， 我们看看官方文档怎么说Text，<a href=\"https://facebook.github.io/react-native/docs/text.html\">https://facebook.github.io/react-native/docs/text.html</a></p>\n\n<pre><code>  &lt;Text&gt;\n    &lt;Text&gt;First part and &lt;/Text&gt;\n    &lt;Text&gt;second part&lt;/Text&gt;\n  &lt;/Text&gt;\n  // Text container: all the text flows as if it was one\n  // |First part |\n  // |and second |\n  // |part       |\n\n  &lt;View&gt;\n    &lt;Text&gt;First part and &lt;/Text&gt;\n    &lt;Text&gt;second part&lt;/Text&gt;\n  &lt;/View&gt;\n  // View container: each text is its own block\n  // |First part |\n  // |and        |\n  // |second part|\n</code></pre>\n\n<p>也就是如果Text元素在Text里边，可以考虑为inline， 如果单独在View里边，那就是Block。 \n下面会专门研究一下文本相关的布局</p>\n\n<h6 id=\"\">文本元素</h6>\n\n<p>在实践中，我主要定义三种大小的字体，12或13的小号字体，行高20；15-17的中号字体，行高23；24号左右的大号字体，行高27。</p>\n\n<p>字体选择默认的，如果自己引入字体那另当别论。</p>\n\n<p>样式继承最近的父元素的样式。</p>\n\n<p>支持的属性如下：</p>\n\n<pre><code> Attributes.style = {\n    color string\n    containerBackgroundColor string\n    fontFamily string\n    fontSize number\n    fontStyle enum('normal', 'italic')\n    fontWeight enum(\"normal\", 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900')\n    lineHeight number\n    textAlign enum(\"auto\", 'left', 'right', 'center')\n    writingDirection enum(\"auto\", 'ltr', 'rtl')\n  }\n</code></pre>\n\n<p>参考： <a href=\"https://segmentfault.com/a/1190000002658374\">https://segmentfault.com/a/1190000002658374</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1467619667519,"created_by":1,"updated_at":1473918127435,"updated_by":1,"published_at":1467621393993,"published_by":1},{"id":24,"uuid":"e92a7d4f-bd2a-436e-ae77-9db3d4ccac97","title":"react Stateless Functions（官方文档翻译）","slug":"react-stateless-functions-guan-fang-wen-dang-fan-yi","markdown":"> 中文社区还停留在 0.14.7，文档上有不少落后了，比如 shadowEqual、context 等的知识，所以只能自己来了。\n\n你也可以用一个普通的 JavaScript 函数定义你的 React classes 。例如使用 stateless function 语法：\n\n```\nfunction HelloMessage(props) {\n  return <div>Hello {props.name}</div>;\n}\nReactDOM.render(<HelloMessage name=\"Sebastian\" />, mountNode);\n```\n\n或者使用 ES6 的 箭头函数语法：\n\n```\nconst HelloMessage = (props) => <div>Hello {props.name}</div>;\nReactDOM.render(<HelloMessage name=\"Sebastian\" />, mountNode);\n```\n\n这个简化的组件 API 设计为纯函数几它们的参数。这些组件必须不能保留内部的状态，没有支持的实例并且没有生命周期方法。 它们是转换起输入的纯函数，没有副作用。然而，你仍然可以具体说明 ` .propTypes ` 和 ` .defaultProps ` 通过设置它们喂函数的参数，就像在 ES6 class上一样设置。\n\n> 注意：\n因为 stateless functions 没有一个支持的实例，你不能使用 ref 来得到一个stateless function 组件。通常这不是一个 issue，因为 stateless functions 不提供一个必须服从的 AP I。没有一个必须服从的 API，也就没有必须要对实例要求做的事。然而，如果一个用户想要找到 stateless function 组件的 DOM 节点 ，它们必须包裹在一个有状态的组件内，然后用 ref 去访问有状态的包裹组件。\n注意：\n在 React v0.14， stateless functional 组件将不被允许去返回 ` null ` 或 ` false `（变通的方法是返回 ` <noscript /> ` 代替）。这个问题在 React v15 当中被修复了， stateless functional 组件现在被允许返回 ` null ` 。\n\n在理想的情况下，你的大部分组件都将是 stateless functions，因为在将来我们也能够给这些组件带来性能优化的规范，通过避免不需要的检查和内存分配。如果可能的话，这是理想的模式。","html":"<blockquote>\n  <p>中文社区还停留在 0.14.7，文档上有不少落后了，比如 shadowEqual、context 等的知识，所以只能自己来了。</p>\n</blockquote>\n\n<p>你也可以用一个普通的 JavaScript 函数定义你的 React classes 。例如使用 stateless function 语法：</p>\n\n<pre><code>function HelloMessage(props) {  \n  return &lt;div&gt;Hello {props.name}&lt;/div&gt;;\n}\nReactDOM.render(&lt;HelloMessage name=\"Sebastian\" /&gt;, mountNode);  \n</code></pre>\n\n<p>或者使用 ES6 的 箭头函数语法：</p>\n\n<pre><code>const HelloMessage = (props) =&gt; &lt;div&gt;Hello {props.name}&lt;/div&gt;;  \nReactDOM.render(&lt;HelloMessage name=\"Sebastian\" /&gt;, mountNode);  \n</code></pre>\n\n<p>这个简化的组件 API 设计为纯函数几它们的参数。这些组件必须不能保留内部的状态，没有支持的实例并且没有生命周期方法。 它们是转换起输入的纯函数，没有副作用。然而，你仍然可以具体说明 <code>.propTypes</code> 和 <code>.defaultProps</code> 通过设置它们喂函数的参数，就像在 ES6 class上一样设置。</p>\n\n<blockquote>\n  <p>注意：\n  因为 stateless functions 没有一个支持的实例，你不能使用 ref 来得到一个stateless function 组件。通常这不是一个 issue，因为 stateless functions 不提供一个必须服从的 AP I。没有一个必须服从的 API，也就没有必须要对实例要求做的事。然而，如果一个用户想要找到 stateless function 组件的 DOM 节点 ，它们必须包裹在一个有状态的组件内，然后用 ref 去访问有状态的包裹组件。\n  注意：\n  在 React v0.14， stateless functional 组件将不被允许去返回 <code>null</code> 或 <code>false</code>（变通的方法是返回 <code>&lt;noscript /&gt;</code> 代替）。这个问题在 React v15 当中被修复了， stateless functional 组件现在被允许返回 <code>null</code> 。</p>\n</blockquote>\n\n<p>在理想的情况下，你的大部分组件都将是 stateless functions，因为在将来我们也能够给这些组件带来性能优化的规范，通过避免不需要的检查和内存分配。如果可能的话，这是理想的模式。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1467695307621,"created_by":1,"updated_at":1467697494691,"updated_by":1,"published_at":1467696282266,"published_by":1},{"id":25,"uuid":"9b062008-ea10-4824-b493-1b795e1eae9b","title":"小葵唱的《ソラニン》","slug":"xiao-kui-chang-de-soranin","markdown":"小葵的声音好好听啊，单曲循环，元气满满！😊就是木有找到能下载的mp3。\n\n<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"http://static.hdslb.com/miniloader.swf\" flashvars=\"aid=180951&page=1\" pluginspage=\"http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed>\n\n思い违いは空のかなた\nさよならだけの人生か\nほんの少しの未来は见えたのに\nさよならなんだ\n\n昔住んでた小さな部屋は今は谁かが住んでんだ\n君に言われたひどい言叶も\n无駄な気がした毎日も\n\nあの日こうしていれば\nあの日に戻れれば\nあの顷の仆にはもう戻れないよ\n\nたとえばゆるい幸せがだらっと続いたとする\nきっと悪い种が芽を出して\nもうさよならんだ\n\n寒い冬の冷えた缶コーヒー 虹色の长いマフラー\n小走りで路地裏を抜けて思い出してみる\n\nたとえばゆるい幸せがだらっと続いたとする\nきっと悪い种が芽を出して\nもうさよならなんだ\n\nさよなら それもいいさ\nどこかで元気でやれよ\nさよなら 仆もどーにかやるさ\nさよなら そうするよ\n\n－－－\n\n误会在天空的彼端\n难道人生只充满了再见吗\n只差那麼一点就可以看见未来\n却只能说再见\n\n以前住过的小房间现在又是谁住在那里\n无论是你对我说过的过分话语\n还是感觉白费力气的每一天\n\n若说那天我这麼做\n若说能回到那一天\n我已无法再回到那一天\n\n如果说弛缓的幸福缓慢地延续\n这样下去坏种子一定会发芽\n还是只能说再见\n\n寒冷冬天中冷掉的罐装咖啡   七彩的长围巾\n小跑步穿过小巷中   我试著回忆起\n\n如果说弛缓的幸福缓慢地延续\n这样下去坏种子一定会发芽\n还是只能说再见\n\n说再见   这样也好\n无论在哪都要好好地过\n再见了   我也一定有办法的\n说再见   就这样吧\n\n－－－\n\no mo i chi ga i wa so ra no ka na ta\nsa yo na ra da ke no jin sei ka\nho n no su ko shi no mi rai wa mi e ta no ni\nsa yo na ra na n da\n\nmu ka shi su n de ta chii sa na he ya wa i ma wa da re ka ga su n de n da\nki mi ni i wa re ta hi do i ko ta ba mo\nmu da na ki ga shi ta mai ni chi mo\n\na no hi ko u shi te i re ba\na no hi ni mo do re re ba\na no ko ro no bo ku ni wa mo u mo do re nai yo\n\nta to e ba yu ru i shi a wa se ga da ra tto tsu du i ta to su ru\nki tto wa ru i ta ne ga me o da shi te\nmo u sa yo na ra na n da\n\nsa mu i fu yu no hi e ta kan ko- hi-   ni ji i ro no na ga i ma fu ra-\nko ba shi ri de ro ji u ra o nu ke te o mo i da shi te mi ru\n\nta to e ba yu ru i shi a wa se ga da ra tto tsu du i ta to su ru\nki tto wa ru i ta ne ga me o da shi te\nmo u sa yo na ra na n da\n\nsa ya na ra   so re mo i i sa\ndo ko ka de gen ki de ya re yo\nsa yo na ra   bo ku mo do- ni ka ya ru sa\nsa yo na ra   so u su ru yo","html":"<p>小葵的声音好好听啊，单曲循环，元气满满！😊就是木有找到能下载的mp3。</p>\n\n<p><embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"http://static.hdslb.com/miniloader.swf\" flashvars=\"aid=180951&amp;page=1\" pluginspage=\"http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed></p>\n\n<p>思い违いは空のかなた\nさよならだけの人生か\nほんの少しの未来は见えたのに\nさよならなんだ</p>\n\n<p>昔住んでた小さな部屋は今は谁かが住んでんだ\n君に言われたひどい言叶も\n无駄な気がした毎日も</p>\n\n<p>あの日こうしていれば\nあの日に戻れれば\nあの顷の仆にはもう戻れないよ</p>\n\n<p>たとえばゆるい幸せがだらっと続いたとする\nきっと悪い种が芽を出して\nもうさよならんだ</p>\n\n<p>寒い冬の冷えた缶コーヒー 虹色の长いマフラー\n小走りで路地裏を抜けて思い出してみる</p>\n\n<p>たとえばゆるい幸せがだらっと続いたとする\nきっと悪い种が芽を出して\nもうさよならなんだ</p>\n\n<p>さよなら それもいいさ\nどこかで元気でやれよ\nさよなら 仆もどーにかやるさ\nさよなら そうするよ</p>\n\n<p>－－－</p>\n\n<p>误会在天空的彼端\n难道人生只充满了再见吗\n只差那麼一点就可以看见未来\n却只能说再见</p>\n\n<p>以前住过的小房间现在又是谁住在那里\n无论是你对我说过的过分话语\n还是感觉白费力气的每一天</p>\n\n<p>若说那天我这麼做\n若说能回到那一天\n我已无法再回到那一天</p>\n\n<p>如果说弛缓的幸福缓慢地延续\n这样下去坏种子一定会发芽\n还是只能说再见</p>\n\n<p>寒冷冬天中冷掉的罐装咖啡   七彩的长围巾\n小跑步穿过小巷中   我试著回忆起</p>\n\n<p>如果说弛缓的幸福缓慢地延续\n这样下去坏种子一定会发芽\n还是只能说再见</p>\n\n<p>说再见   这样也好\n无论在哪都要好好地过\n再见了   我也一定有办法的\n说再见   就这样吧</p>\n\n<p>－－－</p>\n\n<p>o mo i chi ga i wa so ra no ka na ta <br />\nsa yo na ra da ke no jin sei ka <br />\nho n no su ko shi no mi rai wa mi e ta no ni <br />\nsa yo na ra na n da</p>\n\n<p>mu ka shi su n de ta chii sa na he ya wa i ma wa da re ka ga su n de n da <br />\nki mi ni i wa re ta hi do i ko ta ba mo <br />\nmu da na ki ga shi ta mai ni chi mo</p>\n\n<p>a no hi ko u shi te i re ba <br />\na no hi ni mo do re re ba <br />\na no ko ro no bo ku ni wa mo u mo do re nai yo</p>\n\n<p>ta to e ba yu ru i shi a wa se ga da ra tto tsu du i ta to su ru <br />\nki tto wa ru i ta ne ga me o da shi te <br />\nmo u sa yo na ra na n da</p>\n\n<p>sa mu i fu yu no hi e ta kan ko- hi-   ni ji i ro no na ga i ma fu ra- <br />\nko ba shi ri de ro ji u ra o nu ke te o mo i da shi te mi ru</p>\n\n<p>ta to e ba yu ru i shi a wa se ga da ra tto tsu du i ta to su ru <br />\nki tto wa ru i ta ne ga me o da shi te <br />\nmo u sa yo na ra na n da</p>\n\n<p>sa ya na ra   so re mo i i sa <br />\ndo ko ka de gen ki de ya re yo <br />\nsa yo na ra   bo ku mo do- ni ka ya ru sa <br />\nsa yo na ra   so u su ru yo</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1467696313896,"created_by":1,"updated_at":1467762751870,"updated_by":1,"published_at":1467696583407,"published_by":1},{"id":26,"uuid":"6c84f077-565f-4041-b904-5f22ce2b3bf4","title":"Jersey 异常处理","slug":"jerseyyi-chang-chu-li","markdown":"今天的两篇文章都是关于异常处理的，一篇是服务端 Jersey 的异常处理，另一篇是 Fetch API Promise 的异常处理。废话不多说，直接开始。\n\n根据 Jersey 官方文档的说法，Jersey 异常处理有两种方式：\n\n第一是继承 WebApplicationException，不继承默认的状态码为 500，继承后可以修改成对应的状态码，下面是官网的一个例子：\n\n```\npublic class CustomNotFoundException extends WebApplicationException {\n \n  /**\n  * Create a HTTP 404 (Not Found) exception.\n  */\n  public CustomNotFoundException() {\n    super(Responses.notFound().build());\n  }\n \n  /**\n  * Create a HTTP 404 (Not Found) exception.\n  * @param message the String that is the entity of the 404 response.\n  */\n  public CustomNotFoundException(String message) {\n    super(Response.status(Responses.NOT_FOUND).\n    entity(message).type(\"text/plain\").build());\n  }\n}\n```\n\n第二是针对一些现有的异常，官网建议使用实现 javax.ws.rs.ext.ExceptionMapper<T> 的方式，T为所要抛出的异常类型。当 Jersey 捕获到T异常，就返回实现类的响应。\n\n当抛出 RuntimeException 异常，就会返回404异常。需要注意的是：实现类要加 @Provider 注解，而且要放在 Jersey 资源所在的包路径，以便jersey扫描到。\n\n下面是官网的例子：\n\n```\n@Provider\npublic class EntityNotFoundMapper implements ExceptionMapper<javax.persistence.EntityNotFoundException> {\n  public Response toResponse(javax.persistence.EntityNotFoundException ex) {\n    return Response.status(404).\n      entity(ex.getMessage()).\n      type(\"text/plain\").\n      build();\n  }\n}\n```\n\n了解了这些以后，需要针对接口调用的异常进行一个较为统一的处理，使得客户端能够等到统一格式的错误信息，而不会出现 JSON Parse 的错误。目前我的做法是加一个判断，针对 MediaType 为 application/json 的异常（包括 WebApplicationException 抛出的异常）进行 Response 的统一包装，来达到给客户端统一返回结果的目的。如果说要更加规范地解决这个问题，那应当是创建各个情况的异常类继承不同场景的基类，然后用 ExceptionMapper 统一处理该基类的异常，同时也能够区分 rest 接口的异常和网页端抛出的异常。\n\n关于异常更复杂，偏原理的部分请看参考资料，不在本文讨论范围，因为那可以写很长一篇文章了，我这里只关注这个项目中 Jersey 端的实现。\n\n参考资料：\n\n1、 [文档传送门](https://jersey.java.net/documentation/latest/representations.html#d0e6754)\n2、[Jersey Rest 异常统一处理机制](http://blog.csdn.net/niityzu/article/details/51112878)\n3、[Jersey框架的统一异常处理机制](http://redhacker.iteye.com/blog/1924071)\n4、[Checked 和 UnChecked 异常 的使用场合](http://www.tuicool.com/articles/ramuyu)","html":"<p>今天的两篇文章都是关于异常处理的，一篇是服务端 Jersey 的异常处理，另一篇是 Fetch API Promise 的异常处理。废话不多说，直接开始。</p>\n\n<p>根据 Jersey 官方文档的说法，Jersey 异常处理有两种方式：</p>\n\n<p>第一是继承 WebApplicationException，不继承默认的状态码为 500，继承后可以修改成对应的状态码，下面是官网的一个例子：</p>\n\n<pre><code>public class CustomNotFoundException extends WebApplicationException {\n\n  /**\n  * Create a HTTP 404 (Not Found) exception.\n  */\n  public CustomNotFoundException() {\n    super(Responses.notFound().build());\n  }\n\n  /**\n  * Create a HTTP 404 (Not Found) exception.\n  * @param message the String that is the entity of the 404 response.\n  */\n  public CustomNotFoundException(String message) {\n    super(Response.status(Responses.NOT_FOUND).\n    entity(message).type(\"text/plain\").build());\n  }\n}\n</code></pre>\n\n<p>第二是针对一些现有的异常，官网建议使用实现 javax.ws.rs.ext.ExceptionMapper<T> 的方式，T为所要抛出的异常类型。当 Jersey 捕获到T异常，就返回实现类的响应。</p>\n\n<p>当抛出 RuntimeException 异常，就会返回404异常。需要注意的是：实现类要加 @Provider 注解，而且要放在 Jersey 资源所在的包路径，以便jersey扫描到。</p>\n\n<p>下面是官网的例子：</p>\n\n<pre><code>@Provider\npublic class EntityNotFoundMapper implements ExceptionMapper&lt;javax.persistence.EntityNotFoundException&gt; {  \n  public Response toResponse(javax.persistence.EntityNotFoundException ex) {\n    return Response.status(404).\n      entity(ex.getMessage()).\n      type(\"text/plain\").\n      build();\n  }\n}\n</code></pre>\n\n<p>了解了这些以后，需要针对接口调用的异常进行一个较为统一的处理，使得客户端能够等到统一格式的错误信息，而不会出现 JSON Parse 的错误。目前我的做法是加一个判断，针对 MediaType 为 application/json 的异常（包括 WebApplicationException 抛出的异常）进行 Response 的统一包装，来达到给客户端统一返回结果的目的。如果说要更加规范地解决这个问题，那应当是创建各个情况的异常类继承不同场景的基类，然后用 ExceptionMapper 统一处理该基类的异常，同时也能够区分 rest 接口的异常和网页端抛出的异常。</p>\n\n<p>关于异常更复杂，偏原理的部分请看参考资料，不在本文讨论范围，因为那可以写很长一篇文章了，我这里只关注这个项目中 Jersey 端的实现。</p>\n\n<p>参考资料：</p>\n\n<p>1、 <a href=\"https://jersey.java.net/documentation/latest/representations.html#d0e6754\">文档传送门</a> <br />\n2、<a href=\"http://blog.csdn.net/niityzu/article/details/51112878\">Jersey Rest 异常统一处理机制</a> <br />\n3、<a href=\"http://redhacker.iteye.com/blog/1924071\">Jersey框架的统一异常处理机制</a> <br />\n4、<a href=\"http://www.tuicool.com/articles/ramuyu\">Checked 和 UnChecked 异常 的使用场合</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1468372912162,"created_by":1,"updated_at":1471010424392,"updated_by":1,"published_at":1470999361119,"published_by":1},{"id":27,"uuid":"7107ba84-ee23-401d-90a0-6f72c9919ec9","title":"无题","slug":"dyht","markdown":"最近忙屎了，没时间写东西🙄。马上要开工，随便写点。最近大鱼可以说是在舆论的风口浪尖，虽然没去电影院看，但是通过b站的一个个影评，已是略知一二了。\n\n作为一部花了12年撸出的一个东西，确实在剧情上如大家所说有点不如人意，但是画面、配乐都是在向国外看齐的。正如一个up主说，大鱼给他的感觉绝不是让人失望的那种，只是有点微妙。这种微妙感，来源于12年的大鱼承载了太多，来源于作者不那么会讲故事。不过对于国漫来说，这不能说是划时代，却可以称得上是一个新的开始。大雨让我看到仍有那么一批人在认真地做着动画，这是最让我欣慰的。\n\n下面是昨天在b站看到的一组和我一样大的学生做的动画，瞬间对国漫燃起了信心🤗。有这么多有才的少年在追逐着梦想，希望10年、20年后能够看到每一个短片能够出线在大荧幕之上。干活去了！😭\n\n<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"http://static.hdslb.com/miniloader.swf\" flashvars=\"aid=5278719&page=4\" pluginspage=\"http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed>","html":"<p>最近忙屎了，没时间写东西🙄。马上要开工，随便写点。最近大鱼可以说是在舆论的风口浪尖，虽然没去电影院看，但是通过b站的一个个影评，已是略知一二了。</p>\n\n<p>作为一部花了12年撸出的一个东西，确实在剧情上如大家所说有点不如人意，但是画面、配乐都是在向国外看齐的。正如一个up主说，大鱼给他的感觉绝不是让人失望的那种，只是有点微妙。这种微妙感，来源于12年的大鱼承载了太多，来源于作者不那么会讲故事。不过对于国漫来说，这不能说是划时代，却可以称得上是一个新的开始。大雨让我看到仍有那么一批人在认真地做着动画，这是最让我欣慰的。</p>\n\n<p>下面是昨天在b站看到的一组和我一样大的学生做的动画，瞬间对国漫燃起了信心🤗。有这么多有才的少年在追逐着梦想，希望10年、20年后能够看到每一个短片能够出线在大荧幕之上。干活去了！😭</p>\n\n<p><embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"http://static.hdslb.com/miniloader.swf\" flashvars=\"aid=5278719&amp;page=4\" pluginspage=\"http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1468459601710,"created_by":1,"updated_at":1468460846200,"updated_by":1,"published_at":1468460846201,"published_by":1},{"id":28,"uuid":"8aa4ff0b-b33b-4f2c-8741-d86ac04536c5","title":"转：CET,UTC,GMT,CST几种常见时间概述","slug":"zhuan-cet-utc-gmt-cstji-chong-chang-jian-shi-jian-gai-shu","markdown":"###### CET(欧洲中部时间)\n\n欧洲中部时间（英語：Central European Time，CET）是比世界标准时间（UTC）早一个小时的时区名称之一。它被大部分欧洲国家和部分北非国家采用。\n\n冬季时间为UTC+1，夏季欧洲夏令时为UTC+2。\n\n###### WET(欧洲西部时间)\n\n欧洲西部时间（Western European Time，缩写WET）和世界标准时间（UTC）相同。\n\n###### EET(欧洲东部时间)\n\n欧洲东部时间（Eastern European Time，缩写EET）是比世界标准时间（UTC）早二个小时的时区名称之一。它被部分欧洲国家、北非国家和中东国家采用。\n\n###### UTC(世界标准时间)\n\n协调世界时，又称世界标准时间或世界協調時間，简称UTC（从英文「Coordinated Universal Time」／法文「Temps Universel Cordonné」而来），是最主要的世界時間標準，其以原子时秒长为基础，在时刻上尽量接近于格林尼治平時。\n\n###### GMT(格林尼治平时)\n\n格林尼治平时（又称格林尼治平均时间或格林尼治标准时间，旧译格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。\n\n自1924年2月5日开始，格林尼治天文台每隔一小时会向全世界发放调时信息。\n\n理论上来说，格林尼治标准时间的正午是指当太阳横穿格林尼治子午线时（也就是在格林尼治上空最高点时）的时间。由于地球在它的椭圆轨道里的运动速度不均匀，这个时刻可能与实际的太阳时有误差，最大误差达16分钟。\n\n由于地球每天的自转是有些不规则的，而且正在缓慢减速，因此格林尼治时间已经不再被作为标准时间使用。现在的标准时间，是由原子钟报时的协调世界时（UTC）。\n\n###### CST(北京时间)\n\n北京时间，China Standard Time，中国标准时间。在时区划分上，属东八区，比协调世界时早8小时，记为UTC+8。\n\n不过这个CST这个缩写比较纠结的是它可以同时代表四个不同的时间：\n\nCentral Standard Time (USA) UT-6:00\nCentral Standard Time (Australia) UT+9:30\nChina Standard Time UT+8:00\nCuba Standard Time UT-4:00\n因此你平时编写程序过程中也有可能遇到javascript客户端时间和服务端时间不一致的问题，编程的时候还是要多注意。\n\n###### ISO 日期和时间的表示方法\n\n国际标准化组织的国际标准ISO 8601是日期和时间的表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》。目前是第三版ISO8601:2004以替代第一版ISO8601:1988與第二版ISO8601:2000。\n\n这是仅仅就只是一个日期时间的表示方法，我们用这样的方法表示一个UTC时间。","html":"<h6 id=\"cet\">CET(欧洲中部时间)</h6>\n\n<p>欧洲中部时间（英語：Central European Time，CET）是比世界标准时间（UTC）早一个小时的时区名称之一。它被大部分欧洲国家和部分北非国家采用。</p>\n\n<p>冬季时间为UTC+1，夏季欧洲夏令时为UTC+2。</p>\n\n<h6 id=\"wet\">WET(欧洲西部时间)</h6>\n\n<p>欧洲西部时间（Western European Time，缩写WET）和世界标准时间（UTC）相同。</p>\n\n<h6 id=\"eet\">EET(欧洲东部时间)</h6>\n\n<p>欧洲东部时间（Eastern European Time，缩写EET）是比世界标准时间（UTC）早二个小时的时区名称之一。它被部分欧洲国家、北非国家和中东国家采用。</p>\n\n<h6 id=\"utc\">UTC(世界标准时间)</h6>\n\n<p>协调世界时，又称世界标准时间或世界協調時間，简称UTC（从英文「Coordinated Universal Time」／法文「Temps Universel Cordonné」而来），是最主要的世界時間標準，其以原子时秒长为基础，在时刻上尽量接近于格林尼治平時。</p>\n\n<h6 id=\"gmt\">GMT(格林尼治平时)</h6>\n\n<p>格林尼治平时（又称格林尼治平均时间或格林尼治标准时间，旧译格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。</p>\n\n<p>自1924年2月5日开始，格林尼治天文台每隔一小时会向全世界发放调时信息。</p>\n\n<p>理论上来说，格林尼治标准时间的正午是指当太阳横穿格林尼治子午线时（也就是在格林尼治上空最高点时）的时间。由于地球在它的椭圆轨道里的运动速度不均匀，这个时刻可能与实际的太阳时有误差，最大误差达16分钟。</p>\n\n<p>由于地球每天的自转是有些不规则的，而且正在缓慢减速，因此格林尼治时间已经不再被作为标准时间使用。现在的标准时间，是由原子钟报时的协调世界时（UTC）。</p>\n\n<h6 id=\"cst\">CST(北京时间)</h6>\n\n<p>北京时间，China Standard Time，中国标准时间。在时区划分上，属东八区，比协调世界时早8小时，记为UTC+8。</p>\n\n<p>不过这个CST这个缩写比较纠结的是它可以同时代表四个不同的时间：</p>\n\n<p>Central Standard Time (USA) UT-6:00 <br />\nCentral Standard Time (Australia) UT+9:30 <br />\nChina Standard Time UT+8:00 <br />\nCuba Standard Time UT-4:00 <br />\n因此你平时编写程序过程中也有可能遇到javascript客户端时间和服务端时间不一致的问题，编程的时候还是要多注意。</p>\n\n<h6 id=\"iso\">ISO 日期和时间的表示方法</h6>\n\n<p>国际标准化组织的国际标准ISO 8601是日期和时间的表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》。目前是第三版ISO8601:2004以替代第一版ISO8601:1988與第二版ISO8601:2000。</p>\n\n<p>这是仅仅就只是一个日期时间的表示方法，我们用这样的方法表示一个UTC时间。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1468468310903,"created_by":1,"updated_at":1468469618333,"updated_by":1,"published_at":1468469618334,"published_by":1},{"id":29,"uuid":"026a8240-4811-4fa0-af76-7301460de880","title":"生存罪","slug":"react-native-xing-neng-zui-xin-guan-fang-wen-dang-fan-yi","markdown":"表白 up 主，剪得太棒了，又多了好多剧追！bgm 雨——清竜人，1P 2P 一起服用效果更佳，剩下的不多说了，慢慢感受吧！\n\n<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"http://static.hdslb.com/miniloader.swf\" flashvars=\"aid=4753273&page=1\" pluginspage=\"http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed>","html":"<p>表白 up 主，剪得太棒了，又多了好多剧追！bgm 雨——清竜人，1P 2P 一起服用效果更佳，剩下的不多说了，慢慢感受吧！</p>\n\n<p><embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"http://static.hdslb.com/miniloader.swf\" flashvars=\"aid=4753273&amp;page=1\" pluginspage=\"http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1468483412197,"created_by":1,"updated_at":1471064171790,"updated_by":1,"published_at":1471064171791,"published_by":1},{"id":30,"uuid":"e043b29e-50be-470f-9a35-e7c8d04a7bc2","title":"js Date的国际化、格式化的探究","slug":"js","markdown":"这一篇是继续上一篇而写的，大致背景就是我在 react native 中需要实现格式化时间。我首先在 MDN 上找到的是下面几个方法：\n\n```\nDate.prototype.toLocaleDateString()\nDate.prototype.toLocaleFormat()\nDate.prototype.toLocaleString()\nDate.prototype.toLocaleTimeString()\n```\n\n` Date.prototype.toLocaleFormat() ` 方法不是 ES 标准当中，所以首先就舍弃了。专向剩下的三个方法，这三个方法都可以传入两个参数 ` locates ` 和 ` options ` 。下面简单介绍下这两个参数：\n\n` locales ` 是个字符串，指定单个[语言标签](https://www.w3.org/International/articles/language-tags/)，或者包含多个语言标签的类数组对象。语言标签如下面的字符串：en(普通英语)，de-AT(奥地利德语)，zh-Hant-TW(台湾使用的繁体中文)。语言标签可以包含一个“Unicode扩展”，形式为-u-key1-value1-key2-value2..., 其中每个key是“扩展key”。不同的构造函数对此进行具体解释。\n\n` opions ` 是个对象，其属性(如果不存在，就赋值为undefined)决定格式化器(formatter)和整理器(collator)的行为。精确的解释由构造函数决定。\n\n给定区域信息和选项，实现会尝试生成近似理想行为的最接近行为。Firefox 支持用于整理(collation)的400+区域，用于date/time和数字格式化的600+区域，所以很可能(但不保证)你想要的区域是被支持的。\n\n这两个实际上是 js 的国际化 api 里的内容，js 国际化 api 包括了 日期、数字等的格式化，不过不是本文的重点，想了解可以参考[此文](http://www.open-open.com/lib/view/open1418779460683.html#articleHeader8)，虽然两年前的但是讲的很细。\n\n于是我开始使用 ` locales ` 和简单的正则来格式化我的时间，如下：\n\n```\n// 用到的地方不多，所以没用写成通用的format\nfunction DateFormat(now) {\n     return now.toLocaleDateString('zh-CN').substring(5).replace(/\\//g, '月').concat('日 ', now.toLocaleTimeString().slice(0, -3));\n}\n```\n\n这段代码在 ios 下感觉良好，但是今天测试流程用了我自己的安卓机，世界就崩塌了🙄，时间是乱的。然后试了下，发现无论传入什么 ` locates ` 在安卓下都没有效果。擦擦擦，那肯定是兼容性的问题了，再次来到 MDN 翻到兼容性的地方，我方了：\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f7767bp42kj311c0asdi0.jpg)\n\n然后只能去找别的方式了，最后用的是正则表达式，亲测可用，如下：\n\n```\n// 对Date的扩展，将 Date 转化为指定格式的String   \n// 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符，   \n// 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字)   \n// 例子：   \n// (new Date()).Format(\"yyyy-MM-dd hh:mm:ss.S\") ==> 2006-07-02 08:09:04.423   \n// (new Date()).Format(\"yyyy-M-d h:m:s.S\")      ==> 2006-7-2 8:9:4.18   \nDate.prototype.Format = function(fmt)   \n{ //author: meizz   \n  var o = {   \n    \"M+\" : this.getMonth()+1,                 //月份   \n    \"d+\" : this.getDate(),                    //日   \n    \"h+\" : this.getHours(),                   //小时   \n    \"m+\" : this.getMinutes(),                 //分   \n    \"s+\" : this.getSeconds(),                 //秒   \n    \"q+\" : Math.floor((this.getMonth()+3)/3), //季度   \n    \"S\"  : this.getMilliseconds()             //毫秒   \n  };   \n  if(/(y+)/.test(fmt))   \n    fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length));   \n  for(var k in o)   \n    if(new RegExp(\"(\"+ k +\")\").test(fmt))   \n  fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length)));   \n  return fmt;   \n}  \n```\n\n虽然最后完成了，但是对于 js 国际化和正则的部分内容，需要做更深入的研究！开饭了！😬\n\n另外如果不想折腾的话，[moment](https://github.com/moment/moment)这个库可能是一个不错的选择。😜","html":"<p>这一篇是继续上一篇而写的，大致背景就是我在 react native 中需要实现格式化时间。我首先在 MDN 上找到的是下面几个方法：</p>\n\n<pre><code>Date.prototype.toLocaleDateString()  \nDate.prototype.toLocaleFormat()  \nDate.prototype.toLocaleString()  \nDate.prototype.toLocaleTimeString()  \n</code></pre>\n\n<p><code>Date.prototype.toLocaleFormat()</code> 方法不是 ES 标准当中，所以首先就舍弃了。专向剩下的三个方法，这三个方法都可以传入两个参数 <code>locates</code> 和 <code>options</code> 。下面简单介绍下这两个参数：</p>\n\n<p><code>locales</code> 是个字符串，指定单个<a href=\"https://www.w3.org/International/articles/language-tags/\">语言标签</a>，或者包含多个语言标签的类数组对象。语言标签如下面的字符串：en(普通英语)，de-AT(奥地利德语)，zh-Hant-TW(台湾使用的繁体中文)。语言标签可以包含一个“Unicode扩展”，形式为-u-key1-value1-key2-value2..., 其中每个key是“扩展key”。不同的构造函数对此进行具体解释。</p>\n\n<p><code>opions</code> 是个对象，其属性(如果不存在，就赋值为undefined)决定格式化器(formatter)和整理器(collator)的行为。精确的解释由构造函数决定。</p>\n\n<p>给定区域信息和选项，实现会尝试生成近似理想行为的最接近行为。Firefox 支持用于整理(collation)的400+区域，用于date/time和数字格式化的600+区域，所以很可能(但不保证)你想要的区域是被支持的。</p>\n\n<p>这两个实际上是 js 的国际化 api 里的内容，js 国际化 api 包括了 日期、数字等的格式化，不过不是本文的重点，想了解可以参考<a href=\"http://www.open-open.com/lib/view/open1418779460683.html#articleHeader8\">此文</a>，虽然两年前的但是讲的很细。</p>\n\n<p>于是我开始使用 <code>locales</code> 和简单的正则来格式化我的时间，如下：</p>\n\n<pre><code>// 用到的地方不多，所以没用写成通用的format\nfunction DateFormat(now) {  \n     return now.toLocaleDateString('zh-CN').substring(5).replace(/\\//g, '月').concat('日 ', now.toLocaleTimeString().slice(0, -3));\n}\n</code></pre>\n\n<p>这段代码在 ios 下感觉良好，但是今天测试流程用了我自己的安卓机，世界就崩塌了🙄，时间是乱的。然后试了下，发现无论传入什么 <code>locates</code> 在安卓下都没有效果。擦擦擦，那肯定是兼容性的问题了，再次来到 MDN 翻到兼容性的地方，我方了：\n<img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f7767bp42kj311c0asdi0.jpg\" alt=\"\" /></p>\n\n<p>然后只能去找别的方式了，最后用的是正则表达式，亲测可用，如下：</p>\n\n<pre><code>// 对Date的扩展，将 Date 转化为指定格式的String   \n// 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符，   \n// 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字)   \n// 例子：   \n// (new Date()).Format(\"yyyy-MM-dd hh:mm:ss.S\") ==&gt; 2006-07-02 08:09:04.423   \n// (new Date()).Format(\"yyyy-M-d h:m:s.S\")      ==&gt; 2006-7-2 8:9:4.18   \nDate.prototype.Format = function(fmt)  \n{ //author: meizz   \n  var o = {   \n    \"M+\" : this.getMonth()+1,                 //月份   \n    \"d+\" : this.getDate(),                    //日   \n    \"h+\" : this.getHours(),                   //小时   \n    \"m+\" : this.getMinutes(),                 //分   \n    \"s+\" : this.getSeconds(),                 //秒   \n    \"q+\" : Math.floor((this.getMonth()+3)/3), //季度   \n    \"S\"  : this.getMilliseconds()             //毫秒   \n  };   \n  if(/(y+)/.test(fmt))   \n    fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length));   \n  for(var k in o)   \n    if(new RegExp(\"(\"+ k +\")\").test(fmt))   \n  fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length)));   \n  return fmt;   \n}  \n</code></pre>\n\n<p>虽然最后完成了，但是对于 js 国际化和正则的部分内容，需要做更深入的研究！开饭了！😬</p>\n\n<p>另外如果不想折腾的话，<a href=\"https://github.com/moment/moment\">moment</a>这个库可能是一个不错的选择。😜</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1468860542709,"created_by":1,"updated_at":1472195793038,"updated_by":1,"published_at":1468899840142,"published_by":1},{"id":31,"uuid":"40e9f305-a20a-4f5c-b7d3-2fe928b04664","title":"自己撸表单验证插件——简陋版","slug":"zi-ji-lu-biao-dan-yan-zheng-cha-jian-jian-lou-ban","markdown":"写之前先吐槽一下：昨晚半夜起来好像把眼镜踩坏了😭，下午只好去了趟眼镜店，顶着杭城下午两点的太阳，也是很拼。没想到传来了更大的噩耗🙄，测散光时说我原来的眼镜散光做反了，没得救了😒。最后只好勉强得整了一下，但愿新镜片能够慢慢调整好😂。\n\n然后是正片，今天鱼头说把司机招募的验证加上去，刚好写完后台消息的AOP没什么事，所以我就寻思写的一劳永逸的验证模块，岂不是很好很nice。不过作为懒人还是先去 github 上着了一番，不过没有比较适合现在的项目的。主要原因还是页面已经完成了，改用其它组件的工程量太大。所以最后决定自己整一个不侵入现有组件的，只关注验证逻辑，可扩展的验证模块。\n\n先来看看引入插件之前的的表单验证：\n\n```\nhandleSubmit() {\n        if(!this.state.credit_card){\n            Alert.alert('必须填写银行卡号!');\n            return;\n        }\n        if(!this.state.rest || this.state.rest < 0){\n            Alert.alert('请填写正确的提现金额!');\n            return;\n        }\n        if(this.state.rest > this.props.driver.driver_state.rest){\n            Alert.alert('提现金额不能大于余额!');\n            return;\n        }\n        rest.post...\n    }\n```\n\n可以看到是通过 if 进行判断，这种做法，代码十分丑陋，而且复用性十分低。有什么办法能够改进上面的代码呢！进一步思考，其实表单验证的逻辑无非是对某个表单的输入，进行相关逻辑的判断。进行的逻辑判断是不变的，而判断的方式是可以改变的。是不是有点感觉了，我们可以把不变的逻辑固定下来，而可变的策略抽离出来。说到底就是策略模式了，策略模式就是通过把可变的判断策略提取出来，帮助我们省去那些 ` if ` 。废话不多说，先来看看在 web 上我们是如何使用的：[出处](http://brizer.github.io/2016/05/04/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/)\n\n```\n//定义验证策略\nvar strategies = {\n    inNonEmpty:function(value,errorMsg){//不能为空\n        if(value === ''){\n            return errorMsg;\n        }\n    },\n    minLength:function(value,length,errorMsg){//最小长度\n        if(value.length < length){\n            return errorMsg;\n        }\n    },\n    isReg:function(value,reg,errorMsg){//正则匹配\n        if(!reg.test(value)){\n            return errorMsg;\n        }\n    }\n};\n//定义验证类\nvar Validator = function(){\n    this.cache = [];//保存效验规则\n};\n//添加验证规则\nValidator.prototype.add = function(dom,rules){\n    var that = this;\n    //多条规则分别对应\n    for(var i = 0 ,rule; rule = rules[i++];){\n        (function(rule){\n            var stratgyAry = rule.strategy.split(':');\n            var errorMsg = rule.errorMsg;\n\t\t\t//将数据按照策略的格式塞入参数数组\n            that.cache.push(function(){\n                var strategy = strategyAry.shift();\n                strategyAry.unshift(dom.value);\n                strategyAry.push(errorMsg);\n                return strategies[strategy].apply(dom,strategyAry);\n            });\n        })(rule)\n    }\n};\nValidator.prototype.start = function(){\n    //依次验证\n    for(var i = 0,validatorFunc;validatorFunc = this.cache[i++];){\n        var errorMsg = validatorFunc();\n        if(errorMsg){\n            return errorMsg;\n       }\n    }\n};\n\n//调用代码\nvar validataFunc = function(){\n    var validator = new Validator();\n    //多个条件判断\n    validator.add(form.name,[{\n        strategy:'isNonEmpty',\n        errorMsg:'用户不能为空'\n    },{\n        strategy:'minLength:10',\n        errorMsg:'用户长度不能小于10位'\n    }]);\n    validator.add(form.password,[{\n        strategy:'minLength:6',\n        errorMsg:'密码长度不能低于6位'\n    }]);\n    var errorMsg = validator.start();\n    return errorMsg;\n}\nform.onsubmit = function(){\n    var errorMsg = validateFunc();\n    if(errorMsg){\n        alert(errorMsg);\n        return false;\n    }\n    //验证通过，提交表单\n}\n```\n\n上面的代码简单来说，就是定义了一个验证器，在验证前把验证的 dom 和 对应的策略添加到验证器中，然后调用 start 函数，一次运行验证函数，如有验证错误则返回错误信息。这样我们就可以复用验证策略，只需要关心每个输入具体要符合什么规则并传入就可以了，代码也很清爽。\n\n但是这还不能直接运用到 rn 当中，需要稍微改造下，因为我没有 dom ，我有的是 state。[tcomb-form-native](https://github.com/gcanti/tcomb-form-native)这个库给了我一些灵感。\n\n```\n// here we are: define your domain model\nvar Person = t.struct({\n  name: t.String,              // a required string\n  surname: t.maybe(t.String),  // an optional string\n  age: t.Number,               // a required number\n  rememberMe: t.Boolean        // a boolean\n});\n```\n\n它是这么定义验证的信息的，那其实我的 state 当中的需要验证的字段和验证规则之间也可以建立一种类似的规则。于是就有了我最后的简陋版的验证插件，先看代码，然后再谈谈不足：\n\n```\n/**\n * Created by m2mbob on 16/7/20.\n */\nconst strategies = {\n    isRequired:function(value,errorMsg) {\n        if(value === ''){\n            return errorMsg;\n        }\n    },\n    maxLength:function(value,length,errorMsg) {//最小长度\n        if(value.length > length){\n            return errorMsg;\n        }\n    },\n    minLength:function(value,length,errorMsg) {//最小长度\n        if(value.length < length){\n            return errorMsg;\n        }\n    },\n    isPhone:function(value,errorMsg) {\n        return this.isReg(value, /^1[3|4|5|7|8]\\d{9}$/g, errorMsg);\n    },\n    isEmail:function(value, errorMsg) {\n        return this.isReg(value, /^(\\w-*\\.*)+@(\\w-?)+(\\.\\w{2,})+$/g, errorMsg);\n    },\n    isIdCard:function(value, errorMsg) {\n        return this.isReg(value, /(^\\d{15}$)|(^\\d{17}([0-9]|X)$)/g, errorMsg);\n    },\n    isCar:function(value, errorMsg) {\n        return this.isReg(value, /^[\\u4e00-\\u9fa5]{1}[A-Z]{1}[A-Z_0-9]{5}$/g, errorMsg);\n    },\n    isReg:function(value,reg,errorMsg) {//正则匹配\n        if(!reg.test(value)){\n            return errorMsg;\n        }\n    }\n};\n\nexport default class Validator {\n    constructor() {\n        this.errMsg = [];\n    }\n\n    validate(value, rules) {\n        let flag = true;\n        for(let i = 0 ,rule; rule = rules[i++];){\n            let strategyAry = rule.strategy.split(':');\n            let errorMsg = rule.errorMsg;\n            let strategy = strategyAry.shift();\n            strategyAry.unshift(value);\n            strategyAry.push(errorMsg);\n            let err = strategies[strategy](strategyAry);\n            if(err){\n                flag = false;\n                this.errMsg.push(err);\n            }\n        }\n        return flag;\n    }\n\n    validates(source, rules) {\n        for (let key of Object.keys(rules)){\n            if(source[key]){\n                let result = this.validate(source[key], rules[key]);\n                if(!result){\n                    const firstError = this.errMsg.shift();\n                    this.errMsg = [];\n                    return firstError;\n                }\n            }else{\n                return rules[key][0].errorMsg;\n            }\n        }\n\n    }\n\n}\n\n// 调用\nconst firstError = new Validator().validates(this.state.driver, {\n            ...\n            car_model: [{\n                strategy:'isRequired',\n                errorMsg:'车牌号不能为空'\n            },{\n                strategy:'isCar',\n                errorMsg:'车牌号格式错误'\n            }]\n            ...\n        });\n        if (firstError) {\n            Alert.alert(firstError);\n            return;\n        }\n```\n\n主要改动在于 validates 函数，这个函数接受两个参数 ` source ` 和  ` rules ` ， ` source ` 是一个包含了所有待验证输入字段的源对象，大部分情况下就是 state 或 state 中的对象； ` rules ` 是一个对象，它的 ` Object.keys ` 求值结果是 ` source ` 求值结果的子集，也就是说每一个 ` rules ` 的键都能够在 ` source ` 中找到，所以我遍历了 ` rules ` 的 ` key ` 然后向 ` validate ` 方法传入 ` source[key] ` 和 ` rules[key] ` 进行校验，  ` validate ` 方法改动不大。\n\n最后来说说不足的地方，首先是没能够将错误反映到实际的表单当中，而是 alert 的方式，体验稍差，这部分是需要改进的。其次，实际使用当中，当字段很多时，有不少重复的规则，是否可以合并？也就是换个角度来做这个问题！不过在这个项目中已经够用了。\n\n不早了，先写到这，后面在研究下，撸一个更好，更通用的版本！","html":"<p>写之前先吐槽一下：昨晚半夜起来好像把眼镜踩坏了😭，下午只好去了趟眼镜店，顶着杭城下午两点的太阳，也是很拼。没想到传来了更大的噩耗🙄，测散光时说我原来的眼镜散光做反了，没得救了😒。最后只好勉强得整了一下，但愿新镜片能够慢慢调整好😂。</p>\n\n<p>然后是正片，今天鱼头说把司机招募的验证加上去，刚好写完后台消息的AOP没什么事，所以我就寻思写的一劳永逸的验证模块，岂不是很好很nice。不过作为懒人还是先去 github 上着了一番，不过没有比较适合现在的项目的。主要原因还是页面已经完成了，改用其它组件的工程量太大。所以最后决定自己整一个不侵入现有组件的，只关注验证逻辑，可扩展的验证模块。</p>\n\n<p>先来看看引入插件之前的的表单验证：</p>\n\n<pre><code>handleSubmit() {  \n        if(!this.state.credit_card){\n            Alert.alert('必须填写银行卡号!');\n            return;\n        }\n        if(!this.state.rest || this.state.rest &lt; 0){\n            Alert.alert('请填写正确的提现金额!');\n            return;\n        }\n        if(this.state.rest &gt; this.props.driver.driver_state.rest){\n            Alert.alert('提现金额不能大于余额!');\n            return;\n        }\n        rest.post...\n    }\n</code></pre>\n\n<p>可以看到是通过 if 进行判断，这种做法，代码十分丑陋，而且复用性十分低。有什么办法能够改进上面的代码呢！进一步思考，其实表单验证的逻辑无非是对某个表单的输入，进行相关逻辑的判断。进行的逻辑判断是不变的，而判断的方式是可以改变的。是不是有点感觉了，我们可以把不变的逻辑固定下来，而可变的策略抽离出来。说到底就是策略模式了，策略模式就是通过把可变的判断策略提取出来，帮助我们省去那些 <code>if</code> 。废话不多说，先来看看在 web 上我们是如何使用的：<a href=\"http://brizer.github.io/2016/05/04/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/\">出处</a></p>\n\n<pre><code>//定义验证策略\nvar strategies = {  \n    inNonEmpty:function(value,errorMsg){//不能为空\n        if(value === ''){\n            return errorMsg;\n        }\n    },\n    minLength:function(value,length,errorMsg){//最小长度\n        if(value.length &lt; length){\n            return errorMsg;\n        }\n    },\n    isReg:function(value,reg,errorMsg){//正则匹配\n        if(!reg.test(value)){\n            return errorMsg;\n        }\n    }\n};\n//定义验证类\nvar Validator = function(){  \n    this.cache = [];//保存效验规则\n};\n//添加验证规则\nValidator.prototype.add = function(dom,rules){  \n    var that = this;\n    //多条规则分别对应\n    for(var i = 0 ,rule; rule = rules[i++];){\n        (function(rule){\n            var stratgyAry = rule.strategy.split(':');\n            var errorMsg = rule.errorMsg;\n            //将数据按照策略的格式塞入参数数组\n            that.cache.push(function(){\n                var strategy = strategyAry.shift();\n                strategyAry.unshift(dom.value);\n                strategyAry.push(errorMsg);\n                return strategies[strategy].apply(dom,strategyAry);\n            });\n        })(rule)\n    }\n};\nValidator.prototype.start = function(){  \n    //依次验证\n    for(var i = 0,validatorFunc;validatorFunc = this.cache[i++];){\n        var errorMsg = validatorFunc();\n        if(errorMsg){\n            return errorMsg;\n       }\n    }\n};\n\n//调用代码\nvar validataFunc = function(){  \n    var validator = new Validator();\n    //多个条件判断\n    validator.add(form.name,[{\n        strategy:'isNonEmpty',\n        errorMsg:'用户不能为空'\n    },{\n        strategy:'minLength:10',\n        errorMsg:'用户长度不能小于10位'\n    }]);\n    validator.add(form.password,[{\n        strategy:'minLength:6',\n        errorMsg:'密码长度不能低于6位'\n    }]);\n    var errorMsg = validator.start();\n    return errorMsg;\n}\nform.onsubmit = function(){  \n    var errorMsg = validateFunc();\n    if(errorMsg){\n        alert(errorMsg);\n        return false;\n    }\n    //验证通过，提交表单\n}\n</code></pre>\n\n<p>上面的代码简单来说，就是定义了一个验证器，在验证前把验证的 dom 和 对应的策略添加到验证器中，然后调用 start 函数，一次运行验证函数，如有验证错误则返回错误信息。这样我们就可以复用验证策略，只需要关心每个输入具体要符合什么规则并传入就可以了，代码也很清爽。</p>\n\n<p>但是这还不能直接运用到 rn 当中，需要稍微改造下，因为我没有 dom ，我有的是 state。<a href=\"https://github.com/gcanti/tcomb-form-native\">tcomb-form-native</a>这个库给了我一些灵感。</p>\n\n<pre><code>// here we are: define your domain model\nvar Person = t.struct({  \n  name: t.String,              // a required string\n  surname: t.maybe(t.String),  // an optional string\n  age: t.Number,               // a required number\n  rememberMe: t.Boolean        // a boolean\n});\n</code></pre>\n\n<p>它是这么定义验证的信息的，那其实我的 state 当中的需要验证的字段和验证规则之间也可以建立一种类似的规则。于是就有了我最后的简陋版的验证插件，先看代码，然后再谈谈不足：</p>\n\n<pre><code>/**\n * Created by m2mbob on 16/7/20.\n */\nconst strategies = {  \n    isRequired:function(value,errorMsg) {\n        if(value === ''){\n            return errorMsg;\n        }\n    },\n    maxLength:function(value,length,errorMsg) {//最小长度\n        if(value.length &gt; length){\n            return errorMsg;\n        }\n    },\n    minLength:function(value,length,errorMsg) {//最小长度\n        if(value.length &lt; length){\n            return errorMsg;\n        }\n    },\n    isPhone:function(value,errorMsg) {\n        return this.isReg(value, /^1[3|4|5|7|8]\\d{9}$/g, errorMsg);\n    },\n    isEmail:function(value, errorMsg) {\n        return this.isReg(value, /^(\\w-*\\.*)+@(\\w-?)+(\\.\\w{2,})+$/g, errorMsg);\n    },\n    isIdCard:function(value, errorMsg) {\n        return this.isReg(value, /(^\\d{15}$)|(^\\d{17}([0-9]|X)$)/g, errorMsg);\n    },\n    isCar:function(value, errorMsg) {\n        return this.isReg(value, /^[\\u4e00-\\u9fa5]{1}[A-Z]{1}[A-Z_0-9]{5}$/g, errorMsg);\n    },\n    isReg:function(value,reg,errorMsg) {//正则匹配\n        if(!reg.test(value)){\n            return errorMsg;\n        }\n    }\n};\n\nexport default class Validator {  \n    constructor() {\n        this.errMsg = [];\n    }\n\n    validate(value, rules) {\n        let flag = true;\n        for(let i = 0 ,rule; rule = rules[i++];){\n            let strategyAry = rule.strategy.split(':');\n            let errorMsg = rule.errorMsg;\n            let strategy = strategyAry.shift();\n            strategyAry.unshift(value);\n            strategyAry.push(errorMsg);\n            let err = strategies[strategy](strategyAry);\n            if(err){\n                flag = false;\n                this.errMsg.push(err);\n            }\n        }\n        return flag;\n    }\n\n    validates(source, rules) {\n        for (let key of Object.keys(rules)){\n            if(source[key]){\n                let result = this.validate(source[key], rules[key]);\n                if(!result){\n                    const firstError = this.errMsg.shift();\n                    this.errMsg = [];\n                    return firstError;\n                }\n            }else{\n                return rules[key][0].errorMsg;\n            }\n        }\n\n    }\n\n}\n\n// 调用\nconst firstError = new Validator().validates(this.state.driver, {  \n            ...\n            car_model: [{\n                strategy:'isRequired',\n                errorMsg:'车牌号不能为空'\n            },{\n                strategy:'isCar',\n                errorMsg:'车牌号格式错误'\n            }]\n            ...\n        });\n        if (firstError) {\n            Alert.alert(firstError);\n            return;\n        }\n</code></pre>\n\n<p>主要改动在于 validates 函数，这个函数接受两个参数 <code>source</code> 和  <code>rules</code> ， <code>source</code> 是一个包含了所有待验证输入字段的源对象，大部分情况下就是 state 或 state 中的对象； <code>rules</code> 是一个对象，它的 <code>Object.keys</code> 求值结果是 <code>source</code> 求值结果的子集，也就是说每一个 <code>rules</code> 的键都能够在 <code>source</code> 中找到，所以我遍历了 <code>rules</code> 的 <code>key</code> 然后向 <code>validate</code> 方法传入 <code>source[key]</code> 和 <code>rules[key]</code> 进行校验，  <code>validate</code> 方法改动不大。</p>\n\n<p>最后来说说不足的地方，首先是没能够将错误反映到实际的表单当中，而是 alert 的方式，体验稍差，这部分是需要改进的。其次，实际使用当中，当字段很多时，有不少重复的规则，是否可以合并？也就是换个角度来做这个问题！不过在这个项目中已经够用了。</p>\n\n<p>不早了，先写到这，后面在研究下，撸一个更好，更通用的版本！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1469026705376,"created_by":1,"updated_at":1475119482684,"updated_by":1,"published_at":1469029771905,"published_by":1},{"id":32,"uuid":"bc1e84b8-b50e-41b3-ad8d-acea8fa0d04c","title":"有趣、有感、有情","slug":"you-qu-you-gan-you-qing","markdown":"<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"http://static.hdslb.com/miniloader.swf\" flashvars=\"aid=2684667&page=1\" pluginspage=\"http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed>","html":"<p><embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"http://static.hdslb.com/miniloader.swf\" flashvars=\"aid=2684667&amp;page=1\" pluginspage=\"http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1469065163248,"created_by":1,"updated_at":1470055042869,"updated_by":1,"published_at":1470055042869,"published_by":1},{"id":33,"uuid":"b0c15dab-e1f8-41fc-8bd1-d6de3326ca2b","title":"react native —— 安卓知识与踩坑篇（一）","slug":"react-native-an-zhuo-zhi-shi-bu-chong-pian","markdown":"这个系列文章是在编写[react native 高德后台定位插件](https://github.com/yptech/react-native-yunpeng-amplocation)的安卓部分时，使用到的一些原生安卓知识的记录。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=297728&auto=1&height=66\"></iframe>\n\n##### android studio 真机运行的时候gradle 报错\n\nFAILURE: Build failed with an exception.\n\n* What went wrong:\n\nExecution failed for task ':app:preDexDebug'.\n\n> com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process 'command 'C:\\Program Files\\Java\\jdk1.7.0_71\\bin\\java.exe'' finished with non-zero exit value 1\n\n* Try:\n\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.\n\n* solution\n\n>1. 在project structure中去掉重复的jar包，\n2. 如果你的jar包是放到了libs目录中，且在gradle中发现了如下代码：\ncompile fileTree(include: ['*.jar'], dir: 'libs')\n则注释掉即可。\n\n##### Android中Parcelable序列化总结\n\nParcelable 接口与 JDK 当中的 Serializable 接口类似，是为了做对象序列化的。在我本次编写插件过程中，需要通过 intent 传递配置的对象，而这个对象要传递就需要实现 Parcelable 接口。\n\n###### Serializable与Parcelable的区别\n\n1. Serializable是JDK提供的接口，而Parcelable是Android SDK提供的。\n2. Serializable序列化是基于磁盘的，而Parcelable是基于内存的。在内存中读写肯定效率要高于磁盘，所以Android中跨进程传递对象都是使用Parcelable。\n\n最后来看看如何使用，我们需要实现 Parcelable 接口的如下方法：\n\n 1. describeContents方法。内容接口描述，默认返回0就可以;\n 2. writeToParcel 方法。该方法将类的数据写入外部提供的Parcel中.即打包需要传递的数据到Parcel容器保存，以便从parcel容器获取数据，该方法声明如下：`writeToParcel (Parcel dest, int flags)`\n 3. 静态的Parcelable.Creator接口，本接口有两个方法：`createFromParcel(Parcel in)`  从Parcel容器中读取传递数据值，封装成Parcelable对象返回逻辑层。`newArray(int size)` 创建一个类型为T，长度为size的数组，仅一句话（return new T[size])即可。方法是供外部类反序列化本类数组使用。\n\n下面的例子包括了大部分的使用情况：\n\n```\npackage com.suning.mobile.paysdk.pay;\n \nimport java.util.ArrayList;\n \nimport android.os.Parcel;\nimport android.os.Parcelable;\n \nimport com.yaya.test.OrderInfoBean;\n \n/**\n * \n * 〈一句话功能简述〉<br>\n * 〈功能详细描述〉 数据类型序列化\n */\npublic class ParcelableType implements Parcelable {\n    /** int 类型 */\n    int age;\n    /** String 类型 */\n    String name;\n    /** boolean 注意该boolean的get和set方法 **/\n    boolean isGood;\n    /** boolean 类型 **/\n    boolean complete;\n    /** 数组 **/\n    private String[] ids;\n    /** 对象 [内部已经序列化] **/\n    private OrderInfoBean bean;\n    /** list **/\n    private ArrayList<orderinfobean> listBeans;\n \n    /**\n     * 默认构造方法\n     */\n    public ParcelableType() {\n        // TODO Auto-generated constructor stub\n    }\n \n    public ParcelableType(Parcel in) {\n        readFromParcel(in);\n    }\n \n    /***\n     * 默认实现\n     */\n    @Override\n    public int describeContents() {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n \n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        /** int 写入 **/\n        dest.writeInt(age);\n        /** string 写入 **/\n        dest.writeString(name);\n        /** boolean 写入 **/\n        dest.writeInt(isGood ? 1 : 0);\n        /** boolean 写入 **/\n        dest.writeInt(complete ? 1 : 0);\n        /** 数组 写入 **/\n        if (ids != null) {\n            dest.writeInt(ids.length);\n        } else {\n            dest.writeInt(0);\n        }\n        dest.writeStringArray(ids);\n        /** 对象 写入 **/\n        dest.writeParcelable(bean, flags);\n        /** list 写入 **/\n        dest.writeList(listBeans);\n \n    }\n \n    @SuppressWarnings(\"unchecked\")\n    private void readFromParcel(Parcel in) {\n \n        /** int 读出 */\n        age = in.readInt();\n        /** stirng 读出 */\n        name = in.readString();\n        /** boolean 读出 */\n        isGood = (in.readInt() == 1) ? true : false;\n        /** boolean 读出 */\n        complete = (in.readInt() == 1) ? true : false;\n        /** 数组 读出 */\n        int length = in.readInt();\n        ids = new String[length];\n        in.readStringArray(ids);\n        /** 对象 读出 */\n        bean = in.readParcelable(OrderInfoBean.class.getClassLoader());\n        /** list 读出 */\n        listBeans = in.readArrayList(OrderInfoBean.class.getClassLoader());\n \n    }\n \n    public static final Parcelable.Creator<parcelabletype> CREATOR = new Parcelable.Creator<parcelabletype>() {\n        public ParcelableType createFromParcel(Parcel in) {\n            return new ParcelableType(in);\n        }\n \n        public ParcelableType[] newArray(int size) {\n            return new ParcelableType[size];\n        }\n    };\n \n    public int getAge() {\n        return age;\n    }\n \n    public void setAge(int age) {\n        this.age = age;\n    }\n \n    public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n \n    /**\n     * \n     * 功能描述: <br>\n     * 〈功能详细描述〉 fastJson解析时需要格式\n     */\n    public boolean isIsGood() {\n        return isGood;\n    }\n \n    public void setIsGood(boolean isGood) {\n        this.isGood = isGood;\n    }\n \n    public boolean isComplete() {\n        return complete;\n    }\n \n    public void setComplete(boolean complete) {\n        this.complete = complete;\n    }\n \n    public String[] getIds() {\n        return ids;\n    }\n \n    public void setIds(String[] ids) {\n        this.ids = ids;\n    }\n \n    public OrderInfoBean getBean() {\n        return bean;\n    }\n \n    public void setBean(OrderInfoBean bean) {\n        this.bean = bean;\n    }\n \n    public ArrayList<orderinfobean> getListBeans() {\n        return listBeans;\n    }\n \n    public void setListBeans(ArrayList<orderinfobean> listBeans) {\n        this.listBeans = listBeans;\n    }\n \n}\n```\n\n\n\n","html":"<p>这个系列文章是在编写<a href=\"https://github.com/yptech/react-native-yunpeng-amplocation\">react native 高德后台定位插件</a>的安卓部分时，使用到的一些原生安卓知识的记录。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=297728&auto=1&height=66\"></iframe>\n\n<h5 id=\"androidstudiogradle\">android studio 真机运行的时候gradle 报错</h5>\n\n<p>FAILURE: Build failed with an exception.</p>\n\n<ul>\n<li>What went wrong:</li>\n</ul>\n\n<p>Execution failed for task ':app:preDexDebug'.</p>\n\n<blockquote>\n  <p>com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process 'command 'C:\\Program Files\\Java\\jdk1.7.0_71\\bin\\java.exe'' finished with non-zero exit value 1</p>\n</blockquote>\n\n<ul>\n<li>Try:</li>\n</ul>\n\n<p>Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.</p>\n\n<ul>\n<li>solution</li>\n</ul>\n\n<blockquote>\n  <ol>\n  <li>在project structure中去掉重复的jar包，</li>\n  <li>如果你的jar包是放到了libs目录中，且在gradle中发现了如下代码： <br />\n  compile fileTree(include: ['*.jar'], dir: 'libs') <br />\n  则注释掉即可。</li>\n  </ol>\n</blockquote>\n\n<h5 id=\"androidparcelable\">Android中Parcelable序列化总结</h5>\n\n<p>Parcelable 接口与 JDK 当中的 Serializable 接口类似，是为了做对象序列化的。在我本次编写插件过程中，需要通过 intent 传递配置的对象，而这个对象要传递就需要实现 Parcelable 接口。</p>\n\n<h6 id=\"serializableparcelable\">Serializable与Parcelable的区别</h6>\n\n<ol>\n<li>Serializable是JDK提供的接口，而Parcelable是Android SDK提供的。  </li>\n<li>Serializable序列化是基于磁盘的，而Parcelable是基于内存的。在内存中读写肯定效率要高于磁盘，所以Android中跨进程传递对象都是使用Parcelable。</li>\n</ol>\n\n<p>最后来看看如何使用，我们需要实现 Parcelable 接口的如下方法：</p>\n\n<ol>\n<li>describeContents方法。内容接口描述，默认返回0就可以;</li>\n<li>writeToParcel 方法。该方法将类的数据写入外部提供的Parcel中.即打包需要传递的数据到Parcel容器保存，以便从parcel容器获取数据，该方法声明如下：<code>writeToParcel (Parcel dest, int flags)</code></li>\n<li>静态的Parcelable.Creator接口，本接口有两个方法：<code>createFromParcel(Parcel in)</code>  从Parcel容器中读取传递数据值，封装成Parcelable对象返回逻辑层。<code>newArray(int size)</code> 创建一个类型为T，长度为size的数组，仅一句话（return new T[size])即可。方法是供外部类反序列化本类数组使用。</li>\n</ol>\n\n<p>下面的例子包括了大部分的使用情况：</p>\n\n<pre><code>package com.suning.mobile.paysdk.pay;\n\nimport java.util.ArrayList;\n\nimport android.os.Parcel;  \nimport android.os.Parcelable;\n\nimport com.yaya.test.OrderInfoBean;\n\n/**\n * \n * 〈一句话功能简述〉&lt;br&gt;\n * 〈功能详细描述〉 数据类型序列化\n */\npublic class ParcelableType implements Parcelable {  \n    /** int 类型 */\n    int age;\n    /** String 类型 */\n    String name;\n    /** boolean 注意该boolean的get和set方法 **/\n    boolean isGood;\n    /** boolean 类型 **/\n    boolean complete;\n    /** 数组 **/\n    private String[] ids;\n    /** 对象 [内部已经序列化] **/\n    private OrderInfoBean bean;\n    /** list **/\n    private ArrayList&lt;orderinfobean&gt; listBeans;\n\n    /**\n     * 默认构造方法\n     */\n    public ParcelableType() {\n        // TODO Auto-generated constructor stub\n    }\n\n    public ParcelableType(Parcel in) {\n        readFromParcel(in);\n    }\n\n    /***\n     * 默认实现\n     */\n    @Override\n    public int describeContents() {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        /** int 写入 **/\n        dest.writeInt(age);\n        /** string 写入 **/\n        dest.writeString(name);\n        /** boolean 写入 **/\n        dest.writeInt(isGood ? 1 : 0);\n        /** boolean 写入 **/\n        dest.writeInt(complete ? 1 : 0);\n        /** 数组 写入 **/\n        if (ids != null) {\n            dest.writeInt(ids.length);\n        } else {\n            dest.writeInt(0);\n        }\n        dest.writeStringArray(ids);\n        /** 对象 写入 **/\n        dest.writeParcelable(bean, flags);\n        /** list 写入 **/\n        dest.writeList(listBeans);\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void readFromParcel(Parcel in) {\n\n        /** int 读出 */\n        age = in.readInt();\n        /** stirng 读出 */\n        name = in.readString();\n        /** boolean 读出 */\n        isGood = (in.readInt() == 1) ? true : false;\n        /** boolean 读出 */\n        complete = (in.readInt() == 1) ? true : false;\n        /** 数组 读出 */\n        int length = in.readInt();\n        ids = new String[length];\n        in.readStringArray(ids);\n        /** 对象 读出 */\n        bean = in.readParcelable(OrderInfoBean.class.getClassLoader());\n        /** list 读出 */\n        listBeans = in.readArrayList(OrderInfoBean.class.getClassLoader());\n\n    }\n\n    public static final Parcelable.Creator&lt;parcelabletype&gt; CREATOR = new Parcelable.Creator&lt;parcelabletype&gt;() {\n        public ParcelableType createFromParcel(Parcel in) {\n            return new ParcelableType(in);\n        }\n\n        public ParcelableType[] newArray(int size) {\n            return new ParcelableType[size];\n        }\n    };\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * \n     * 功能描述: &lt;br&gt;\n     * 〈功能详细描述〉 fastJson解析时需要格式\n     */\n    public boolean isIsGood() {\n        return isGood;\n    }\n\n    public void setIsGood(boolean isGood) {\n        this.isGood = isGood;\n    }\n\n    public boolean isComplete() {\n        return complete;\n    }\n\n    public void setComplete(boolean complete) {\n        this.complete = complete;\n    }\n\n    public String[] getIds() {\n        return ids;\n    }\n\n    public void setIds(String[] ids) {\n        this.ids = ids;\n    }\n\n    public OrderInfoBean getBean() {\n        return bean;\n    }\n\n    public void setBean(OrderInfoBean bean) {\n        this.bean = bean;\n    }\n\n    public ArrayList&lt;orderinfobean&gt; getListBeans() {\n        return listBeans;\n    }\n\n    public void setListBeans(ArrayList&lt;orderinfobean&gt; listBeans) {\n        this.listBeans = listBeans;\n    }\n\n}\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1469240531228,"created_by":1,"updated_at":1473918099995,"updated_by":1,"published_at":1469535290970,"published_by":1},{"id":34,"uuid":"44877e28-bbec-4496-a6f0-b21cc68f2c79","title":"Android Studio 中 .gitignore 的编写","slug":"zhuan-android-studio-zhong-gitignore-de-bian-xie","markdown":"<embed src=\"https://www.xiami.com/widget/49883737_1770692731/singlePlayer.swf\" type=\"application/x-shockwave-flash\" width=\"257\" height=\"33\" wmode=\"transparent\"></embed>\n\n最近花了比较大的力气，写了一个 react native 版高德地图定位及后台持续监听定位的插件，主要写的是安卓的原生代码，所以后面会有不少关于本次编写当中原生知识相关的博文！这算是第一篇😪。还有好久木有放歌了，懒得回去加了，不过这首确实很好听，如果弹过吉他更会有不同的体会，T121 3121！😊。\n\n因为之前的项目的 .gitignore 文件都是 node 或者 react 相关的模板，或者稍微定制一下，用在这个插件当中，发现传上去很多不必要的文件，所以找了一个比较通用的放在这，以后肯定用得到。\n\n```\n# built application files\n*.apk\n*.ap_\n\n# files for the dex VM\n*.dex\n\n# Java class files\n*.class\n\n# generated files\nbin/\ngen/\nout/\nbuild/\n\n# Local configuration file (sdk path, etc)\nlocal.properties\n\n# Windows thumbnail db\nThumbs.db\n\n# OSX files\n.DS_Store\n\n# Eclipse project files\n.classpath\n.project\n\n# Android Studio\n*.iml\n.idea\n\n# Local IDEA workspace\n.idea/workspace.xml\n\n# Gradle cache\n.gradle\n\n#NDK\nobj/\n```","html":"<p><embed src=\"https://www.xiami.com/widget/49883737_1770692731/singlePlayer.swf\" type=\"application/x-shockwave-flash\" width=\"257\" height=\"33\" wmode=\"transparent\"></embed></p>\n\n<p>最近花了比较大的力气，写了一个 react native 版高德地图定位及后台持续监听定位的插件，主要写的是安卓的原生代码，所以后面会有不少关于本次编写当中原生知识相关的博文！这算是第一篇😪。还有好久木有放歌了，懒得回去加了，不过这首确实很好听，如果弹过吉他更会有不同的体会，T121 3121！😊。</p>\n\n<p>因为之前的项目的 .gitignore 文件都是 node 或者 react 相关的模板，或者稍微定制一下，用在这个插件当中，发现传上去很多不必要的文件，所以找了一个比较通用的放在这，以后肯定用得到。</p>\n\n<pre><code># built application files\n*.apk\n*.ap_\n\n# files for the dex VM\n*.dex\n\n# Java class files\n*.class\n\n# generated files\nbin/  \ngen/  \nout/  \nbuild/\n\n# Local configuration file (sdk path, etc)\nlocal.properties\n\n# Windows thumbnail db\nThumbs.db\n\n# OSX files\n.DS_Store\n\n# Eclipse project files\n.classpath\n.project\n\n# Android Studio\n*.iml\n.idea\n\n# Local IDEA workspace\n.idea/workspace.xml\n\n# Gradle cache\n.gradle\n\n#NDK\nobj/  \n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1469436400951,"created_by":1,"updated_at":1473918812718,"updated_by":1,"published_at":1469436760761,"published_by":1},{"id":35,"uuid":"1a7afcb5-1488-4fac-891d-5ea2b4df142a","title":"react native —— 安卓知识与踩坑篇（二）","slug":"react-native-an-zhuo-zhi-shi-yu-cai-keng-pian-er","markdown":"这个系列文章是在编写[react native 高德后台定位插件](https://github.com/yptech/react-native-yunpeng-amplocation)的安卓部分时，使用到的一些原生安卓知识的记录。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=668472&auto=1&height=66\"></iframe>\n\n##### Android Service \n\nService 是我实现后台持续监听定位的主要工具，他是 android 的四大组件之一，它主要用于在后台处理一些耗时的逻辑，或者去执行某些需要长期运行的任务。必要的时候我们甚至可以在程序退出的情况下，让Service在后台继续保持运行状态。Service 的内容很多可以看下面这几篇文章。\n\n在这里主要要讲的是如何让 Service 不被杀死，因为 app 进入后台后，当内存比较紧张时，后台 Service 就有可能被杀死，在下面的文章一中对三种杀死的情况做了讨论。\n\n1. 系统根据资源分配情况杀死服务\n2. 用户通过settings->Apps->Running->Stop方式杀死服务\n3. 用户通过settings->Apps->Downloaded->Force Stop方式杀死服务\n\n###### 第一种情况：\n\n用户不干预，完全靠系统来控制，办法有很多。比如 ` onStartCommand() ` 方法的返回值设为 ` START_STICKY ` ，服务就会在资源紧张的时候被杀掉，然后在资源足够的时候再恢复。当然也可设置为前台服务，使其有高的优先级，在资源紧张的时候也不会被杀掉。\n\n###### 第二种情况：\n  用户干预，主动杀掉运行中的服务。这个过程杀死服务会通过服务的生命周期，也就是会调用 ` onDestory() ` 方法，这时候一个方案就是在` onDestory() ` 中发送广播开启自己。这样杀死服务后会立即启动。如下：\n\n```\n@Override\npublic void onCreate() {\n    // TODO Auto-generated method stub\n    super.onCreate();\n\n    mBR = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            // TODO Auto-generated method stub\n            Intent a = new Intent(ServiceA.this, ServiceA.class);\n            startService(a);\n        }\n    };\n    mIF = new IntentFilter();\n    mIF.addAction(\"listener\");\n    registerReceiver(mBR, mIF);\n}\n\n@Override\npublic void onDestroy() {\n    // TODO Auto-generated method stub\n    super.onDestroy();\n\n    Intent intent = new Intent();\n    intent.setAction(\"listener\");\n    sendBroadcast(intent);\n\n    unregisterReceiver(mBR);\n}\n```\n当然，从理论上来讲这个方案是可行的，实验一下也可以。但有些情况下，发送的广播在消息队列中排的靠后，就有可能服务还没接收到广播就销毁了(这是我对实验结果的猜想，具体执行步骤暂时还不了解)。所以为了能让这个机制完美运行，可以开启两个服务，相互监听，相互启动。服务A监听B的广播来启动B，服务B监听A的广播来启动A。经过实验，这个方案可行，并且用360杀掉后几秒后服务也还是能自启的。到这里再说一句，如果不是某些功能需要的服务，不建议这么做，会降低用户体验。\n\n###### 第三种情况：\n  强制关闭就没有办法。这个好像是从包的level去关的，并不走完整的生命周期。所以在服务里加代码是无法被调用的。处理这个情况的唯一方法是屏蔽掉force stop和uninstall按钮，让其不可用。方法自己去找吧。当然有些手机自带的清理功能就是从这个地方清理的，比如华为的清理。所以第三种情况我也没有什么更好的办法了。\n\n  最后再说一句，别在这上面太折腾，弄成流氓软件就不好了。我就是讨厌一些软件乱发通知，起服务才转而用iPhone的。不过下一代Android好像可以支持用户选择是否开启软件设置的权限了，倒是可以期待一下。\n\n我最后使用的是设置前台服务的方式，基本够用了。不过据说高德本身已经实现了后台定位的功能，据说还和我写的差不多😂。不过通过写这个插件，基本熟悉了 Service 用法的各个细节了。\n\n参考资料：\n\n1. http://www.cnblogs.com/rossoneri/p/4530216.html\n2. http://blog.csdn.net/guolin_blog/article/details/11952435\n3. http://blog.csdn.net/guolin_blog/article/details/9797169\n4. http://www.cnblogs.com/mengdd/archive/2013/03/24/2979944.html\n\n##### Android Intent启动flag\n\n网上一查这个 flag 有 20 多种，而且内容很多，所以先只记录下我在插件中使用的 FLAG_FROM_BACKGROUND ，这个 flag 表示这个Intent来自一个后台操作，而不是用户交互。用到了再继续记录。","html":"<p>这个系列文章是在编写<a href=\"https://github.com/yptech/react-native-yunpeng-amplocation\">react native 高德后台定位插件</a>的安卓部分时，使用到的一些原生安卓知识的记录。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=668472&auto=1&height=66\"></iframe>\n\n<h5 id=\"androidservice\">Android Service</h5>\n\n<p>Service 是我实现后台持续监听定位的主要工具，他是 android 的四大组件之一，它主要用于在后台处理一些耗时的逻辑，或者去执行某些需要长期运行的任务。必要的时候我们甚至可以在程序退出的情况下，让Service在后台继续保持运行状态。Service 的内容很多可以看下面这几篇文章。</p>\n\n<p>在这里主要要讲的是如何让 Service 不被杀死，因为 app 进入后台后，当内存比较紧张时，后台 Service 就有可能被杀死，在下面的文章一中对三种杀死的情况做了讨论。</p>\n\n<ol>\n<li>系统根据资源分配情况杀死服务  </li>\n<li>用户通过settings->Apps->Running->Stop方式杀死服务  </li>\n<li>用户通过settings->Apps->Downloaded->Force Stop方式杀死服务</li>\n</ol>\n\n<h6 id=\"\">第一种情况：</h6>\n\n<p>用户不干预，完全靠系统来控制，办法有很多。比如 <code>onStartCommand()</code> 方法的返回值设为 <code>START_STICKY</code> ，服务就会在资源紧张的时候被杀掉，然后在资源足够的时候再恢复。当然也可设置为前台服务，使其有高的优先级，在资源紧张的时候也不会被杀掉。</p>\n\n<h6 id=\"\">第二种情况：</h6>\n\n<p>  用户干预，主动杀掉运行中的服务。这个过程杀死服务会通过服务的生命周期，也就是会调用 <code>onDestory()</code> 方法，这时候一个方案就是在<code>onDestory()</code> 中发送广播开启自己。这样杀死服务后会立即启动。如下：</p>\n\n<pre><code>@Override\npublic void onCreate() {  \n    // TODO Auto-generated method stub\n    super.onCreate();\n\n    mBR = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            // TODO Auto-generated method stub\n            Intent a = new Intent(ServiceA.this, ServiceA.class);\n            startService(a);\n        }\n    };\n    mIF = new IntentFilter();\n    mIF.addAction(\"listener\");\n    registerReceiver(mBR, mIF);\n}\n\n@Override\npublic void onDestroy() {  \n    // TODO Auto-generated method stub\n    super.onDestroy();\n\n    Intent intent = new Intent();\n    intent.setAction(\"listener\");\n    sendBroadcast(intent);\n\n    unregisterReceiver(mBR);\n}\n</code></pre>\n\n<p>当然，从理论上来讲这个方案是可行的，实验一下也可以。但有些情况下，发送的广播在消息队列中排的靠后，就有可能服务还没接收到广播就销毁了(这是我对实验结果的猜想，具体执行步骤暂时还不了解)。所以为了能让这个机制完美运行，可以开启两个服务，相互监听，相互启动。服务A监听B的广播来启动B，服务B监听A的广播来启动A。经过实验，这个方案可行，并且用360杀掉后几秒后服务也还是能自启的。到这里再说一句，如果不是某些功能需要的服务，不建议这么做，会降低用户体验。</p>\n\n<h6 id=\"\">第三种情况：</h6>\n\n<p>  强制关闭就没有办法。这个好像是从包的level去关的，并不走完整的生命周期。所以在服务里加代码是无法被调用的。处理这个情况的唯一方法是屏蔽掉force stop和uninstall按钮，让其不可用。方法自己去找吧。当然有些手机自带的清理功能就是从这个地方清理的，比如华为的清理。所以第三种情况我也没有什么更好的办法了。</p>\n\n<p>  最后再说一句，别在这上面太折腾，弄成流氓软件就不好了。我就是讨厌一些软件乱发通知，起服务才转而用iPhone的。不过下一代Android好像可以支持用户选择是否开启软件设置的权限了，倒是可以期待一下。</p>\n\n<p>我最后使用的是设置前台服务的方式，基本够用了。不过据说高德本身已经实现了后台定位的功能，据说还和我写的差不多😂。不过通过写这个插件，基本熟悉了 Service 用法的各个细节了。</p>\n\n<p>参考资料：</p>\n\n<ol>\n<li><a href=\"http://www.cnblogs.com/rossoneri/p/4530216.html\">http://www.cnblogs.com/rossoneri/p/4530216.html</a>  </li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/11952435\">http://blog.csdn.net/guolin_blog/article/details/11952435</a>  </li>\n<li><a href=\"http://blog.csdn.net/guolin_blog/article/details/9797169\">http://blog.csdn.net/guolin_blog/article/details/9797169</a>  </li>\n<li><a href=\"http://www.cnblogs.com/mengdd/archive/2013/03/24/2979944.html\">http://www.cnblogs.com/mengdd/archive/2013/03/24/2979944.html</a></li>\n</ol>\n\n<h5 id=\"androidintentflag\">Android Intent启动flag</h5>\n\n<p>网上一查这个 flag 有 20 多种，而且内容很多，所以先只记录下我在插件中使用的 FLAG<em>FROM</em>BACKGROUND ，这个 flag 表示这个Intent来自一个后台操作，而不是用户交互。用到了再继续记录。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1469538467105,"created_by":1,"updated_at":1473918078103,"updated_by":1,"published_at":1469540968037,"published_by":1},{"id":36,"uuid":"5bd403a4-4255-4ca8-9c0f-344e89f98391","title":"关于电商网站订单号","slug":"build-gradle-pei-zhi-wen-jian-xiang-jie","markdown":"在我自主编写的支付系统生成的签名串当中采用的订单号就是自增的账单 id ，好处是在支付宝的异步回调当中操作方便。但是在发布正式版测试时出现了订单号重复的问题，于是我决定修改传递给支付宝的订单号的生成策略。\n\n关于生成电商订单号，我觉得需要考虑：\n\n1. 唯一性（主要是分布式环境中，这部分我不必须满足）\n2. 不暴露信息（自增订单号会暴露网站的经营状况）\n3. 长度适中（32位guid略长，控制在15位左右）\n\n我的方案参考淘宝：\n\n> 时间 + 随机数或业务要素ID\n\n建议结合实际情况，充分利用时间、随机数、商家ID、会员ID、自增ID这些来组合，根据自身运营特点来制定。如果真的对并发要求特别高，在 guid 上做文章也是不错的方案。\n\n更多的业务场景，可以看参考资料三。\n\n参考资料：\n\n1. https://segmentfault.com/q/1010000004104517/a-1020000004119558\n2. http://blog.sina.com.cn/s/blog_47039e010100ho7v.html\n3. http://www.php1.cn/article/8506.html","html":"<p>在我自主编写的支付系统生成的签名串当中采用的订单号就是自增的账单 id ，好处是在支付宝的异步回调当中操作方便。但是在发布正式版测试时出现了订单号重复的问题，于是我决定修改传递给支付宝的订单号的生成策略。</p>\n\n<p>关于生成电商订单号，我觉得需要考虑：</p>\n\n<ol>\n<li>唯一性（主要是分布式环境中，这部分我不必须满足）  </li>\n<li>不暴露信息（自增订单号会暴露网站的经营状况）  </li>\n<li>长度适中（32位guid略长，控制在15位左右）</li>\n</ol>\n\n<p>我的方案参考淘宝：</p>\n\n<blockquote>\n  <p>时间 + 随机数或业务要素ID</p>\n</blockquote>\n\n<p>建议结合实际情况，充分利用时间、随机数、商家ID、会员ID、自增ID这些来组合，根据自身运营特点来制定。如果真的对并发要求特别高，在 guid 上做文章也是不错的方案。</p>\n\n<p>更多的业务场景，可以看参考资料三。</p>\n\n<p>参考资料：</p>\n\n<ol>\n<li><a href=\"https://segmentfault.com/q/1010000004104517/a-1020000004119558\">https://segmentfault.com/q/1010000004104517/a-1020000004119558</a>  </li>\n<li><a href=\"http://blog.sina.com.cn/s/blog_47039e010100ho7v.html\">http://blog.sina.com.cn/s/blog_47039e010100ho7v.html</a>  </li>\n<li><a href=\"http://www.php1.cn/article/8506.html\">http://www.php1.cn/article/8506.html</a></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1469542163724,"created_by":1,"updated_at":1470842942480,"updated_by":1,"published_at":1470842891895,"published_by":1},{"id":37,"uuid":"822a333b-0ec6-4596-b8b3-952731a62b35","title":"react native —— 安卓知识与踩坑篇（三）","slug":"react-native-an-zhuo-zhi-shi-yu-cai-keng-pian-er-2","markdown":"这个系列文章是在编写[react native 高德后台定位插件](https://github.com/yptech/react-native-yunpeng-amplocation)的安卓部分时，使用到的一些原生安卓知识的记录。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=2742998&auto=1&height=66\"></iframe>\n\n下午没事，思考和总结了下 flux 、 redux 相关的东西，爆炸了！还没有想得特别的清楚，先放松一下，把这个系列最后的一些部分写一下！\n\n##### Gradle 简介\n\n一个构建工具，写过 javaWeb 的同学肯定知道另一个构建工具 Apache Maven，两者做的工作基本差不多，就是依赖管理、编译、打包等等工作，当然还有古老的 ant。不过这篇文章不会对这几者进行比较，这里的重点是 Android 和 Gradle。\n\n##### 安装Gradle\n\n在 Android Studio 中新建项目成功后会下载Gradle，貌似这个过程不翻墙也是可以下载，但是访问特别慢，建议翻墙下载。\n\n* Mac上会默认下载到 /Users/<用户名>/.gradle/wrapper/dists 目录\n* Win平台会默认下载到 C:\\Documents and Settings<用户名>.gradle\\wrapper\\dists 目录\n\n你会看到这个目录下有个 gradle-x.xx-all 的文件夹, 如果下载实在太慢，但是又不想翻墙的话，可以自己手动到Gradle官网下载对应的版本，然后将下载的.zip文件(也可以解压)复制到上述的gradle-x.xx-all 文件夹下，不过还是建议让它直接下载的好。\n\n##### 项目下的 gradle 文件\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f7763a9c6rj30aq0nhwhm.jpg)\n\n首先简单介绍下那个， yunpeng_cms_app_scx 是我的 app，其余是这个 app 所依赖的第三方模块。\n\n文件一： yunpeng_cms_app_scx/app/build.gradle\n\n这个文件是app文件夹下这个Module的gradle配置文件，也可以算是整个项目最主要的gradle配置文件。也是我们在编写 react native 应用时会修改的一个文件，当然有 rnpm 很多都是自动的。这个文件一般以 `apply plugin: \"com.android.application\"` 开头，而下面会提到的模块则是一般以 `apply plugin: \"com.android.library\"` 开头，原因也显而易见。\n\n这个文件其他的配置还很多，如 task，java版本信息，android sdk版本信息，签名等 ，但平时用到不多，常用的配置主要还是依赖的配置：\n\n```\ndependencies {\n//    compile project(':react-native-yunpeng-amaplocation')\n    compile project(':react-native-umeng-push')\n    compile project(':react-native-yunpeng-datetime')\n    compile project(':react-native-image-picker')\n    compile project(':react-native-share')\n    compile project(':react-native-linear-gradient')\n    compile project(':react-native-amaplocating')\n    compile project(':react-native-vector-icons')\n    compile project(':react-native-yunpeng-alipay')\n    compile project(':react-native-yyamap')\n    compile fileTree(dir: \"libs\", include: [\"*.jar\"])\n    compile \"com.android.support:appcompat-v7:23.0.1\"\n    compile \"com.facebook.react:react-native:+\"  // From node_modules\n}\n``` \n\n文件二：react-native-yunpeng-datetime/build.gradle\n\n这个就是上面提到的模块的 gradle 配置文件。每一个Module都需要有一个gradle配置文件，语法都是一样，唯一不同的是开头声明的是 apply plugin: 'com.android.library'。\n\n文件三：yunpeng_cms_app_scx/gradle/\n\n这个目录下有个 wrapper 文件夹，里面可以看到有两个文件，我们主要看下 gradle-wrapper.properties 这个文件的内容：\n\n```\n#Thu Dec 18 16:02:24 CST 2014\ndistributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-2.2.1-all.zip\n```\n\n可以看到里面声明了gradle的目录与下载路径以及当前项目使用的gradle版本，这些默认的路径我们一般不会更改的，这个文件里指明的gradle版本不对也是很多导包不成功的原因之一。\n\n文件四：yunpeng_cms_app_scx/build.gradle\n\n这个文件是整个项目的gradle基础配置文件,我们来看看这里面的内容\n\n```\n// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:1.0.0'\n    }\n}\n\nallprojects {\n    repositories {\n        jcenter()\n    }\n}\n```\n\n内容主要包含了两个方面：一个是声明仓库的源，这里可以看到是指明的jcenter(), 之前版本则是mavenCentral(), jcenter可以理解成是一个新的中央远程仓库，兼容maven中心仓库，而且性能更优。另一个是声明了android gradle plugin的版本，android studio 1.0正式版必须要求支持gradle plugin 1.0的版本。不过实际使用中jenter很慢啊，mavenCentral相对来说快一点。\n\n另外就是这里的buildscript和allprojects都定义了repositories，他们的区别是，前者定义的gradle自身需要使用的资源，而后者是项目所需要的资源。\n\n文件五：yunpeng_cms_app_scx/setting.gradle\n\n这是在 react native 编写过程当中另一个需要修改的文件，这个文件是全局的项目配置文件，里面主要声明一些需要加入gradle的module，因此我们往往在添加插件时会要修改这个文件。不过在编写原生模块时要注意，要把模块代码放在android文件夹下，否则rnpm的自动链接是无效的。\n\n##### sqlite\n本来还有一篇 sqlite 的，但是这个网上资料很多，就把写模块过程中的文章记在这供以后回来回顾啦。后面就要回到rn的编写啦。\n\n资料：\n\n1. http://blog.sina.com.cn/s/blog_8191005601019so8.html\n2. http://blog.csdn.net/showdy/article/details/51578138\n3. http://blog.csdn.net/codeeer/article/details/30237597\n4. http://www.cnblogs.com/youxilua/archive/2011/09/18/2180654.html\n\n\n\n\n\n\n\n","html":"<p>这个系列文章是在编写<a href=\"https://github.com/yptech/react-native-yunpeng-amplocation\">react native 高德后台定位插件</a>的安卓部分时，使用到的一些原生安卓知识的记录。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=2742998&auto=1&height=66\"></iframe>\n\n<p>下午没事，思考和总结了下 flux 、 redux 相关的东西，爆炸了！还没有想得特别的清楚，先放松一下，把这个系列最后的一些部分写一下！</p>\n\n<h5 id=\"gradle\">Gradle 简介</h5>\n\n<p>一个构建工具，写过 javaWeb 的同学肯定知道另一个构建工具 Apache Maven，两者做的工作基本差不多，就是依赖管理、编译、打包等等工作，当然还有古老的 ant。不过这篇文章不会对这几者进行比较，这里的重点是 Android 和 Gradle。</p>\n\n<h5 id=\"gradle\">安装Gradle</h5>\n\n<p>在 Android Studio 中新建项目成功后会下载Gradle，貌似这个过程不翻墙也是可以下载，但是访问特别慢，建议翻墙下载。</p>\n\n<ul>\n<li>Mac上会默认下载到 /Users/&lt;用户名>/.gradle/wrapper/dists 目录</li>\n<li>Win平台会默认下载到 C:\\Documents and Settings&lt;用户名>.gradle\\wrapper\\dists 目录</li>\n</ul>\n\n<p>你会看到这个目录下有个 gradle-x.xx-all 的文件夹, 如果下载实在太慢，但是又不想翻墙的话，可以自己手动到Gradle官网下载对应的版本，然后将下载的.zip文件(也可以解压)复制到上述的gradle-x.xx-all 文件夹下，不过还是建议让它直接下载的好。</p>\n\n<h5 id=\"gradle\">项目下的 gradle 文件</h5>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f7763a9c6rj30aq0nhwhm.jpg\" alt=\"\" /></p>\n\n<p>首先简单介绍下那个， yunpeng<em>cms</em>app_scx 是我的 app，其余是这个 app 所依赖的第三方模块。</p>\n\n<p>文件一： yunpeng<em>cms</em>app_scx/app/build.gradle</p>\n\n<p>这个文件是app文件夹下这个Module的gradle配置文件，也可以算是整个项目最主要的gradle配置文件。也是我们在编写 react native 应用时会修改的一个文件，当然有 rnpm 很多都是自动的。这个文件一般以 <code>apply plugin: \"com.android.application\"</code> 开头，而下面会提到的模块则是一般以 <code>apply plugin: \"com.android.library\"</code> 开头，原因也显而易见。</p>\n\n<p>这个文件其他的配置还很多，如 task，java版本信息，android sdk版本信息，签名等 ，但平时用到不多，常用的配置主要还是依赖的配置：</p>\n\n<pre><code>dependencies {  \n//    compile project(':react-native-yunpeng-amaplocation')\n    compile project(':react-native-umeng-push')\n    compile project(':react-native-yunpeng-datetime')\n    compile project(':react-native-image-picker')\n    compile project(':react-native-share')\n    compile project(':react-native-linear-gradient')\n    compile project(':react-native-amaplocating')\n    compile project(':react-native-vector-icons')\n    compile project(':react-native-yunpeng-alipay')\n    compile project(':react-native-yyamap')\n    compile fileTree(dir: \"libs\", include: [\"*.jar\"])\n    compile \"com.android.support:appcompat-v7:23.0.1\"\n    compile \"com.facebook.react:react-native:+\"  // From node_modules\n}\n</code></pre>\n\n<p>文件二：react-native-yunpeng-datetime/build.gradle</p>\n\n<p>这个就是上面提到的模块的 gradle 配置文件。每一个Module都需要有一个gradle配置文件，语法都是一样，唯一不同的是开头声明的是 apply plugin: 'com.android.library'。</p>\n\n<p>文件三：yunpeng<em>cms</em>app_scx/gradle/</p>\n\n<p>这个目录下有个 wrapper 文件夹，里面可以看到有两个文件，我们主要看下 gradle-wrapper.properties 这个文件的内容：</p>\n\n<pre><code>#Thu Dec 18 16:02:24 CST 2014\ndistributionBase=GRADLE_USER_HOME  \ndistributionPath=wrapper/dists  \nzipStoreBase=GRADLE_USER_HOME  \nzipStorePath=wrapper/dists  \ndistributionUrl=https\\://services.gradle.org/distributions/gradle-2.2.1-all.zip  \n</code></pre>\n\n<p>可以看到里面声明了gradle的目录与下载路径以及当前项目使用的gradle版本，这些默认的路径我们一般不会更改的，这个文件里指明的gradle版本不对也是很多导包不成功的原因之一。</p>\n\n<p>文件四：yunpeng<em>cms</em>app_scx/build.gradle</p>\n\n<p>这个文件是整个项目的gradle基础配置文件,我们来看看这里面的内容</p>\n\n<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {  \n    repositories {\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:1.0.0'\n    }\n}\n\nallprojects {  \n    repositories {\n        jcenter()\n    }\n}\n</code></pre>\n\n<p>内容主要包含了两个方面：一个是声明仓库的源，这里可以看到是指明的jcenter(), 之前版本则是mavenCentral(), jcenter可以理解成是一个新的中央远程仓库，兼容maven中心仓库，而且性能更优。另一个是声明了android gradle plugin的版本，android studio 1.0正式版必须要求支持gradle plugin 1.0的版本。不过实际使用中jenter很慢啊，mavenCentral相对来说快一点。</p>\n\n<p>另外就是这里的buildscript和allprojects都定义了repositories，他们的区别是，前者定义的gradle自身需要使用的资源，而后者是项目所需要的资源。</p>\n\n<p>文件五：yunpeng<em>cms</em>app_scx/setting.gradle</p>\n\n<p>这是在 react native 编写过程当中另一个需要修改的文件，这个文件是全局的项目配置文件，里面主要声明一些需要加入gradle的module，因此我们往往在添加插件时会要修改这个文件。不过在编写原生模块时要注意，要把模块代码放在android文件夹下，否则rnpm的自动链接是无效的。</p>\n\n<h5 id=\"sqlite\">sqlite</h5>\n\n<p>本来还有一篇 sqlite 的，但是这个网上资料很多，就把写模块过程中的文章记在这供以后回来回顾啦。后面就要回到rn的编写啦。</p>\n\n<p>资料：</p>\n\n<ol>\n<li><a href=\"http://blog.sina.com.cn/s/blog_8191005601019so8.html\">http://blog.sina.com.cn/s/blog_8191005601019so8.html</a>  </li>\n<li><a href=\"http://blog.csdn.net/showdy/article/details/51578138\">http://blog.csdn.net/showdy/article/details/51578138</a>  </li>\n<li><a href=\"http://blog.csdn.net/codeeer/article/details/30237597\">http://blog.csdn.net/codeeer/article/details/30237597</a>  </li>\n<li><a href=\"http://www.cnblogs.com/youxilua/archive/2011/09/18/2180654.html\">http://www.cnblogs.com/youxilua/archive/2011/09/18/2180654.html</a></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1469611788552,"created_by":1,"updated_at":1473918065899,"updated_by":1,"published_at":1469625294015,"published_by":1},{"id":38,"uuid":"0df4ce60-891a-40bb-a8b3-ac2cfa62da34","title":"flux与设计模式","slug":"yi-ju-hua-she-ji-mo-shi","markdown":"##### 外观模式\n\n包装子系统接口，实现一个可统一调用的高层接口，举例来说：ie只支持attachEvent，而FF和Chrome只支持addEventListener，那么为了兼容性考虑，我们就可以封装一个高层的接口来屏蔽底层接口兼容性的问题。\n\n##### 观察者模式\n\n主要是一主题对多观察者的通信，多个观察者订阅一个主题，然后主题发生某种变化时，调用订阅的回调方法，修改观察者的状态，举例来说，多个求职者订阅了某个猎头，当有新的职位出现时，猎头会调用所有的订阅函数通知订阅的求职者。\n\n##### 中介者\n\n客户之间通信的问题。注意是客户间的通信，这是和观察者模式本质上的区别。\n\n##### flux\nreact 组件本身是一个状态机，state和props决定了组件最终的渲染，也就是中介者模式中的客户，一个组件状态的改变很可能影响到另一个组件，flux 所做的就是首先在改变的组件上触发一个 action ，这个 action 会被 Dispatcher 分发，并得到 store 的响应并触发一个 change 事件，然后所有订阅了这个事件的组件能够根据事件修改自身的状态，不过这里更像是观察者模式。","html":"<h5 id=\"\">外观模式</h5>\n\n<p>包装子系统接口，实现一个可统一调用的高层接口，举例来说：ie只支持attachEvent，而FF和Chrome只支持addEventListener，那么为了兼容性考虑，我们就可以封装一个高层的接口来屏蔽底层接口兼容性的问题。</p>\n\n<h5 id=\"\">观察者模式</h5>\n\n<p>主要是一主题对多观察者的通信，多个观察者订阅一个主题，然后主题发生某种变化时，调用订阅的回调方法，修改观察者的状态，举例来说，多个求职者订阅了某个猎头，当有新的职位出现时，猎头会调用所有的订阅函数通知订阅的求职者。</p>\n\n<h5 id=\"\">中介者</h5>\n\n<p>客户之间通信的问题。注意是客户间的通信，这是和观察者模式本质上的区别。</p>\n\n<h5 id=\"flux\">flux</h5>\n\n<p>react 组件本身是一个状态机，state和props决定了组件最终的渲染，也就是中介者模式中的客户，一个组件状态的改变很可能影响到另一个组件，flux 所做的就是首先在改变的组件上触发一个 action ，这个 action 会被 Dispatcher 分发，并得到 store 的响应并触发一个 change 事件，然后所有订阅了这个事件的组件能够根据事件修改自身的状态，不过这里更像是观察者模式。</p>","image":null,"featured":0,"page":0,"status":"draft","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1469671882667,"created_by":1,"updated_at":1474093289689,"updated_by":1,"published_at":null,"published_by":null},{"id":39,"uuid":"3932a515-76f5-4594-aff1-ff63492da9d3","title":"随笔","slug":"sui-bi","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=30635613&auto=1&height=66\"></iframe>\n\n打完球、吃了点东西、看了部东野圭吾小说改编的电影《麒麟之翼》、洗了个澡还木有弹吉他就已经10点了。\n\n没投几个球，手就酸了，还是要多运动运动啊！不过现在每周能够保持打球，还是有进步的哈！\n\n三天晚饭都是蛋黄粽加酸奶，有点腻了啊，明天老弟来我这玩，可以改善改善伙食了。\n\n东野圭吾小说改编的剧还是一如往常，不到最后不知所以，越到后面则越是让人感慨，到最后更是让人泪目。另外这一部的阵容意外的强大啊，宽叔、gakki、黑木明纱。。。尤其是宽叔，还是一如龙樱中的帅，和《嫌疑人X》中的福山雅治两种风格，都很让人喜欢。🤗\n\n虽然懒得洗衣服，还是洗掉了，因为衣架空出来了，好牵强的理由🤔。\n\n好了，扯到这，大半夜也不弹琴了，滚去看看能不能睡着😪。","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=30635613&auto=1&height=66\"></iframe>\n\n<p>打完球、吃了点东西、看了部东野圭吾小说改编的电影《麒麟之翼》、洗了个澡还木有弹吉他就已经10点了。</p>\n\n<p>没投几个球，手就酸了，还是要多运动运动啊！不过现在每周能够保持打球，还是有进步的哈！</p>\n\n<p>三天晚饭都是蛋黄粽加酸奶，有点腻了啊，明天老弟来我这玩，可以改善改善伙食了。</p>\n\n<p>东野圭吾小说改编的剧还是一如往常，不到最后不知所以，越到后面则越是让人感慨，到最后更是让人泪目。另外这一部的阵容意外的强大啊，宽叔、gakki、黑木明纱。。。尤其是宽叔，还是一如龙樱中的帅，和《嫌疑人X》中的福山雅治两种风格，都很让人喜欢。🤗</p>\n\n<p>虽然懒得洗衣服，还是洗掉了，因为衣架空出来了，好牵强的理由🤔。</p>\n\n<p>好了，扯到这，大半夜也不弹琴了，滚去看看能不能睡着😪。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1469714938923,"created_by":1,"updated_at":1473918044544,"updated_by":1,"published_at":1469715620612,"published_by":1},{"id":40,"uuid":"489ce5b2-00a0-4fd0-a9b8-0028deaa2bf7","title":"致鱼头","slug":"zhi-yutou","markdown":"马上就要开学了，是时候给鱼头一个回复了。事实上这不光是给鱼头的回复，也是给自己大四生活的一个回复，所以这几天思考这个问题都没怎么睡好！\n\n废话不多说，直接上我的决定，然后再解释吧！我的决定包括两部分，首先是我决定接下来的一段时间闭关，不接任何项目不找任何实习；其次是关于闭关结束以后是否留在公司，我把这个决定交给公司还有我两个兄弟，和钱无关，也就是我不会要那5%的股份，如果公司能够在我闭关的这一两个月里让他们能够慢慢产生要留下来的想法，那么毕业前我之后会继续留在公司。毕业后的事我还不能够确定。\n\n接下来是我做出这个决定的原因：第一个部分是个人原因，我的大学三年有两年是在项目中度过的，前端、后端、移动端都有所涉及，但是始终没有一个主要的方向，也没有对于一个方向以专家为目标进行深层次的努力，这是我目前想要改善的东西，也是这次闭关所要做的事。第二部分是公司的原因，作为在公司呆了一年多的老人，看着原来的伙伴一个个离开，确实也有过离开的想法。所以第二个决定是我希望这段时间鱼头你能够想办法解决掉留不住人这个公司目前致命的问题，这个问题绝不是仅是钱的问题，而是从管理、个人发展等各个方面来处理的。不解决这个问题，我即使留下来，公司也不会有比较长远的发展。\n\n以上大致是我的回答！","html":"<p>马上就要开学了，是时候给鱼头一个回复了。事实上这不光是给鱼头的回复，也是给自己大四生活的一个回复，所以这几天思考这个问题都没怎么睡好！</p>\n\n<p>废话不多说，直接上我的决定，然后再解释吧！我的决定包括两部分，首先是我决定接下来的一段时间闭关，不接任何项目不找任何实习；其次是关于闭关结束以后是否留在公司，我把这个决定交给公司还有我两个兄弟，和钱无关，也就是我不会要那5%的股份，如果公司能够在我闭关的这一两个月里让他们能够慢慢产生要留下来的想法，那么毕业前我之后会继续留在公司。毕业后的事我还不能够确定。</p>\n\n<p>接下来是我做出这个决定的原因：第一个部分是个人原因，我的大学三年有两年是在项目中度过的，前端、后端、移动端都有所涉及，但是始终没有一个主要的方向，也没有对于一个方向以专家为目标进行深层次的努力，这是我目前想要改善的东西，也是这次闭关所要做的事。第二部分是公司的原因，作为在公司呆了一年多的老人，看着原来的伙伴一个个离开，确实也有过离开的想法。所以第二个决定是我希望这段时间鱼头你能够想办法解决掉留不住人这个公司目前致命的问题，这个问题绝不是仅是钱的问题，而是从管理、个人发展等各个方面来处理的。不解决这个问题，我即使留下来，公司也不会有比较长远的发展。</p>\n\n<p>以上大致是我的回答！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1470044991675,"created_by":1,"updated_at":1473249380874,"updated_by":1,"published_at":1473246900301,"published_by":1},{"id":41,"uuid":"4df8c76c-4bf5-40d6-85ab-fcabeb3319f4","title":"有生之年系列——卡卡西露脸","slug":"you-sheng-zhi-nian-xi-lie-qia-qia-xi-lu-lian","markdown":"哈哈哈，打球回来看了最新一期的火影，卡卡西终于露脸了，此生无憾啊，必须发一波！顺便预告下，正翻译 MobX.js 中，可能会断更几天。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=531925&auto=1&height=66\"></iframe>\n\n![](https://ws4.sinaimg.cn/large/006bH5BKgw1f7761harpyj31kw0zkwjl.jpg)\n\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f7761xl5icj31kw0zktng.jpg)\n\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f7762a3re3j31kw0zktpq.jpg)","html":"<p>哈哈哈，打球回来看了最新一期的火影，卡卡西终于露脸了，此生无憾啊，必须发一波！顺便预告下，正翻译 MobX.js 中，可能会断更几天。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=531925&auto=1&height=66\"></iframe>\n\n<p><img src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f7761harpyj31kw0zkwjl.jpg\" alt=\"\" /></p>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f7761xl5icj31kw0zktng.jpg\" alt=\"\" /></p>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f7762a3re3j31kw0zktpq.jpg\" alt=\"\" /></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1470222294757,"created_by":1,"updated_at":1473918031970,"updated_by":1,"published_at":1470222651618,"published_by":1},{"id":42,"uuid":"08b55319-bdd4-4f5e-a337-ce03dcf9c01e","title":"十分钟介绍MobX和React（译）","slug":"shi-fen-zhong-jie-shao-mobxhe-react-yi","markdown":"<style>\nhr {\n    border: none;\n    border-top: 1px dotted #999;\n    width: 30%;\n    margin: 10pt auto;\n}\n\n#project_title {\n    font-family: 'Pacifico', cursive;\n    font-size: 60pt;\n    padding-top: 20pt;\n}\n#project_tagline {\n    clear: left;\n    font-family: 'arial';\n    font-size: 18pt;\n    text-align: center;\n    padding-top: 16pt;\n}\n</style>\n<header>\n<a href=\"index.html\" style=\"float:left\">\n<img style=\"width: 120px; padding-right: 20px;\" src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f775zli3msj305k05k3yh.jpg\" id=\"logo\"></a>\n<h1 id=\"project_title\">MobX</h1>\n<h2 id=\"project_tagline\" style=\"font-size: 18pt\">Ten minute introduction to MobX and React</h2>\n<hr>\n</header>\n\nMobX 是一个简单的、可扩展的、经过实战检验的状态管理解决方案。这篇教程将会在十分钟内把 MobX 所有重要的概念教给你。MobX 是一个独立的库，但是大多数人正把他和 React 一起使用，因此本篇教程将关注两者如何一起工作。\n\n##### 核心思想\n\n状态是每个应用的心脏，产生不一致的状态或者状态与持久的本地变量不同步往往是导致应用漏洞多、难以管理最快的影响因素。因此产生了大量状态管理解决方案，这些方案限制你修改状态的方式，例如使状态不可变。但是这引入了新的问题；数据需要被规范化，参照完整性不再能够保证；它也使得像原型这样强大的概念不能够使用。\n\nMobX 通过解决核心问题，使状态管理再次变得简单：它使得应用不可能去产生一个不一致的状态。实现这一策略是简单的：*保证所有可以从应用状态派生的东西，都自动地被派生。*\n\n从概念上讲，MobX 对待你的应用就像对待一张电子表格。\n\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f7760acznkj30mi0geq4d.jpg)\n\n1. 首先，这里有应用状态。对象、数组、基础类型、引用类型的组合组成了你的应用模型。这些值就是你的应用的“数据单元”。\n2. 其次，这还有 *derivations*（推导）。从根本上来讲，任何值能够从你的应用状态上自动地被计算出来。这些被推导出来或者计算出来的值，可以是没有完成的 todos 的数量这类简单的值；也可以是代表你的 todos 的一段可渲染的 HTML 这类复杂的东西。用电子表格程序的术语，它就是你的应用的公式和图表。\n3. *Reactions*（响应）与 *derivations*（推导）类似。主要不同是响应的函数不产生新的值。相反，它会自动地运行来完成一些任务。通常是一些 I/O 相关的任务。它保证 DOM 更新和网络请求的自动触发都在正确的时间进行。\n4. 最后是 *actions*（动作）。 *actions* 是修改状态的唯一途径。MobX 将会确保所有应用状态的变动由 *actions* 产生，并自动地进行推导和响应。同步且没有干扰地。\n\n##### 一个简单的 todo store \n\n有了充足的理论，让我们用一个实际的例子来更全面地解释上面的东西。为了独创性，让我们从一个非常简单的 ToDo store 开始。下面是一个十分直白的 `TodoStore` ，它包邮一个 todos 的集合，还不涉及 MobX 。可以在[JSFiddle](https://jsfiddle.net/mweststrate/wv3yopo0/)或者[原文处](https://mobxjs.github.io/mobx/getting-started.html)运行代码修改代码。\n\n```\nclass TodoStore {\n\ttodos = [];\n\n\tget completedTodosCount() {\n    \treturn this.todos.filter(\n\t\t\ttodo => todo.completed === true\n\t\t).length;\n    }\n\n\treport() {\n\t\tif (this.todos.length === 0)\n\t\t\treturn \"<none>\";\n\t\treturn `Next todo: \"${this.todos[0].task}\". ` + \n\t\t\t`Progress: ${this.completedTodosCount}/${this.todos.length}`; \n\t}\n\n    addTodo(task) {\n\t\tthis.todos.push({ \n\t\t\ttask: task,\n\t\t\tcompleted: false,\n            assignee: null\n\t\t});\n\t}\n}\n\nconst todoStore = new TodoStore();\n```\n\n我们只是创建了一个带有 todo 集合的 `todoStore` 。是时候给 `todoStore` 加入一些对象了。为了确保能够看到改变的效果，我们在每个改变后调用 `todoStore.report` 方法，打印它。注意，这个打印过程总是有意地只输出第一条任务。它使得这个例子有点假，但是正如你下面将要看到的，它很漂亮地展示了 MobX 的追踪的动态性。\n\n```\ntodoStore.addTodo(\"read MobX tutorial\");\nconsole.log(todoStore.report());\n// Next todo: \"read MobX tutorial\". Progress: 0/1\n\ntodoStore.addTodo(\"try MobX\");\nconsole.log(todoStore.report());\n// Next todo: \"read MobX tutorial\". Progress: 0/2\n\ntodoStore.todos[0].completed = true;\nconsole.log(todoStore.report());\n// Next todo: \"read MobX tutorial\". Progress: 1/2\n\ntodoStore.todos[1].task = \"try MobX in own project\";\nconsole.log(todoStore.report());\n// Next todo: \"read MobX tutorial\". Progress: 1/2\n\ntodoStore.todos[0].task = \"grok MobX tutorial\";\nconsole.log(todoStore.report());\n// Next todo: \"grok MobX tutorial\". Progress: 1/2\n```\n\n##### 变成响应式\n\n到目前为止，这些代码还没有什么特殊的。但是如果我们不需要显式地去调用 `report` 方法，而只要声明什么需要在状态改变的时候被调用。这能够将我们从在每个可能会触发报告的地方调用 `report` 方法的则责任中解放出来。我们想要确保最新的报告被打印了，但是我们不想要被组织相关代码而干扰。\n\n幸运的是，这正是 MobX 能够为你做的。完全依据状态自动地执行代码。所以我们的 `report` 函数更新自动地，就像电子表格中的一张图表。为了达到这个目的，`TodoStore` 必须变得可观察，以至于 MobX 能够跟踪所有改变。让我们修改这个类，使它能够做到这一点。\n\n同时，`completedTodosCount` 属性能够被自动地从 todo 列表派生。通过使用 `@observable` 和 `@computed` 装饰器，我们能够在一个对象上引入可观察的属性。\n\n```\nclass ObservableTodoStore {\n\t@observable todos = [];\n    @observable pendingRequests = 0;\n\n    constructor() {\n        mobx.autorun(() => console.log(this.report));\n    }\n\n\t@computed get completedTodosCount() {\n    \treturn this.todos.filter(\n\t\t\ttodo => todo.completed === true\n\t\t).length;\n    }\n\n\t@computed get report() {\n\t\tif (this.todos.length === 0)\n\t\t\treturn \"<none>\";\n\t\treturn `Next todo: \"${this.todos[0].task}\". ` + \n\t\t\t`Progress: ${this.completedTodosCount}/${this.todos.length}`; \n\t}\n\n\taddTodo(task) {\n\t\tthis.todos.push({ \n\t\t\ttask: task,\n\t\t\tcompleted: false,\n\t\t\tassignee: null\n\t\t});\n\t}\n}\n\n\nconst observableTodoStore = new ObservableTodoStore();\n```\n\n就是这样！我们用 `@observable` 标记一些属性，使得 MobX能够知道这些值能够随着时间改变。计算方法用 `@computed` 装饰，来辨认那些可以从状态派生的值。\n\n`pendingRequests` 和 `assignee` 属性目前还未用到，将会在本教程后面部分使用。为了使所有的例子代码简洁，本教程使用 ES6、JSX 和 装饰器。但是不用担心过，所有的装饰器在 MobX中都有对应的 [ES5](https://mobxjs.github.io/mobx/best/syntax.html) 版本。\n\n在构造函数中，我们创建了一个小函数来打印 `report` 函数的返回值，并把它包裹在 `autorun` 函数当中。`autorun` 函数创建了一个只运行一次的响应，在这之后每当在该函数中使用的任何被观察数据改变时，这个响应都会被自动地触发。因为 `report` 函数使用了被观察的 `todos` 属性，他将会在适当的时候打印报告。这在下面的例子中展示，可以在[JSFiddle][原文处](https://mobxjs.github.io/mobx/getting-started.html)运行代码。\n\n```\nobservableTodoStore.addTodo(\"read MobX tutorial\");\n// Next todo: \"read MobX tutorial\". Progress: 0/1\nobservableTodoStore.addTodo(\"try MobX\");\n// Next todo: \"read MobX tutorial\". Progress: 0/2\nobservableTodoStore.todos[0].completed = true;\n// Next todo: \"read MobX tutorial\". Progress: 1/2\nobservableTodoStore.todos[1].task = \"try MobX in own project\";\nobservableTodoStore.todos[0].task = \"grok MobX tutorial\";\n// Next todo: \"grok MobX tutorial\". Progress: 1/2\n```\n\n`report` 函数返回值确实被自动地、同步地打印出来了，并且没有泄露中间值。如果你看日志比较仔细，你肯定看到了第四行没有触发报告的输出。因为 `report` 函数返回值被没有因为重命名的行为而真正的改变，虽然背后的数据变了。在另一方面，改变第一条 todo 的名字，更新了 `report` 函数返回值，因为这个名字在 `report` 函数中被使用。这很漂亮地演示了不仅仅是 `todos` 数组被 `autorun` 函数观察，todo 列表项中的私有属性也可以被观察。\n\n##### 使 React 响应式\n\n好了，到目前为止，我们做了一个无聊的报告响应例子。是时候用十分相似的 store 去构建一个响应式的用户界面了。\n\n##### 未完待续。。。\n","html":"<style>  \nhr {  \n    border: none;\n    border-top: 1px dotted #999;\n    width: 30%;\n    margin: 10pt auto;\n}\n\n#project_title {\n    font-family: 'Pacifico', cursive;\n    font-size: 60pt;\n    padding-top: 20pt;\n}\n#project_tagline {\n    clear: left;\n    font-family: 'arial';\n    font-size: 18pt;\n    text-align: center;\n    padding-top: 16pt;\n}\n</style>  \n\n<header>  \n<a href=\"index.html\" style=\"float:left\">  \n<img style=\"width: 120px; padding-right: 20px;\" src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f775zli3msj305k05k3yh.jpg\" id=\"logo\"></a>  \n<h1 id=\"project_title\">MobX</h1>  \n<h2 id=\"project_tagline\" style=\"font-size: 18pt\">Ten minute introduction to MobX and React</h2>  \n<hr>  \n</header>\n\n<p>MobX 是一个简单的、可扩展的、经过实战检验的状态管理解决方案。这篇教程将会在十分钟内把 MobX 所有重要的概念教给你。MobX 是一个独立的库，但是大多数人正把他和 React 一起使用，因此本篇教程将关注两者如何一起工作。</p>\n\n<h5 id=\"\">核心思想</h5>\n\n<p>状态是每个应用的心脏，产生不一致的状态或者状态与持久的本地变量不同步往往是导致应用漏洞多、难以管理最快的影响因素。因此产生了大量状态管理解决方案，这些方案限制你修改状态的方式，例如使状态不可变。但是这引入了新的问题；数据需要被规范化，参照完整性不再能够保证；它也使得像原型这样强大的概念不能够使用。</p>\n\n<p>MobX 通过解决核心问题，使状态管理再次变得简单：它使得应用不可能去产生一个不一致的状态。实现这一策略是简单的：<em>保证所有可以从应用状态派生的东西，都自动地被派生。</em></p>\n\n<p>从概念上讲，MobX 对待你的应用就像对待一张电子表格。</p>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f7760acznkj30mi0geq4d.jpg\" alt=\"\" /></p>\n\n<ol>\n<li>首先，这里有应用状态。对象、数组、基础类型、引用类型的组合组成了你的应用模型。这些值就是你的应用的“数据单元”。  </li>\n<li>其次，这还有 <em>derivations</em>（推导）。从根本上来讲，任何值能够从你的应用状态上自动地被计算出来。这些被推导出来或者计算出来的值，可以是没有完成的 todos 的数量这类简单的值；也可以是代表你的 todos 的一段可渲染的 HTML 这类复杂的东西。用电子表格程序的术语，它就是你的应用的公式和图表。  </li>\n<li><em>Reactions</em>（响应）与 <em>derivations</em>（推导）类似。主要不同是响应的函数不产生新的值。相反，它会自动地运行来完成一些任务。通常是一些 I/O 相关的任务。它保证 DOM 更新和网络请求的自动触发都在正确的时间进行。  </li>\n<li>最后是 <em>actions</em>（动作）。 <em>actions</em> 是修改状态的唯一途径。MobX 将会确保所有应用状态的变动由 <em>actions</em> 产生，并自动地进行推导和响应。同步且没有干扰地。</li>\n</ol>\n\n<h5 id=\"todostore\">一个简单的 todo store</h5>\n\n<p>有了充足的理论，让我们用一个实际的例子来更全面地解释上面的东西。为了独创性，让我们从一个非常简单的 ToDo store 开始。下面是一个十分直白的 <code>TodoStore</code> ，它包邮一个 todos 的集合，还不涉及 MobX 。可以在<a href=\"https://jsfiddle.net/mweststrate/wv3yopo0/\">JSFiddle</a>或者<a href=\"https://mobxjs.github.io/mobx/getting-started.html\">原文处</a>运行代码修改代码。</p>\n\n<pre><code>class TodoStore {  \n    todos = [];\n\n    get completedTodosCount() {\n        return this.todos.filter(\n            todo =&gt; todo.completed === true\n        ).length;\n    }\n\n    report() {\n        if (this.todos.length === 0)\n            return \"&lt;none&gt;\";\n        return `Next todo: \"${this.todos[0].task}\". ` + \n            `Progress: ${this.completedTodosCount}/${this.todos.length}`; \n    }\n\n    addTodo(task) {\n        this.todos.push({ \n            task: task,\n            completed: false,\n            assignee: null\n        });\n    }\n}\n\nconst todoStore = new TodoStore();  \n</code></pre>\n\n<p>我们只是创建了一个带有 todo 集合的 <code>todoStore</code> 。是时候给 <code>todoStore</code> 加入一些对象了。为了确保能够看到改变的效果，我们在每个改变后调用 <code>todoStore.report</code> 方法，打印它。注意，这个打印过程总是有意地只输出第一条任务。它使得这个例子有点假，但是正如你下面将要看到的，它很漂亮地展示了 MobX 的追踪的动态性。</p>\n\n<pre><code>todoStore.addTodo(\"read MobX tutorial\");  \nconsole.log(todoStore.report());  \n// Next todo: \"read MobX tutorial\". Progress: 0/1\n\ntodoStore.addTodo(\"try MobX\");  \nconsole.log(todoStore.report());  \n// Next todo: \"read MobX tutorial\". Progress: 0/2\n\ntodoStore.todos[0].completed = true;  \nconsole.log(todoStore.report());  \n// Next todo: \"read MobX tutorial\". Progress: 1/2\n\ntodoStore.todos[1].task = \"try MobX in own project\";  \nconsole.log(todoStore.report());  \n// Next todo: \"read MobX tutorial\". Progress: 1/2\n\ntodoStore.todos[0].task = \"grok MobX tutorial\";  \nconsole.log(todoStore.report());  \n// Next todo: \"grok MobX tutorial\". Progress: 1/2\n</code></pre>\n\n<h5 id=\"\">变成响应式</h5>\n\n<p>到目前为止，这些代码还没有什么特殊的。但是如果我们不需要显式地去调用 <code>report</code> 方法，而只要声明什么需要在状态改变的时候被调用。这能够将我们从在每个可能会触发报告的地方调用 <code>report</code> 方法的则责任中解放出来。我们想要确保最新的报告被打印了，但是我们不想要被组织相关代码而干扰。</p>\n\n<p>幸运的是，这正是 MobX 能够为你做的。完全依据状态自动地执行代码。所以我们的 <code>report</code> 函数更新自动地，就像电子表格中的一张图表。为了达到这个目的，<code>TodoStore</code> 必须变得可观察，以至于 MobX 能够跟踪所有改变。让我们修改这个类，使它能够做到这一点。</p>\n\n<p>同时，<code>completedTodosCount</code> 属性能够被自动地从 todo 列表派生。通过使用 <code>@observable</code> 和 <code>@computed</code> 装饰器，我们能够在一个对象上引入可观察的属性。</p>\n\n<pre><code>class ObservableTodoStore {  \n    @observable todos = [];\n    @observable pendingRequests = 0;\n\n    constructor() {\n        mobx.autorun(() =&gt; console.log(this.report));\n    }\n\n    @computed get completedTodosCount() {\n        return this.todos.filter(\n            todo =&gt; todo.completed === true\n        ).length;\n    }\n\n    @computed get report() {\n        if (this.todos.length === 0)\n            return \"&lt;none&gt;\";\n        return `Next todo: \"${this.todos[0].task}\". ` + \n            `Progress: ${this.completedTodosCount}/${this.todos.length}`; \n    }\n\n    addTodo(task) {\n        this.todos.push({ \n            task: task,\n            completed: false,\n            assignee: null\n        });\n    }\n}\n\n\nconst observableTodoStore = new ObservableTodoStore();  \n</code></pre>\n\n<p>就是这样！我们用 <code>@observable</code> 标记一些属性，使得 MobX能够知道这些值能够随着时间改变。计算方法用 <code>@computed</code> 装饰，来辨认那些可以从状态派生的值。</p>\n\n<p><code>pendingRequests</code> 和 <code>assignee</code> 属性目前还未用到，将会在本教程后面部分使用。为了使所有的例子代码简洁，本教程使用 ES6、JSX 和 装饰器。但是不用担心过，所有的装饰器在 MobX中都有对应的 <a href=\"https://mobxjs.github.io/mobx/best/syntax.html\">ES5</a> 版本。</p>\n\n<p>在构造函数中，我们创建了一个小函数来打印 <code>report</code> 函数的返回值，并把它包裹在 <code>autorun</code> 函数当中。<code>autorun</code> 函数创建了一个只运行一次的响应，在这之后每当在该函数中使用的任何被观察数据改变时，这个响应都会被自动地触发。因为 <code>report</code> 函数使用了被观察的 <code>todos</code> 属性，他将会在适当的时候打印报告。这在下面的例子中展示，可以在[JSFiddle]<a href=\"https://mobxjs.github.io/mobx/getting-started.html\">原文处</a>运行代码。</p>\n\n<pre><code>observableTodoStore.addTodo(\"read MobX tutorial\");  \n// Next todo: \"read MobX tutorial\". Progress: 0/1\nobservableTodoStore.addTodo(\"try MobX\");  \n// Next todo: \"read MobX tutorial\". Progress: 0/2\nobservableTodoStore.todos[0].completed = true;  \n// Next todo: \"read MobX tutorial\". Progress: 1/2\nobservableTodoStore.todos[1].task = \"try MobX in own project\";  \nobservableTodoStore.todos[0].task = \"grok MobX tutorial\";  \n// Next todo: \"grok MobX tutorial\". Progress: 1/2\n</code></pre>\n\n<p><code>report</code> 函数返回值确实被自动地、同步地打印出来了，并且没有泄露中间值。如果你看日志比较仔细，你肯定看到了第四行没有触发报告的输出。因为 <code>report</code> 函数返回值被没有因为重命名的行为而真正的改变，虽然背后的数据变了。在另一方面，改变第一条 todo 的名字，更新了 <code>report</code> 函数返回值，因为这个名字在 <code>report</code> 函数中被使用。这很漂亮地演示了不仅仅是 <code>todos</code> 数组被 <code>autorun</code> 函数观察，todo 列表项中的私有属性也可以被观察。</p>\n\n<h5 id=\"react\">使 React 响应式</h5>\n\n<p>好了，到目前为止，我们做了一个无聊的报告响应例子。是时候用十分相似的 store 去构建一个响应式的用户界面了。</p>\n\n<h5 id=\"\">未完待续。。。</h5>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1470231539886,"created_by":1,"updated_at":1475408258900,"updated_by":1,"published_at":1470231894955,"published_by":1},{"id":43,"uuid":"3b2adc01-8ea0-4bc1-85da-adfaaa286f01","title":"网站备案中","slug":"wang-zhan-bei-an-zhong","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=30814948&auto=1&height=66\"></iframe>\n\n刚刚收到阿里云的提醒，为了保证网站能够一直正常的访问，需要备下案，虽然麻烦但是已经提交了备案申请，期间可能会出现无法访问的情况😂，见谅。不过备案成功了就不用带着端口号访问了😀!","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=30814948&auto=1&height=66\"></iframe>\n\n<p>刚刚收到阿里云的提醒，为了保证网站能够一直正常的访问，需要备下案，虽然麻烦但是已经提交了备案申请，期间可能会出现无法访问的情况😂，见谅。不过备案成功了就不用带着端口号访问了😀!</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1470294695518,"created_by":1,"updated_at":1473918018881,"updated_by":1,"published_at":1470294781906,"published_by":1},{"id":44,"uuid":"f50fdad1-3b8c-4f77-8269-68a96d35b7d3","title":"有生之年系列——生日","slug":"you-sheng-zhi-nian-xi-lie-sheng-ri","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=30814948&auto=1&height=66\"></iframe>\n\n虽然生日在周日，但是因为明天要回家，星爷也马上要回家了，所以今天请星爷、兵哥哥还有鸣鸣吃了饭，聚了下，也算是提前过了生日。\n\n很久没有这么过生日了，很高兴，谢谢星爷的蛋糕、军哥哥的GitHub T恤，鸣鸣的全程直播，还有傻奶奶的红包！感谢有你们陪我度过这个生日！便便也不要生气，下次会补回来的，但是你要戒网瘾哇！🤗\n\n马上大四了，将要迎来又一次的离别，但是人生本就是如此一次次的别离而构成的！哈哈，要开心，不要伤感！😅\n\n许愿的时候没多想，就是希望大家都幸福！说出来会不会不灵了🤔！睡了，晚安，世界！\n\n","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=30814948&auto=1&height=66\"></iframe>\n\n<p>虽然生日在周日，但是因为明天要回家，星爷也马上要回家了，所以今天请星爷、兵哥哥还有鸣鸣吃了饭，聚了下，也算是提前过了生日。</p>\n\n<p>很久没有这么过生日了，很高兴，谢谢星爷的蛋糕、军哥哥的GitHub T恤，鸣鸣的全程直播，还有傻奶奶的红包！感谢有你们陪我度过这个生日！便便也不要生气，下次会补回来的，但是你要戒网瘾哇！🤗</p>\n\n<p>马上大四了，将要迎来又一次的离别，但是人生本就是如此一次次的别离而构成的！哈哈，要开心，不要伤感！😅</p>\n\n<p>许愿的时候没多想，就是希望大家都幸福！说出来会不会不灵了🤔！睡了，晚安，世界！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1470404187519,"created_by":1,"updated_at":1473918003425,"updated_by":1,"published_at":1470404914579,"published_by":1},{"id":45,"uuid":"8fa7990c-f296-4073-ad83-577e01c3eaf1","title":"有生之年系列——面试","slug":"you-sheng-zhi-nian-xi-lie-zhi-mian-shi","markdown":"今天参加了人生的第一场面试，没什么经验，没有做什么准备，想展示最真实的自身状态，是伯乐自然会相中。🤗\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=28786397&auto=1&height=66\"></iframe>\n\n首先是一个黑衣的大叔，有点资历的，先是和他简单探讨了一些现在的情况，这一部分还是比较顺利的。然后就开始了做题，第一题是 cookie 和 storage 的区别，这就尴尬了，写了那么多应用，没有 cookie 也活的好好的我自然是答不太好，然后是一些 http 及 dom 的知识，基本也是死伤惨重，因为大部分前端的经验来自于 supersonic 或是 react native。我讲 react native 的场景，他讲前端场景，两个人都有点 get 不到对方的点，所以感觉有些不妙。大叔也意识到这点，然后开始问了一些我比较擅长的部分，js 异步、redux 等，虽然语言组织的一般，但是还是能够讲得比较全面的。\n\n然后换了一个白衣小哥，先让我自我介绍，于是照着简历上的目录介绍了一番。可是这小哥便抓住了期望职位和发展方向问了不少问题，这可能是我多写了点，导致他多想了吧，后面还是把这玩意拿掉吧。然后是我觉得本次面试收获最大的一点，我到底想写什么，面试当场的我有些犹豫，但回去路上包括现在，我认真思考过后，觉得自己会以 react native 、 weex 这类的移动开发为暂时的主要方向，把网收小，专注一点。选择这个方向主要是我看好基于 virtual dom 的这种跨平台的应用开发方式，它必将在之后几年改变整个移动端开发的格局，另外就是自己在这个方面经验和理论都比较丰富，如果今天面的是这方面的职位那结果应该不会是这样了吧。\n\n今天面试的主要失败在于对自己定位不清，选择了一个自己不擅长的职位，说了一些不该说的话，以至于把自己的缺点暴露的太明显，而优势则没有体现出来。\n\n总结一下收获：第一、找准方向，继续努力；第二、面试技巧上要提高，要诱导面试官往自己优势的地方看；第三、对问题的研究要更加深入\n\n小牢骚：🙄最后就是要吐槽这家公司面试太敷衍，没有看过我的博客，没有看过我的开源项目，没有看过一行我写的代码，即使给了我下次的机会，我想我也不会去了吧！另外我并不觉得自己只是学了一些高大上表面的东西，我能够把他们用得很好，处理复杂的业务场景，甚至能在一定基础上创造一些东西，在体验和性能上也绝不会比面试公司的人做出来的东西差。\n","html":"<p>今天参加了人生的第一场面试，没什么经验，没有做什么准备，想展示最真实的自身状态，是伯乐自然会相中。🤗</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=28786397&auto=1&height=66\"></iframe>\n\n<p>首先是一个黑衣的大叔，有点资历的，先是和他简单探讨了一些现在的情况，这一部分还是比较顺利的。然后就开始了做题，第一题是 cookie 和 storage 的区别，这就尴尬了，写了那么多应用，没有 cookie 也活的好好的我自然是答不太好，然后是一些 http 及 dom 的知识，基本也是死伤惨重，因为大部分前端的经验来自于 supersonic 或是 react native。我讲 react native 的场景，他讲前端场景，两个人都有点 get 不到对方的点，所以感觉有些不妙。大叔也意识到这点，然后开始问了一些我比较擅长的部分，js 异步、redux 等，虽然语言组织的一般，但是还是能够讲得比较全面的。</p>\n\n<p>然后换了一个白衣小哥，先让我自我介绍，于是照着简历上的目录介绍了一番。可是这小哥便抓住了期望职位和发展方向问了不少问题，这可能是我多写了点，导致他多想了吧，后面还是把这玩意拿掉吧。然后是我觉得本次面试收获最大的一点，我到底想写什么，面试当场的我有些犹豫，但回去路上包括现在，我认真思考过后，觉得自己会以 react native 、 weex 这类的移动开发为暂时的主要方向，把网收小，专注一点。选择这个方向主要是我看好基于 virtual dom 的这种跨平台的应用开发方式，它必将在之后几年改变整个移动端开发的格局，另外就是自己在这个方面经验和理论都比较丰富，如果今天面的是这方面的职位那结果应该不会是这样了吧。</p>\n\n<p>今天面试的主要失败在于对自己定位不清，选择了一个自己不擅长的职位，说了一些不该说的话，以至于把自己的缺点暴露的太明显，而优势则没有体现出来。</p>\n\n<p>总结一下收获：第一、找准方向，继续努力；第二、面试技巧上要提高，要诱导面试官往自己优势的地方看；第三、对问题的研究要更加深入</p>\n\n<p>小牢骚：🙄最后就是要吐槽这家公司面试太敷衍，没有看过我的博客，没有看过我的开源项目，没有看过一行我写的代码，即使给了我下次的机会，我想我也不会去了吧！另外我并不觉得自己只是学了一些高大上表面的东西，我能够把他们用得很好，处理复杂的业务场景，甚至能在一定基础上创造一些东西，在体验和性能上也绝不会比面试公司的人做出来的东西差。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1470838177557,"created_by":1,"updated_at":1473917993143,"updated_by":1,"published_at":1470840846607,"published_by":1},{"id":46,"uuid":"009b885b-f44e-4942-a915-1757cf8cb480","title":"react native 踩坑实录续集","slug":"react-native-cai-keng-shi-lu-er","markdown":"前面的踩坑实录已经记录比较多了，而且翻过去也比较麻烦，所以新开一篇续集，更加精彩哦！😜\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=442031&auto=1&height=66\"></iframe>\n\n1、 [Android] FormData fails to send data in multipart/form-data（简单来说就是 android 下用 fetch 上传图片时存在问题）\n\n这个问题困扰了我很久，今天在 github 找到了相对满意的答案，[5308](https://github.com/facebook/react-native/issues/5308)。简单来讲就是在使用 FormData 时不需要再设置 header 中的 Content-Type 为 multipart/form-data，因为这是 FormData 会为我们做的事。另外本人在测试中还发现的事去掉 Content-Type 后， base64 格式图片还是无法正确上传的，而直接上传图片是可以的。这部分的原因需要更加深入的而研究！\n\n2、 Android 和 IOS 的 WebView 在处理没有 DOCTYPE 以及其他的 html、body 标签的情况，而只拥有 h1 这类标签时，有着不一样的规则 其中 Android 能够正常解析，IOS 解析异常，建议手动加上 html 文件必要的这些标签，来解决这个问题。\n","html":"<p>前面的踩坑实录已经记录比较多了，而且翻过去也比较麻烦，所以新开一篇续集，更加精彩哦！😜</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=442031&auto=1&height=66\"></iframe>\n\n<p>1、 [Android] FormData fails to send data in multipart/form-data（简单来说就是 android 下用 fetch 上传图片时存在问题）</p>\n\n<p>这个问题困扰了我很久，今天在 github 找到了相对满意的答案，<a href=\"https://github.com/facebook/react-native/issues/5308\">5308</a>。简单来讲就是在使用 FormData 时不需要再设置 header 中的 Content-Type 为 multipart/form-data，因为这是 FormData 会为我们做的事。另外本人在测试中还发现的事去掉 Content-Type 后， base64 格式图片还是无法正确上传的，而直接上传图片是可以的。这部分的原因需要更加深入的而研究！</p>\n\n<p>2、 Android 和 IOS 的 WebView 在处理没有 DOCTYPE 以及其他的 html、body 标签的情况，而只拥有 h1 这类标签时，有着不一样的规则 其中 Android 能够正常解析，IOS 解析异常，建议手动加上 html 文件必要的这些标签，来解决这个问题。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":"","author_id":1,"created_at":1470925501002,"created_by":1,"updated_at":1473917964755,"updated_by":1,"published_at":1470925890042,"published_by":1},{"id":47,"uuid":"5791cb6f-5f21-477f-998d-0bde0859e898","title":"转：Cookie与Session的区别-总结很好的文章","slug":"zhuan-cookieyu-sessionde-qu-bie-zong-jie-hen-hao-de-wen-zhang","markdown":"[猛戳原文](http://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&mid=504090000&idx=3&sn=f57d4f194c902daadd80296d5b8ed001#rd)\n\n虽然写了这么多项目，因为应用的场景有限、应用的并发有限，所以基本使用的都是 Session，今天在百川的公众号上看到这篇文章，觉得总结地很好，转过来给自己给大家补补知识！\n\n##### cookie机制\n\nCookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965 HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。\n\n具体来说cookie机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客户端的cookie支持。cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。\n\n正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。\n\ncookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。\n\n而session机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。而session提供了方便管理全局变量的方式 。\n﻿\nsession是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器。\n\n就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的session机制更安全些，因为它不会任意读取客户存储的信息。\n\n##### session机制\n\nsession机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。\n\n当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。\n\n保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。\n\n经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。\n\nCookie与Session都能够进行会话跟踪，但是完成的原理不太一样。普通状况下二者均能够满足需求，但有时分不能够运用Cookie，有时分不能够运用Session。下面经过比拟阐明二者的特性以及适用的场所。\n\n1、存取方式的不同\n\nCookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。\n\n而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。\n\n2、隐私策略的不同\n\nCookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。\n\n假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。\n\n3、有效期上的不同\n\n使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。\n\n由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。\n\n4、服务器压力的不同\n\nSession是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。\n\n而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。\n\n5、浏览器支持的不同\n\nCookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。\n\n假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。\n\n假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。（IE8下不同窗口Session相干）\n\n6、跨域支持上的不同\n\nCookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。\n\n仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。","html":"<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;mid=504090000&amp;idx=3&amp;sn=f57d4f194c902daadd80296d5b8ed001#rd\">猛戳原文</a></p>\n\n<p>虽然写了这么多项目，因为应用的场景有限、应用的并发有限，所以基本使用的都是 Session，今天在百川的公众号上看到这篇文章，觉得总结地很好，转过来给自己给大家补补知识！</p>\n\n<h5 id=\"cookie\">cookie机制</h5>\n\n<p>Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965 HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。</p>\n\n<p>具体来说cookie机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客户端的cookie支持。cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。</p>\n\n<p>正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。</p>\n\n<p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</p>\n\n<p>而session机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。而session提供了方便管理全局变量的方式 。\n﻿\nsession是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器。</p>\n\n<p>就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的session机制更安全些，因为它不会任意读取客户存储的信息。</p>\n\n<h5 id=\"session\">session机制</h5>\n\n<p>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p>\n\n<p>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。</p>\n\n<p>保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。</p>\n\n<p>经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。</p>\n\n<p>Cookie与Session都能够进行会话跟踪，但是完成的原理不太一样。普通状况下二者均能够满足需求，但有时分不能够运用Cookie，有时分不能够运用Session。下面经过比拟阐明二者的特性以及适用的场所。</p>\n\n<p>1、存取方式的不同</p>\n\n<p>Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。</p>\n\n<p>而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。</p>\n\n<p>2、隐私策略的不同</p>\n\n<p>Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。</p>\n\n<p>假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。</p>\n\n<p>3、有效期上的不同</p>\n\n<p>使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。</p>\n\n<p>由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。</p>\n\n<p>4、服务器压力的不同</p>\n\n<p>Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。</p>\n\n<p>而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。</p>\n\n<p>5、浏览器支持的不同</p>\n\n<p>Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。</p>\n\n<p>假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。</p>\n\n<p>假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。（IE8下不同窗口Session相干）</p>\n\n<p>6、跨域支持上的不同</p>\n\n<p>Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。</p>\n\n<p>仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1471071021724,"created_by":1,"updated_at":1471071706555,"updated_by":1,"published_at":1471071283539,"published_by":1},{"id":48,"uuid":"69cc2b15-2e63-45ce-b878-3c7bdfdd9a55","title":"有生之年系列——护国神翼","slug":"you-sheng-zhi-nian-xi-lie-zhi-hu-guo-shen-yi","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=4209157&auto=1&height=66\"></iframe>\n\n作为一个多年的老 Dotaer，虽然不玩 Dota2 而且也很久没有玩 Dota 这款游戏了，但是还是十分关注本届的 Ti 。看了一早上，我们的护国神翼终于翻盘 3:1 拿下了本届 Ti 的冠军。虽然护国神翼这个名字有些又爱又恨的味道，但是这一刻，他们值得这么叫。\n\n![](https://ws4.sinaimg.cn/large/006bH5BKgw1f775vnmgbqj30dw08pwgf.jpg)\n\n这是一只年轻的队伍，和去年的 CDEC 很像，但是但又很不同，因为我在这支队伍上看到了不凡的创造力，在国内这样的竞技环境下，他们能够保持这样一种创造力实在让人惊讶。于创造力之外，他们又显得十分的稳重，在先失一局的情况下，连下三局，拿下冠军。完全不像是几个比我可能还小的男孩所做的事，但是看到这些真的很高兴，我们的创造力、实力是完全不输给欧美的。\n\n![](https://ws4.sinaimg.cn/large/006bH5BKgw1f775vnlqolj30dw08pq6m.jpg)\n\n当然车长老和 DC 老师以及弹幕们的毒奶也是功不可没，O(∩_∩)O哈哈~尤其是当最后一句，Wings 在拿下一场团战胜利，扭转胜负的时候，DC 老师果断阻止了车长老的毒奶，真是笑死了！那一刻的弹幕就是冷静啊，车长老😂。\n\n再来谈谈 DC，之前看了他和 EHome 的比赛，从 BP 上就能看出这是一只同样具备灵性及韧性的队伍，能够干倒 EG 冲回来确实也令人刮目相看！\n\n最后希望拿到冠军的几个小伙子能够保持这样的一种创造力和团队，在明年给我们带来新的惊喜！\n\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f775vnlt8kj30dw08p0ww.jpg)","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=4209157&auto=1&height=66\"></iframe>\n\n<p>作为一个多年的老 Dotaer，虽然不玩 Dota2 而且也很久没有玩 Dota 这款游戏了，但是还是十分关注本届的 Ti 。看了一早上，我们的护国神翼终于翻盘 3:1 拿下了本届 Ti 的冠军。虽然护国神翼这个名字有些又爱又恨的味道，但是这一刻，他们值得这么叫。</p>\n\n<p><img src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f775vnmgbqj30dw08pwgf.jpg\" alt=\"\" /></p>\n\n<p>这是一只年轻的队伍，和去年的 CDEC 很像，但是但又很不同，因为我在这支队伍上看到了不凡的创造力，在国内这样的竞技环境下，他们能够保持这样一种创造力实在让人惊讶。于创造力之外，他们又显得十分的稳重，在先失一局的情况下，连下三局，拿下冠军。完全不像是几个比我可能还小的男孩所做的事，但是看到这些真的很高兴，我们的创造力、实力是完全不输给欧美的。</p>\n\n<p><img src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f775vnlqolj30dw08pq6m.jpg\" alt=\"\" /></p>\n\n<p>当然车长老和 DC 老师以及弹幕们的毒奶也是功不可没，O(∩_∩)O哈哈~尤其是当最后一句，Wings 在拿下一场团战胜利，扭转胜负的时候，DC 老师果断阻止了车长老的毒奶，真是笑死了！那一刻的弹幕就是冷静啊，车长老😂。</p>\n\n<p>再来谈谈 DC，之前看了他和 EHome 的比赛，从 BP 上就能看出这是一只同样具备灵性及韧性的队伍，能够干倒 EG 冲回来确实也令人刮目相看！</p>\n\n<p>最后希望拿到冠军的几个小伙子能够保持这样的一种创造力和团队，在明年给我们带来新的惊喜！</p>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f775vnlt8kj30dw08p0ww.jpg\" alt=\"\" /></p>","image":"/content/images/2016/08/17185891_1200x1000_0-1.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1471146558750,"created_by":1,"updated_at":1473917908578,"updated_by":1,"published_at":1471147979226,"published_by":1},{"id":49,"uuid":"e0b8e7ae-089d-4506-9d08-696fba564fd0","title":"http 缓存","slug":"http-huan-cun","markdown":"怎么说呢，这块知识说重要但是往往不是我们直接需要做的，因此很容易在实际的项目中所忽略。毕竟像 Last-Modified 以及 Etag 这些缓存的策略大部分的服务器已经帮我们实现了，拿比较熟悉的 Tomcat 来说，Tomcat 自带了 DefaultServlet，用来处理静态资源的缓存问题。但是了解了 http 缓存我们还是能够做更多的事的，比如启用 Cache-Control ，这样静态资源得到的状态码将是 200（from cache）而不是 304，可以减少 http 请求。\n\n讲了了一些废话，那就开始慢慢介绍 http 缓存的一些基础知识！\n![](https://ws4.sinaimg.cn/large/006bH5BKgw1f775tm5vg3j30fe0eojsk.jpg)\n\n##### Pragma 和 Expires\n\n这是 http 1.0 时代，关于缓存的两个用来控制缓存的字段。\n\nPragma 的启用是通过添加如下的信息到 http 文件头部，来禁用客户端缓存该资源，主要是页面资源。\n\n```\n<meta http-equiv=\"Pragma\" content=\"no-cache\">\n```\n\n但是使用时存在一些注意点，首先只有 IE 支持这个 meta 属性，其次是往往需要放到 body 后面[点我点我](https://support.microsoft.com/zh-cn/kb/222064)。总的来说这种客户端定义Pragma的形式基本没起到多少作用。而在响应头部中加入这个字段，反而能够禁用缓存生效。\n\n有了 Pragma 来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对http 1.0 而言，Expires 就是做这件事的首部字段。\n\nExpires 的值对应一个GMT（格林尼治时间），比如“Mon, 22 Jul 2002 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。\n\n在客户端我们同样可以使用meta标签来知会IE（也仅有IE能识别）页面（同样也只对页面有效，对页面上的资源无效）缓存时间：\n\n```\n<meta http-equiv=\"expires\" content=\"mon, 18 apr 2016 14:30:00 GMT\">\n```\n\n如果希望在IE下页面不走缓存，希望每次刷新页面都能发新请求，那么可以把“content”里的值写为“-1”或“0”。\n\n注意的是该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段。如果是在服务端报头返回Expires字段，则在任何浏览器中都能正确设置资源缓存的时间。\n\n另外在优先级上 Pragma 要高于 Expires，并且 Expires 存在的劣势也很明显，就是客户端和服务器时间的不一致可能导致问题。\n\n实践：为了向下兼容 http 1.0 的标准，还是有很多网站会使用这两个字段的，正确的使用姿势也是在服务端向 response header 中设置对应的参数。\n\n##### Cache-Control\n\n针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了 Cache-Control 来定义缓存过期时间，若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准。\n\nCache-Control 是一个通用首部，有很多取值，这里主要介绍几个常用的值，其余的可以查阅 RFC 2616 文档。\n\n>值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age\n>\n各个消息中的指令含义如下：\n>\nPublic指示响应可被任何缓存区缓存。\nPrivate指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。\nno-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~\nno-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。\nmax-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。\nmin-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。\nmax-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。\n\n实践，针对页面资源，主要还是要根据页面的更新速度，如果经常变化则可以不用缓存或者设置一个较短的过期时间。腾讯首页选择的是设置 max-age=60，较短时间的缓存，而百度则是使用 private（简要介绍一下private，首先这是默认值，在地址栏回车或后退键是不会重新请求的，刷新或者第一次访问时才会请求）。而针对静态资源，一般可以设置一个较长的缓存时间，百度设置的是 30 天，部分资源会达到一年，不过在工程化的前端当中静态资源的更新是一个比较常见的场景，这会在之后的文章中有所涉及。\n\n##### Last-Modified 和 Etag\n\n服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。\n\n客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码即可。\n\n至于传递标记起来的最终修改时间的请求报文首部字段一共有两个：\n\n1、 If-Modified-Since: Last-Modified-value\n\n示例为  If-Modified-Since: Thu, 31 Mar 2016 07:07:52 GMT\n该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送304 和响应报头即可。当前各浏览器均是使用的该请求首部来向服务器传递保存的 Last-Modified 值。\n\n2、 If-Unmodified-Since: Last-Modified-value\n\n告诉服务器，若Last-Modified没有匹配上（资源在服务端的最后更新时间改变了），则应当返回412(Precondition Failed) 状态码给客户端。\n\n当遇到下面情况时，If-Unmodified-Since 字段会被忽略：\n\n1. Last-Modified值对上了（资源在服务端没有新的修改）；\n2. 服务端需返回2XX和412之外的状态码；\n3. 传来的指定日期不合法\n\nLast-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。\n\n为了解决上面的这个问题，http 1.1 又提出了Etag。服务器会通过某种算法，给资源计算得出一个唯一标志符（比如md5标志），比起 Last-Modified 更加能够说明文件的变化，在把资源响应给客户端的时候，会在实体首部加上“ETag: 唯一标识符”一起返回给客户端。\n\n> 今天看文章讲到了Etag的劣势，在集群的情况下，对同一个资源，不用服务器给出的Etag不同。这是因为像 Apache 和 IIS，产生Etag的规则依赖于 inode。所以在集群环境下的策略是不用Etag或者配置Etag，比如把 inode 从生成规则中去掉。\n\n客户端会保留该 ETag 字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的ETag跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。\n\n如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。\n\n那么客户端是如何把标记在资源上的 ETag 传去给服务器的呢？请求报文中有两个首部字段可以带上 ETag 值：\n\n1、If-None-Match: ETag-value\n\n示例为  If-None-Match: \"56fcccc8-1699\"\n告诉服务端如果 ETag 没匹配上需要重发资源数据，否则直接回送304 和响应报头即可。\n\n当前各浏览器均是使用的该请求首部来向服务器传递保存的 ETag 值。\n\n2、If-Match: ETag-value\n\n告诉服务器如果没有匹配到ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412(Precondition Failed) 状态码给客户端。否则服务器直接忽略该字段。\n\nIf-Match 的一个应用场景是，客户端走PUT方法向服务端请求上传/更替资源，这时候可以通过 If-Match 传递资源的ETag。\n\n需要注意的是，如果资源是走分布式服务器（比如CDN）存储的情况，需要这些服务器上计算ETag唯一值的算法保持一致，才不会导致明明同一个文件，在服务器A和服务器B上生成的ETag却不一样。\n\nLast-Modified 和 Etag 很好，但是配合上面提到的三个东西一起使用，会有更好的效果，因为对于一些资源，完全可以使用 200（from cache），而不是重新去请求，通过 304 在做，这样可以减少大量的不必要的 http 请求。\n\n##### 不同用户行为的影响\n\n<table>\n<thead>\n<tr>\n<td>用户操作</td>\n<td>Expires/Cache-Control</td>\n<td>Last-Modified/Etag</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>地址栏回车</td>\n<td>有效</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>页面链接跳转</td>\n<td>有效</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>新开窗口</td>\n<td>有效</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>前进、后退</td>\n<td>有效</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>F5/按钮刷新</td>\n<td>无效(BR重置max-age=0)</td>\n<td>有效</td>\n</tr>\n<tr>\n<td>Ctrl+F5刷新</td>\n<td>无效（重置CC=no-cache）</td>\n<td>无效（请求头丢弃该选项）</td>\n</tr>\n</tbody>\n</table>\n\n##### 总结\n\n在服务器为我们实现了 Last-Modified 和 Etag 的基础上，我们需要对自己的静态资源以及页面资源进行缓存的设置。对于静态资源可以设置一个较长时间的缓存，而对于页面的缓存可以根据页面的更新频次进行精确地控制，具体的策略我也需要更多的实践来进行试验。当然写了这么多很多东西还是没有涉及的，有兴趣可以再回去啃啃 http 1.1 的 RFC 文档，虽然看起来一点都不好啃。最后不得不吐槽下 ghost 博客的 markdown 支持太差了！🙄\n\n参考资料：\n\n1、 [浅谈浏览器http的缓存机制](http://www.cnblogs.com/vajoy/p/5341664.html)\n","html":"<p>怎么说呢，这块知识说重要但是往往不是我们直接需要做的，因此很容易在实际的项目中所忽略。毕竟像 Last-Modified 以及 Etag 这些缓存的策略大部分的服务器已经帮我们实现了，拿比较熟悉的 Tomcat 来说，Tomcat 自带了 DefaultServlet，用来处理静态资源的缓存问题。但是了解了 http 缓存我们还是能够做更多的事的，比如启用 Cache-Control ，这样静态资源得到的状态码将是 200（from cache）而不是 304，可以减少 http 请求。</p>\n\n<p>讲了了一些废话，那就开始慢慢介绍 http 缓存的一些基础知识！\n<img src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f775tm5vg3j30fe0eojsk.jpg\" alt=\"\" /></p>\n\n<h5 id=\"pragmaexpires\">Pragma 和 Expires</h5>\n\n<p>这是 http 1.0 时代，关于缓存的两个用来控制缓存的字段。</p>\n\n<p>Pragma 的启用是通过添加如下的信息到 http 文件头部，来禁用客户端缓存该资源，主要是页面资源。</p>\n\n<pre><code>&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt;  \n</code></pre>\n\n<p>但是使用时存在一些注意点，首先只有 IE 支持这个 meta 属性，其次是往往需要放到 body 后面<a href=\"https://support.microsoft.com/zh-cn/kb/222064\">点我点我</a>。总的来说这种客户端定义Pragma的形式基本没起到多少作用。而在响应头部中加入这个字段，反而能够禁用缓存生效。</p>\n\n<p>有了 Pragma 来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对http 1.0 而言，Expires 就是做这件事的首部字段。</p>\n\n<p>Expires 的值对应一个GMT（格林尼治时间），比如“Mon, 22 Jul 2002 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。</p>\n\n<p>在客户端我们同样可以使用meta标签来知会IE（也仅有IE能识别）页面（同样也只对页面有效，对页面上的资源无效）缓存时间：</p>\n\n<pre><code>&lt;meta http-equiv=\"expires\" content=\"mon, 18 apr 2016 14:30:00 GMT\"&gt;  \n</code></pre>\n\n<p>如果希望在IE下页面不走缓存，希望每次刷新页面都能发新请求，那么可以把“content”里的值写为“-1”或“0”。</p>\n\n<p>注意的是该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段。如果是在服务端报头返回Expires字段，则在任何浏览器中都能正确设置资源缓存的时间。</p>\n\n<p>另外在优先级上 Pragma 要高于 Expires，并且 Expires 存在的劣势也很明显，就是客户端和服务器时间的不一致可能导致问题。</p>\n\n<p>实践：为了向下兼容 http 1.0 的标准，还是有很多网站会使用这两个字段的，正确的使用姿势也是在服务端向 response header 中设置对应的参数。</p>\n\n<h5 id=\"cachecontrol\">Cache-Control</h5>\n\n<p>针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了 Cache-Control 来定义缓存过期时间，若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准。</p>\n\n<p>Cache-Control 是一个通用首部，有很多取值，这里主要介绍几个常用的值，其余的可以查阅 RFC 2616 文档。</p>\n\n<blockquote>\n  <p>值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age</p>\n  \n  <p>各个消息中的指令含义如下：</p>\n  \n  <p>Public指示响应可被任何缓存区缓存。 <br />\n  Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。 <br />\n  no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~ <br />\n  no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。 <br />\n  max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。 <br />\n  min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。 <br />\n  max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p>\n</blockquote>\n\n<p>实践，针对页面资源，主要还是要根据页面的更新速度，如果经常变化则可以不用缓存或者设置一个较短的过期时间。腾讯首页选择的是设置 max-age=60，较短时间的缓存，而百度则是使用 private（简要介绍一下private，首先这是默认值，在地址栏回车或后退键是不会重新请求的，刷新或者第一次访问时才会请求）。而针对静态资源，一般可以设置一个较长的缓存时间，百度设置的是 30 天，部分资源会达到一年，不过在工程化的前端当中静态资源的更新是一个比较常见的场景，这会在之后的文章中有所涉及。</p>\n\n<h5 id=\"lastmodifiedetag\">Last-Modified 和 Etag</h5>\n\n<p>服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。</p>\n\n<p>客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码即可。</p>\n\n<p>至于传递标记起来的最终修改时间的请求报文首部字段一共有两个：</p>\n\n<p>1、 If-Modified-Since: Last-Modified-value</p>\n\n<p>示例为  If-Modified-Since: Thu, 31 Mar 2016 07:07:52 GMT\n该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送304 和响应报头即可。当前各浏览器均是使用的该请求首部来向服务器传递保存的 Last-Modified 值。</p>\n\n<p>2、 If-Unmodified-Since: Last-Modified-value</p>\n\n<p>告诉服务器，若Last-Modified没有匹配上（资源在服务端的最后更新时间改变了），则应当返回412(Precondition Failed) 状态码给客户端。</p>\n\n<p>当遇到下面情况时，If-Unmodified-Since 字段会被忽略：</p>\n\n<ol>\n<li>Last-Modified值对上了（资源在服务端没有新的修改）；  </li>\n<li>服务端需返回2XX和412之外的状态码；  </li>\n<li>传来的指定日期不合法</li>\n</ol>\n\n<p>Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。</p>\n\n<p>为了解决上面的这个问题，http 1.1 又提出了Etag。服务器会通过某种算法，给资源计算得出一个唯一标志符（比如md5标志），比起 Last-Modified 更加能够说明文件的变化，在把资源响应给客户端的时候，会在实体首部加上“ETag: 唯一标识符”一起返回给客户端。</p>\n\n<blockquote>\n  <p>今天看文章讲到了Etag的劣势，在集群的情况下，对同一个资源，不用服务器给出的Etag不同。这是因为像 Apache 和 IIS，产生Etag的规则依赖于 inode。所以在集群环境下的策略是不用Etag或者配置Etag，比如把 inode 从生成规则中去掉。</p>\n</blockquote>\n\n<p>客户端会保留该 ETag 字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的ETag跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。</p>\n\n<p>如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p>\n\n<p>那么客户端是如何把标记在资源上的 ETag 传去给服务器的呢？请求报文中有两个首部字段可以带上 ETag 值：</p>\n\n<p>1、If-None-Match: ETag-value</p>\n\n<p>示例为  If-None-Match: \"56fcccc8-1699\"\n告诉服务端如果 ETag 没匹配上需要重发资源数据，否则直接回送304 和响应报头即可。</p>\n\n<p>当前各浏览器均是使用的该请求首部来向服务器传递保存的 ETag 值。</p>\n\n<p>2、If-Match: ETag-value</p>\n\n<p>告诉服务器如果没有匹配到ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412(Precondition Failed) 状态码给客户端。否则服务器直接忽略该字段。</p>\n\n<p>If-Match 的一个应用场景是，客户端走PUT方法向服务端请求上传/更替资源，这时候可以通过 If-Match 传递资源的ETag。</p>\n\n<p>需要注意的是，如果资源是走分布式服务器（比如CDN）存储的情况，需要这些服务器上计算ETag唯一值的算法保持一致，才不会导致明明同一个文件，在服务器A和服务器B上生成的ETag却不一样。</p>\n\n<p>Last-Modified 和 Etag 很好，但是配合上面提到的三个东西一起使用，会有更好的效果，因为对于一些资源，完全可以使用 200（from cache），而不是重新去请求，通过 304 在做，这样可以减少大量的不必要的 http 请求。</p>\n\n<h5 id=\"\">不同用户行为的影响</h5>\n\n<table>  \n<thead>  \n<tr>  \n<td>用户操作</td>  \n<td>Expires/Cache-Control</td>  \n<td>Last-Modified/Etag</td>  \n</tr>  \n</thead>  \n<tbody>  \n<tr>  \n<td>地址栏回车</td>  \n<td>有效</td>  \n<td>有效</td>  \n</tr>  \n<tr>  \n<td>页面链接跳转</td>  \n<td>有效</td>  \n<td>有效</td>  \n</tr>  \n<tr>  \n<td>新开窗口</td>  \n<td>有效</td>  \n<td>有效</td>  \n</tr>  \n<tr>  \n<td>前进、后退</td>  \n<td>有效</td>  \n<td>有效</td>  \n</tr>  \n<tr>  \n<td>F5/按钮刷新</td>  \n<td>无效(BR重置max-age=0)</td>  \n<td>有效</td>  \n</tr>  \n<tr>  \n<td>Ctrl+F5刷新</td>  \n<td>无效（重置CC=no-cache）</td>  \n<td>无效（请求头丢弃该选项）</td>  \n</tr>  \n</tbody>  \n</table>\n\n<h5 id=\"\">总结</h5>\n\n<p>在服务器为我们实现了 Last-Modified 和 Etag 的基础上，我们需要对自己的静态资源以及页面资源进行缓存的设置。对于静态资源可以设置一个较长时间的缓存，而对于页面的缓存可以根据页面的更新频次进行精确地控制，具体的策略我也需要更多的实践来进行试验。当然写了这么多很多东西还是没有涉及的，有兴趣可以再回去啃啃 http 1.1 的 RFC 文档，虽然看起来一点都不好啃。最后不得不吐槽下 ghost 博客的 markdown 支持太差了！🙄</p>\n\n<p>参考资料：</p>\n\n<p>1、 <a href=\"http://www.cnblogs.com/vajoy/p/5341664.html\">浅谈浏览器http的缓存机制</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1471156822874,"created_by":1,"updated_at":1474861624607,"updated_by":1,"published_at":1471164888546,"published_by":1},{"id":50,"uuid":"7b3a5b8f-2231-4013-bed4-c073406dec87","title":"随笔","slug":"shenlun","markdown":"晚上做完客回到家已是 11 点，洗完澡看了这周的火影已经是 12 点，本来想分享点关于今天看的 《css揭秘》一书中的 css 历史及草案制定的内容的，但是感觉还需要看一遍，再找点资料，才能写的好点，所以放到明天。但还是要写点什么的，养成习惯了，毕竟这不仅仅是一个单纯的技术博客，所以扯点别的也无所谓，金色梦乡嘛！！\n\n晚上饭后，爸妈和叔叔阿姨讨论着那些未来的事，大致也就是考研啊、工作啊什么的！听了很多遍了，也烦了，就管自己看新歌声周董队的 pk 了！\n\n对于已经放弃保研的我来说，好像都关系不大了。为什么要放弃保研？我是不是傻！🤔\n\n简单讲讲我的想法吧，首先，我本身对于本科阶段三年的接受的教学是失望的，我所学的只是大多来自自发的学习和实践。这也是目前普通大学的普遍现象，清华北大是否如此我不知道。面对这个现象，我大致可以有两个选择，一是进入更好的学府一探究竟；第二是借助我目前的能力投入更丰富的实践，为这个问题提出申论，甚至和一群志同道合的同学一起为解决这个问题而努力。我选择了后者，因为意义更大！\n\n另外一个原因是，我能够拿到保研名额，一部分功劳是来自于导师发的论文的。在这篇论文与我毫无干系，并不能提现我大学期间所做的事，我不想靠着与我无关的东西保研。我也并不觉得论文、奖项比我参与过的项目、开源的代码要来得有分量。所以可能从我大学期间的方向来看也并不适合读研。\n\n第三点是我的疑问，就是读研与工作，哪一个能够真正地提升我的能力和视野，而不是工作的身价。钱固然重要，但是够了就好，我很知足！我觉得就我目前接受的教育水平来看，读研能够带给我的很有限，当然不包括所有大学的教育！\n\n最后回到第一点申论的话题，这是一个很喜欢的歌手张悬在14年一席的演讲上提到的。她大致讲到，我们这个世代的年轻人，需要找到一个关于自身或者社会问题困惑的申论的方式。我很有感触，但是申论如何提出，如何得到更多人的响应，如何去做实验，拿出一个相对更好的方案，这是我所在思考的！我想借助现有的力量做出这样一个东西，可能是小众的，但是绝对是意义非凡的！帮助我们这个世代的年轻人能够真正团结起来为解决自身的困惑而努力，不碌碌一生！\n\n一点了，就先写到这，熬夜都长痘痘了！😓外链不支持 https，外链暂时就不放了，只放个连接！[一点点——周董](http://music.163.com/#/song?id=418603076)，因为晚上新声音看到周董，所以回来听了它的新专辑，这首挺喜欢😊。","html":"<p>晚上做完客回到家已是 11 点，洗完澡看了这周的火影已经是 12 点，本来想分享点关于今天看的 《css揭秘》一书中的 css 历史及草案制定的内容的，但是感觉还需要看一遍，再找点资料，才能写的好点，所以放到明天。但还是要写点什么的，养成习惯了，毕竟这不仅仅是一个单纯的技术博客，所以扯点别的也无所谓，金色梦乡嘛！！</p>\n\n<p>晚上饭后，爸妈和叔叔阿姨讨论着那些未来的事，大致也就是考研啊、工作啊什么的！听了很多遍了，也烦了，就管自己看新歌声周董队的 pk 了！</p>\n\n<p>对于已经放弃保研的我来说，好像都关系不大了。为什么要放弃保研？我是不是傻！🤔</p>\n\n<p>简单讲讲我的想法吧，首先，我本身对于本科阶段三年的接受的教学是失望的，我所学的只是大多来自自发的学习和实践。这也是目前普通大学的普遍现象，清华北大是否如此我不知道。面对这个现象，我大致可以有两个选择，一是进入更好的学府一探究竟；第二是借助我目前的能力投入更丰富的实践，为这个问题提出申论，甚至和一群志同道合的同学一起为解决这个问题而努力。我选择了后者，因为意义更大！</p>\n\n<p>另外一个原因是，我能够拿到保研名额，一部分功劳是来自于导师发的论文的。在这篇论文与我毫无干系，并不能提现我大学期间所做的事，我不想靠着与我无关的东西保研。我也并不觉得论文、奖项比我参与过的项目、开源的代码要来得有分量。所以可能从我大学期间的方向来看也并不适合读研。</p>\n\n<p>第三点是我的疑问，就是读研与工作，哪一个能够真正地提升我的能力和视野，而不是工作的身价。钱固然重要，但是够了就好，我很知足！我觉得就我目前接受的教育水平来看，读研能够带给我的很有限，当然不包括所有大学的教育！</p>\n\n<p>最后回到第一点申论的话题，这是一个很喜欢的歌手张悬在14年一席的演讲上提到的。她大致讲到，我们这个世代的年轻人，需要找到一个关于自身或者社会问题困惑的申论的方式。我很有感触，但是申论如何提出，如何得到更多人的响应，如何去做实验，拿出一个相对更好的方案，这是我所在思考的！我想借助现有的力量做出这样一个东西，可能是小众的，但是绝对是意义非凡的！帮助我们这个世代的年轻人能够真正团结起来为解决自身的困惑而努力，不碌碌一生！</p>\n\n<p>一点了，就先写到这，熬夜都长痘痘了！😓外链不支持 https，外链暂时就不放了，只放个连接！<a href=\"http://music.163.com/#/song?id=418603076\">一点点——周董</a>，因为晚上新声音看到周董，所以回来听了它的新专辑，这首挺喜欢😊。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1471245064499,"created_by":1,"updated_at":1472318288846,"updated_by":1,"published_at":1472317683444,"published_by":1},{"id":51,"uuid":"31dbfd34-fafb-452f-a108-a2c81e166de7","title":"金色梦乡","slug":"jin-se-meng-xiang","markdown":"备案上交管局也有一周了吧，但是还毫无音讯啊🙄。提交备案时选择的名称是“金色梦乡”，The Beatles 的一首歌，亦是雅人叔的一部电影。当时还没有看雅人叔的这部电影，仅是看了影评，也有另一个选择，小葵演的“编舟记”。\n\n“编舟记”之意是这个博客是我不断成长的小舟，而我的成长之路亦是编舟之路，不断积累的过程。从这层意思上来讲，“编舟记”也不失为一个恰当的题目。但是最终我还是莫名其妙的选择了“金色梦乡”，这个更加温润的题目。今晚看了雅人叔的 10 年的这部代表作，有种感觉，我是选对了啊！\n\n从披头士讲起吧，之前听披头士是高一的时候了吧，Yesterday、Hey Jude，还有那首充满回忆的 Let It Be。记得还学唱过 Yesterday；记得班长唱 hey jude 很好听；记得教室里放着这首歌，然后和同桌调侃着 let it be 好像方言中一句骂人的话，都是回忆啊！不过不记得当时是否听过 Golden Slumbers 这首了，不过 Golden Slumbers 之于片中的几人，就像 let it be 之于我和同桌吧。\n\n不矫情，继续！《Golden Slumbers》选自Beatles 1969年的专辑《Abbey Road》。虽然从时间上来看，《Let It Be》是发表于1970年，但实际上69年的时候 Beatles 已经走向分裂，而《Abbey Road》才是Beatles 真正的告别。 Golden Slumbers 是保罗麦卡特尼创作的，对四人过去岁月的一种诗意的怀念。\n\n而影片中刚好也是四个人，四个人虽然已经分开过上了各自的生活，但是他们的生活通过青柳的这件事再次联系起来。不管他们的现状如何，在这件事中，他们回忆起的过往都是那么的美妙，他们也没有真正的背叛过青柳。加上剧本的戏剧性，我甚至想要设想这是青柳的一个梦，青柳的金色梦乡。梦中的那一切不幸就像是大学毕业后进入社会，遭受到的束缚与挫折；面对这些，朋友家人的回忆在青柳的脑中构建出了以种种力量，帮助他逃离！\n\n这力量告诉他：听好青柳！快逃！不管多么凄惨！总之要逃走！活下去！能活下来是最好的！快逃啊！青柳！\n\n快逃啊！青柳！脑洞大了点，也不符合影片的细节，但是我想要这么解读。不服打我呀！😜\n\n影片感动、温润的地方还很多，就不更多据透露了！而这个博客之于我，绝不仅仅是一个技术博客那么简单，它记录了我美好的点点滴滴，像个梦但是却又那么的真实。另外还有牵强的一点，就是外部的力量，也就是青柳从朋友、家人甚至陌生人身上得到的力量，这是我不想忽略的东西。\n\n😂12点半了，不行了，不写了，关机睡觉！\n\n<embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"http://static.hdslb.com/miniloader.swf\" flashvars=\"aid=2696215&page=1\" pluginspage=\"http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed>\n\n","html":"<p>备案上交管局也有一周了吧，但是还毫无音讯啊🙄。提交备案时选择的名称是“金色梦乡”，The Beatles 的一首歌，亦是雅人叔的一部电影。当时还没有看雅人叔的这部电影，仅是看了影评，也有另一个选择，小葵演的“编舟记”。</p>\n\n<p>“编舟记”之意是这个博客是我不断成长的小舟，而我的成长之路亦是编舟之路，不断积累的过程。从这层意思上来讲，“编舟记”也不失为一个恰当的题目。但是最终我还是莫名其妙的选择了“金色梦乡”，这个更加温润的题目。今晚看了雅人叔的 10 年的这部代表作，有种感觉，我是选对了啊！</p>\n\n<p>从披头士讲起吧，之前听披头士是高一的时候了吧，Yesterday、Hey Jude，还有那首充满回忆的 Let It Be。记得还学唱过 Yesterday；记得班长唱 hey jude 很好听；记得教室里放着这首歌，然后和同桌调侃着 let it be 好像方言中一句骂人的话，都是回忆啊！不过不记得当时是否听过 Golden Slumbers 这首了，不过 Golden Slumbers 之于片中的几人，就像 let it be 之于我和同桌吧。</p>\n\n<p>不矫情，继续！《Golden Slumbers》选自Beatles 1969年的专辑《Abbey Road》。虽然从时间上来看，《Let It Be》是发表于1970年，但实际上69年的时候 Beatles 已经走向分裂，而《Abbey Road》才是Beatles 真正的告别。 Golden Slumbers 是保罗麦卡特尼创作的，对四人过去岁月的一种诗意的怀念。</p>\n\n<p>而影片中刚好也是四个人，四个人虽然已经分开过上了各自的生活，但是他们的生活通过青柳的这件事再次联系起来。不管他们的现状如何，在这件事中，他们回忆起的过往都是那么的美妙，他们也没有真正的背叛过青柳。加上剧本的戏剧性，我甚至想要设想这是青柳的一个梦，青柳的金色梦乡。梦中的那一切不幸就像是大学毕业后进入社会，遭受到的束缚与挫折；面对这些，朋友家人的回忆在青柳的脑中构建出了以种种力量，帮助他逃离！</p>\n\n<p>这力量告诉他：听好青柳！快逃！不管多么凄惨！总之要逃走！活下去！能活下来是最好的！快逃啊！青柳！</p>\n\n<p>快逃啊！青柳！脑洞大了点，也不符合影片的细节，但是我想要这么解读。不服打我呀！😜</p>\n\n<p>影片感动、温润的地方还很多，就不更多据透露了！而这个博客之于我，绝不仅仅是一个技术博客那么简单，它记录了我美好的点点滴滴，像个梦但是却又那么的真实。另外还有牵强的一点，就是外部的力量，也就是青柳从朋友、家人甚至陌生人身上得到的力量，这是我不想忽略的东西。</p>\n\n<p>😂12点半了，不行了，不写了，关机睡觉！</p>\n\n<p><embed height=\"415\" width=\"544\" quality=\"high\" allowfullscreen=\"true\" type=\"application/x-shockwave-flash\" src=\"http://static.hdslb.com/miniloader.swf\" flashvars=\"aid=2696215&amp;page=1\" pluginspage=\"http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\"></embed></p>","image":"/content/images/2016/08/d1160924ab18972b76de0bb1e6cd7b899f510ae0.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1471361067936,"created_by":1,"updated_at":1473917893125,"updated_by":1,"published_at":1471365183323,"published_by":1},{"id":52,"uuid":"05bcaa58-2e47-4f49-9397-a11fe66598bd","title":"git 代码合并：Merge、Rebase的选择","slug":"git-xiao-jie","markdown":"[原文](https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9)\n\n因为原文已经写得很清楚了，所以我就不再写一遍了，仅仅是总结一下。\n\n##### git Merge \n\n- 优势：一个安全的操作，现有的分支不会被更改，可跟踪；\n- 劣势：合并时会引入外来提交，或多或少会污染你的分支历史。\n\n##### git Rebase\n\n- 优势：项目历史会非常整洁；\n- 劣势：安全性和可跟踪性。\n\n##### 应用场景（最佳实践）\n\n什么时候使用 Rebase？（符合黄金法则）\n\n黄金法则：绝不要在公共的分支上使用它。个人总结了一下就是下面几个场景符合黄金法则：\n\n1. 一个人的项目，只有自己提交；\n2. 交互式 Rebase，用于清理本地的提交（原文中有）；\n3. 这个分支只有你在工作（不光是主分支，如果一个特性分支上多人在提交，也不能使用 Rebase）。\n\n除了以上几个场景，我认为都建议用 Merge。另外，扯点其他的，首先就是养成比较好的习惯，上班第一件事 pull；其次，和同事沟通好；另外就是尽量先 fetch，再 merge，而不是直接pull，可控一点。\n\n参考资料：\n\n1. [Git Rebase原理以及黄金准则详解](https://segmentfault.com/a/1190000005937408)\n2. [Git 分支 - 分支的衍合](https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88)","html":"<p><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase%E7%9A%84%E9%80%89%E6%8B%A9\">原文</a></p>\n\n<p>因为原文已经写得很清楚了，所以我就不再写一遍了，仅仅是总结一下。</p>\n\n<h5 id=\"gitmerge\">git Merge</h5>\n\n<ul>\n<li>优势：一个安全的操作，现有的分支不会被更改，可跟踪；</li>\n<li>劣势：合并时会引入外来提交，或多或少会污染你的分支历史。</li>\n</ul>\n\n<h5 id=\"gitrebase\">git Rebase</h5>\n\n<ul>\n<li>优势：项目历史会非常整洁；</li>\n<li>劣势：安全性和可跟踪性。</li>\n</ul>\n\n<h5 id=\"\">应用场景（最佳实践）</h5>\n\n<p>什么时候使用 Rebase？（符合黄金法则）</p>\n\n<p>黄金法则：绝不要在公共的分支上使用它。个人总结了一下就是下面几个场景符合黄金法则：</p>\n\n<ol>\n<li>一个人的项目，只有自己提交；  </li>\n<li>交互式 Rebase，用于清理本地的提交（原文中有）；  </li>\n<li>这个分支只有你在工作（不光是主分支，如果一个特性分支上多人在提交，也不能使用 Rebase）。</li>\n</ol>\n\n<p>除了以上几个场景，我认为都建议用 Merge。另外，扯点其他的，首先就是养成比较好的习惯，上班第一件事 pull；其次，和同事沟通好；另外就是尽量先 fetch，再 merge，而不是直接pull，可控一点。</p>\n\n<p>参考资料：</p>\n\n<ol>\n<li><a href=\"https://segmentfault.com/a/1190000005937408\">Git Rebase原理以及黄金准则详解</a>  </li>\n<li><a href=\"https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88\">Git 分支 - 分支的衍合</a></li>\n</ol>","image":"/content/images/2016/08/1-e-tlWqLwbUd1UmZyC_KbGg.png","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1471421090540,"created_by":1,"updated_at":1471422860787,"updated_by":1,"published_at":1471422860788,"published_by":1},{"id":53,"uuid":"2aa68f9f-c0b4-4742-8778-42d3156bee1d","title":"备案成功😀","slug":"bei-an-cheng-gong-2","markdown":"早上管局终于来了电话，然后问了几个问题，备案成功的短信就收到了！没想到等了半个月，最后就这么敷衍的成功了！以后就直接访问 https://m2mbob.cn 就行了，原来的端口号，我看看配置下 nginx 能不能成功！😎\n\nnginx 配置 https 失败，证书搞了半天居然没用！！！😷 \n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=28784417&auto=1&height=66\"></iframe>","html":"<p>早上管局终于来了电话，然后问了几个问题，备案成功的短信就收到了！没想到等了半个月，最后就这么敷衍的成功了！以后就直接访问 <a href=\"https://m2mbob.cn\">https://m2mbob.cn</a> 就行了，原来的端口号，我看看配置下 nginx 能不能成功！😎</p>\n\n<p>nginx 配置 https 失败，证书搞了半天居然没用！！！😷 </p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=28784417&auto=1&height=66\"></iframe>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1471917700169,"created_by":1,"updated_at":1473917831639,"updated_by":1,"published_at":1471917809949,"published_by":1},{"id":54,"uuid":"92886ad7-43fc-4222-902c-337c02d7a439","title":"升级博客到 HTTP/2 实录——CentOS升级Nginx到最新版","slug":"sheng-ji-bo-ke-dao-http2shi-lu-centossheng-ji-nginxdao-zui-xin-ban","markdown":"最近看 w3c 的文档都快吐了，尤其是视觉格式化模型，但是收获还是很大的，更加深入的理解了很多东西。这部分的东西会在之后总结完放出来的，而这个系列升级博客到 HTTP/2 实录，则是一边熟悉 HTTP 、 HTTPS 、HTTP/2，一边实践的产物，每天会实践一点，更新一点，直到把博客升级到 HTTP/2 为止。对于博客搞这个虽然是有点大材小用了，但是玩玩加上学习还是很不错的。\n\n这是本系列的第一篇，是关于 CentOS 安装和升级 nginx 的，因为 nginx 要到 1.9.0 才支持 HTTP/2 。废话不多讲，开始。\n\n首先，我的服务器是阿里云 CentOS 7，64位的，所以以下内容都是在这个环境下的。打开命令行，执行 `yum install yum-fastestmirror`，这个插件可以帮助我们自动选择最快的 yum 源。\n\n然后执行 `yum install nginx` ，安装 nginx。一般这时候安装的 nginx 版本是 1.6.3 。而且执行 `yum update nginx`，也无法更新。这就无法满足版本大于 1.9.0 的要求。\n\n在查阅了一些资料后，得到的方案是，在 update 之前，需要配置一下 nginx 源。打开命令行执行 `vim /etc/yum.repos.d/nginx.repo`，然后在 vim 中输入以下内容：\n\n```\n#nginx.repo  \n  \n[nginx]  \nname=nginx repo  \nbaseurl=http://nginx.org/packages/centos/7/$basearch/  \ngpgcheck=0  \nenabled=1  \n```\n\n配置完之后，在执行 `yum update nginx` 可以更新 nginx 了。打出 `nginx -v`，可以看到 nginx 已经升级到了 1.10.1 了😁。最后别忘了重启一下 nginx，`service nginx restart`。\n\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f774ek4suvj30m80bp43m.jpg)\n\n至此，我们的 nginx就升级成功了，明天继续升级！！！🤗\n\n参考资料：\n\n1. [CentOS配置Nginx官方的Yum源](http://zhangzifan.com/centos-nginx-yum-source.html)\n2. [CentOS下安装nginx并且升级nginx到最新版](http://www.centoscn.com/nginx/2015/0505/5363.html)\n\n","html":"<p>最近看 w3c 的文档都快吐了，尤其是视觉格式化模型，但是收获还是很大的，更加深入的理解了很多东西。这部分的东西会在之后总结完放出来的，而这个系列升级博客到 HTTP/2 实录，则是一边熟悉 HTTP 、 HTTPS 、HTTP/2，一边实践的产物，每天会实践一点，更新一点，直到把博客升级到 HTTP/2 为止。对于博客搞这个虽然是有点大材小用了，但是玩玩加上学习还是很不错的。</p>\n\n<p>这是本系列的第一篇，是关于 CentOS 安装和升级 nginx 的，因为 nginx 要到 1.9.0 才支持 HTTP/2 。废话不多讲，开始。</p>\n\n<p>首先，我的服务器是阿里云 CentOS 7，64位的，所以以下内容都是在这个环境下的。打开命令行，执行 <code>yum install yum-fastestmirror</code>，这个插件可以帮助我们自动选择最快的 yum 源。</p>\n\n<p>然后执行 <code>yum install nginx</code> ，安装 nginx。一般这时候安装的 nginx 版本是 1.6.3 。而且执行 <code>yum update nginx</code>，也无法更新。这就无法满足版本大于 1.9.0 的要求。</p>\n\n<p>在查阅了一些资料后，得到的方案是，在 update 之前，需要配置一下 nginx 源。打开命令行执行 <code>vim /etc/yum.repos.d/nginx.repo</code>，然后在 vim 中输入以下内容：</p>\n\n<pre><code>#nginx.repo  \n\n[nginx]  \nname=nginx repo  \nbaseurl=http://nginx.org/packages/centos/7/$basearch/  \ngpgcheck=0  \nenabled=1  \n</code></pre>\n\n<p>配置完之后，在执行 <code>yum update nginx</code> 可以更新 nginx 了。打出 <code>nginx -v</code>，可以看到 nginx 已经升级到了 1.10.1 了😁。最后别忘了重启一下 nginx，<code>service nginx restart</code>。</p>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f774ek4suvj30m80bp43m.jpg\" alt=\"\" /></p>\n\n<p>至此，我们的 nginx就升级成功了，明天继续升级！！！🤗</p>\n\n<p>参考资料：</p>\n\n<ol>\n<li><a href=\"http://zhangzifan.com/centos-nginx-yum-source.html\">CentOS配置Nginx官方的Yum源</a>  </li>\n<li><a href=\"http://www.centoscn.com/nginx/2015/0505/5363.html\">CentOS下安装nginx并且升级nginx到最新版</a></li>\n</ol>","image":"/content/images/2016/08/QQ20160824-0-2x.png","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1472050275710,"created_by":1,"updated_at":1472192071553,"updated_by":1,"published_at":1472051608652,"published_by":1},{"id":55,"uuid":"3261c781-f0d4-482d-b8d5-584756c661ae","title":"升级博客到 HTTP/2 实录——Nginx启用Let's Encrypt SSL证书","slug":"sheng-ji-bo-ke-dao-http-2-shi-lu-centossheng-ji-nginxdao-zui-xin-ban","markdown":"这篇本来是昨晚发的，但是由于阿里云的学生服务器太渣了、房间网速又不行，一直卡在 letsencrypt 的安装上。早上起来一试，没想到就这么成功了。\n\n[Let's Encrypt](https://letsencrypt.org/) 是一个免费的 SSL/TLS 证书发行机构，证书有效期为90天，到期前30内可续期, 实现永久免费。\n\nLet's Encrypt SSL 证书的的获取并不是像其他网站一样，在页面上填写资申请证书，而是需要在域名所在的服务器上安装一个客户端(python写的)去获取证书和续期。而像 StartSSL 之前搞了半天，弄下来的证书也没办法用。而这个利用 python 客户端的，只要敲敲命令就可以完成一切，方便多了。\n\n本次安装使用的服务器配置:\nAliyun9.9学生服务器 + CentOS 7 + Nginx 1.10.1\n\n##### 客户端\n\nLet's Encrypt 提供了两种客户端。Certbot 和 官方客户端。前者是官方推荐的，不过我使用的是后者，所以前者就不介绍了，感兴趣的可以看参考资料里的链接。\n\nLet's Encrypt 官方的客户端托管在 github 上，每次运行客户端都会先自动升级，再运行最新的客户端，所以需要安装 git。因为是 python 写的程序，所以需要安装 python。\n\n第一步，安装 python 及 git，已经安装的则跳过；\n\n```\nyum install git python\n```\n\n第二步，下载客户端, 放到某路径下；\n\n```\ngit clone https://github.com/letsencrypt/letsencrypt\n```\n\n第三步，运行一次客户端，自动检查升级，请确保内存足够多，大概要几十兆吧。\n\n```\ncd letsencrypt\n./letsencrypt-auto --help\n```\n\n第四步，验证域名所有权，其原理就是申请人在域名所在的服务器上申请证书，然后 Let's Encrypt 会访问绑定的域名与客户端通信成功即可通过。\n\n这个验证的方法有两种，一种需要停止当前的 web server 服务，让出 80 端口，由客户端内置的 web server 启动与 Let's Encrypt 通信. 另一种不需要停止当前 web server，但需要在域名根目录下创建一个临时目录，并要保证外网通过域名可以访问这个目录。\n\n###### 通过客户端 web server 获取证书\n\n```\n#停止nginx\nsystemctl stop nginx\n \n#获取证书，--standalone 参数：使用内置web server。--email 参数：管理员邮箱，证书到期前会发邮件到此邮箱提醒。-d 参数：要绑定的域名，同一域的不同子域都要输入。\n./letsencrypt-auto certonly --standalone --email xxx@qq.com -d m2mbob.cn -d www.m2mbob.cn\n \n#启动nginx\nsystemctl start nginx\n```\n\n###### 通过临时目录获取证书\n\n```\n#创建临时目录，可能要修改nginx rewrite 规则才能从外网访问\nmkdir -p /usr/share/nginx/html/.well-known/acme-challenge\n \n#--webroot 参数:指定使用临时目录的方式。-w 参数：指定后面-d 域名所在的根目录，如果一次申请多个域的, 可以附加更多 -w...-d... 这段。\n./letsencrypt-auto certonly --webroot --email xxx@qq.com -w /usr/sha\n```\n\n执行此命令后会生成证书，保存在 /etc/letsencrypt/live 中对应的域名目录下面，其实这里面并不是真正的证书文件,而是通过链接的形式链到了 /etc/letsencrypt/archive 中对应的域名目录下。\n\n##### 自动更新\n\n完成以上四步，其实就可以配置 nginx ，完成升级了。但是考虑到证书有效期为90天，每次到期需要在申请证书一波很麻烦，所以在这里我们需要写个脚本来自动更新证书。\n\n```\n#!/bin/sh\n#停止 nginx 服务,使用 --standalone 独立服务器验证需要停止当前 web server.\nsystemctl stop nginx\nif ! /path/to/letsencrypt-auto renew -nvv --standalone > /var/log/letsencrypt/renew.log 2>&1 ; then\n    echo Automated renewal failed:\n    cat /var/log/letsencrypt/renew.log\n    exit 1\nfi\n#启动 nginx\nsystemctl start nginx\n```\n\n然后添加执行权限 \n\n```\nchmod +x letsencrypt-renew.sh\n```\n\n最后一步就是编辑 crontab 配置文件或执行 crontab -e 添加 cron 任务\n\n```\nnano /etc/crontab\n```\n\n我这里设置为每月25号23点59分执行此脚本.\n\n```\n#分 时 日 月 星期 执行用户 执行命令\n 59 23 25 *  *   root    /脚本目录/letsencrypt-renew.sh\n```\n\n保存退出即可。\n\n##### 配置 nginx\n\n```\n#设置非安全连接永久跳转到安全连接\nserver{\n    listen 80;\n    server_name m2mbob.cn www.m2mbob.cn;\n    #告诉浏览器有效期内只准用 https 访问\n    add_header Strict-Transport-Security max-age=15768000;\n    #永久重定向到 https 站点\n    return 301 https://$server_name$request_uri;\n}\nserver {\n    #启用 https，使用 http/2 协议\n    listen 443 ssl http2;\n    server_name m2mbob.cn www.m2mbob.cn;\n    #告诉浏览器当前页面禁止被frame\n    add_header X-Frame-Options DENY;\n    #告诉浏览器不要猜测mime类型\n    add_header X-Content-Type-Options nosniff;\n \n    #证书路径\n    ssl_certificate /etc/letsencrypt/live/m2mbob.cn/fullchain.pem;\n    #私钥路径\n    ssl_certificate_key /etc/letsencrypt/live/m2mbob.cn/privkey.pem;\n    #安全链接可选的加密协议\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    #可选的加密算法,顺序很重要,越靠前的优先级越高.\n    ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-RC4-SHA:!ECDHE-RSA-RC4-SHA:ECDH-ECDSA-RC4-SHA:ECDH-RSA-RC4-SHA:ECDHE-RSA-AES256-SHA:HIGH:!RC4-SHA:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!CBC:!EDH:!kEDH:!PSK:!SRP:!kECDH;\n    #在 SSLv3 或 TLSv1 握手过程一般使用客户端的首选算法,如果启用下面的配置,则会使用服务器端的首选算法.\n    ssl_prefer_server_ciphers on;\n    #储存SSL会话的缓存类型和大小\n    ssl_session_cache shared:SSL:10m;\n    #缓存有效期\n    ssl_session_timeout 60m;\n \n    #省略后面与证书无关的设置\n}\n```\n\n最后效果😬：\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f774d06ggdj30gu064t9e.jpg)\n\n可是[极简图床](http://www.yotuku.cn/)挂了，而且由于提供的图片不是 https 的，所以访问一些页面时，chrome 绿色的认证又木有了。下午换用了微博图床，支持 HTTPS 而且是 chrome 插件，很好用。但是b站和网易云音乐外链的问题还解决不了！😂再看看，再看看！\n\n到这里，博客其实已经成功升级到 HTTP/2 了，但是仅仅是实践，对于 HTTP/2 及 HTTPS 理解还不是那么的深刻，需要找时间在学习学习！😳\n\n参考资料：\n\n1. [CentOS 7 Nginx Let’ s Encrypt SSL 证书安装配置](https://blog.itnmg.net/letsencrypt-ssl/)\n2. [Nginx启用Let’s Encrypt SSL证书](https://www.iwwenbo.com/nginx-lets-encrypt-ssl/)","html":"<p>这篇本来是昨晚发的，但是由于阿里云的学生服务器太渣了、房间网速又不行，一直卡在 letsencrypt 的安装上。早上起来一试，没想到就这么成功了。</p>\n\n<p><a href=\"https://letsencrypt.org/\">Let's Encrypt</a> 是一个免费的 SSL/TLS 证书发行机构，证书有效期为90天，到期前30内可续期, 实现永久免费。</p>\n\n<p>Let's Encrypt SSL 证书的的获取并不是像其他网站一样，在页面上填写资申请证书，而是需要在域名所在的服务器上安装一个客户端(python写的)去获取证书和续期。而像 StartSSL 之前搞了半天，弄下来的证书也没办法用。而这个利用 python 客户端的，只要敲敲命令就可以完成一切，方便多了。</p>\n\n<p>本次安装使用的服务器配置:\nAliyun9.9学生服务器 + CentOS 7 + Nginx 1.10.1</p>\n\n<h5 id=\"\">客户端</h5>\n\n<p>Let's Encrypt 提供了两种客户端。Certbot 和 官方客户端。前者是官方推荐的，不过我使用的是后者，所以前者就不介绍了，感兴趣的可以看参考资料里的链接。</p>\n\n<p>Let's Encrypt 官方的客户端托管在 github 上，每次运行客户端都会先自动升级，再运行最新的客户端，所以需要安装 git。因为是 python 写的程序，所以需要安装 python。</p>\n\n<p>第一步，安装 python 及 git，已经安装的则跳过；</p>\n\n<pre><code>yum install git python  \n</code></pre>\n\n<p>第二步，下载客户端, 放到某路径下；</p>\n\n<pre><code>git clone https://github.com/letsencrypt/letsencrypt  \n</code></pre>\n\n<p>第三步，运行一次客户端，自动检查升级，请确保内存足够多，大概要几十兆吧。</p>\n\n<pre><code>cd letsencrypt  \n./letsencrypt-auto --help\n</code></pre>\n\n<p>第四步，验证域名所有权，其原理就是申请人在域名所在的服务器上申请证书，然后 Let's Encrypt 会访问绑定的域名与客户端通信成功即可通过。</p>\n\n<p>这个验证的方法有两种，一种需要停止当前的 web server 服务，让出 80 端口，由客户端内置的 web server 启动与 Let's Encrypt 通信. 另一种不需要停止当前 web server，但需要在域名根目录下创建一个临时目录，并要保证外网通过域名可以访问这个目录。</p>\n\n<h6 id=\"webserver\">通过客户端 web server 获取证书</h6>\n\n<pre><code>#停止nginx\nsystemctl stop nginx\n\n#获取证书，--standalone 参数：使用内置web server。--email 参数：管理员邮箱，证书到期前会发邮件到此邮箱提醒。-d 参数：要绑定的域名，同一域的不同子域都要输入。\n./letsencrypt-auto certonly --standalone --email xxx@qq.com -d m2mbob.cn -d www.m2mbob.cn\n\n#启动nginx\nsystemctl start nginx  \n</code></pre>\n\n<h6 id=\"\">通过临时目录获取证书</h6>\n\n<pre><code>#创建临时目录，可能要修改nginx rewrite 规则才能从外网访问\nmkdir -p /usr/share/nginx/html/.well-known/acme-challenge\n\n#--webroot 参数:指定使用临时目录的方式。-w 参数：指定后面-d 域名所在的根目录，如果一次申请多个域的, 可以附加更多 -w...-d... 这段。\n./letsencrypt-auto certonly --webroot --email xxx@qq.com -w /usr/sha\n</code></pre>\n\n<p>执行此命令后会生成证书，保存在 /etc/letsencrypt/live 中对应的域名目录下面，其实这里面并不是真正的证书文件,而是通过链接的形式链到了 /etc/letsencrypt/archive 中对应的域名目录下。</p>\n\n<h5 id=\"\">自动更新</h5>\n\n<p>完成以上四步，其实就可以配置 nginx ，完成升级了。但是考虑到证书有效期为90天，每次到期需要在申请证书一波很麻烦，所以在这里我们需要写个脚本来自动更新证书。</p>\n\n<pre><code>#!/bin/sh\n#停止 nginx 服务,使用 --standalone 独立服务器验证需要停止当前 web server.\nsystemctl stop nginx  \nif ! /path/to/letsencrypt-auto renew -nvv --standalone &gt; /var/log/letsencrypt/renew.log 2&gt;&amp;1 ; then  \n    echo Automated renewal failed:\n    cat /var/log/letsencrypt/renew.log\n    exit 1\nfi  \n#启动 nginx\nsystemctl start nginx  \n</code></pre>\n\n<p>然后添加执行权限 </p>\n\n<pre><code>chmod +x letsencrypt-renew.sh  \n</code></pre>\n\n<p>最后一步就是编辑 crontab 配置文件或执行 crontab -e 添加 cron 任务</p>\n\n<pre><code>nano /etc/crontab  \n</code></pre>\n\n<p>我这里设置为每月25号23点59分执行此脚本.</p>\n\n<pre><code>#分 时 日 月 星期 执行用户 执行命令\n 59 23 25 *  *   root    /脚本目录/letsencrypt-renew.sh\n</code></pre>\n\n<p>保存退出即可。</p>\n\n<h5 id=\"nginx\">配置 nginx</h5>\n\n<pre><code>#设置非安全连接永久跳转到安全连接\nserver{  \n    listen 80;\n    server_name m2mbob.cn www.m2mbob.cn;\n    #告诉浏览器有效期内只准用 https 访问\n    add_header Strict-Transport-Security max-age=15768000;\n    #永久重定向到 https 站点\n    return 301 https://$server_name$request_uri;\n}\nserver {  \n    #启用 https，使用 http/2 协议\n    listen 443 ssl http2;\n    server_name m2mbob.cn www.m2mbob.cn;\n    #告诉浏览器当前页面禁止被frame\n    add_header X-Frame-Options DENY;\n    #告诉浏览器不要猜测mime类型\n    add_header X-Content-Type-Options nosniff;\n\n    #证书路径\n    ssl_certificate /etc/letsencrypt/live/m2mbob.cn/fullchain.pem;\n    #私钥路径\n    ssl_certificate_key /etc/letsencrypt/live/m2mbob.cn/privkey.pem;\n    #安全链接可选的加密协议\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    #可选的加密算法,顺序很重要,越靠前的优先级越高.\n    ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-RC4-SHA:!ECDHE-RSA-RC4-SHA:ECDH-ECDSA-RC4-SHA:ECDH-RSA-RC4-SHA:ECDHE-RSA-AES256-SHA:HIGH:!RC4-SHA:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!CBC:!EDH:!kEDH:!PSK:!SRP:!kECDH;\n    #在 SSLv3 或 TLSv1 握手过程一般使用客户端的首选算法,如果启用下面的配置,则会使用服务器端的首选算法.\n    ssl_prefer_server_ciphers on;\n    #储存SSL会话的缓存类型和大小\n    ssl_session_cache shared:SSL:10m;\n    #缓存有效期\n    ssl_session_timeout 60m;\n\n    #省略后面与证书无关的设置\n}\n</code></pre>\n\n<p>最后效果😬：</p>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f774d06ggdj30gu064t9e.jpg\" alt=\"\" /></p>\n\n<p>可是<a href=\"http://www.yotuku.cn/\">极简图床</a>挂了，而且由于提供的图片不是 https 的，所以访问一些页面时，chrome 绿色的认证又木有了。下午换用了微博图床，支持 HTTPS 而且是 chrome 插件，很好用。但是b站和网易云音乐外链的问题还解决不了！😂再看看，再看看！</p>\n\n<p>到这里，博客其实已经成功升级到 HTTP/2 了，但是仅仅是实践，对于 HTTP/2 及 HTTPS 理解还不是那么的深刻，需要找时间在学习学习！😳</p>\n\n<p>参考资料：</p>\n\n<ol>\n<li><a href=\"https://blog.itnmg.net/letsencrypt-ssl/\">CentOS 7 Nginx Let’ s Encrypt SSL 证书安装配置</a>  </li>\n<li><a href=\"https://www.iwwenbo.com/nginx-lets-encrypt-ssl/\">Nginx启用Let’s Encrypt SSL证书</a></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1472175887078,"created_by":1,"updated_at":1472200210647,"updated_by":1,"published_at":1472181171990,"published_by":1},{"id":56,"uuid":"5c03c309-e87f-4fb6-a79c-2d4840a8cb6d","title":"升级博客到 HTTP/2 实录——新版Chrome下滚回HTTP/1.1","slug":"sheng-ji-bo-ke-dao-http-2-shi-lu-chromexia-gun-hui-http1-1bug","markdown":"本以为这个系列就要这么结束，但是当我用 Chrome 查看协议版本时，惊奇地发现还是 HTTP/1.1，这又是怎么回事，然后就开始了一路的踩坑。有几个大牛写着 HTTP/2，实际还不知道自己的还是HTTP/1.1，其他的不知是歪打正着，实现了HTTP/2，但是都没有提到这个问题。于是只能从度娘走向谷歌，才找到了问题所在。\n\n首先明确，只有在新版的 Chrome 下才有这个现象，其次造成这个现象的原因与 openssl 有关。然后我们来看一段英文：\n\n> Users of the Google Chrome web browser are seeing some sites that they previously accessed over HTTP/2 falling back to HTTP/1. This is because of a policy change in the most recent update to Chrome, released in late May, which removes support for NPN, one method for upgrading a connection to HTTP/2.\n\n> The only way Chrome users can continue using HTTP/2 to access these websites is by switching to a different browser. Website administrators can restore HTTP/2 support for Chrome users by upgrading their OpenSSL installation to the recently released 1.0.2 version. Unfortunately, this requires either a major operating system upgrade or using a private build of NGINX.\n\n大致意思就是说 Chrome 在最近的更新中放弃了对 NPN 的支持，如果想要继续在 Chrome上支持 HTTP/2 ，则需要安装最新 1.0.2 版的 OpenSSL，并且用 1.0.2 的 OpenSSL 重新编译 Nginx。\n\n知道问题的所在了，后面找日子再试试了，今天已经搞得身心俱疲了，而且明天还要处理 gitlab 上的一大堆 issue。急着解决问题的同学直接看参考链接哈！！！\n\n参考链接：\n\n1. [Supporting HTTP/2 for Google Chrome Users](https://www.nginx.com/blog/supporting-http2-google-chrome-users/)\n2. [Nginx HTTP2 编译](http://www.tuicool.com/articles/3eeIVfi)","html":"<p>本以为这个系列就要这么结束，但是当我用 Chrome 查看协议版本时，惊奇地发现还是 HTTP/1.1，这又是怎么回事，然后就开始了一路的踩坑。有几个大牛写着 HTTP/2，实际还不知道自己的还是HTTP/1.1，其他的不知是歪打正着，实现了HTTP/2，但是都没有提到这个问题。于是只能从度娘走向谷歌，才找到了问题所在。</p>\n\n<p>首先明确，只有在新版的 Chrome 下才有这个现象，其次造成这个现象的原因与 openssl 有关。然后我们来看一段英文：</p>\n\n<blockquote>\n  <p>Users of the Google Chrome web browser are seeing some sites that they previously accessed over HTTP/2 falling back to HTTP/1. This is because of a policy change in the most recent update to Chrome, released in late May, which removes support for NPN, one method for upgrading a connection to HTTP/2.</p>\n  \n  <p>The only way Chrome users can continue using HTTP/2 to access these websites is by switching to a different browser. Website administrators can restore HTTP/2 support for Chrome users by upgrading their OpenSSL installation to the recently released 1.0.2 version. Unfortunately, this requires either a major operating system upgrade or using a private build of NGINX.</p>\n</blockquote>\n\n<p>大致意思就是说 Chrome 在最近的更新中放弃了对 NPN 的支持，如果想要继续在 Chrome上支持 HTTP/2 ，则需要安装最新 1.0.2 版的 OpenSSL，并且用 1.0.2 的 OpenSSL 重新编译 Nginx。</p>\n\n<p>知道问题的所在了，后面找日子再试试了，今天已经搞得身心俱疲了，而且明天还要处理 gitlab 上的一大堆 issue。急着解决问题的同学直接看参考链接哈！！！</p>\n\n<p>参考链接：</p>\n\n<ol>\n<li><a href=\"https://www.nginx.com/blog/supporting-http2-google-chrome-users/\">Supporting HTTP/2 for Google Chrome Users</a>  </li>\n<li><a href=\"http://www.tuicool.com/articles/3eeIVfi\">Nginx HTTP2 编译</a></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1472229137358,"created_by":1,"updated_at":1472230036207,"updated_by":1,"published_at":1472230018473,"published_by":1},{"id":57,"uuid":"719704a5-6f93-4ea8-9a99-156caf71b95c","title":"转：JS中函数定义和函数表达式的区别","slug":"zhuan-jszhong-han-shu-ding-yi-he-han-shu-biao-da-shi-de-qu-bie","markdown":"Javascript中有2个语法都与function关键字有关，分别是：\n\n> 函数定义：function FunctionName(FormalParameterList) { FunctionBody }\n\n> 函数表达式：function [FunctionName](FormalParameterList) { FunctionBody }\n\n从语法的定义上看，这两者几乎是一模一样的（唯一的区别是函数表达式可以省略函数名称），那么就解释器而言，当遇到这个结构的语句时，判定为函数表达式还是函数定义呢？\n\n就javascript的语法而言，如果一条语句是以function关键字开始，那么这段会被判定为函数定义。而函数定义是不能被立即执行的，这无疑会导致语法的错误（SyntaxError），因此就必须有一个办法，使解析器可以将之识别为函数表达式。\n\n前面已经说到，解析器识别函数定义的条件是以function关键字开始，那么自然，只要在function关键字的前面有任何其他的元素，就会从函数定义转变为函数表达式，以下方法都是可以的，这个大家都知道：\n\n```\n~function() {}();\n\n!function() {}();\n\nvoid function() {}();\n```\n\n但是这几个方法都有一个特点，就是看起来很别扭，所以现在为止，以括号包裹成了比较公认的方案。\n\n回到正题，括号包裹同样有2个方式：(function() {})();和(function(){}());\n\n他们的共通点是：都有括号。而括号在javascript中有2种作用：确立运算优先级，以及分组运算符，从代码上看，显然没有进行数学或逻辑运算，因此我认为这里的括号属于分组运算符。\n\n根据标准，分组运算符的作用是：\n\n> Return the result of evaluating Expression. This may be of type Reference. \n\n返回评估括号中的表达式的结果。结果可能是Reference类型。\n\n抛开像Reference类型这种词汇，这里的一个关键词应当是“ 评估 ”，但是关于分组运算符，又有一个很重要的下文：\n\n> This algorithm does not apply GetValue to the result of evaluating Expression.\n\n这个算法不会对估算的结果使用GetValue。\n\n有很多专用的名词，看起来确实复杂，简而言之，使用括号运算符本身不会让括号中的代码立即执行，只有当括号包含的这个“分组”参与其他运算时，才会执行。因此，(function(){})()这个语句，其实是首先用分组运算符评估了一个函数表达式，随后参与“函数调用”。而(function(){}())这个语句，则是用分组运算符评估了一个函数调用，随后由于语句的结束而被执行。\n\n[原文地址](http://www.zhihu.com/question/20292224)","html":"<p>Javascript中有2个语法都与function关键字有关，分别是：</p>\n\n<blockquote>\n  <p>函数定义：function FunctionName(FormalParameterList) { FunctionBody }</p>\n  \n  <p>函数表达式：function <a href=\"FormalParameterList\">FunctionName</a> { FunctionBody }</p>\n</blockquote>\n\n<p>从语法的定义上看，这两者几乎是一模一样的（唯一的区别是函数表达式可以省略函数名称），那么就解释器而言，当遇到这个结构的语句时，判定为函数表达式还是函数定义呢？</p>\n\n<p>就javascript的语法而言，如果一条语句是以function关键字开始，那么这段会被判定为函数定义。而函数定义是不能被立即执行的，这无疑会导致语法的错误（SyntaxError），因此就必须有一个办法，使解析器可以将之识别为函数表达式。</p>\n\n<p>前面已经说到，解析器识别函数定义的条件是以function关键字开始，那么自然，只要在function关键字的前面有任何其他的元素，就会从函数定义转变为函数表达式，以下方法都是可以的，这个大家都知道：</p>\n\n<pre><code>~function() {}();\n\n!function() {}();\n\nvoid function() {}();  \n</code></pre>\n\n<p>但是这几个方法都有一个特点，就是看起来很别扭，所以现在为止，以括号包裹成了比较公认的方案。</p>\n\n<p>回到正题，括号包裹同样有2个方式：(function() {})();和(function(){}());</p>\n\n<p>他们的共通点是：都有括号。而括号在javascript中有2种作用：确立运算优先级，以及分组运算符，从代码上看，显然没有进行数学或逻辑运算，因此我认为这里的括号属于分组运算符。</p>\n\n<p>根据标准，分组运算符的作用是：</p>\n\n<blockquote>\n  <p>Return the result of evaluating Expression. This may be of type Reference. </p>\n</blockquote>\n\n<p>返回评估括号中的表达式的结果。结果可能是Reference类型。</p>\n\n<p>抛开像Reference类型这种词汇，这里的一个关键词应当是“ 评估 ”，但是关于分组运算符，又有一个很重要的下文：</p>\n\n<blockquote>\n  <p>This algorithm does not apply GetValue to the result of evaluating Expression.</p>\n</blockquote>\n\n<p>这个算法不会对估算的结果使用GetValue。</p>\n\n<p>有很多专用的名词，看起来确实复杂，简而言之，使用括号运算符本身不会让括号中的代码立即执行，只有当括号包含的这个“分组”参与其他运算时，才会执行。因此，(function(){})()这个语句，其实是首先用分组运算符评估了一个函数表达式，随后参与“函数调用”。而(function(){}())这个语句，则是用分组运算符评估了一个函数调用，随后由于语句的结束而被执行。</p>\n\n<p><a href=\"http://www.zhihu.com/question/20292224\">原文地址</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1472875383514,"created_by":1,"updated_at":1472875565217,"updated_by":1,"published_at":1472875537256,"published_by":1},{"id":58,"uuid":"6ea8836d-d787-4574-bdfd-9d217fed6ac7","title":"可执行代码与执行环境","slug":"js-function-context","markdown":"*不行不行，太大了，好难整合。。。还是分开写吧*\n\n这是一个很大的话题，在ECMA262规范（ES5，本文不涉及ES6，因为引入块状作用域后情况会变得更加复杂，下同）的第十章，本文把规范的内容进行了注释，加入了一些个人的理解，不过有点多，写得貌似有点乱！建议在看本文前可以把[汤姆大叔-深入理解JavaScript系列的11-16](http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html)看一下。后面也会针对汤姆大叔这几篇文章的内容结合规范写一些文章的。\n\n#### 可执行代码\n\n首先规范中讲到三种可执行代码类型（三种执行上下文，With和Catch算特例）：\n\n- 全局代码：这种类型的代码是在\"程序\"级处理的。例如加载外部的js文件或者本地`<script></script>`标签内的代码。全局代码不包括任何function体内的代码。\n- eval代码：指提供给 eval 内置函数的源代码文本。eval第二个参数可以指定上下文，但是是非规范的，本文不做讨论。\n- 函数代码：作为函数体被解析的源代码文本，但不包括作为其嵌套函数的函数体被解析的源代码文本。另外需要提的是使用Function构造器创建函数时，最后一个参数将被转换为字符串并作为函数体使用，同样不包括嵌套函数的函数体。\n\n在严格模式下，这些代码将被称为严格全局代码、严格 eval 代码和严格函数代码，相应地处理会有一些差异。不过不是本文的重点，不做太多的展开，可以看前面的文章。\n\n#### 词法环境\n\n简单来讲，词法环境对象（后面在部分执行环境会看到词法环境和变量环境，本质都是词法环境对象）基本可以等同于汤姆大叔[变量对象](http://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html)一文中所讲的变量对象，汤姆大叔已经讲得十分到位了，但是我希望能够把隐藏在变量对象下的知识讲清楚。建议看下面的内容前，先看一下汤姆大叔[变量对象](http://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html)一文，这样能够更好地做对应和理解。\n\n首先，词法环境包括两个内容：环境记录项和可能为空的外部词法环境引用。通常词法环境会与特定的 ECMAScript 代码诸如 FunctionDeclaration、WithStatement 或者 TryStatement 的 Catch 块这样的语法结构相联系，且类似代码每次执行都会有一个新的语法环境被创建出来。\n\n###### 外部词法环境引用\n\n外部词法环境引用比较简单，就先讲了。它就是用来记录词法环境的嵌套关系的，在创建一个新的词法环境时需要指定它的外部词法环境，`GetIdentifierReference`（根据标识符得到引用函数）就会在这条链上一层层找上去，直到全局词法环境，而全局词法环境的外部词法环境是null，所以这里就是终点，有点感觉了吧。这个其实就是作用域链了，本质就是指向外部词法环境的一个指针。\n\n###### 环境记录项\n\n环境记录项包括声明式环境记录项和对象式环境记录项。声明式环境记录项用于定义那些将标识符与语言值直接绑定的 ECMA 脚本语法元素，例如函数声明，变量声明以及 Catch 语句。对象式环境记录项用于定义那些将标识符 与具体对象的属性绑定的 ECMA 脚本元素，例如程序以及 With 表达式。\n\n*简单来说环境记录项就保存了标识符以及标识符对应的引用。*\n\n全局级别（因为全局环境本质上就是全局对象，这也是汤姆大叔博文中一直强调的）和 With 的词法环境拥有的是对象式环境记录项，函数、和 catch 的词法环境拥有的是声明式环境记录项。\n\n我们可以把环境记录项当做一个抽象类，它上面有一些抽象方法，这些方法都是供语言内部使用的，声明式环境记录项和对象式环境记录项分别实现了这些抽象方法，这些方法就是用来处理标识符和引用的关系的，具体实现可以查看文档。\n\n<table>\n<thead>\n<tr><td width=\"30%\">方法</td><td>作用</td></tr>\n</thead>\n<tbody>\n<tr>\n<td>HasBinding(N)</td><td>判断环境记录项是否包含对某个标识符的绑定。如果包含该绑定则返回 true，反之返回 false。其中字符串 N 是标识符文本。</td></tr>\n<tr>\n<td>CreateMutableBinding(N, D)</td><td>\n在环境记录项中创建一个新的可变绑定。其中字符串 N 指定绑定名称。如果可选参数 D 的值为true，则该绑定在后续操作中可以被删除。</td></tr>\n<tr><td>SetMutableBinding(N,V, S)</td><td>在环境记录项中设置一个已经存在的绑定的值。其中字符串 N 指定绑定名称。V 用于指定绑定的值，可以是任何 ECMA 脚本语言的类型。S 是一个布尔类型的标记，当 S 为 true 并且该绑定不允许赋值时，则抛出一个 TypeError 异常。S 用于指定是否为严格模式。</td></tr>\n<tr><td>GetBindingValue(N,S)</td><td>返回环境记录项中一个已经存在的绑定的值。其中字符串 N 指定绑定的名称。S 用于指定是否为严格模式。如果 S 的值为 true 并且该绑定不存在或未初始化，则抛出一个 ReferenceError 异常。</td></tr>\n<tr><td>DeleteBinding(N)</td><td>从环境记录项中删除一个绑定。其中字符串 N 指定绑定的名称。如果 N 指定的绑定存在，将其删除并返回 true。如果绑定存在但无法删除则返回false。如果绑定不存在则返回 true。</td></tr>\n<tr><td>ImplicitThisValue()</td><td>当从该环境记录项的绑定中获取一个函数对象并且调用时，该方法返回该函数对象使用的 this 对象的值。</td></tr>\n</tbody>\n</table>\n\n声明式环境记录项有两个额外方法，用来创建和初始化不可变的绑定，用在定义严格模式下的 arguments 对象，因为严格模式下要求 arguments 是不和形参进行关联的：\n\n<table>\n<thead>\n<tr><td width=\"30%\">方法</td><td>作用</td></tr>\n</thead>\n<tbody><tr><td>CreateImmutableBinding(N)</td><td>在环境记录项中创建一个未初始化的不可变绑定。其中字符串 N 指定绑定名称。</td></tr>\n<tr><td>\nInitializeImmutableBinding(N,V)</td><td>在环境记录项中设置一个已经创建但未初始化的不可变绑定的值。其中字符串 N 指定绑定名称。V 用于指定绑定的值，可以是任何 ECMA 脚本语言的类型。</td></tr></tbody>\n</table>\n\n对象式环境记录项有一个关联的对象，这个对象被称作绑定对象。对象式环境记录项直接将一系列标识符与其绑定对象的属性名称建立一一对应关系。另外它还有一个 provideThis，用来指定 ImplicitThisValue 对象内部方法的 this，With 环境中 provideThis 为 true，在 ImplicitThisValue算法中，便会根据这个值，将返回值设为 With 语句块绑定的对象。\n\n令人发指了，还有三个词法环境的运算方法：\n\nGetIdentifierReference (lex, name, strict)\n\n*作用是根据标识符，在给定的词法环境获取引用。*当调用 GetIdentifierReference 抽象运算时，需要指定一个 词法环境 lex，一个标识符字符串 name 以及一个布尔型标识 strict。lex 的值可以为 null。\n\nNewDeclarativeEnvironment (E)\n\n*作用是创建词法环境E的子声明式词法环境。*当调用 NewDeclarativeEnvironment 抽象运算时，需指定一个 词法环境 E，其值可以为 null。\n\nNewObjectEnvironment (O, E)\n\n*作用是创建词法环境E的子对象式词法环境。*当调用 NewObjectEnvironmentis 抽象运算时，需指定一个对象 O 及一个 词法环境 E（其值可以为 null）。\n\n###### 全局环境\n\n全局环境是全局代码对应的词法环境，它也是全局对象本身。这里我们就可以解决一个很常见的问题，不用 var 声明时为何就变成全局的了。因为在作用域链上找，直到全局环境时，此时的`b=1`已经变成了在全局对象上的属性赋值，而不再是变量了。也就没有变量提升一说，在之前调用就会报错。\n\n#### 执行环境\n\n执行环境也就是通常我们所说的执行上下文。活动的执行上下文组在逻辑上组成一个堆栈。堆栈底部永远都是全局上下文(global context)，而顶部就是当前(活动的)执行上下文。堆栈在EC类型进入和退出上下文的时候被修改（推入或弹出）。\n\n执行环境包含所有用于追踪与其相关的代码的执行进度的状态。共包括三个组件：词法环境、变量环境、this绑定。词法环境和变量环境都是上一部分提到的词法环境对象。当创建一个执行环境时，其词法环境组件和变量环境组件最初是同一个值。在该执行环境相关联的代码的执行过程中，变量环境组件引用永远不变，而词法环境组件引用有可能改变。改变的两个情况就是 With 和 Catch 语句块，为了实现这种改变，所以有了词法环境和变量环境。\n\n#### 建立执行环境\n\n写到这我都快晕了。。。不过进入建立执行环境部分会明朗起来吧！分三种，也就对应最开始讲的三种可执行代码！\n\n###### 全局执行环境\n\n当控制流进入全局代码的执行环境时，执行以下步骤：\n\n1. 将变量环境设置为全局环境；\n2. 将词法环境设置为全局环境；\n3. 将 this 绑定设置为全局对象；\n4. 执行初始化绑定，按下文。\n\n前三步就是把执行环境的三个组件确定，很好理解，初始化绑定比较复杂，并且与 eval 及函数是共用的，因此放在下文。\n\n###### eval \n\n当控制流进入 eval 代码 的执行环境时，执行以下步骤：\n\n1. 如果没有调用环境，或者 eval 代码并非通过[直接调用 eval](http://www.cnblogs.com/_franky/archive/2012/08/18/2645024.html) 函数进行评估的，则\n 1.按描述的初始化全局执行环境的方案，以 eval 代码作为 C 来初始化执行环境。\n2. 否则\n 1. 将 this 绑定设置为当前执行环境下的 this 绑定。\n 2. 将词法环境设置为当前执行环境下的词法环境。\n 3. 将变量环境设置为当前执行环境下的变量环境。\n3. 如果 eval 代码 是 严格模式下的代码 ，则\n 1. 令 strictVarEnv 为以词法环境为参数调用 NewDeclarativeEnvironment 得到的结果。\n 2. 设置词法环境为 strictVarEnv。\n 3. 设置变量环境为 strictVarEnv。\n4. 按下文描述的方案，使用 eval 代码 执行定义绑定初始化步骤。\n\n首先对于严格模式，它的词法环境是独立的，这是严格模式中要求的。而上面步骤中另一个区别是是否直接调用。不过要讲这个东西，又是一篇长文了。简单的来说就是 eval('xxx')这种算是直接调用，(1, eval)('xxx')算是间接调用，具体点开链接。\n\n###### 函数执行环境\n\n当控制流根据一个函数对象 F、调用者提供的 thisArg 以及调用者提供的 argumentList，进入 函数代码 的执行环境时，执行以下步骤：\n\n1. 如果函数代码是严格模式下的代码，设 this 绑定为 thisArg。\n2. 否则如果 thisArg 是 null 或 undefined，则设 this 绑定为 全局对象 。\n3. 否则如果 Type(thisArg) 的结果不为 Object，则设 this 绑定为 ToObject(thisArg)。\n4. 否则设 this 绑定为 thisArg。\n5. 以 F 的 [[Scope]] 内部属性为参数调用 NewDeclarativeEnvironment，并令 localEnv 为调用的结果。\n6. 设词法环境为 localEnv。\n7. 设变量环境为 localEnv。\n8. 令 code 为 F 的 [[Code]] 内部属性的值。\n9. 按下文描述的方案，使用 函数代码 code 和 argumentList 执行定义绑定初始化步骤。\n\n调用者提供的 thisArg，在调用者是引用类型时，就是引用类型的 base；非引用类型时是 null或undefined。非严格模式下es5会把null和undefined自动转化为全局对象，this不是对象就会转为对象。这就是函数this绑定的过程。这部分比起全局和eval来说复杂一些，之后还是老样子，创建设置词法环境，变量环境，初始化绑定。\n\n#### 初始化绑定，放大招了\n\n当进入一个执行环境时，会按以下步骤在变量环境上创建绑定，其中使用到调用者提供的代码设为 code，如果执行的是函数代码，则设 参数列表 为 args：\n\n1. 令 env 是当前运行执行环境的变量环境。\n2. 如果 code 是 eval 代码 ，则令 configurableBindings 为 true，否则令 configurableBindings 为 false。（因此 eval 中的变量是可以 delete 的）\n3. 如果代码是 严格模式下的代码 ，则令 strict 为 true，否则令 strict 为 false。\n4. 如果代码为函数代码，则：（首先绑定的就是参数）\n 1. 令 func 为通过 [[Call]] 内部属性初始化 code 的执行的函数对象。令 names 为 func 的 [[FormalParameters]] 内部属性。\n 2. 令 argCount 为 args 中元素的数量。\n 3. 令 n 为数字类型，其值为 0。\n 4. 按列表顺序遍历 names，对于每一个字符串 argName（这里会把传入的实参对应的形参绑定到变量环境上，严格模式下则不会进行绑定）\n5. 按源码顺序遍历 code，对于每一个 FunctionDeclaration 表达式 f：（其次绑定的是函数声明，这部分还没完全看懂）\n6. 以 arguments 为参数，调用 env 的 HasBinding 具体方法，并令 argumentsAlreadyDeclared 为调用的结果。（针对名字叫arguments的形参或是函数定义？测试了下，名为arguments的形参或者内部函数声明出现时，argumentsAlreadyDeclared会变成 true）\n7. 如果 code 是函数代码，并且 argumentsAlreadyDeclared 为 false，则：（这一部构建arguments对象）\n 1. 以 fn、names、args、env 和 strict 为参数，调用 CreateArgumentsObject 抽象运算函数，并令 argsObj 为调用的结果。\n 2. 如果 strict 为 true，则进行不可变绑定。\n 3. 否则进行可变绑定。\n8. 按源码顺序遍历 code，对于每一个 VariableDeclaration 和VariableDeclarationNoIn 表达式：（最后才是变量声明）\n 1. 令 dn 为 d 中的标识符。\n 2. 以 dn 为参数，调用 env 的 HasBinding 具体方法，并令 varAlreadyDeclared 为调用的结果。\n 3. 如果 varAlreadyDeclared 为 false，则：以 dn 和 configurableBindings 为参数，调用 env 的 CreateMutableBinding 具体方法。以 dn、undefined 和 strict 为参数，调用 env 的 SetMutableBinding 具体方法。\n\n可以看到绑定上下文的顺序是形参、函数声明、arguments对象、变量声明，搞清楚这个流程，那些面试题就都清楚了，不过好像也没有什么卵用。es文档中还有一节讲的是Arguments对象的创建，居然比绑定上下文的创建还要复杂，先跳过了！！\n\n#### 最后扯几句\n\n过了一遍*可执行代码与执行环境*的文档之后，我们来看看那些困扰我们很久的一些js问题。[汤姆大叔-深入理解JavaScript系列的11-16](http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html)分别讲是执行上下文、变量对象、this、作用域链、函数、闭包。从规范的角度再去看汤姆大叔对这些概念的解释，有一种豁然开朗的感觉。当然他没有点到的背后的东西，也可以知晓。\n\n所以还是应该把这些话题用上面的规范再分别讲一遍，等有空吧！\n\n","html":"<p><em>不行不行，太大了，好难整合。。。还是分开写吧</em></p>\n\n<p>这是一个很大的话题，在ECMA262规范（ES5，本文不涉及ES6，因为引入块状作用域后情况会变得更加复杂，下同）的第十章，本文把规范的内容进行了注释，加入了一些个人的理解，不过有点多，写得貌似有点乱！建议在看本文前可以把<a href=\"http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html\">汤姆大叔-深入理解JavaScript系列的11-16</a>看一下。后面也会针对汤姆大叔这几篇文章的内容结合规范写一些文章的。</p>\n\n<h4 id=\"\">可执行代码</h4>\n\n<p>首先规范中讲到三种可执行代码类型（三种执行上下文，With和Catch算特例）：</p>\n\n<ul>\n<li>全局代码：这种类型的代码是在\"程序\"级处理的。例如加载外部的js文件或者本地<code>&lt;script&gt;&lt;/script&gt;</code>标签内的代码。全局代码不包括任何function体内的代码。</li>\n<li>eval代码：指提供给 eval 内置函数的源代码文本。eval第二个参数可以指定上下文，但是是非规范的，本文不做讨论。</li>\n<li>函数代码：作为函数体被解析的源代码文本，但不包括作为其嵌套函数的函数体被解析的源代码文本。另外需要提的是使用Function构造器创建函数时，最后一个参数将被转换为字符串并作为函数体使用，同样不包括嵌套函数的函数体。</li>\n</ul>\n\n<p>在严格模式下，这些代码将被称为严格全局代码、严格 eval 代码和严格函数代码，相应地处理会有一些差异。不过不是本文的重点，不做太多的展开，可以看前面的文章。</p>\n\n<h4 id=\"\">词法环境</h4>\n\n<p>简单来讲，词法环境对象（后面在部分执行环境会看到词法环境和变量环境，本质都是词法环境对象）基本可以等同于汤姆大叔<a href=\"http://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html\">变量对象</a>一文中所讲的变量对象，汤姆大叔已经讲得十分到位了，但是我希望能够把隐藏在变量对象下的知识讲清楚。建议看下面的内容前，先看一下汤姆大叔<a href=\"http://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html\">变量对象</a>一文，这样能够更好地做对应和理解。</p>\n\n<p>首先，词法环境包括两个内容：环境记录项和可能为空的外部词法环境引用。通常词法环境会与特定的 ECMAScript 代码诸如 FunctionDeclaration、WithStatement 或者 TryStatement 的 Catch 块这样的语法结构相联系，且类似代码每次执行都会有一个新的语法环境被创建出来。</p>\n\n<h6 id=\"\">外部词法环境引用</h6>\n\n<p>外部词法环境引用比较简单，就先讲了。它就是用来记录词法环境的嵌套关系的，在创建一个新的词法环境时需要指定它的外部词法环境，<code>GetIdentifierReference</code>（根据标识符得到引用函数）就会在这条链上一层层找上去，直到全局词法环境，而全局词法环境的外部词法环境是null，所以这里就是终点，有点感觉了吧。这个其实就是作用域链了，本质就是指向外部词法环境的一个指针。</p>\n\n<h6 id=\"\">环境记录项</h6>\n\n<p>环境记录项包括声明式环境记录项和对象式环境记录项。声明式环境记录项用于定义那些将标识符与语言值直接绑定的 ECMA 脚本语法元素，例如函数声明，变量声明以及 Catch 语句。对象式环境记录项用于定义那些将标识符 与具体对象的属性绑定的 ECMA 脚本元素，例如程序以及 With 表达式。</p>\n\n<p><em>简单来说环境记录项就保存了标识符以及标识符对应的引用。</em></p>\n\n<p>全局级别（因为全局环境本质上就是全局对象，这也是汤姆大叔博文中一直强调的）和 With 的词法环境拥有的是对象式环境记录项，函数、和 catch 的词法环境拥有的是声明式环境记录项。</p>\n\n<p>我们可以把环境记录项当做一个抽象类，它上面有一些抽象方法，这些方法都是供语言内部使用的，声明式环境记录项和对象式环境记录项分别实现了这些抽象方法，这些方法就是用来处理标识符和引用的关系的，具体实现可以查看文档。</p>\n\n<table>  \n<thead>  \n<tr><td width=\"30%\">方法</td><td>作用</td></tr>  \n</thead>  \n<tbody>  \n<tr>  \n<td>HasBinding(N)</td><td>判断环境记录项是否包含对某个标识符的绑定。如果包含该绑定则返回 true，反之返回 false。其中字符串 N 是标识符文本。</td></tr>  \n<tr>  \n<td>CreateMutableBinding(N, D)</td><td>  \n在环境记录项中创建一个新的可变绑定。其中字符串 N 指定绑定名称。如果可选参数 D 的值为true，则该绑定在后续操作中可以被删除。</td></tr>\n<tr><td>SetMutableBinding(N,V, S)</td><td>在环境记录项中设置一个已经存在的绑定的值。其中字符串 N 指定绑定名称。V 用于指定绑定的值，可以是任何 ECMA 脚本语言的类型。S 是一个布尔类型的标记，当 S 为 true 并且该绑定不允许赋值时，则抛出一个 TypeError 异常。S 用于指定是否为严格模式。</td></tr>  \n<tr><td>GetBindingValue(N,S)</td><td>返回环境记录项中一个已经存在的绑定的值。其中字符串 N 指定绑定的名称。S 用于指定是否为严格模式。如果 S 的值为 true 并且该绑定不存在或未初始化，则抛出一个 ReferenceError 异常。</td></tr>  \n<tr><td>DeleteBinding(N)</td><td>从环境记录项中删除一个绑定。其中字符串 N 指定绑定的名称。如果 N 指定的绑定存在，将其删除并返回 true。如果绑定存在但无法删除则返回false。如果绑定不存在则返回 true。</td></tr>  \n<tr><td>ImplicitThisValue()</td><td>当从该环境记录项的绑定中获取一个函数对象并且调用时，该方法返回该函数对象使用的 this 对象的值。</td></tr>  \n</tbody>  \n</table>\n\n<p>声明式环境记录项有两个额外方法，用来创建和初始化不可变的绑定，用在定义严格模式下的 arguments 对象，因为严格模式下要求 arguments 是不和形参进行关联的：</p>\n\n<table>  \n<thead>  \n<tr><td width=\"30%\">方法</td><td>作用</td></tr>  \n</thead>  \n<tbody><tr><td>CreateImmutableBinding(N)</td><td>在环境记录项中创建一个未初始化的不可变绑定。其中字符串 N 指定绑定名称。</td></tr>  \n<tr><td>  \nInitializeImmutableBinding(N,V)</td><td>在环境记录项中设置一个已经创建但未初始化的不可变绑定的值。其中字符串 N 指定绑定名称。V 用于指定绑定的值，可以是任何 ECMA 脚本语言的类型。</td></tr></tbody>  \n</table>\n\n<p>对象式环境记录项有一个关联的对象，这个对象被称作绑定对象。对象式环境记录项直接将一系列标识符与其绑定对象的属性名称建立一一对应关系。另外它还有一个 provideThis，用来指定 ImplicitThisValue 对象内部方法的 this，With 环境中 provideThis 为 true，在 ImplicitThisValue算法中，便会根据这个值，将返回值设为 With 语句块绑定的对象。</p>\n\n<p>令人发指了，还有三个词法环境的运算方法：</p>\n\n<p>GetIdentifierReference (lex, name, strict)</p>\n\n<p><em>作用是根据标识符，在给定的词法环境获取引用。</em>当调用 GetIdentifierReference 抽象运算时，需要指定一个 词法环境 lex，一个标识符字符串 name 以及一个布尔型标识 strict。lex 的值可以为 null。</p>\n\n<p>NewDeclarativeEnvironment (E)</p>\n\n<p><em>作用是创建词法环境E的子声明式词法环境。</em>当调用 NewDeclarativeEnvironment 抽象运算时，需指定一个 词法环境 E，其值可以为 null。</p>\n\n<p>NewObjectEnvironment (O, E)</p>\n\n<p><em>作用是创建词法环境E的子对象式词法环境。</em>当调用 NewObjectEnvironmentis 抽象运算时，需指定一个对象 O 及一个 词法环境 E（其值可以为 null）。</p>\n\n<h6 id=\"\">全局环境</h6>\n\n<p>全局环境是全局代码对应的词法环境，它也是全局对象本身。这里我们就可以解决一个很常见的问题，不用 var 声明时为何就变成全局的了。因为在作用域链上找，直到全局环境时，此时的<code>b=1</code>已经变成了在全局对象上的属性赋值，而不再是变量了。也就没有变量提升一说，在之前调用就会报错。</p>\n\n<h4 id=\"\">执行环境</h4>\n\n<p>执行环境也就是通常我们所说的执行上下文。活动的执行上下文组在逻辑上组成一个堆栈。堆栈底部永远都是全局上下文(global context)，而顶部就是当前(活动的)执行上下文。堆栈在EC类型进入和退出上下文的时候被修改（推入或弹出）。</p>\n\n<p>执行环境包含所有用于追踪与其相关的代码的执行进度的状态。共包括三个组件：词法环境、变量环境、this绑定。词法环境和变量环境都是上一部分提到的词法环境对象。当创建一个执行环境时，其词法环境组件和变量环境组件最初是同一个值。在该执行环境相关联的代码的执行过程中，变量环境组件引用永远不变，而词法环境组件引用有可能改变。改变的两个情况就是 With 和 Catch 语句块，为了实现这种改变，所以有了词法环境和变量环境。</p>\n\n<h4 id=\"\">建立执行环境</h4>\n\n<p>写到这我都快晕了。。。不过进入建立执行环境部分会明朗起来吧！分三种，也就对应最开始讲的三种可执行代码！</p>\n\n<h6 id=\"\">全局执行环境</h6>\n\n<p>当控制流进入全局代码的执行环境时，执行以下步骤：</p>\n\n<ol>\n<li>将变量环境设置为全局环境；  </li>\n<li>将词法环境设置为全局环境；  </li>\n<li>将 this 绑定设置为全局对象；  </li>\n<li>执行初始化绑定，按下文。</li>\n</ol>\n\n<p>前三步就是把执行环境的三个组件确定，很好理解，初始化绑定比较复杂，并且与 eval 及函数是共用的，因此放在下文。</p>\n\n<h6 id=\"eval\">eval</h6>\n\n<p>当控制流进入 eval 代码 的执行环境时，执行以下步骤：</p>\n\n<ol>\n<li>如果没有调用环境，或者 eval 代码并非通过<a href=\"http://www.cnblogs.com/_franky/archive/2012/08/18/2645024.html\">直接调用 eval</a> 函数进行评估的，则 <br />\n1.按描述的初始化全局执行环境的方案，以 eval 代码作为 C 来初始化执行环境。</li>\n<li>否则 <br />\n<ol><li>将 this 绑定设置为当前执行环境下的 this 绑定。</li>\n<li>将词法环境设置为当前执行环境下的词法环境。</li>\n<li>将变量环境设置为当前执行环境下的变量环境。</li></ol></li>\n<li>如果 eval 代码 是 严格模式下的代码 ，则 <br />\n<ol><li>令 strictVarEnv 为以词法环境为参数调用 NewDeclarativeEnvironment 得到的结果。</li>\n<li>设置词法环境为 strictVarEnv。</li>\n<li>设置变量环境为 strictVarEnv。</li></ol></li>\n<li>按下文描述的方案，使用 eval 代码 执行定义绑定初始化步骤。</li>\n</ol>\n\n<p>首先对于严格模式，它的词法环境是独立的，这是严格模式中要求的。而上面步骤中另一个区别是是否直接调用。不过要讲这个东西，又是一篇长文了。简单的来说就是 eval('xxx')这种算是直接调用，(1, eval)('xxx')算是间接调用，具体点开链接。</p>\n\n<h6 id=\"\">函数执行环境</h6>\n\n<p>当控制流根据一个函数对象 F、调用者提供的 thisArg 以及调用者提供的 argumentList，进入 函数代码 的执行环境时，执行以下步骤：</p>\n\n<ol>\n<li>如果函数代码是严格模式下的代码，设 this 绑定为 thisArg。  </li>\n<li>否则如果 thisArg 是 null 或 undefined，则设 this 绑定为 全局对象 。  </li>\n<li>否则如果 Type(thisArg) 的结果不为 Object，则设 this 绑定为 ToObject(thisArg)。  </li>\n<li>否则设 this 绑定为 thisArg。  </li>\n<li>以 F 的 [[Scope]] 内部属性为参数调用 NewDeclarativeEnvironment，并令 localEnv 为调用的结果。  </li>\n<li>设词法环境为 localEnv。  </li>\n<li>设变量环境为 localEnv。  </li>\n<li>令 code 为 F 的 [[Code]] 内部属性的值。  </li>\n<li>按下文描述的方案，使用 函数代码 code 和 argumentList 执行定义绑定初始化步骤。</li>\n</ol>\n\n<p>调用者提供的 thisArg，在调用者是引用类型时，就是引用类型的 base；非引用类型时是 null或undefined。非严格模式下es5会把null和undefined自动转化为全局对象，this不是对象就会转为对象。这就是函数this绑定的过程。这部分比起全局和eval来说复杂一些，之后还是老样子，创建设置词法环境，变量环境，初始化绑定。</p>\n\n<h4 id=\"\">初始化绑定，放大招了</h4>\n\n<p>当进入一个执行环境时，会按以下步骤在变量环境上创建绑定，其中使用到调用者提供的代码设为 code，如果执行的是函数代码，则设 参数列表 为 args：</p>\n\n<ol>\n<li>令 env 是当前运行执行环境的变量环境。  </li>\n<li>如果 code 是 eval 代码 ，则令 configurableBindings 为 true，否则令 configurableBindings 为 false。（因此 eval 中的变量是可以 delete 的）  </li>\n<li>如果代码是 严格模式下的代码 ，则令 strict 为 true，否则令 strict 为 false。  </li>\n<li>如果代码为函数代码，则：（首先绑定的就是参数） <br />\n<ol><li>令 func 为通过 [[Call]] 内部属性初始化 code 的执行的函数对象。令 names 为 func 的 [[FormalParameters]] 内部属性。</li>\n<li>令 argCount 为 args 中元素的数量。</li>\n<li>令 n 为数字类型，其值为 0。</li>\n<li>按列表顺序遍历 names，对于每一个字符串 argName（这里会把传入的实参对应的形参绑定到变量环境上，严格模式下则不会进行绑定）</li></ol></li>\n<li>按源码顺序遍历 code，对于每一个 FunctionDeclaration 表达式 f：（其次绑定的是函数声明，这部分还没完全看懂）  </li>\n<li>以 arguments 为参数，调用 env 的 HasBinding 具体方法，并令 argumentsAlreadyDeclared 为调用的结果。（针对名字叫arguments的形参或是函数定义？测试了下，名为arguments的形参或者内部函数声明出现时，argumentsAlreadyDeclared会变成 true）  </li>\n<li>如果 code 是函数代码，并且 argumentsAlreadyDeclared 为 false，则：（这一部构建arguments对象） <br />\n<ol><li>以 fn、names、args、env 和 strict 为参数，调用 CreateArgumentsObject 抽象运算函数，并令 argsObj 为调用的结果。</li>\n<li>如果 strict 为 true，则进行不可变绑定。</li>\n<li>否则进行可变绑定。</li></ol></li>\n<li>按源码顺序遍历 code，对于每一个 VariableDeclaration 和VariableDeclarationNoIn 表达式：（最后才是变量声明） <br />\n<ol><li>令 dn 为 d 中的标识符。</li>\n<li>以 dn 为参数，调用 env 的 HasBinding 具体方法，并令 varAlreadyDeclared 为调用的结果。</li>\n<li>如果 varAlreadyDeclared 为 false，则：以 dn 和 configurableBindings 为参数，调用 env 的 CreateMutableBinding 具体方法。以 dn、undefined 和 strict 为参数，调用 env 的 SetMutableBinding 具体方法。</li></ol></li>\n</ol>\n\n<p>可以看到绑定上下文的顺序是形参、函数声明、arguments对象、变量声明，搞清楚这个流程，那些面试题就都清楚了，不过好像也没有什么卵用。es文档中还有一节讲的是Arguments对象的创建，居然比绑定上下文的创建还要复杂，先跳过了！！</p>\n\n<h4 id=\"\">最后扯几句</h4>\n\n<p>过了一遍<em>可执行代码与执行环境</em>的文档之后，我们来看看那些困扰我们很久的一些js问题。<a href=\"http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html\">汤姆大叔-深入理解JavaScript系列的11-16</a>分别讲是执行上下文、变量对象、this、作用域链、函数、闭包。从规范的角度再去看汤姆大叔对这些概念的解释，有一种豁然开朗的感觉。当然他没有点到的背后的东西，也可以知晓。</p>\n\n<p>所以还是应该把这些话题用上面的规范再分别讲一遍，等有空吧！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1472880637599,"created_by":1,"updated_at":1475051261595,"updated_by":1,"published_at":1473842716089,"published_by":1},{"id":59,"uuid":"b60f6f88-f27f-4908-9ea3-63b7afd72950","title":"随笔","slug":"sui-bi-2","markdown":"昨晚寝室没网，看了部存在硬盘中的电影《第八日的蝉》就睡了。挺好的片子，如果后面还记得的话会写写这片子。\n\n早上起得挺早，就准备找个有网能自习的地方去，然而学校图书馆没开，只好跑远点到了浙江图书馆。环境挺不错，就是计算机类的书又少又旧。还好了带了本书，好了，开始学习了！\n\n看了一章，发现普通的书已经解决不了我的问题了，只能上文档了，就是有点厚！","html":"<p>昨晚寝室没网，看了部存在硬盘中的电影《第八日的蝉》就睡了。挺好的片子，如果后面还记得的话会写写这片子。</p>\n\n<p>早上起得挺早，就准备找个有网能自习的地方去，然而学校图书馆没开，只好跑远点到了浙江图书馆。环境挺不错，就是计算机类的书又少又旧。还好了带了本书，好了，开始学习了！</p>\n\n<p>看了一章，发现普通的书已经解决不了我的问题了，只能上文档了，就是有点厚！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1473385751621,"created_by":1,"updated_at":1473389562246,"updated_by":1,"published_at":1473386005922,"published_by":1},{"id":60,"uuid":"20ff95ab-2c25-491a-a722-17bfc527be8b","title":"MDN js bind 解读","slug":"mdn-js-bind-jie-du","markdown":"#### 基础\n\n###### 语法\n\n>fun.bind(thisArg[, arg1[, arg2[, ...]]])\n\n###### 参数\n\n> thisArg\n\n> 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。\n\n> arg1, arg2, ...\n\n> 当绑定函数被调用时，这些参数加上绑定函数本身的参数会按照顺序作为原函数运行时的参数。\n\n###### 返回值\n\n> 返回由指定的this值和初始化参数改造的原函数拷贝\n\n注意点：上面bind返回的新函数可以作为构造函数，此时bind指定的this无效，而会使用构造函数产生的对象作为this。其次，就是最终的参数包括两部分，一是bind时指定的参数，二是函数调用是指定的参数，此处涉及了偏函数以及函数科里化的只是后面会补充。\n\n#### 有了call、apply，为何还要bind\n\nbind能够和call、apply一样绑定上下文，但是相较于call和apply，它还有很多别的特点。首先，bind会返回一个新的函数，而不是立即执行；其次，我们在bind时，可以固定一些参数，此时产生的便是一个偏函数。偏函数在js或者python中就是指固定一些参数，返回一个新的函数，来方便函数调用的。举个例子：\n\n```\n// parseInt()支持第二个参数，表示进制，如果我们要指定第一个参数是二进制，并且在很多地方使用，我们就可以把第二个参数固定下来，然后返回一个新的函数，方便调用。\n\nfunction toInt2(x){\n    return parseInt(x, 2);\n}\n```\n\n第三是作为构造函数的绑定函数，不过不建议在生产环境中使用。\n\n```\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function() { \n  return this.x + ',' + this.y; \n};\n\nvar p = new Point(1, 2);\np.toString(); // '1,2'\n\nvar emptyObj = {};\nvar YAxisPoint = Point.bind(emptyObj, 0/*x*/);\n// 以下这行代码在 polyfill 不支持,\n// 在原生的bind方法运行没问题:\n//(译注：polyfill的bind方法如果加上把bind的第一个参数，即新绑定的this执行Object()来包装为对象，Object(null)则是{}，那么也可以支持)\nvar YAxisPoint = Point.bind(null, 0/*x*/);\n\nvar axisPoint = new YAxisPoint(5);\naxisPoint.toString(); // '0,5'\n\naxisPoint instanceof Point; // true\naxisPoint instanceof YAxisPoint; // true\nnew Point(17, 42) instanceof YAxisPoint; // true\n```\n\n上面这段代码使用原生的bind和其他的实现运行的效果有出入，所以在构造函数上还是不建议使用bind吧。\n\n第四是快捷调用，你可以用 Array.prototype.slice 来将一个类似于数组的对象（array-like object）转换成一个真正的数组，就拿它来举例子吧。你可以创建这样一个捷径：\n\n```\nvar slice = Array.prototype.slice;\n//...\nslice.apply(arguments);\n```\n\n但是使用bind，可以使这个过程变得简单。\n\n```\n// same as \"slice\" in the previous example\nvar unboundSlice = Array.prototype.slice;\nvar slice = Function.prototype.call.bind(unboundSlice);\n// ...\nslice(arguments);\n```\n\n主要要讲的是`Function.prototype.call.bind(unboundSlice)`，这是什么写法？其实就是把call执行的时候的this绑定为unboundSlice，然后返回一个新的函数，此时执行`slice(arguments)`，就相当于执行`unboundSlice.call(arguments)`。\n\n#### bind的劣势\n\n目前看到的主要有两个劣势，第一是兼容性，IE9以下不支持；第二是性能，引用一段话：\n\n> 我测试了一下浏览器原生的Function.prototype.bind，发现使用了bind之后，函数的内存占用增加了近2倍！CoffeeScript实现的绑定稍微轻量一点，内存占用也增加了1倍多。\n\n>再顺便测试了下ES6新增的Arrow function（也是=>），因为这个特殊函数是自带绑定技能的，结果惊奇地发现，它的内存占用和普通的Function没啥区别。所以以后需要或者不需要bind的场景如果一定要滥用bind图个安心的话，可以通通上高逼格的箭头函数。:)\n\n>文／寂寞的原子（简书作者）\n原文链接：http://www.jianshu.com/p/45515682be0d\n著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。\n\nbind和箭头函数又是一个新的问题了，这里不展开讨论了。\n\n不过总的来说，bind还是一个比较好的方案，像很多库都在使用，underscore、lodash、jquery也都有对应的实现。\n\n#### bind的实现\n\n最简单的实现：\n\n```\nFunction.prototype.bind = function(context){  \n  self = this;  //保存this，即调用bind方法的目标函数\n  return function(){\n      return self.apply(context,arguments);\n  };\n};\n```\n\n加入科里化，也就是把两部分参数进行合并：\n\n```\nFunction.prototype.bind = function(context){  \n  var args = Array.prototype.slice.call(arguments, 1),\n  self = this;\n  return function(){\n      var innerArgs = Array.prototype.slice.call(arguments);\n      var finalArgs = args.concat(innerArgs);\n      return self.apply(context,finalArgs);\n  };\n};\n```\n\n最后要分析一下Polyfill（兼容旧浏览器），它考虑到了构造函数，但是与原生的实现还是有点区别，可以见构造函数一节的注释：\n\n```\n// 判断是否原生支持\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function (oThis) {\n    // 如果需要bind的不是函数则报错\n    if (typeof this !== \"function\") {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n    }\n\n    // aArgs是bind时固定下来的参数\n    // fToBind保存了要bind函数的引用\n    // fNOP作为中介\n    // fBound是最后返回的函数\n    var aArgs = Array.prototype.slice.call(arguments, 1), \n        fToBind = this, \n        fNOP = function () {},\n        fBound = function () {\n          return fToBind.apply(this instanceof fNOP\n                                 ? this\n                                 : oThis || this,\n// 连接两次的参数                            aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n\n    // 保证bind出来的函数与借用的函数拥有相同的原型链\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n}\n```\n\n剩下还有`this instanceof fNOP ? this : oThis || this`是我百思不得其解的，最后在一篇博客上找到了答案，当bind返回的函数用作构造函数时，`this instanceof fNOP`为true，也就是定义中所说的忽略this的情况。\n\n至于为什么需要fNOP作为中介，这是构造函数继承的一种方法，它的好处是防止`this.prototype`和`fBound.prototype`两者会指向同一个引用。\n\n#### 扩展es7绑定函数\n\n该语法还是ES7的一个提案，但是Babel转码器已经支持。\n\n函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。\n\n```\nfoo::bar;\n// 等同于\nbar.bind(foo);\n\nfoo::bar(...arguments);\n// 等同于\nbar.apply(foo, arguments);\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return obj::hasOwnProperty(key);\n}\n```\n\n详情见阮老师的es6入门吧！\n\n#### 最后扯两句\n\n仅仅是bind就有这么多东西，如果把它放到整块知识中肯定能够有更多的收获，不过在晕之前还先把阶段性的结果写下来，到时候好整合！","html":"<h4 id=\"\">基础</h4>\n\n<h6 id=\"\">语法</h6>\n\n<blockquote>\n  <p>fun.bind(thisArg[, arg1[, arg2[, ...]]])</p>\n</blockquote>\n\n<h6 id=\"\">参数</h6>\n\n<blockquote>\n  <p>thisArg</p>\n  \n  <p>当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</p>\n  \n  <p>arg1, arg2, ...</p>\n  \n  <p>当绑定函数被调用时，这些参数加上绑定函数本身的参数会按照顺序作为原函数运行时的参数。</p>\n</blockquote>\n\n<h6 id=\"\">返回值</h6>\n\n<blockquote>\n  <p>返回由指定的this值和初始化参数改造的原函数拷贝</p>\n</blockquote>\n\n<p>注意点：上面bind返回的新函数可以作为构造函数，此时bind指定的this无效，而会使用构造函数产生的对象作为this。其次，就是最终的参数包括两部分，一是bind时指定的参数，二是函数调用是指定的参数，此处涉及了偏函数以及函数科里化的只是后面会补充。</p>\n\n<h4 id=\"callapplybind\">有了call、apply，为何还要bind</h4>\n\n<p>bind能够和call、apply一样绑定上下文，但是相较于call和apply，它还有很多别的特点。首先，bind会返回一个新的函数，而不是立即执行；其次，我们在bind时，可以固定一些参数，此时产生的便是一个偏函数。偏函数在js或者python中就是指固定一些参数，返回一个新的函数，来方便函数调用的。举个例子：</p>\n\n<pre><code>// parseInt()支持第二个参数，表示进制，如果我们要指定第一个参数是二进制，并且在很多地方使用，我们就可以把第二个参数固定下来，然后返回一个新的函数，方便调用。\n\nfunction toInt2(x){  \n    return parseInt(x, 2);\n}\n</code></pre>\n\n<p>第三是作为构造函数的绑定函数，不过不建议在生产环境中使用。</p>\n\n<pre><code>function Point(x, y) {  \n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function() {  \n  return this.x + ',' + this.y; \n};\n\nvar p = new Point(1, 2);  \np.toString(); // '1,2'\n\nvar emptyObj = {};  \nvar YAxisPoint = Point.bind(emptyObj, 0/*x*/);  \n// 以下这行代码在 polyfill 不支持,\n// 在原生的bind方法运行没问题:\n//(译注：polyfill的bind方法如果加上把bind的第一个参数，即新绑定的this执行Object()来包装为对象，Object(null)则是{}，那么也可以支持)\nvar YAxisPoint = Point.bind(null, 0/*x*/);\n\nvar axisPoint = new YAxisPoint(5);  \naxisPoint.toString(); // '0,5'\n\naxisPoint instanceof Point; // true  \naxisPoint instanceof YAxisPoint; // true  \nnew Point(17, 42) instanceof YAxisPoint; // true  \n</code></pre>\n\n<p>上面这段代码使用原生的bind和其他的实现运行的效果有出入，所以在构造函数上还是不建议使用bind吧。</p>\n\n<p>第四是快捷调用，你可以用 Array.prototype.slice 来将一个类似于数组的对象（array-like object）转换成一个真正的数组，就拿它来举例子吧。你可以创建这样一个捷径：</p>\n\n<pre><code>var slice = Array.prototype.slice;  \n//...\nslice.apply(arguments);  \n</code></pre>\n\n<p>但是使用bind，可以使这个过程变得简单。</p>\n\n<pre><code>// same as \"slice\" in the previous example\nvar unboundSlice = Array.prototype.slice;  \nvar slice = Function.prototype.call.bind(unboundSlice);  \n// ...\nslice(arguments);  \n</code></pre>\n\n<p>主要要讲的是<code>Function.prototype.call.bind(unboundSlice)</code>，这是什么写法？其实就是把call执行的时候的this绑定为unboundSlice，然后返回一个新的函数，此时执行<code>slice(arguments)</code>，就相当于执行<code>unboundSlice.call(arguments)</code>。</p>\n\n<h4 id=\"bind\">bind的劣势</h4>\n\n<p>目前看到的主要有两个劣势，第一是兼容性，IE9以下不支持；第二是性能，引用一段话：</p>\n\n<blockquote>\n  <p>我测试了一下浏览器原生的Function.prototype.bind，发现使用了bind之后，函数的内存占用增加了近2倍！CoffeeScript实现的绑定稍微轻量一点，内存占用也增加了1倍多。</p>\n  \n  <p>再顺便测试了下ES6新增的Arrow function（也是=>），因为这个特殊函数是自带绑定技能的，结果惊奇地发现，它的内存占用和普通的Function没啥区别。所以以后需要或者不需要bind的场景如果一定要滥用bind图个安心的话，可以通通上高逼格的箭头函数。:)</p>\n  \n  <p>文／寂寞的原子（简书作者）\n  原文链接：<a href=\"http://www.jianshu.com/p/45515682be0d\">http://www.jianshu.com/p/45515682be0d</a>\n  著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>\n</blockquote>\n\n<p>bind和箭头函数又是一个新的问题了，这里不展开讨论了。</p>\n\n<p>不过总的来说，bind还是一个比较好的方案，像很多库都在使用，underscore、lodash、jquery也都有对应的实现。</p>\n\n<h4 id=\"bind\">bind的实现</h4>\n\n<p>最简单的实现：</p>\n\n<pre><code>Function.prototype.bind = function(context){  \n  self = this;  //保存this，即调用bind方法的目标函数\n  return function(){\n      return self.apply(context,arguments);\n  };\n};\n</code></pre>\n\n<p>加入科里化，也就是把两部分参数进行合并：</p>\n\n<pre><code>Function.prototype.bind = function(context){  \n  var args = Array.prototype.slice.call(arguments, 1),\n  self = this;\n  return function(){\n      var innerArgs = Array.prototype.slice.call(arguments);\n      var finalArgs = args.concat(innerArgs);\n      return self.apply(context,finalArgs);\n  };\n};\n</code></pre>\n\n<p>最后要分析一下Polyfill（兼容旧浏览器），它考虑到了构造函数，但是与原生的实现还是有点区别，可以见构造函数一节的注释：</p>\n\n<pre><code>// 判断是否原生支持\nif (!Function.prototype.bind) {  \n  Function.prototype.bind = function (oThis) {\n    // 如果需要bind的不是函数则报错\n    if (typeof this !== \"function\") {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n    }\n\n    // aArgs是bind时固定下来的参数\n    // fToBind保存了要bind函数的引用\n    // fNOP作为中介\n    // fBound是最后返回的函数\n    var aArgs = Array.prototype.slice.call(arguments, 1), \n        fToBind = this, \n        fNOP = function () {},\n        fBound = function () {\n          return fToBind.apply(this instanceof fNOP\n                                 ? this\n                                 : oThis || this,\n// 连接两次的参数                            aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n\n    // 保证bind出来的函数与借用的函数拥有相同的原型链\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n}\n</code></pre>\n\n<p>剩下还有<code>this instanceof fNOP ? this : oThis || this</code>是我百思不得其解的，最后在一篇博客上找到了答案，当bind返回的函数用作构造函数时，<code>this instanceof fNOP</code>为true，也就是定义中所说的忽略this的情况。</p>\n\n<p>至于为什么需要fNOP作为中介，这是构造函数继承的一种方法，它的好处是防止<code>this.prototype</code>和<code>fBound.prototype</code>两者会指向同一个引用。</p>\n\n<h4 id=\"es7\">扩展es7绑定函数</h4>\n\n<p>该语法还是ES7的一个提案，但是Babel转码器已经支持。</p>\n\n<p>函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>\n\n<pre><code>foo::bar;  \n// 等同于\nbar.bind(foo);\n\nfoo::bar(...arguments);  \n// 等同于\nbar.apply(foo, arguments);\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;  \nfunction hasOwn(obj, key) {  \n  return obj::hasOwnProperty(key);\n}\n</code></pre>\n\n<p>详情见阮老师的es6入门吧！</p>\n\n<h4 id=\"\">最后扯两句</h4>\n\n<p>仅仅是bind就有这么多东西，如果把它放到整块知识中肯定能够有更多的收获，不过在晕之前还先把阶段性的结果写下来，到时候好整合！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1473729418209,"created_by":1,"updated_at":1474022560461,"updated_by":1,"published_at":1473733465651,"published_by":1},{"id":61,"uuid":"149d7964-a6f5-4ecc-8b5d-4a98d5b2dc1c","title":"有生之年系列之——编剧出来谈人生","slug":"you-sheng-zhi-nian-xi-lie-zhi-bian-ju-chu-lai-tan-ren-sheng","markdown":"大哥搞完事情，编剧又出来搞事情，哈哈哈哈哈哈！\n\n坐等下周大结局！！！\n\n![](https://ws2.sinaimg.cn/large/76fc6301gw1f7rw8zmuxej20x00qcq91.jpg)\n\n![](https://ws1.sinaimg.cn/large/76fc6301gw1f7rw9l9pi4j218w0oogst.jpg)\n\n![](https://ws3.sinaimg.cn/large/76fc6301gw1f7rwa2amjej214u0q2n66.jpg)\n\n![](https://ws4.sinaimg.cn/large/76fc6301gw1f7rwahfw9nj21bs0vg7s0.jpg)","html":"<p>大哥搞完事情，编剧又出来搞事情，哈哈哈哈哈哈！</p>\n\n<p>坐等下周大结局！！！</p>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/76fc6301gw1f7rw8zmuxej20x00qcq91.jpg\" alt=\"\" /></p>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/76fc6301gw1f7rw9l9pi4j218w0oogst.jpg\" alt=\"\" /></p>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/76fc6301gw1f7rwa2amjej214u0q2n66.jpg\" alt=\"\" /></p>\n\n<p><img src=\"https://ws4.sinaimg.cn/large/76fc6301gw1f7rwahfw9nj21bs0vg7s0.jpg\" alt=\"\" /></p>","image":"/content/images/2016/09/76fc6301gw1f7rwahfw9nj21bs0vg7s0.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1473744682232,"created_by":1,"updated_at":1473756483186,"updated_by":1,"published_at":1473744849848,"published_by":1},{"id":62,"uuid":"43bc67b4-73d6-4764-b873-1d351631b482","title":"js 正则表达式小结","slug":"js-zheng-ze-biao-da-shi-xiao-jie","markdown":"这是之前欠下的，一直没空总结一下。看完剧，先把之前的总结了，在进行下一步的学习。在讲js的正则之前，先要讲一下正则的基本概念。结合一些例子，应该能快速了解吧！本文只能算扫盲加知识拓展性质，要熟练掌握，还是要靠多练！\n\n#### 基础\n\n##### 字符\n\n1、普通字符（单个字符）\n\n字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是\"普通字符\"。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。\n\n2、转义字符（单个字符）\n\n一些不便书写的字符，采用在前面加 \"\\\" 的方法。这些字符其实我们都已经熟知了。\n\n<table>\n<thead>\n<tr>\n<td width=\"20%\">表达式</td>\n<td>可匹配</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\r, \\n</td>\n<td>代表回车和换行符</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>制表符</td>\n</tr>\n<tr>\n<td>\\/</td>\n<td>/本身</td>\n</tr>\n<tr>\n<td>...</td>\n<td>...</td>\n</tr>\n</tbody>\n</table>\n\n还有其他一些在后边章节中有特殊用处的标点符号，在前面加 \"\\\" 后，就代表该符号本身。比如：^，$ 都有特殊意义，如果要想匹配字符串中 \"^\" 和 \"$\" 字符，则表达式就需要写成 \"\\^\" 和 \"\\$\"。\n\n<table>\n<thead>\n<tr>\n<td width=\"20%\">表达式</td>\n<td>可匹配</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\^</td>\n<td>匹配 ^ 符号本身</td>\n</tr>\n<tr>\n<td>\\$</td>\n<td>匹配 $ 符号本身</td>\n</tr>\n<tr>\n<td>\\.</td>\n<td>匹配小数点（.）本身</td>\n</tr>\n<tr>\n<td>...</td>\n<td>...</td>\n</tr>\n</tbody>\n</table>\n\n这些转义字符的匹配方法与 \"普通字符\" 是类似的。也是匹配与之相同的一个字符。\n\n3、自定义范围类（多个字符）\n\n上面两个匹配的都是单个字符，当我们需要匹配多个字符时，就可以用\"[]\"来表示一个范围，可以匹配范围内的任意字符，另外只匹配一个字符。\n\n<table>\n<thead>\n<tr>\n<td width=\"20%\">表达式</td>\n<td>可匹配</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[ab5@]</td>\n<td>匹配 \"a\" 或 \"b\" 或 \"5\" 或 \"@\"</td>\n</tr>\n<tr>\n<td>[^abc]</td>\n<td>匹配 \"a\",\"b\",\"c\" 之外的任意一个字符</td>\n</tr>\n<tr>\n<td>[f-k]</td>\n<td>匹配 \"f\"~\"k\" 之间的任意一个字母</td>\n</tr>\n<td>[^A-F0-3]</td>\n<td>匹配 \"A\"~\"F\",\"0\"~\"3\" 之外的任意一个字符</td>\n</tr>\n<tr>\n<td>...</td>\n<td>...</td>\n</tr>\n</tbody>\n</table>\n\n4、预范围类（多个字符）\n\n除了上面的自定义的范围类，为了写起来比较方便，还有一些预定义的范围类。\n\n<table>\n<thead>\n<tr>\n<td width=\"20%\">表达式</td>\n<td>可匹配</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\d</td>\n<td>任意一个数字，0~9 中的任意一个</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>包括空格、制表符、换页符等空白字符的其中任意一个</td>\n</tr>\n<td>.</td>\n<td>小数点可以匹配除了换行符（\\n）以外的任意一个字符</td>\n</tr>\n<tr>\n<td>...</td>\n<td>...</td>\n</tr>\n</tbody>\n</table>\n\n##### 量词\n\n上文的字符或者范围类匹配的都是原串中的一个字符，如果要重复匹配多次，则需要量词，主要有以下一些：\n\n<table>\n<thead>\n<tr>\n<td width=\"20%\">表达式</td>\n<td>作用</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>{n}</td>\n<td>表达式重复n次，比如：\"\\w{2}\" 相当于 \"\\w\\w\"；\"a{5}\" 相当于 \"aaaaa\"</td>\n</tr>\n<tr>\n<td>{m,n}</td>\n<td>表达式至少重复m次，最多重复n次，比如：\"ba{1,3}\"可以匹配 \"ba\"或\"baa\"或\"baaa\"</td>\n</tr>\n<tr>\n<td>{m,}</td>\n<td>表达式至少重复m次，比如：\"\\w\\d{2,}\"可以匹配 \"a12\",\"_456\",\"M12344\"...</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配表达式0次或者1次，相当于 {0,1}，比如：\"a[cd]?\"可以匹配 \"a\",\"ac\",\"ad\"</td>\n</tr>\n<tr>\n<td>+</td>\n<td>表达式至少出现1次，相当于 {1,}，比如：\"a+b\"可以匹配 \"ab\",\"aab\",\"aaab\"...</td>\n</tr>\n<tr>\n<td>*</td>\n<td>表达式不出现或出现任意次，相当于 {0,}，比如：\"\\^*b\"可以匹配 \"b\",\"^^^b\"...</td>\n</tr>\n</tbody>\n</table>\n\n##### 边界\n\n我们经常要匹配文件名后缀，这时候我们就会用到边界匹配符号。当然匹配开头、单词边界都很常见。\n\n<table>\n<thead>\n<tr>\n<td width=\"20%\">表达式</td>\n<td>作用</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>^</td>\n<td>与字符串开始的地方匹配，不匹配任何字符</td>\n</tr>\n<tr>\n<td>$</td>\n<td>与字符串结束的地方匹配，不匹配任何字符</td>\n</tr>\n<td>\\b</td>\n<td>匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符</td>\n</tr>\n</tbody>\n</table>\n\n##### 分组\n\n分组的符号是\"()\"，它的作用是在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰；并且取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到。\n\n另外还有一个\"|\"，用于表达两个表达式之间或的关系。\n\n#### 高级\n\n##### 贪婪、非贪婪\n\n量词在匹配的时候是不确定的，例如aaaaa匹配a{1,3}，可以匹配一到三次，但是如何选择呢？正则表达式默认规定是使用贪婪模式，也就是越多越好，尽量多地匹配。相反的还有一种非贪婪模式，要启用非贪婪模式只要在量词表达式之后跟上\"?\"即可。\n\n##### 反向引用\n\n表达式在匹配时，表达式引擎会将小括号 \"( )\" 包含的表达式所匹配到的字符串记录下来。并且记录下来的字符串我们可以通过\"$1\"，\"$2\"的方式进行引用。举个例子，有电话号码13588884444，我们通常会把中间四位变成\"*\"，来保护用户信息，这用正则表达式来做很简单。\n\n```\n'13588884444'.replace(/(\\d{3})\\d{4}(\\d{4})/g, '$1****$2')\n```\n\n上面的表达式将前三位和后四位分组，然后在替换的时候通过\"$1\"和\"$2\"进行反向引用，很神奇吧！\n\n##### 忽略分组\n\n假设上面的例子如果我们把中间四位也进行分组，但是中间四位没有记录下来的必要，此时我们就可以忽略分组，用\"(?:)\"表达式。\n\n##### 前瞻后顾（正向预搜索、反向预搜索）\n\njs目前只支持前瞻，所以只介绍前瞻了，后顾的道理是一样的。有的时候我们会有如下的需求，就是在匹配的时候，字符串的前后需要满足一定的要求。前瞻就是右边满足一定的要求，后顾就是左边满足一定的要求。例子如下：\n\n```\n'windows95,windows98,windows2000'.match(/windows(?=95|98)/g);//[\"windows\", \"windows\"]\n```\n\n上面的表达式匹配要求匹配windows的同时，后边是95或98，匹配的结果也就是[\"windows\", \"windows\"]，可以看到条件是不会被匹配进结果的。\n\n#### js 中的正则\n\n##### es6之前\n\n###### 创建正则表达式：\n\n```\n// 构造函数\nvar regex = new RegExp('xyz', 'i');\nvar regex = new RegExp(/xyz/i);\nvar regex = new RegExp(/xyz/, 'i');//es6才支持\n// 字面量\nvar regex = /xyz/i;\n```\n\n###### 修饰符：\n\n<table>\n<thead>\n<tr><td width=\"20%\">修饰符</td><td>描述</td></tr>\n</thead>\n<tbody>\n<tr><td>i</td><td>执行对大小写不敏感的匹配。</td></tr>\n<tr><td>g</td><td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr>\n<tr><td>m</td><td>执行多行匹配。</td></tr>\n</tbody>\n</table>\n\n###### RegExp 对象属性：\n\n<table>\n<thead>\n<tr><td width=\"20%\">属性</td><td>描述</td></tr>\n</thead>\n<tbody>\n<tr><td>global</td><td>RegExp 对象是否具有标志 g。</td></tr>\n<tr><td>ignoreCase</td><td>RegExp 对象是否具有标志 i。</td></tr>\n<tr><td>lastIndex</td><td>一个整数，标示开始下一次匹配的字符位置。</td></tr>\n<tr><td>multiline</td><td>RegExp 对象是否具有标志 m。</td></tr>\n<tr><td>source</td><td>正则表达式的源文本。</td></tr>\n</tbody>\n</table>\n\n###### Regex.prototype.test\n\ntest() 方法用于检测一个字符串是否匹配某个模式。存在则返回true，否则返回false。表单验证时经常会用到。\n\n###### Regex.prototype.exec \n\n```\n// Match \"quick brown\" followed by \"jumps\", ignoring characters in between\n// Remember \"brown\" and \"jumps\"\n// Ignore case\nvar re = /quick\\s(brown).+?(jumps)/ig;\nvar result = re.exec('The Quick Brown Fox Jumps Over The Lazy Dog');\n```\n\n下面的表格展示这个脚本的返回值：\n<table>\n<thead>\n<tr>\n<td width=\"33%\">属性/索引</td>\n<td width=\"33%\">描述</td>\n<td>例子</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[0]</td><td>匹配的全部字符串</td><td>\tQuick Brown Fox Jumps</td>\n</tr>\n<tr>\n<td>[1], ...[n ]</td><td>括号中的分组捕获</td><td>\t[1] = Brown[2] = Jumps</td>\n</tr>\n<tr>\n<td>index</td><td>匹配到的字符位于原始字符串的基于0的索引值</td><td>4</td>\n</tr>\t\t\n<tr>\n<td>input</td><td>原始字符串</td><td>The Quick Brown Fox Jumps Over The Lazy Dog</td>\n</tr>\n</tbody>\n</table>\t\n\n全局模式下：它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。\n\n> 注意：如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串，就必须手动地把 lastIndex 属性重置为 0。\n\n###### String.prototype.match \n\n非全局模式：和Regex.prototype.exec返回的信息相同。\n\n全局模式：全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是 stringObject 中所有的匹配子串，而且也没有 index 属性或 input 属性。\n\n> 注意：在全局检索模式下，match() 即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的位置。如果您需要这些全局检索的信息，可以使用 RegExp.prototype.exec()。\n\n###### String.prototype.search\n\nsearch() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。\n\n###### String.prototype.replace\n\n字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。\nreplacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。\n\n但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换，也就是反向引用。\n\n###### String.prototype.split\n\n这个比较简单，举个例子吧：\n\n```\n'How are you doing today?'.split(/o/); //[\"H\", \"w are y\", \"u d\", \"ing t\", \"day?\"]\n```\n\n另外这个函数还接收第二个参数，表示数组的最大长度。\n\n##### es6正则扩展\n\n1、构造函数支持第一个参数为正则的同时，还可以使用修饰符参数。\n\n```\nvar regex = new RegExp(/xyz/, 'i');\n// ES5 Uncaught TypeError: Cannot supply flags when constructing one RegExp from another\n// ES6支持了这种写法\n```\n\n2、字符串的四个正则相关的方法定义在了Regex对象上。\n\n3、加入了u修饰符，含义为“Unicode模式”，用来正确处理大于\\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。\n\n4、加入了y修饰符，y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。\n\n```\nvar s = 'aaa_aa_a';\nvar r1 = /a+/g;\nvar r2 = /a+/y;\n\nr1.exec(s) // [\"aaa\"]\nr2.exec(s) // [\"aaa\"]\n\nr1.exec(s) // [\"aa\"]\nr2.exec(s) // null\n```\n\n5、正则对象增加了两个属性，flags和sticky。分别表示修饰符和是否设置y修饰符。\n\n##### es7正则扩展\n\n1、RegExp.escape()方法。\n\n2、加入后顾（反向预搜索）哈哈，迟早要支持的吧！\n\nes6和es7的部分只是列了一下，具体还是看阮一峰老师的[es6入门](http://es6.ruanyifeng.com/#docs/regex)。\n\n参考资料：\n\n1. [es6入门](http://es6.ruanyifeng.com/#docs/regex)\n2. [js正则表达式语法](http://blog.csdn.net/zaifendou/article/details/5746988)\n3. [将正则表达式图形化工具](https://regexper.com/)","html":"<p>这是之前欠下的，一直没空总结一下。看完剧，先把之前的总结了，在进行下一步的学习。在讲js的正则之前，先要讲一下正则的基本概念。结合一些例子，应该能快速了解吧！本文只能算扫盲加知识拓展性质，要熟练掌握，还是要靠多练！</p>\n\n<h4 id=\"\">基础</h4>\n\n<h5 id=\"\">字符</h5>\n\n<p>1、普通字符（单个字符）</p>\n\n<p>字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是\"普通字符\"。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。</p>\n\n<p>2、转义字符（单个字符）</p>\n\n<p>一些不便书写的字符，采用在前面加 \"\\\" 的方法。这些字符其实我们都已经熟知了。</p>\n\n<table>  \n<thead>  \n<tr>  \n<td width=\"20%\">表达式</td>  \n<td>可匹配</td>  \n</tr>  \n</thead>  \n<tbody>  \n<tr>  \n<td>\\r, \\n</td>  \n<td>代表回车和换行符</td>  \n</tr>  \n<tr>  \n<td>\\t</td>  \n<td>制表符</td>  \n</tr>  \n<tr>  \n<td>\\/</td>  \n<td>/本身</td>  \n</tr>  \n<tr>  \n<td>...</td>  \n<td>...</td>  \n</tr>  \n</tbody>  \n</table>\n\n<p>还有其他一些在后边章节中有特殊用处的标点符号，在前面加 \"\\\" 后，就代表该符号本身。比如：^，$ 都有特殊意义，如果要想匹配字符串中 \"^\" 和 \"$\" 字符，则表达式就需要写成 \"\\^\" 和 \"\\$\"。</p>\n\n<table>  \n<thead>  \n<tr>  \n<td width=\"20%\">表达式</td>  \n<td>可匹配</td>  \n</tr>  \n</thead>  \n<tbody>  \n<tr>  \n<td>\\^</td>  \n<td>匹配 ^ 符号本身</td>  \n</tr>  \n<tr>  \n<td>\\$</td>  \n<td>匹配 $ 符号本身</td>  \n</tr>  \n<tr>  \n<td>\\.</td>  \n<td>匹配小数点（.）本身</td>  \n</tr>  \n<tr>  \n<td>...</td>  \n<td>...</td>  \n</tr>  \n</tbody>  \n</table>\n\n<p>这些转义字符的匹配方法与 \"普通字符\" 是类似的。也是匹配与之相同的一个字符。</p>\n\n<p>3、自定义范围类（多个字符）</p>\n\n<p>上面两个匹配的都是单个字符，当我们需要匹配多个字符时，就可以用\"[]\"来表示一个范围，可以匹配范围内的任意字符，另外只匹配一个字符。</p>\n\n<table>  \n<thead>  \n<tr>  \n<td width=\"20%\">表达式</td>  \n<td>可匹配</td>  \n</tr>  \n</thead>  \n<tbody>  \n<tr>  \n<td>[ab5@]</td>  \n<td>匹配 \"a\" 或 \"b\" 或 \"5\" 或 \"@\"</td>  \n</tr>  \n<tr>  \n<td>[^abc]</td>  \n<td>匹配 \"a\",\"b\",\"c\" 之外的任意一个字符</td>  \n</tr>  \n<tr>  \n<td>[f-k]</td>  \n<td>匹配 \"f\"~\"k\" 之间的任意一个字母</td>  \n</tr>  \n<td>[^A-F0-3]</td>  \n<td>匹配 \"A\"~\"F\",\"0\"~\"3\" 之外的任意一个字符</td>  \n</tr>  \n<tr>  \n<td>...</td>  \n<td>...</td>  \n</tr>  \n</tbody>  \n</table>\n\n<p>4、预范围类（多个字符）</p>\n\n<p>除了上面的自定义的范围类，为了写起来比较方便，还有一些预定义的范围类。</p>\n\n<table>  \n<thead>  \n<tr>  \n<td width=\"20%\">表达式</td>  \n<td>可匹配</td>  \n</tr>  \n</thead>  \n<tbody>  \n<tr>  \n<td>\\d</td>  \n<td>任意一个数字，0~9 中的任意一个</td>  \n</tr>  \n<tr>  \n<td>\\w</td>  \n<td>任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个</td>  \n</tr>  \n<tr>  \n<td>\\s</td>  \n<td>包括空格、制表符、换页符等空白字符的其中任意一个</td>  \n</tr>  \n<td>.</td>  \n<td>小数点可以匹配除了换行符（\\n）以外的任意一个字符</td>  \n</tr>  \n<tr>  \n<td>...</td>  \n<td>...</td>  \n</tr>  \n</tbody>  \n</table>\n\n<h5 id=\"\">量词</h5>\n\n<p>上文的字符或者范围类匹配的都是原串中的一个字符，如果要重复匹配多次，则需要量词，主要有以下一些：</p>\n\n<table>  \n<thead>  \n<tr>  \n<td width=\"20%\">表达式</td>  \n<td>作用</td>  \n</tr>  \n</thead>  \n<tbody>  \n<tr>  \n<td>{n}</td>  \n<td>表达式重复n次，比如：\"\\w{2}\" 相当于 \"\\w\\w\"；\"a{5}\" 相当于 \"aaaaa\"</td>  \n</tr>  \n<tr>  \n<td>{m,n}</td>  \n<td>表达式至少重复m次，最多重复n次，比如：\"ba{1,3}\"可以匹配 \"ba\"或\"baa\"或\"baaa\"</td>  \n</tr>  \n<tr>  \n<td>{m,}</td>  \n<td>表达式至少重复m次，比如：\"\\w\\d{2,}\"可以匹配 \"a12\",\"_456\",\"M12344\"...</td>  \n</tr>  \n<tr>  \n<td>?</td>  \n<td>匹配表达式0次或者1次，相当于 {0,1}，比如：\"a[cd]?\"可以匹配 \"a\",\"ac\",\"ad\"</td>  \n</tr>  \n<tr>  \n<td>+</td>  \n<td>表达式至少出现1次，相当于 {1,}，比如：\"a+b\"可以匹配 \"ab\",\"aab\",\"aaab\"...</td>  \n</tr>  \n<tr>  \n<td>*</td>  \n<td>表达式不出现或出现任意次，相当于 {0,}，比如：\"\\^*b\"可以匹配 \"b\",\"^^^b\"...</td>  \n</tr>  \n</tbody>  \n</table>\n\n<h5 id=\"\">边界</h5>\n\n<p>我们经常要匹配文件名后缀，这时候我们就会用到边界匹配符号。当然匹配开头、单词边界都很常见。</p>\n\n<table>  \n<thead>  \n<tr>  \n<td width=\"20%\">表达式</td>  \n<td>作用</td>  \n</tr>  \n</thead>  \n<tbody>  \n<tr>  \n<td>^</td>  \n<td>与字符串开始的地方匹配，不匹配任何字符</td>  \n</tr>  \n<tr>  \n<td>$</td>  \n<td>与字符串结束的地方匹配，不匹配任何字符</td>  \n</tr>  \n<td>\\b</td>  \n<td>匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符</td>  \n</tr>  \n</tbody>  \n</table>\n\n<h5 id=\"\">分组</h5>\n\n<p>分组的符号是\"()\"，它的作用是在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰；并且取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到。</p>\n\n<p>另外还有一个\"|\"，用于表达两个表达式之间或的关系。</p>\n\n<h4 id=\"\">高级</h4>\n\n<h5 id=\"\">贪婪、非贪婪</h5>\n\n<p>量词在匹配的时候是不确定的，例如aaaaa匹配a{1,3}，可以匹配一到三次，但是如何选择呢？正则表达式默认规定是使用贪婪模式，也就是越多越好，尽量多地匹配。相反的还有一种非贪婪模式，要启用非贪婪模式只要在量词表达式之后跟上\"?\"即可。</p>\n\n<h5 id=\"\">反向引用</h5>\n\n<p>表达式在匹配时，表达式引擎会将小括号 \"( )\" 包含的表达式所匹配到的字符串记录下来。并且记录下来的字符串我们可以通过\"$1\"，\"$2\"的方式进行引用。举个例子，有电话号码13588884444，我们通常会把中间四位变成\"*\"，来保护用户信息，这用正则表达式来做很简单。</p>\n\n<pre><code>'13588884444'.replace(/(\\d{3})\\d{4}(\\d{4})/g, '$1****$2')  \n</code></pre>\n\n<p>上面的表达式将前三位和后四位分组，然后在替换的时候通过\"$1\"和\"$2\"进行反向引用，很神奇吧！</p>\n\n<h5 id=\"\">忽略分组</h5>\n\n<p>假设上面的例子如果我们把中间四位也进行分组，但是中间四位没有记录下来的必要，此时我们就可以忽略分组，用\"(?:)\"表达式。</p>\n\n<h5 id=\"\">前瞻后顾（正向预搜索、反向预搜索）</h5>\n\n<p>js目前只支持前瞻，所以只介绍前瞻了，后顾的道理是一样的。有的时候我们会有如下的需求，就是在匹配的时候，字符串的前后需要满足一定的要求。前瞻就是右边满足一定的要求，后顾就是左边满足一定的要求。例子如下：</p>\n\n<pre><code>'windows95,windows98,windows2000'.match(/windows(?=95|98)/g);//[\"windows\", \"windows\"]  \n</code></pre>\n\n<p>上面的表达式匹配要求匹配windows的同时，后边是95或98，匹配的结果也就是[\"windows\", \"windows\"]，可以看到条件是不会被匹配进结果的。</p>\n\n<h4 id=\"js\">js 中的正则</h4>\n\n<h5 id=\"es6\">es6之前</h5>\n\n<h6 id=\"\">创建正则表达式：</h6>\n\n<pre><code>// 构造函数\nvar regex = new RegExp('xyz', 'i');  \nvar regex = new RegExp(/xyz/i);  \nvar regex = new RegExp(/xyz/, 'i');//es6才支持  \n// 字面量\nvar regex = /xyz/i;  \n</code></pre>\n\n<h6 id=\"\">修饰符：</h6>\n\n<table>  \n<thead>  \n<tr><td width=\"20%\">修饰符</td><td>描述</td></tr>  \n</thead>  \n<tbody>  \n<tr><td>i</td><td>执行对大小写不敏感的匹配。</td></tr>  \n<tr><td>g</td><td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr>  \n<tr><td>m</td><td>执行多行匹配。</td></tr>  \n</tbody>  \n</table>\n\n<h6 id=\"regexp\">RegExp 对象属性：</h6>\n\n<table>  \n<thead>  \n<tr><td width=\"20%\">属性</td><td>描述</td></tr>  \n</thead>  \n<tbody>  \n<tr><td>global</td><td>RegExp 对象是否具有标志 g。</td></tr>  \n<tr><td>ignoreCase</td><td>RegExp 对象是否具有标志 i。</td></tr>  \n<tr><td>lastIndex</td><td>一个整数，标示开始下一次匹配的字符位置。</td></tr>  \n<tr><td>multiline</td><td>RegExp 对象是否具有标志 m。</td></tr>  \n<tr><td>source</td><td>正则表达式的源文本。</td></tr>  \n</tbody>  \n</table>\n\n<h6 id=\"regexprototypetest\">Regex.prototype.test</h6>\n\n<p>test() 方法用于检测一个字符串是否匹配某个模式。存在则返回true，否则返回false。表单验证时经常会用到。</p>\n\n<h6 id=\"regexprototypeexec\">Regex.prototype.exec</h6>\n\n<pre><code>// Match \"quick brown\" followed by \"jumps\", ignoring characters in between\n// Remember \"brown\" and \"jumps\"\n// Ignore case\nvar re = /quick\\s(brown).+?(jumps)/ig;  \nvar result = re.exec('The Quick Brown Fox Jumps Over The Lazy Dog');  \n</code></pre>\n\n<p>下面的表格展示这个脚本的返回值：</p>\n\n<table>  \n<thead>  \n<tr>  \n<td width=\"33%\">属性/索引</td>  \n<td width=\"33%\">描述</td>  \n<td>例子</td>  \n</tr>  \n</thead>  \n<tbody>  \n<tr>  \n<td>[0]</td><td>匹配的全部字符串</td><td>    Quick Brown Fox Jumps</td>  \n</tr>  \n<tr>  \n<td>[1], ...[n ]</td><td>括号中的分组捕获</td><td>    [1] = Brown[2] = Jumps</td>  \n</tr>  \n<tr>  \n<td>index</td><td>匹配到的字符位于原始字符串的基于0的索引值</td><td>4</td>  \n</tr>  \n<tr>  \n<td>input</td><td>原始字符串</td><td>The Quick Brown Fox Jumps Over The Lazy Dog</td>  \n</tr>  \n</tbody>  \n</table>    \n\n<p>全局模式下：它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。</p>\n\n<blockquote>\n  <p>注意：如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串，就必须手动地把 lastIndex 属性重置为 0。</p>\n</blockquote>\n\n<h6 id=\"stringprototypematch\">String.prototype.match</h6>\n\n<p>非全局模式：和Regex.prototype.exec返回的信息相同。</p>\n\n<p>全局模式：全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是 stringObject 中所有的匹配子串，而且也没有 index 属性或 input 属性。</p>\n\n<blockquote>\n  <p>注意：在全局检索模式下，match() 即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的位置。如果您需要这些全局检索的信息，可以使用 RegExp.prototype.exec()。</p>\n</blockquote>\n\n<h6 id=\"stringprototypesearch\">String.prototype.search</h6>\n\n<p>search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。</p>\n\n<h6 id=\"stringprototypereplace\">String.prototype.replace</h6>\n\n<p>字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。\nreplacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。</p>\n\n<p>但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换，也就是反向引用。</p>\n\n<h6 id=\"stringprototypesplit\">String.prototype.split</h6>\n\n<p>这个比较简单，举个例子吧：</p>\n\n<pre><code>'How are you doing today?'.split(/o/); //[\"H\", \"w are y\", \"u d\", \"ing t\", \"day?\"]  \n</code></pre>\n\n<p>另外这个函数还接收第二个参数，表示数组的最大长度。</p>\n\n<h5 id=\"es6\">es6正则扩展</h5>\n\n<p>1、构造函数支持第一个参数为正则的同时，还可以使用修饰符参数。</p>\n\n<pre><code>var regex = new RegExp(/xyz/, 'i');  \n// ES5 Uncaught TypeError: Cannot supply flags when constructing one RegExp from another\n// ES6支持了这种写法\n</code></pre>\n\n<p>2、字符串的四个正则相关的方法定义在了Regex对象上。</p>\n\n<p>3、加入了u修饰符，含义为“Unicode模式”，用来正确处理大于\\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</p>\n\n<p>4、加入了y修饰符，y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>\n\n<pre><code>var s = 'aaa_aa_a';  \nvar r1 = /a+/g;  \nvar r2 = /a+/y;\n\nr1.exec(s) // [\"aaa\"]  \nr2.exec(s) // [\"aaa\"]\n\nr1.exec(s) // [\"aa\"]  \nr2.exec(s) // null  \n</code></pre>\n\n<p>5、正则对象增加了两个属性，flags和sticky。分别表示修饰符和是否设置y修饰符。</p>\n\n<h5 id=\"es7\">es7正则扩展</h5>\n\n<p>1、RegExp.escape()方法。</p>\n\n<p>2、加入后顾（反向预搜索）哈哈，迟早要支持的吧！</p>\n\n<p>es6和es7的部分只是列了一下，具体还是看阮一峰老师的<a href=\"http://es6.ruanyifeng.com/#docs/regex\">es6入门</a>。</p>\n\n<p>参考资料：</p>\n\n<ol>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/regex\">es6入门</a>  </li>\n<li><a href=\"http://blog.csdn.net/zaifendou/article/details/5746988\">js正则表达式语法</a>  </li>\n<li><a href=\"https://regexper.com/\">将正则表达式图形化工具</a></li>\n</ol>","image":"/content/images/2016/09/QQ20160913-5-2x.png","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1473745279085,"created_by":1,"updated_at":1473757279089,"updated_by":1,"published_at":1473748641713,"published_by":1},{"id":63,"uuid":"6b0923c3-aa1a-4002-a4b9-1f2303870b36","title":"js 严格模式小结","slug":"js-yan-ge-mo-shi-xiao-jie","markdown":"大部分内容来自MDN，最后个人补充了一些，总结了一下使用严格模式的策略。在node6.2环境测试过程中发现严格模式在ES6可能有部分调整，想要了解的同学看[这里](http://www.ecma-international.org/ecma-262/6.0/#sec-strict-mode-of-ecmascript)，我暂时不去折腾了。\n\n#### 简介\n\n严格模式是ES5引入的一种限制性更强的变种方式。严格模式不是一个子集：它在语义上与正常代码有着明显的差异。不支持严格模式的浏览器与支持严格模式的浏览器行为上也不一样，所以不要在未经严格模式特性测试情况下使用严格模式。严格模式可以与非严格模式共存，所以脚本可以逐渐的选择性加入严格模式。\n\n严格模式在语义上与正常的JavaScript有一些不同。 首先，严格模式会将JavaScript陷阱直接变成明显的错误。其次，严格模式修正了一些引擎难以优化的错误：同样的代码有些时候严格模式会比非严格模式下更快。 第三，严格模式禁用了一些有可能在未来版本中定义的语法。\n\n#### 开启\n\n在全局或者函数或者eval代码块所有语句前中加入'use strict'，就这该作用域内开启了严格模式。\n\n#### 与正常模式的差别\n\n###### 将问题直接转化为错误（如语法错误或运行时错误，方便找错）\n\n1、 不通过var声明变量，不会变为全局变量，而是报错；\n```\n\"use strict\";\n                       // 假如有一个全局变量叫做mistypedVariable\nmistypedVaraible = 17; // 因为变量名拼写错误\n                       // 这一行代码就会抛出 ReferenceError\n```\n\n2、 给不可写属性赋值，给只读属性(getter-only)赋值赋值，给不可扩展对象(non-extensible object)的新属性赋值都会抛出异常；\n\n```\n\"use strict\";\n\n// 给不可写属性赋值\nvar obj1 = {};\nObject.defineProperty(obj1, \"x\", { value: 42, writable: false });\nobj1.x = 9; // 抛出TypeError错误\n\n// 给只读属性赋值\nvar obj2 = { get x() { return 17; } };\nobj2.x = 5; // 抛出TypeError错误\n\n// 给不可扩展对象的新属性赋值\nvar fixed = {};\nObject.preventExtensions(fixed);\nfixed.newProp = \"ohai\"; // 抛出TypeError错误\n```\n\n3、在严格模式下，试图删除不可删除的属性时会抛出异常；\n\n```\n\"use strict\";\ndelete Object.prototype; // 抛出TypeError错误\n```\n\n4、第四，在Gecko版本34之前，严格模式要求一个对象内的所有属性名在对象内必须唯一。正常模式下重名属性是允许的，最后一个重名的属性决定其属性值。因为只有最后一个属性起作用，当代码是要改变属性值而却不是修改的最后一个重名属性的时候，复制这个对象就产生一连串的bug。在严格模式下，重名属性被认为是语法错误：\n\n> 这个问题在ECMAScript6中已经不复存在([bug 1041128](https://bugzilla.mozilla.org/show_bug.cgi?id=1041128))。\n\n```\n\"use strict\";\nvar o = { p: 1, p: 2 }; // !!! 语法错误\n```\n\n5、严格模式要求函数的参数名唯一。在正常模式下，最后一个重名参数名会掩盖之前的重名参数。之前的参数仍然可以通过 arguments[i] 来访问，还不是完全无法访问。然而，这种隐藏毫无意义而且可能是意料之外的 (比如它可能本来是打错了)，所以在严格模式下重名参数被认为是语法错误：\n\n```\nfunction sum(a, a, c){ // !!! 语法错误\n  \"use strict\";\n  return a + b + c; // 代码运行到这里会出错\n}\n```\n\n6、严格模式禁止八进制数字语法。ECMAScript并不包含八进制语法，但所有的浏览器都支持这种以零(0)开头的八进制语法：0644 === 420 还有 \"\\045\" = = = \"%\"。有些新手开发者认为数字的前导零没有语法意义，所以他们会用作对齐措施 — 但其实这会改变数字的意义！八进制语法很少有用并且可能会错误使用，所以严格模式下八进制语法会引起语法错误：\n\n```\n\"use strict\";\nvar sum = 015 + // !!! 语法错误\n          197 +\n          142;\n```\n\n###### 简化变量的使用（禁用动态绑定，因为js引擎不能很好地优化）\n\n严格模式简化了代码中变量名字映射到变量定义的方式。很多编译器的优化是依赖存储变量X位置的能力：这对全面优化JavaScript代码至关重要。\n\n1、with的使用块内的任何名称可以映射(map)到with传进来的对象的属性，也可以映射到包围这个块的作用域内的变量(甚至是全局变量)，这一切都是在运行时决定的：在代码运行之前是无法得知的。造成的问题就是js引擎无法对with的代码块做出优化！\n\n```\n\"use strict\";\nvar x = 17;\nwith (obj) // !!! 语法错误\n{\n  // 如果没有开启严格模式，with中的这个x会指向with上面的那个x，还是obj.x？\n  // 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。\n  x;\n}\n```\n\n2、严格模式下的 eval 不再为上层范围(surrounding scope，注：包围eval代码块的范围)引入新变量。在正常模式下，代码 eval(\"var x;\") 会给上层函数(surrounding function)或者全局引入一个新的变量 x 。 这意味着，一般情况下，在一个包含 eval 调用的函数内所有没有引用到参数或者局部变量的名称都必须在运行时才能被映射到特定的定义 (因为 eval 可能引入的新变量会覆盖它的外层变量)。在严格模式下 eval 仅仅为被运行的代码创建变量，所以 eval 不会影响到名称映射到外部变量或者其他局部变量：\n\n```\nvar x = 17;\nvar evalX = eval(\"'use strict'; var x = 42; x\");\nassert(x === 17);\nassert(evalX === 42);\n```\n\n相应的，如果函数 eval 被在被严格模式下的eval(...)以表达式的形式调用时，其代码会被当做严格模式下的代码执行。当然也可以在代码中显式开启严格模式，但这样做并不是必须的。\n\n3、严格模式禁止删除声明变量。delete name 在严格模式下会引起语法错误：\n\n```\n\"use strict\";\nvar x;\ndelete x; // !!! 语法错误\neval(\"var x; delete x;\"); // !!! 语法错误\n```\n\n###### 让eval和arguments变的简单（减少出错的机会）\n\n1、名称 eval 和 arguments 不能通过程序语法被绑定(be bound)或赋值。以下的所有尝试将引起语法错误：\n\n```\n\"use strict\";\neval = 17;\narguments++;\n++eval;\nvar obj = { set p(arguments) { } };\nvar eval;\ntry { } catch (arguments) { }\nfunction x(eval) { }\nfunction arguments() { }\nvar y = function eval() { };\nvar f = new Function(\"arguments\", \"'use strict'; return 17;\");\n```\n\n2、严格模式下，参数的值不会随 arguments 对象的值的改变而变化。在正常模式下，对于第一个参数是 arg 的函数，对 arg 赋值时会同时赋值给 arguments[0]，反之亦然（除非没有参数，或者 arguments[0] 被删除）。严格模式下，函数的 arguments 对象会保存函数被调用时的原始参数。arguments[i] 的值不会随与之相应的参数的值的改变而变化，同名参数的值也不会随与之相应的 arguments[i] 的值的改变而变化。\n\n```\nfunction f(a)\n{\n  \"use strict\";\n  a = 42;\n  return [a, arguments[0]];//[42,17]严格模式下未发生绑定\n}\nvar pair = f(17);\nconsole.assert(pair[0] === 42);\nconsole.assert(pair[1] === 17);\n```\n\n第三，不再支持 arguments.callee。正常模式下，arguments.callee 指向当前正在执行的函数。这个作用很小：直接给执行函数命名就可以了！此外，arguments.callee 十分不利于优化，例如内联函数，因为 arguments.callee 会依赖对非内联函数的引用。在严格模式下，arguments.callee 是一个不可删除属性，而且赋值和读取时都会抛出异常：\n\n```\n\"use strict\";\nvar f = function() { return arguments.callee; };\nf(); // 抛出类型错误\n```\n\n###### 消除代码运行的一些不安全之处\n\n1、禁止this关键字指向全局对象；\n\n2、第一，在严格模式下通过this传递给一个函数的值不会被强制转换为一个对象；\n\n3、禁止在函数内部遍历调用栈。在普通模式下用这些扩展的话，当一个叫fun的函数正在被调用的时候，fun.caller是最后一个调用fun的函数，而且fun.arguments包含调用fun时用的形参。这两个扩展接口对于“安全”JavaScript而言都是有问题的，因为他们允许“安全的”代码访问\"专有\"函数和他们的（通常是没有经过保护的）形参。如果fun在严格模式下，那么fun.caller和fun.arguments都是不可删除的属性而且在存值、取值时都会报错：\n\n4、严格模式下的arguments不会再提供访问与调用这个函数相关的变量的途径。\n\n###### 为未来的ECMAScript版本铺平道路\n\n1、将implements, interface, let, package, private, protected, public, static和yield作为了保留的关键词，事实也证明是对的，let、static、yield已经出现在了ES6中。\n\n2、严格模式禁止了不在脚本或者函数层面上的函数声明。在浏览器的普通代码中，在“所有地方”的函数声明都是合法的。这并不在ES5规范中（甚至是ES3）！这是一种针对不同浏览器中不同语义的一种延伸。未来的ECMAScript版本很有希望制定一个新的，针对不在脚本函数层面进行函数声明的语法。在严格模式下禁止这样的函数声明对于将来ECMAScript版本的推出扫清了障碍。(测试在node6.2中启用严格模式，在块级作用域内声明函数没有报错，这与阮老师es6入门中描述的不符，个人猜测应该是严格模式在ES6做了调整)。\n\n#### 副作用\n\n1、兼容性，市场上仍然有大量的浏览器版本只部分支持严格模式或者根本就不支持（比如IE10之前的版本），在不支持的浏览器上会把'use strict'当做普通字符串；\n\n2、在为整个script标签开启严格模式后，如果合并开启严格模式的代码和未开启严格模式的代码时便会出现问题。\n\n#### 使用策略\n\n看了下Angular、Vue、Jquery都是在自执行函数内部开启了严格模式，这种方式可以解决合并代码的问题，另外也浏览了阿里云、知乎等网站，都没有在整个script范围启用严格模式，只是部分文件启用，启用的方式都是在匿名自执行函数之内，所以就目前来说在函数级别开启严格模式是比较好的做法，即使要在整个脚本开启，也建议把脚本代码包进自执行的函数内部。\n\n#### 小结\n\n为了能够写出更加安全、可调式的代码，从现在开始开启严格模式吧！\n\n参考资料：\n\n1.[MDN 严格模式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)\n2.[Javascript 严格模式详解](http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html)","html":"<p>大部分内容来自MDN，最后个人补充了一些，总结了一下使用严格模式的策略。在node6.2环境测试过程中发现严格模式在ES6可能有部分调整，想要了解的同学看<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-strict-mode-of-ecmascript\">这里</a>，我暂时不去折腾了。</p>\n\n<h4 id=\"\">简介</h4>\n\n<p>严格模式是ES5引入的一种限制性更强的变种方式。严格模式不是一个子集：它在语义上与正常代码有着明显的差异。不支持严格模式的浏览器与支持严格模式的浏览器行为上也不一样，所以不要在未经严格模式特性测试情况下使用严格模式。严格模式可以与非严格模式共存，所以脚本可以逐渐的选择性加入严格模式。</p>\n\n<p>严格模式在语义上与正常的JavaScript有一些不同。 首先，严格模式会将JavaScript陷阱直接变成明显的错误。其次，严格模式修正了一些引擎难以优化的错误：同样的代码有些时候严格模式会比非严格模式下更快。 第三，严格模式禁用了一些有可能在未来版本中定义的语法。</p>\n\n<h4 id=\"\">开启</h4>\n\n<p>在全局或者函数或者eval代码块所有语句前中加入'use strict'，就这该作用域内开启了严格模式。</p>\n\n<h4 id=\"\">与正常模式的差别</h4>\n\n<h6 id=\"\">将问题直接转化为错误（如语法错误或运行时错误，方便找错）</h6>\n\n<p>1、 不通过var声明变量，不会变为全局变量，而是报错；  </p>\n\n<pre><code>\"use strict\";\n                       // 假如有一个全局变量叫做mistypedVariable\nmistypedVaraible = 17; // 因为变量名拼写错误  \n                       // 这一行代码就会抛出 ReferenceError\n</code></pre>\n\n<p>2、 给不可写属性赋值，给只读属性(getter-only)赋值赋值，给不可扩展对象(non-extensible object)的新属性赋值都会抛出异常；</p>\n\n<pre><code>\"use strict\";\n\n// 给不可写属性赋值\nvar obj1 = {};  \nObject.defineProperty(obj1, \"x\", { value: 42, writable: false });  \nobj1.x = 9; // 抛出TypeError错误\n\n// 给只读属性赋值\nvar obj2 = { get x() { return 17; } };  \nobj2.x = 5; // 抛出TypeError错误\n\n// 给不可扩展对象的新属性赋值\nvar fixed = {};  \nObject.preventExtensions(fixed);  \nfixed.newProp = \"ohai\"; // 抛出TypeError错误  \n</code></pre>\n\n<p>3、在严格模式下，试图删除不可删除的属性时会抛出异常；</p>\n\n<pre><code>\"use strict\";\ndelete Object.prototype; // 抛出TypeError错误  \n</code></pre>\n\n<p>4、第四，在Gecko版本34之前，严格模式要求一个对象内的所有属性名在对象内必须唯一。正常模式下重名属性是允许的，最后一个重名的属性决定其属性值。因为只有最后一个属性起作用，当代码是要改变属性值而却不是修改的最后一个重名属性的时候，复制这个对象就产生一连串的bug。在严格模式下，重名属性被认为是语法错误：</p>\n\n<blockquote>\n  <p>这个问题在ECMAScript6中已经不复存在(<a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1041128\">bug 1041128</a>)。</p>\n</blockquote>\n\n<pre><code>\"use strict\";\nvar o = { p: 1, p: 2 }; // !!! 语法错误  \n</code></pre>\n\n<p>5、严格模式要求函数的参数名唯一。在正常模式下，最后一个重名参数名会掩盖之前的重名参数。之前的参数仍然可以通过 arguments[i] 来访问，还不是完全无法访问。然而，这种隐藏毫无意义而且可能是意料之外的 (比如它可能本来是打错了)，所以在严格模式下重名参数被认为是语法错误：</p>\n\n<pre><code>function sum(a, a, c){ // !!! 语法错误  \n  \"use strict\";\n  return a + b + c; // 代码运行到这里会出错\n}\n</code></pre>\n\n<p>6、严格模式禁止八进制数字语法。ECMAScript并不包含八进制语法，但所有的浏览器都支持这种以零(0)开头的八进制语法：0644 === 420 还有 \"\\045\" = = = \"%\"。有些新手开发者认为数字的前导零没有语法意义，所以他们会用作对齐措施 — 但其实这会改变数字的意义！八进制语法很少有用并且可能会错误使用，所以严格模式下八进制语法会引起语法错误：</p>\n\n<pre><code>\"use strict\";\nvar sum = 015 + // !!! 语法错误  \n          197 +\n          142;\n</code></pre>\n\n<h6 id=\"js\">简化变量的使用（禁用动态绑定，因为js引擎不能很好地优化）</h6>\n\n<p>严格模式简化了代码中变量名字映射到变量定义的方式。很多编译器的优化是依赖存储变量X位置的能力：这对全面优化JavaScript代码至关重要。</p>\n\n<p>1、with的使用块内的任何名称可以映射(map)到with传进来的对象的属性，也可以映射到包围这个块的作用域内的变量(甚至是全局变量)，这一切都是在运行时决定的：在代码运行之前是无法得知的。造成的问题就是js引擎无法对with的代码块做出优化！</p>\n\n<pre><code>\"use strict\";\nvar x = 17;  \nwith (obj) // !!! 语法错误  \n{\n  // 如果没有开启严格模式，with中的这个x会指向with上面的那个x，还是obj.x？\n  // 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。\n  x;\n}\n</code></pre>\n\n<p>2、严格模式下的 eval 不再为上层范围(surrounding scope，注：包围eval代码块的范围)引入新变量。在正常模式下，代码 eval(\"var x;\") 会给上层函数(surrounding function)或者全局引入一个新的变量 x 。 这意味着，一般情况下，在一个包含 eval 调用的函数内所有没有引用到参数或者局部变量的名称都必须在运行时才能被映射到特定的定义 (因为 eval 可能引入的新变量会覆盖它的外层变量)。在严格模式下 eval 仅仅为被运行的代码创建变量，所以 eval 不会影响到名称映射到外部变量或者其他局部变量：</p>\n\n<pre><code>var x = 17;  \nvar evalX = eval(\"'use strict'; var x = 42; x\");  \nassert(x === 17);  \nassert(evalX === 42);  \n</code></pre>\n\n<p>相应的，如果函数 eval 被在被严格模式下的eval(...)以表达式的形式调用时，其代码会被当做严格模式下的代码执行。当然也可以在代码中显式开启严格模式，但这样做并不是必须的。</p>\n\n<p>3、严格模式禁止删除声明变量。delete name 在严格模式下会引起语法错误：</p>\n\n<pre><code>\"use strict\";\nvar x;  \ndelete x; // !!! 语法错误  \neval(\"var x; delete x;\"); // !!! 语法错误  \n</code></pre>\n\n<h6 id=\"evalarguments\">让eval和arguments变的简单（减少出错的机会）</h6>\n\n<p>1、名称 eval 和 arguments 不能通过程序语法被绑定(be bound)或赋值。以下的所有尝试将引起语法错误：</p>\n\n<pre><code>\"use strict\";\neval = 17;  \narguments++;  \n++eval;\nvar obj = { set p(arguments) { } };  \nvar eval;  \ntry { } catch (arguments) { }  \nfunction x(eval) { }  \nfunction arguments() { }  \nvar y = function eval() { };  \nvar f = new Function(\"arguments\", \"'use strict'; return 17;\");  \n</code></pre>\n\n<p>2、严格模式下，参数的值不会随 arguments 对象的值的改变而变化。在正常模式下，对于第一个参数是 arg 的函数，对 arg 赋值时会同时赋值给 arguments[0]，反之亦然（除非没有参数，或者 arguments[0] 被删除）。严格模式下，函数的 arguments 对象会保存函数被调用时的原始参数。arguments[i] 的值不会随与之相应的参数的值的改变而变化，同名参数的值也不会随与之相应的 arguments[i] 的值的改变而变化。</p>\n\n<pre><code>function f(a)  \n{\n  \"use strict\";\n  a = 42;\n  return [a, arguments[0]];//[42,17]严格模式下未发生绑定\n}\nvar pair = f(17);  \nconsole.assert(pair[0] === 42);  \nconsole.assert(pair[1] === 17);  \n</code></pre>\n\n<p>第三，不再支持 arguments.callee。正常模式下，arguments.callee 指向当前正在执行的函数。这个作用很小：直接给执行函数命名就可以了！此外，arguments.callee 十分不利于优化，例如内联函数，因为 arguments.callee 会依赖对非内联函数的引用。在严格模式下，arguments.callee 是一个不可删除属性，而且赋值和读取时都会抛出异常：</p>\n\n<pre><code>\"use strict\";\nvar f = function() { return arguments.callee; };  \nf(); // 抛出类型错误  \n</code></pre>\n\n<h6 id=\"\">消除代码运行的一些不安全之处</h6>\n\n<p>1、禁止this关键字指向全局对象；</p>\n\n<p>2、第一，在严格模式下通过this传递给一个函数的值不会被强制转换为一个对象；</p>\n\n<p>3、禁止在函数内部遍历调用栈。在普通模式下用这些扩展的话，当一个叫fun的函数正在被调用的时候，fun.caller是最后一个调用fun的函数，而且fun.arguments包含调用fun时用的形参。这两个扩展接口对于“安全”JavaScript而言都是有问题的，因为他们允许“安全的”代码访问\"专有\"函数和他们的（通常是没有经过保护的）形参。如果fun在严格模式下，那么fun.caller和fun.arguments都是不可删除的属性而且在存值、取值时都会报错：</p>\n\n<p>4、严格模式下的arguments不会再提供访问与调用这个函数相关的变量的途径。</p>\n\n<h6 id=\"ecmascript\">为未来的ECMAScript版本铺平道路</h6>\n\n<p>1、将implements, interface, let, package, private, protected, public, static和yield作为了保留的关键词，事实也证明是对的，let、static、yield已经出现在了ES6中。</p>\n\n<p>2、严格模式禁止了不在脚本或者函数层面上的函数声明。在浏览器的普通代码中，在“所有地方”的函数声明都是合法的。这并不在ES5规范中（甚至是ES3）！这是一种针对不同浏览器中不同语义的一种延伸。未来的ECMAScript版本很有希望制定一个新的，针对不在脚本函数层面进行函数声明的语法。在严格模式下禁止这样的函数声明对于将来ECMAScript版本的推出扫清了障碍。(测试在node6.2中启用严格模式，在块级作用域内声明函数没有报错，这与阮老师es6入门中描述的不符，个人猜测应该是严格模式在ES6做了调整)。</p>\n\n<h4 id=\"\">副作用</h4>\n\n<p>1、兼容性，市场上仍然有大量的浏览器版本只部分支持严格模式或者根本就不支持（比如IE10之前的版本），在不支持的浏览器上会把'use strict'当做普通字符串；</p>\n\n<p>2、在为整个script标签开启严格模式后，如果合并开启严格模式的代码和未开启严格模式的代码时便会出现问题。</p>\n\n<h4 id=\"\">使用策略</h4>\n\n<p>看了下Angular、Vue、Jquery都是在自执行函数内部开启了严格模式，这种方式可以解决合并代码的问题，另外也浏览了阿里云、知乎等网站，都没有在整个script范围启用严格模式，只是部分文件启用，启用的方式都是在匿名自执行函数之内，所以就目前来说在函数级别开启严格模式是比较好的做法，即使要在整个脚本开启，也建议把脚本代码包进自执行的函数内部。</p>\n\n<h4 id=\"\">小结</h4>\n\n<p>为了能够写出更加安全、可调式的代码，从现在开始开启严格模式吧！</p>\n\n<p>参考资料：</p>\n\n<p>1.<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\">MDN 严格模式</a> <br />\n2.<a href=\"http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html\">Javascript 严格模式详解</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1473817012014,"created_by":1,"updated_at":1474782745577,"updated_by":1,"published_at":1473834551640,"published_by":1},{"id":64,"uuid":"462dd77c-e983-4dc6-8f4c-7cb8eaaae5d2","title":"为了N","slug":"wei-liao-n","markdown":"下面那篇可执行代码与执行环境写得我心力交瘁，所以先休息下写点关于前几天看的《为了N》这本书或者这部日剧的一些东西，算不上是影评或书评。写完插音乐时发现只要把网易外链的http改成https音乐就能播放了，副作用是chrome绿色的锁没了。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=30798011&auto=1&height=66\"></iframe>\n\n之前哪一篇来着，讲着去了浙江图书馆。也就是那天，办了张卡，借了几本书回来，其中就有凑佳苗的《为了N》，就是写《告白》那个，电影版是松隆子演的。花了两天吧，把小说看完了，但是还是不过瘾，于是找来了改编的剧，也是一天刷完。感觉改编的还不错，大部分还原了小说，并在小说的基础上加入了警察夫妇这一对，来推进剧情，对于小说中没有交代的一些东西，编剧也还算合理地做了交代。\n\nN是什么，杉下的N是成濑和安腾；成濑的N是杉下；安腾的N是杉下；西崎的N是奈央子；奈央子的N是野口；警察的N是他妻子；他妻子的N则是他（不是成濑父亲哈）；野口呢，也许没有N，硬是要说的话就是奈央子了。\n\nN在剧中是每个人的姓氏开头的字母，也是每个人最重要的人。杉下为了成濑共有罪行；杉下为了安腾则不让他陷入N计划；西崎为了奈央子则打算去救他；奈央子为了野口和杉下分开（本来也没在一起）则向西崎求救；警察为了妻子，调查14年前的火灾；妻子为了警察保守秘密14年。这里的每一个人都有自己要守护的东西，也是这份东西在潜移默化的改变着他们，朝着或好或坏的方向上不断前行。\n\n就是这么一种每个人都可能拥有的东西，用戏剧化的方式表达出来，让我们产生深深地共鸣。最后杉下和母亲和好了、警察妻子能够说话了、杉下回到了岛上；安腾继续为着当初的梦想努力；西崎开始找工作了；成濑在岛上有了店...为了N还在继续，留下的是美好的当下。\n\n不管从前如何，记得不忘初衷，为了N努力向上吧！为来就是那个样子的，闪闪发光！がんばって，加油！\n\n![](https://ws4.sinaimg.cn/large/006bH5BKgw1f7u7i9mb6mj30g4094q38.jpg)\n\n![](https://ws4.sinaimg.cn/large/006bH5BKgw1f7u7gfg2oij30g4092aad.jpg)\n\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f7u7ioojb1j30g40923yu.jpg)\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f7u7hs6e92j30g4092t8y.jpg)","html":"<p>下面那篇可执行代码与执行环境写得我心力交瘁，所以先休息下写点关于前几天看的《为了N》这本书或者这部日剧的一些东西，算不上是影评或书评。写完插音乐时发现只要把网易外链的http改成https音乐就能播放了，副作用是chrome绿色的锁没了。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=30798011&auto=1&height=66\"></iframe>\n\n<p>之前哪一篇来着，讲着去了浙江图书馆。也就是那天，办了张卡，借了几本书回来，其中就有凑佳苗的《为了N》，就是写《告白》那个，电影版是松隆子演的。花了两天吧，把小说看完了，但是还是不过瘾，于是找来了改编的剧，也是一天刷完。感觉改编的还不错，大部分还原了小说，并在小说的基础上加入了警察夫妇这一对，来推进剧情，对于小说中没有交代的一些东西，编剧也还算合理地做了交代。</p>\n\n<p>N是什么，杉下的N是成濑和安腾；成濑的N是杉下；安腾的N是杉下；西崎的N是奈央子；奈央子的N是野口；警察的N是他妻子；他妻子的N则是他（不是成濑父亲哈）；野口呢，也许没有N，硬是要说的话就是奈央子了。</p>\n\n<p>N在剧中是每个人的姓氏开头的字母，也是每个人最重要的人。杉下为了成濑共有罪行；杉下为了安腾则不让他陷入N计划；西崎为了奈央子则打算去救他；奈央子为了野口和杉下分开（本来也没在一起）则向西崎求救；警察为了妻子，调查14年前的火灾；妻子为了警察保守秘密14年。这里的每一个人都有自己要守护的东西，也是这份东西在潜移默化的改变着他们，朝着或好或坏的方向上不断前行。</p>\n\n<p>就是这么一种每个人都可能拥有的东西，用戏剧化的方式表达出来，让我们产生深深地共鸣。最后杉下和母亲和好了、警察妻子能够说话了、杉下回到了岛上；安腾继续为着当初的梦想努力；西崎开始找工作了；成濑在岛上有了店...为了N还在继续，留下的是美好的当下。</p>\n\n<p>不管从前如何，记得不忘初衷，为了N努力向上吧！为来就是那个样子的，闪闪发光！がんばって，加油！</p>\n\n<p><img src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f7u7i9mb6mj30g4094q38.jpg\" alt=\"\" /></p>\n\n<p><img src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f7u7gfg2oij30g4092aad.jpg\" alt=\"\" /></p>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f7u7ioojb1j30g40923yu.jpg\" alt=\"\" /></p>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f7u7hs6e92j30g4092t8y.jpg\" alt=\"\" /></p>","image":"/content/images/2016/09/418faf2ddd1f5c03bc9c2c93acbcab93.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1473898791496,"created_by":1,"updated_at":1474242566946,"updated_by":1,"published_at":1473917132919,"published_by":1},{"id":65,"uuid":"3596cf79-d838-43af-9f5d-c87de225bd29","title":"随笔","slug":"sui-bi-3","markdown":"早上八点到晚上八点了，快看不下去了，边上这群人真是啊，不会累吗？这样想想当初如果选保研还挺划算，哈哈！\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=26619498&auto=1&height=66\"></iframe>\n\n这几天的收获还挺大的，基本弄清楚了js的执行环境，顺带还把相关的this、作用域链等知识一起解决了，不过这些本来就是一整块的知识。现在看着一段js代码，差不多都能把它在解释器里的样子看出来了，是不是疯了😝。\n\n今天Angular2最终的release版出了，本来想玩玩的，可惜最近没这么多精力了，而且看上去这玩意也不必1的时候简单，就先放放吧，等把手头的东西搞完。\n\n听了一个晚上优叔的歌，顺带原型链开了个头，给人力量啊！这声音！！！！还能写些什么呢？奥，最近的作息算是调整过来了，十点多一点睡，早上7点左右准时起，白天也不会困，挺好！\n\n就是这雨天有点讨厌，跑步的计划泡汤了！！！昨天淘宝了把伞，看样子伞到的时候雨就没了。🙄\n\n瞎扯这么多了，差不多了，军哥哥我们回去吧！\n\n","html":"<p>早上八点到晚上八点了，快看不下去了，边上这群人真是啊，不会累吗？这样想想当初如果选保研还挺划算，哈哈！</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=26619498&auto=1&height=66\"></iframe>\n\n<p>这几天的收获还挺大的，基本弄清楚了js的执行环境，顺带还把相关的this、作用域链等知识一起解决了，不过这些本来就是一整块的知识。现在看着一段js代码，差不多都能把它在解释器里的样子看出来了，是不是疯了😝。</p>\n\n<p>今天Angular2最终的release版出了，本来想玩玩的，可惜最近没这么多精力了，而且看上去这玩意也不必1的时候简单，就先放放吧，等把手头的东西搞完。</p>\n\n<p>听了一个晚上优叔的歌，顺带原型链开了个头，给人力量啊！这声音！！！！还能写些什么呢？奥，最近的作息算是调整过来了，十点多一点睡，早上7点左右准时起，白天也不会困，挺好！</p>\n\n<p>就是这雨天有点讨厌，跑步的计划泡汤了！！！昨天淘宝了把伞，看样子伞到的时候雨就没了。🙄</p>\n\n<p>瞎扯这么多了，差不多了，军哥哥我们回去吧！</p>","image":"/content/images/2016/09/0b2833ae9667c4cb849b2cb45cd18ef8.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474027770176,"created_by":1,"updated_at":1474028765525,"updated_by":1,"published_at":1474028765526,"published_by":1},{"id":66,"uuid":"fd2bc94b-51ee-4120-beb0-12318e43f98c","title":"函数定义","slug":"han-shu-ding-yi","markdown":"之前转过一篇关于函数声明和函数表达式的文章，今天在研究对象系统的时候，反复地遇到了函数对象这个东西，而且在《可执行代码执行环境一文中》也略过了函数绑定那里部分，所以顺便就把ES5的函数定义这一章看了一遍，应该能够有比较大的收获，以下是规范加上一些个人理解。\n\n#### 语法\n\n```\n// 函数声明\nFunctionDeclaration : function Identifier ( FormalParameterList(可选) ) { FunctionBody } \n```\n\n```\n// 函数表达式 \nFunctionExpression : function Identifier(可选) ( FormalParameterList(可选) ) { FunctionBody } \n```\n\n```\nFormalParameterList : Identifier FormalParameterList , Identifier\n```\n\n```\nFunctionBody : SourceElements(可选)\n```\n\n#### 语义\n\n`FunctionDeclaration : function Identifier ( FormalParameterListopt ) { FunctionBody }`（函数声明）被如下实例化（绑定阶段）：\n\n1. 依照下文函数对象创建一节，指定 FormalParameterListopt 为参数，指定 FunctionBody 为 body，创建一个新函数对象，返回结果。运行中的执行环境的 VariableEnvironment 传递作为 Scope。如果 FunctionDeclaration 包含在严格模式代码里或 FunctionBody 是严格模式代码，那么传递 true 为 Strict 标志。\n\n`FunctionExpression : function ( FormalParameterListopt ) { FunctionBody }`（匿名函数表达式）被如下评估（执行阶段）：\n\n1. 同上，除了传递给 Scope 的是 LexicalEnvironment，而不是VariableEnvironment。\n\n这也就是为什么函数声明会影响变量环境而函数表达式不会的原因了吧！\n\n`FunctionExpression : function Identifier ( FormalParameterListopt ) { FunctionBody }`（具名函数表达式）被如下评估（执行阶段）：\n\n1. 令 funcEnv 为以运行中执行环境的 Lexical Environment 为参数调用 NewDeclarativeEnvironment 的结果。\n2. 令 envRec 为 funcEnv 的环境记录项。\n3. 以 Identifier 的字符串值为参数调用 envRec 的具体方法 CreateImmutableBinding(N)。\n4. 令 closure 为依照下文函数对象创建一节，指定 FormalParameterListopt 为参数，指定 FunctionBody 为 body，创建一个新函数对象的结果。传递 funcEnv 为 Scope。如果 FunctionExpression 包含在严格模式代码 里或 FunctionBody 是严格模式代码，那么传递 true 为 Strict 标志。\n5. 以 Identifier 的字符串值和 closure 为参数调用 envRec 的具体方法 InitializeImmutableBinding(N,V)。\n6. 返回 closure。\n\n这个很重要，具名函数表达式执行前创建了一个新的词法环境在栈顶，然后把具名函数表达式创建的函数对象设置到这个新的词法环境上，并且是不变的。\n\n#### 严格模式的限制\n\n> 这在之前的严格模式一文中已经提到，但是结合《可执行代码和执行环境》一文，在绑定上下文的步骤中提到arguments会被函数声明和变量声明覆盖，这明显是一个错误，在严格模式下有以下的限制，个人觉得很有必要。而下面的第一条限制在绑定上下文的参数初始化中也是有提现的。\n\n* 如果严格模式 FunctionDeclaration 或 FunctionExpression 的 FormalParameterList 里出现多个相同 Identifier 值，那么这是个 SyntaxError。\n\n* 如果严格模式 FunctionDeclaration 或 FunctionExpression 的 FormalParameterList 里出现标识符 \"eval\" 或标识符 \"arguments\"，那么这是个 SyntaxError。\n\n* 如果严格模式 FunctionDeclaration 或 FunctionExpression 的 Identifier 是标识符 \"eval\" 或标识符 \"arguments\"，那么这是个 SyntaxError。\n\n#### 创建函数对象\n\n指定 FormalParameterList 为可选参数列表，指定 FunctionBody 为函数体，指定 Scope 为 词法环境 ，Strict 为布尔标记，按照如下步骤构建函数对象：\n\n1. 创建一个新的 ECMAScript 原生对象，令 F 为此对象。\n2. 依照 8.12 描述设定 F 的除 [[Get]] 以外的所有内部方法。\n3. 设定 F 的 [[Class]] 内部属性为 \"Function\"。\n4. 设定 F 的 [[Prototype]] 内部属性为 15.3.3.1 指定的标准内置 Function 对象的 prototype 属性。\n5. 依照 15.3.5.4 描述，设定 F 的 [[Get]] 内部属性。\n6. 依照 13.2.1 描述，设定 F 的 [[Call]] 内部属性。\n7. 依照 13.2.2 描述，设定 F 的 [[Construct]] 内部属性。\n8. 依照 15.3.5.3 描述，设定 F 的 [[HasInstance]] 内部属性。\n9. 设定 F 的 [[Scope]] 内部属性为 Scope 的值。\n10. 令 names 为一个列表容器，其中元素是以从左到右的文本顺序对应 FormalParameterList 的标识符的字符串。\n11. 设定 F 的 [[FormalParameters]] 内部属性为 names。\n12. 设定 F 的 [[Code]] 内部属性为 FunctionBody。\n13. 设定 F 的 [[Extensible]] 内部属性为 true。\n14. 令 len 为 FormalParameterList 指定的形式参数的个数。如果没有指定参数，则令 len 为 0。\n15. 以参数 \"length\"，属性描述符 {[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}，false 调用 F 的 [[DefineOwnProperty]] 内部方法。\n16. 令 proto 为仿佛使用 new Object() 表达式创建新对象的结果，其中 Object 是标准内置构造器名。\n17. 以参数 \"constructor\", 属性描述符 {[[Value]]: F, { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}, false 调用 proto 的 [[DefineOwnProperty]] 内部方法。\n18. 以参数 \"prototype\", 属性描述符 {[[Value]]: proto, { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}, false 调用 F 的 [[DefineOwnProperty]] 内部方法。\n19. 如果 Strict 是 true，则\n 1. 令 thrower 为 [[ThrowTypeError]] 函数对象 (13.2.3)。\n 2. 以参数 \"caller\", 属性描述符 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, false 调用 F 的 [[DefineOwnProperty]] 内部方法。\n 3. 以参数 \"caller\", 属性描述符 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, false 调用 F 的 [[DefineOwnProperty]] 内部方法。\n20. 返回 F。\n\n> 每个函数都会自动创建一个 prototype 属性，以满足函数会被当作构造器的可能性。\n\n好像木有什么卵用，就是设置了一些内部属性。这就尴尬了！！！函数对象好像也没有什么特别的，除了指定了内部[[Prototype]]是Function.prototype，然后新建了一个内部对象，并设置了一个唯一的属性constructor指向函数本身，然后把这个内部对象设置到了函数对象的prototype属性上了。\n\n好像又有点意思了，因为和对象系统的内容接上了！！！可以滚去看对象系统了。😝\n\n\n\n","html":"<p>之前转过一篇关于函数声明和函数表达式的文章，今天在研究对象系统的时候，反复地遇到了函数对象这个东西，而且在《可执行代码执行环境一文中》也略过了函数绑定那里部分，所以顺便就把ES5的函数定义这一章看了一遍，应该能够有比较大的收获，以下是规范加上一些个人理解。</p>\n\n<h4 id=\"\">语法</h4>\n\n<pre><code>// 函数声明\nFunctionDeclaration : function Identifier ( FormalParameterList(可选) ) { FunctionBody }  \n</code></pre>\n\n<pre><code>// 函数表达式 \nFunctionExpression : function Identifier(可选) ( FormalParameterList(可选) ) { FunctionBody }  \n</code></pre>\n\n<pre><code>FormalParameterList : Identifier FormalParameterList , Identifier  \n</code></pre>\n\n<pre><code>FunctionBody : SourceElements(可选)  \n</code></pre>\n\n<h4 id=\"\">语义</h4>\n\n<p><code>FunctionDeclaration : function Identifier ( FormalParameterListopt ) { FunctionBody }</code>（函数声明）被如下实例化（绑定阶段）：</p>\n\n<ol>\n<li>依照下文函数对象创建一节，指定 FormalParameterListopt 为参数，指定 FunctionBody 为 body，创建一个新函数对象，返回结果。运行中的执行环境的 VariableEnvironment 传递作为 Scope。如果 FunctionDeclaration 包含在严格模式代码里或 FunctionBody 是严格模式代码，那么传递 true 为 Strict 标志。</li>\n</ol>\n\n<p><code>FunctionExpression : function ( FormalParameterListopt ) { FunctionBody }</code>（匿名函数表达式）被如下评估（执行阶段）：</p>\n\n<ol>\n<li>同上，除了传递给 Scope 的是 LexicalEnvironment，而不是VariableEnvironment。</li>\n</ol>\n\n<p>这也就是为什么函数声明会影响变量环境而函数表达式不会的原因了吧！</p>\n\n<p><code>FunctionExpression : function Identifier ( FormalParameterListopt ) { FunctionBody }</code>（具名函数表达式）被如下评估（执行阶段）：</p>\n\n<ol>\n<li>令 funcEnv 为以运行中执行环境的 Lexical Environment 为参数调用 NewDeclarativeEnvironment 的结果。  </li>\n<li>令 envRec 为 funcEnv 的环境记录项。  </li>\n<li>以 Identifier 的字符串值为参数调用 envRec 的具体方法 CreateImmutableBinding(N)。  </li>\n<li>令 closure 为依照下文函数对象创建一节，指定 FormalParameterListopt 为参数，指定 FunctionBody 为 body，创建一个新函数对象的结果。传递 funcEnv 为 Scope。如果 FunctionExpression 包含在严格模式代码 里或 FunctionBody 是严格模式代码，那么传递 true 为 Strict 标志。  </li>\n<li>以 Identifier 的字符串值和 closure 为参数调用 envRec 的具体方法 InitializeImmutableBinding(N,V)。  </li>\n<li>返回 closure。</li>\n</ol>\n\n<p>这个很重要，具名函数表达式执行前创建了一个新的词法环境在栈顶，然后把具名函数表达式创建的函数对象设置到这个新的词法环境上，并且是不变的。</p>\n\n<h4 id=\"\">严格模式的限制</h4>\n\n<blockquote>\n  <p>这在之前的严格模式一文中已经提到，但是结合《可执行代码和执行环境》一文，在绑定上下文的步骤中提到arguments会被函数声明和变量声明覆盖，这明显是一个错误，在严格模式下有以下的限制，个人觉得很有必要。而下面的第一条限制在绑定上下文的参数初始化中也是有提现的。</p>\n</blockquote>\n\n<ul>\n<li><p>如果严格模式 FunctionDeclaration 或 FunctionExpression 的 FormalParameterList 里出现多个相同 Identifier 值，那么这是个 SyntaxError。</p></li>\n<li><p>如果严格模式 FunctionDeclaration 或 FunctionExpression 的 FormalParameterList 里出现标识符 \"eval\" 或标识符 \"arguments\"，那么这是个 SyntaxError。</p></li>\n<li><p>如果严格模式 FunctionDeclaration 或 FunctionExpression 的 Identifier 是标识符 \"eval\" 或标识符 \"arguments\"，那么这是个 SyntaxError。</p></li>\n</ul>\n\n<h4 id=\"\">创建函数对象</h4>\n\n<p>指定 FormalParameterList 为可选参数列表，指定 FunctionBody 为函数体，指定 Scope 为 词法环境 ，Strict 为布尔标记，按照如下步骤构建函数对象：</p>\n\n<ol>\n<li>创建一个新的 ECMAScript 原生对象，令 F 为此对象。  </li>\n<li>依照 8.12 描述设定 F 的除 [[Get]] 以外的所有内部方法。  </li>\n<li>设定 F 的 [[Class]] 内部属性为 \"Function\"。  </li>\n<li>设定 F 的 [[Prototype]] 内部属性为 15.3.3.1 指定的标准内置 Function 对象的 prototype 属性。  </li>\n<li>依照 15.3.5.4 描述，设定 F 的 [[Get]] 内部属性。  </li>\n<li>依照 13.2.1 描述，设定 F 的 [[Call]] 内部属性。  </li>\n<li>依照 13.2.2 描述，设定 F 的 [[Construct]] 内部属性。  </li>\n<li>依照 15.3.5.3 描述，设定 F 的 [[HasInstance]] 内部属性。  </li>\n<li>设定 F 的 [[Scope]] 内部属性为 Scope 的值。  </li>\n<li>令 names 为一个列表容器，其中元素是以从左到右的文本顺序对应 FormalParameterList 的标识符的字符串。  </li>\n<li>设定 F 的 [[FormalParameters]] 内部属性为 names。  </li>\n<li>设定 F 的 [[Code]] 内部属性为 FunctionBody。  </li>\n<li>设定 F 的 [[Extensible]] 内部属性为 true。  </li>\n<li>令 len 为 FormalParameterList 指定的形式参数的个数。如果没有指定参数，则令 len 为 0。  </li>\n<li>以参数 \"length\"，属性描述符 {[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}，false 调用 F 的 [[DefineOwnProperty]] 内部方法。  </li>\n<li>令 proto 为仿佛使用 new Object() 表达式创建新对象的结果，其中 Object 是标准内置构造器名。  </li>\n<li>以参数 \"constructor\", 属性描述符 {[[Value]]: F, { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}, false 调用 proto 的 [[DefineOwnProperty]] 内部方法。  </li>\n<li>以参数 \"prototype\", 属性描述符 {[[Value]]: proto, { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}, false 调用 F 的 [[DefineOwnProperty]] 内部方法。  </li>\n<li>如果 Strict 是 true，则 <br />\n<ol><li>令 thrower 为 [[ThrowTypeError]] 函数对象 (13.2.3)。</li>\n<li>以参数 \"caller\", 属性描述符 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, false 调用 F 的 [[DefineOwnProperty]] 内部方法。</li>\n<li>以参数 \"caller\", 属性描述符 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, false 调用 F 的 [[DefineOwnProperty]] 内部方法。</li></ol></li>\n<li>返回 F。</li>\n</ol>\n\n<blockquote>\n  <p>每个函数都会自动创建一个 prototype 属性，以满足函数会被当作构造器的可能性。</p>\n</blockquote>\n\n<p>好像木有什么卵用，就是设置了一些内部属性。这就尴尬了！！！函数对象好像也没有什么特别的，除了指定了内部[[Prototype]]是Function.prototype，然后新建了一个内部对象，并设置了一个唯一的属性constructor指向函数本身，然后把这个内部对象设置到了函数对象的prototype属性上了。</p>\n\n<p>好像又有点意思了，因为和对象系统的内容接上了！！！可以滚去看对象系统了。😝</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474087459334,"created_by":1,"updated_at":1474093338204,"updated_by":1,"published_at":1474092935765,"published_by":1},{"id":67,"uuid":"e8ef7472-1074-424f-a561-adda4bd46568","title":"线香花火","slug":"xian-xiang-hua-huo","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=829845&auto=1&height=66\"></iframe>\n\n原来线香花火不只是首歌，它就是我们在日剧里经常看到的手上拿着玩的烟火啊！[流焰飞花、夏夜独语：日本线香花火的一生](http://www.vccoo.com/v/bb3f0e?source=rss)\n\n据说线香花火是比壁咚更加浪漫的哦！想想也是。\n\n《乐与路》中小葵这段现在在我脑中还是很清晰呢！！！真的很不错哇！！\n\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f7y1po0h2ij30go090aao.jpg)\n","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=829845&auto=1&height=66\"></iframe>\n\n<p>原来线香花火不只是首歌，它就是我们在日剧里经常看到的手上拿着玩的烟火啊！<a href=\"http://www.vccoo.com/v/bb3f0e?source=rss\">流焰飞花、夏夜独语：日本线香花火的一生</a></p>\n\n<p>据说线香花火是比壁咚更加浪漫的哦！想想也是。</p>\n\n<p>《乐与路》中小葵这段现在在我脑中还是很清晰呢！！！真的很不错哇！！</p>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f7y1po0h2ij30go090aao.jpg\" alt=\"\" /></p>","image":"/content/images/2016/09/5c2db3db9a89833d71a32c7c215f7c2b.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474095946336,"created_by":1,"updated_at":1474242547521,"updated_by":1,"published_at":1474204036391,"published_by":1},{"id":68,"uuid":"f1568e71-fb89-4186-b2c1-269e724f2e0a","title":"编译原理入门——绪论","slug":"bian-yi-yuan-li-ru-men-xu-lun","markdown":"今天开始重头开始看es5的文档看到第五章，句法和词法部分就懵逼了，什么上下文无关文法？？。之前看的第十章和第十三章都不会有这种感觉。所以就去边上的书架上拿来了编译原理的书，了解下，至少能够把es5那几章看懂，毕竟这对于更好地理解语言有很大的好处。不过不会进行很深入的研究，毕竟现在的重点是js。（虽然在计算机学院，但因为不是计算机专业，这门课是不学的）\n\n#### 发展\n\n> 机器语言（二进制）--->汇编语言（助记符）--->高级语言\n\n计算机语言的发展类似于人类语言的进化，而古代人要看懂现代的文字就需要将现代的语言翻译成古代语言，就类似于编译干的事\n\n#### 高级语言的执行\n\n###### 编译型语言程序：\n\n1. 编译阶段：高级语言-(编译)->机器语言或汇编语言\n2. 汇编阶段：如果高级语言编译的目标程序是汇编程序，那么还有一个汇编阶段把汇编程序变换成机器语言目标程序\n3. 运行阶段\n\n###### 解释型语言程序\n\n无需翻译成目标程序，直接逐条运行。js就是解释执行，经过词法分析、语法分析生成语法分析树后，便开始执行了。\n\n#### 编译阶段简述\n\n编译阶段可以细分为词法分析、语法分析、语义分析、中间代码生成、代码优化、和目标代码生成六个阶段。\n\n1. 词法分析\n\n 把源程序字符串变成单词符号流，单词用同一长度的标准形式表示。简单来说也就是从左到右一个一个的读入源程序，识别一个单词或符号，并进行归类。类似分析汉语语法，例如，我们输入一句话，我是中国人。然后进行分析，读入我可以识别这个单词，为名词，我就归到名词这类；读入是，我们归到动词这类；读入中字，不能构成一个可识别的东东，接着读入，中国人，为名词类。而在计算机中，例如我们写的某行代码，var  sum = first + count*10 ; 进行分类，1保留字：var；标识符：2 sum 3 first  4 count  乘号：5*；\n\n2. 语法分析  \n\n 在词法分析的基础上，根据语言的语法规则把单词符号流分解成各类语法单位，如“程序”，“语句”，“表达式”等。例如通过上面的单词“我”“中国人”“是”，可以构成两种形式的语句，我是中国人，中国人是我，都符合<主语><谓语>这样的语法。\n\n3. 语义分析\n\n 审查源程序是否有语义的错误，当不符合语言规范的时候，程序就会报错。例如上面的“我是中国人”和“中国人是我”两个句子，显然后面的中国人是我就不符合语义了。\n\n4. 生成中间代码\n\n 在进行了语法和语义的分析工作之后，编译程序将源程序变成了一种内部表示形式，这种内部表示形式叫做中间语言或中间代码。（比较抽象些），生成一种介于源码和机器语言的形式，常见的有四元式、三元式、逆波兰式。\n\n5. 代码优化\n\n 这个阶段是对前阶段的中间代码进行变换或改造，目的是使生成的目标代码更为高效，即节省时间和空间。\n\n6. 目标代码生成\n\n 也就是把优化后的中间代码变换成机器代码或汇编代码。这是工作的最后阶段，与硬件系统结构，指令系统相关，涉及到硬件系统功能部件运用、机器指令的选择等等。\n\n> 造表和出错处理环绕于这各个阶段！\n\n参考资料：\n\n1. [编译原理学习周入门教程](http://blog.csdn.net/lovesummerforever/article/category/1438807)\n2. 《编译原理（第三版）》科学出版社","html":"<p>今天开始重头开始看es5的文档看到第五章，句法和词法部分就懵逼了，什么上下文无关文法？？。之前看的第十章和第十三章都不会有这种感觉。所以就去边上的书架上拿来了编译原理的书，了解下，至少能够把es5那几章看懂，毕竟这对于更好地理解语言有很大的好处。不过不会进行很深入的研究，毕竟现在的重点是js。（虽然在计算机学院，但因为不是计算机专业，这门课是不学的）</p>\n\n<h4 id=\"\">发展</h4>\n\n<blockquote>\n  <p>机器语言（二进制）--->汇编语言（助记符）--->高级语言</p>\n</blockquote>\n\n<p>计算机语言的发展类似于人类语言的进化，而古代人要看懂现代的文字就需要将现代的语言翻译成古代语言，就类似于编译干的事</p>\n\n<h4 id=\"\">高级语言的执行</h4>\n\n<h6 id=\"\">编译型语言程序：</h6>\n\n<ol>\n<li>编译阶段：高级语言-(编译)->机器语言或汇编语言  </li>\n<li>汇编阶段：如果高级语言编译的目标程序是汇编程序，那么还有一个汇编阶段把汇编程序变换成机器语言目标程序  </li>\n<li>运行阶段</li>\n</ol>\n\n<h6 id=\"\">解释型语言程序</h6>\n\n<p>无需翻译成目标程序，直接逐条运行。js就是解释执行，经过词法分析、语法分析生成语法分析树后，便开始执行了。</p>\n\n<h4 id=\"\">编译阶段简述</h4>\n\n<p>编译阶段可以细分为词法分析、语法分析、语义分析、中间代码生成、代码优化、和目标代码生成六个阶段。</p>\n\n<ol>\n<li><p>词法分析</p>\n\n<p>把源程序字符串变成单词符号流，单词用同一长度的标准形式表示。简单来说也就是从左到右一个一个的读入源程序，识别一个单词或符号，并进行归类。类似分析汉语语法，例如，我们输入一句话，我是中国人。然后进行分析，读入我可以识别这个单词，为名词，我就归到名词这类；读入是，我们归到动词这类；读入中字，不能构成一个可识别的东东，接着读入，中国人，为名词类。而在计算机中，例如我们写的某行代码，var  sum = first + count<em>10 ; 进行分类，1保留字：var；标识符：2 sum 3 first  4 count  乘号：5</em>；</p></li>\n<li><p>语法分析  </p>\n\n<p>在词法分析的基础上，根据语言的语法规则把单词符号流分解成各类语法单位，如“程序”，“语句”，“表达式”等。例如通过上面的单词“我”“中国人”“是”，可以构成两种形式的语句，我是中国人，中国人是我，都符合&lt;主语>&lt;谓语>这样的语法。</p></li>\n<li><p>语义分析</p>\n\n<p>审查源程序是否有语义的错误，当不符合语言规范的时候，程序就会报错。例如上面的“我是中国人”和“中国人是我”两个句子，显然后面的中国人是我就不符合语义了。</p></li>\n<li><p>生成中间代码</p>\n\n<p>在进行了语法和语义的分析工作之后，编译程序将源程序变成了一种内部表示形式，这种内部表示形式叫做中间语言或中间代码。（比较抽象些），生成一种介于源码和机器语言的形式，常见的有四元式、三元式、逆波兰式。</p></li>\n<li><p>代码优化</p>\n\n<p>这个阶段是对前阶段的中间代码进行变换或改造，目的是使生成的目标代码更为高效，即节省时间和空间。</p></li>\n<li><p>目标代码生成</p>\n\n<p>也就是把优化后的中间代码变换成机器代码或汇编代码。这是工作的最后阶段，与硬件系统结构，指令系统相关，涉及到硬件系统功能部件运用、机器指令的选择等等。</p></li>\n</ol>\n\n<blockquote>\n  <p>造表和出错处理环绕于这各个阶段！</p>\n</blockquote>\n\n<p>参考资料：</p>\n\n<ol>\n<li><a href=\"http://blog.csdn.net/lovesummerforever/article/category/1438807\">编译原理学习周入门教程</a>  </li>\n<li>《编译原理（第三版）》科学出版社</li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474175904212,"created_by":1,"updated_at":1474336655881,"updated_by":1,"published_at":1474176633881,"published_by":1},{"id":69,"uuid":"9ebaabb5-790f-43f3-a691-dacb4548c53d","title":"编译原理入门——词法分析","slug":"bian-yi-yuan-li-ru-men-ci-fa-fen-xi","markdown":"词法分析是编译的第一个阶段，其任务是：从左至右逐个字符地对源程序进行扫描，产生一个个单词符号，把字符串形式的源程序改造成单词符号形式的中间程序。执行词法分析的程序称为词法分析程序，也称为词法分析器或扫描器。词法分析器的功能是输入源程序，输出单词符号。\n\n#### 两种处理结构\n\n1. 把词法分析作为主程序（图a）。将词法分析作为独立的过程，由词法分析将字符串形式的源程序改造成单词符号串的形式的中间程序，并以这个中间程序作为语法分析程序的输入。\n2. 把词法分析作为语法分析程序调用的子程序（图b）。在进行语法分析时，每当语法分析程序需要一个单词时，便调用词法分析程序，词法分析程序每一次调用便从字符串源程序中识别出一个单词交给语法分析程序。（通常采用）\n\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f7xwh3z01xj311s0aajsz.jpg)\n\n#### 设计方法\n\n###### 单词符号分类\n\n单词符号是一次词法分析的结果，也是程序语言的基本语法单位，具有确定的语法意义。它通常可以分为下面五种：\n\n- 保留字：if、while、switch等，限制作为标识符；\n- 标识符：变量、函数等；\n- 常数：各种类型的常数；\n- 运算符：加减乘除大于小于等；\n- 界符：逗号、分好、括号这种。\n\n> 一个语言的保留字、运算符、界符数量是确定，标识符和常量数量则是不确定。\n\n###### 输出形式\n\n词法分析程序的输出形式通常是如下的二元式：\n\n```\n(单词种别，单词自身的值)\n```\n\n单词种别顾名思义是单词的种类，一个语言的单词划分种类、分为几类、如何编码都属于技术性问题，主要取决于处理上的方便。通常的做法是让一类单词对应一个整数码。通常情况下，保留字可以一字一种也可以所有一种；标识符和常量统一归为一种；运算符和界符则是一字一种。\n\n单词自身的值是编译中其他阶段需要的信息。如果单词是一字一种的，那么种别就能代表单词自身的值；否则的话给出单词种别的同属还需要给出单词自身的值。标识符自身的值就是标识符字符串，常量自身的值则是常量对应的二进制数值。\n\n###### 状态转换图\n\n初看状态转换图，感觉挺像正则表达式的图形式的。学习下来确实也差不多，因为正则其实也是按一条条规则进行匹配和词法这里的单词匹配其实挺像的。\n\n看几个例子就明白了，下图中a是标识符的状态转换图，首先0是初始状态，0到1匹配字母，因为标识符不能以数字开头哇。然后自己指向自己的箭头表示重复，直到遇到不是字母或数字的字符，匹配结束，结束用两个圈表示。结束符上的*表示的是退回最后多读的一个字符。其它两个图也可以用这种方式去理解。\n\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f7xxu3990kj310s0nqq6m.jpg)\n\n#### 正规表达式、有限自动机理论\n\n###### 正规表达式和正规集\n\n正规表达式同状态转换图，只是相对于状态转换图来说，它是一种形式化的表示法，可以表示单词符号的结构，从而精确地定义单词符号集。\n\n还是标志符的例子，假设字母用letter表示，数字用dight表示，则可得正规表达式：\n\n```\nletter (letter|dight)*\n```\n\nletter表示了标识符的第一个字符必为字母，而*号表示字母或数字重复0到n词。符合这个正规式的字符集就是这个正规式所表示的正规集。\n\n当然也可以通过递归定义，推出一些正规式的性质，这里略过了！\n\n###### 有限自动机 \n\n 能准确的识别正规集，能识别正规文法所定义的语言和正规式表示的集合，也为词法分析程序的自动构造寻找特殊的方法和工具。有限自动机是更加一般化的状态转换图，分为以下两种：\n\n1. 确定有限自动机（DFA）\n\n 一个确定的有穷自动机M是一个五元组：M=（K， ∑，f，S，Z）其中，\n 1. K是一个有穷集，他的每个元素称为一种状态。\n 2. ∑是一个有穷字母表，他的每个元素称为一个输入符号，所以∑称为输入符号表。\n 3. f是转换函数，是KX∑-->K 上的映像，例如f（ki，a）=kj这就意味着，当前状态为k，输入字符a后，将转换到下一状态kj，我们把kj称为ki的一个后继状态；\n 4. S属于K，是唯一的一个出态。\n 5. Z属于K，是一个终态，终态也称为可接受状态或结束状态。\n\n还是放个别人那截来的例子吧：\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f7xzwnloetj3118114784.jpg)\n\n2. 非确定有限自动机（NFA）\n 1. 是一个子集映像。\n 2. S属于K是一个非空出态集；\n 3. Z属于K是一个终态集。\n\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f7y00e152aj30va0x876b.jpg)\n\n两个区别：第一，NFA有若干的初始状态，DFA只有一个；第二，NFA状态转换函数不是单值映射。\n\n我们可以用正规表达式来识别单词，再用有限自动机来识别正规表达式，然后就可以做点有趣的事了！书上还有一章讲到了从正规表达式到有限自动机的转换，这里不展开了！\n\n#### 说了这么多的目的\n\n###### 自动生成词法分析器\n\n说了这么多，正规表达式和有限自动机的理论，归根到底还是程序员们偷懒搞出来的。借助这些理论，自动生成词法分析器成为了可能。只要给出某高级语言各类单词的词法结构的正规表达式以及识别各类单词时词法分析程序应采用的语义动作，系统就可以自动产生此高级程序的词法分析程序。所生成的词法分析程序就如同一台有限自动机，可以用来识别和分析单词符号！！！\n\n参考资料：\n\n1. 《编译原理（第三版）》科学出版社\n2. [编译原理学习周入门教程](http://blog.csdn.net/lovesummerforever/article/category/1438807)\n3. 传说中好像还有龙虎鲸三本经典，然而图书馆并没有🙄","html":"<p>词法分析是编译的第一个阶段，其任务是：从左至右逐个字符地对源程序进行扫描，产生一个个单词符号，把字符串形式的源程序改造成单词符号形式的中间程序。执行词法分析的程序称为词法分析程序，也称为词法分析器或扫描器。词法分析器的功能是输入源程序，输出单词符号。</p>\n\n<h4 id=\"\">两种处理结构</h4>\n\n<ol>\n<li>把词法分析作为主程序（图a）。将词法分析作为独立的过程，由词法分析将字符串形式的源程序改造成单词符号串的形式的中间程序，并以这个中间程序作为语法分析程序的输入。  </li>\n<li>把词法分析作为语法分析程序调用的子程序（图b）。在进行语法分析时，每当语法分析程序需要一个单词时，便调用词法分析程序，词法分析程序每一次调用便从字符串源程序中识别出一个单词交给语法分析程序。（通常采用）</li>\n</ol>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f7xwh3z01xj311s0aajsz.jpg\" alt=\"\" /></p>\n\n<h4 id=\"\">设计方法</h4>\n\n<h6 id=\"\">单词符号分类</h6>\n\n<p>单词符号是一次词法分析的结果，也是程序语言的基本语法单位，具有确定的语法意义。它通常可以分为下面五种：</p>\n\n<ul>\n<li>保留字：if、while、switch等，限制作为标识符；</li>\n<li>标识符：变量、函数等；</li>\n<li>常数：各种类型的常数；</li>\n<li>运算符：加减乘除大于小于等；</li>\n<li>界符：逗号、分好、括号这种。</li>\n</ul>\n\n<blockquote>\n  <p>一个语言的保留字、运算符、界符数量是确定，标识符和常量数量则是不确定。</p>\n</blockquote>\n\n<h6 id=\"\">输出形式</h6>\n\n<p>词法分析程序的输出形式通常是如下的二元式：</p>\n\n<pre><code>(单词种别，单词自身的值)\n</code></pre>\n\n<p>单词种别顾名思义是单词的种类，一个语言的单词划分种类、分为几类、如何编码都属于技术性问题，主要取决于处理上的方便。通常的做法是让一类单词对应一个整数码。通常情况下，保留字可以一字一种也可以所有一种；标识符和常量统一归为一种；运算符和界符则是一字一种。</p>\n\n<p>单词自身的值是编译中其他阶段需要的信息。如果单词是一字一种的，那么种别就能代表单词自身的值；否则的话给出单词种别的同属还需要给出单词自身的值。标识符自身的值就是标识符字符串，常量自身的值则是常量对应的二进制数值。</p>\n\n<h6 id=\"\">状态转换图</h6>\n\n<p>初看状态转换图，感觉挺像正则表达式的图形式的。学习下来确实也差不多，因为正则其实也是按一条条规则进行匹配和词法这里的单词匹配其实挺像的。</p>\n\n<p>看几个例子就明白了，下图中a是标识符的状态转换图，首先0是初始状态，0到1匹配字母，因为标识符不能以数字开头哇。然后自己指向自己的箭头表示重复，直到遇到不是字母或数字的字符，匹配结束，结束用两个圈表示。结束符上的*表示的是退回最后多读的一个字符。其它两个图也可以用这种方式去理解。</p>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f7xxu3990kj310s0nqq6m.jpg\" alt=\"\" /></p>\n\n<h4 id=\"\">正规表达式、有限自动机理论</h4>\n\n<h6 id=\"\">正规表达式和正规集</h6>\n\n<p>正规表达式同状态转换图，只是相对于状态转换图来说，它是一种形式化的表示法，可以表示单词符号的结构，从而精确地定义单词符号集。</p>\n\n<p>还是标志符的例子，假设字母用letter表示，数字用dight表示，则可得正规表达式：</p>\n\n<pre><code>letter (letter|dight)*  \n</code></pre>\n\n<p>letter表示了标识符的第一个字符必为字母，而*号表示字母或数字重复0到n词。符合这个正规式的字符集就是这个正规式所表示的正规集。</p>\n\n<p>当然也可以通过递归定义，推出一些正规式的性质，这里略过了！</p>\n\n<h6 id=\"\">有限自动机</h6>\n\n<p>能准确的识别正规集，能识别正规文法所定义的语言和正规式表示的集合，也为词法分析程序的自动构造寻找特殊的方法和工具。有限自动机是更加一般化的状态转换图，分为以下两种：</p>\n\n<ol>\n<li><p>确定有限自动机（DFA）</p>\n\n<p>一个确定的有穷自动机M是一个五元组：M=（K， ∑，f，S，Z）其中，</p>\n\n<ol><li>K是一个有穷集，他的每个元素称为一种状态。</li>\n<li>∑是一个有穷字母表，他的每个元素称为一个输入符号，所以∑称为输入符号表。</li>\n<li>f是转换函数，是KX∑-->K 上的映像，例如f（ki，a）=kj这就意味着，当前状态为k，输入字符a后，将转换到下一状态kj，我们把kj称为ki的一个后继状态；</li>\n<li>S属于K，是唯一的一个出态。</li>\n<li>Z属于K，是一个终态，终态也称为可接受状态或结束状态。</li></ol></li>\n</ol>\n\n<p>还是放个别人那截来的例子吧：</p>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f7xzwnloetj3118114784.jpg\" alt=\"\" /></p>\n\n<ol>\n<li>非确定有限自动机（NFA） <br />\n<ol><li>是一个子集映像。</li>\n<li>S属于K是一个非空出态集；</li>\n<li>Z属于K是一个终态集。</li></ol></li>\n</ol>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f7y00e152aj30va0x876b.jpg\" alt=\"\" /></p>\n\n<p>两个区别：第一，NFA有若干的初始状态，DFA只有一个；第二，NFA状态转换函数不是单值映射。</p>\n\n<p>我们可以用正规表达式来识别单词，再用有限自动机来识别正规表达式，然后就可以做点有趣的事了！书上还有一章讲到了从正规表达式到有限自动机的转换，这里不展开了！</p>\n\n<h4 id=\"\">说了这么多的目的</h4>\n\n<h6 id=\"\">自动生成词法分析器</h6>\n\n<p>说了这么多，正规表达式和有限自动机的理论，归根到底还是程序员们偷懒搞出来的。借助这些理论，自动生成词法分析器成为了可能。只要给出某高级语言各类单词的词法结构的正规表达式以及识别各类单词时词法分析程序应采用的语义动作，系统就可以自动产生此高级程序的词法分析程序。所生成的词法分析程序就如同一台有限自动机，可以用来识别和分析单词符号！！！</p>\n\n<p>参考资料：</p>\n\n<ol>\n<li>《编译原理（第三版）》科学出版社  </li>\n<li><a href=\"http://blog.csdn.net/lovesummerforever/article/category/1438807\">编译原理学习周入门教程</a>  </li>\n<li>传说中好像还有龙虎鲸三本经典，然而图书馆并没有🙄</li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474187112076,"created_by":1,"updated_at":1474201206584,"updated_by":1,"published_at":1474201046318,"published_by":1},{"id":70,"uuid":"5d2e6a22-c09d-4368-b67a-c37508f5dbcc","title":"爱情洗牌","slug":"ai-qing-xi-pai","markdown":"这篇本来应该是昨晚写的，但是昨晚去和搬出去的两个室友吃了顿饭。大家聚在一起的时间越来越少了，所以要珍惜这样不多的机会了。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=21758226&auto=1&height=66\"></iframe>\n\n吃的时候聊的也都是以前的一些事，相互也调侃一下各自的近况，当然我是被调侃最多的😂。反正三个大男人就那么做了好久，都没怎么吃。吃完走到图书馆，我就和他们分开了。虽然不是再见，但是我们的人生已经开始都慢慢划出了一条新的线，都为对方高兴吧！\n\n好了，扯了点有用没用的，开始写这部刚看完的日记《爱情洗牌》。这也是个脑洞挺大的故事，但是如往常的日剧一样，脑洞给我们带来了对于生活的思考和感动。\n\n大致讲的是同住高级公寓同一层的人，一天同时在电梯被困，从此相互认识。在相互的交谈中，大家对于自己现在的爱情都觉得不满意，于是谷原叔演的医生就提议了爱情洗牌。大致就是每人每周抽牌分配自己的恋人，然后找到真爱或者回归原来的恋人。在经过两轮的爱情洗牌之后（过程还是挺戏剧性的，编剧任性），宏爷饰演的启和爱爱在了一起，绵羊则和吉高妹子在了一起，谕吉和芽衣在了一起。配对成功了三对，真是不可思议！但是确实最后每个人都跟更加适合自己的人在一起了。\n\n我们的经历也是如此吧，爱情会经历像启和芽衣那样的从闪闪发光到渐渐被抹去光芒；也会有出于爱爱对谕吉的那种同情；但是真正能够支撑相互走下去的是什么，应该不是第一眼的闪闪发光、也不是一时的同情，而是相互理解相互依赖吧！\n\n哎，这些不该从我嘴里出来的！毕竟昨天被莫名其妙地冠名了‘国民负心汉’🙄。开玩笑的！\n\n最后，编剧给了我们一个意料之中的甜蜜结局！下面是看的时候的一些截图，大多数是最后一集的甜蜜镜头，还有几张是笑喷我的，over，新的一天开始！\n\n可爱的吉高妹子😁：\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f7zq2l6umfj30zk0k0dp1.jpg)\n\n绵羊调皮了：\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f7zq2fkzguj30zk0k0q7i.jpg)\n\n宏爷乱入：\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f7zq2ky451j30zk0k0n5w.jpg)\n\n心疼宏爷：\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f7zq2jabbpj30zk0k0jxa.jpg)\n\n经典的画面：\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f7zq2nw0dqj30zk0k0thy.jpg)\n\n经典的画面：\n![](https://ws4.sinaimg.cn/large/006bH5BKgw1f7zq2ptsjuj30zk0k0k0o.jpg)\n\n闪闪发光的启：\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f7zq2qbdnlj30zk0k0n8w.jpg)\n\n全剧终：\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f7zq2iu7jqj30zk0k0wjg.jpg)","html":"<p>这篇本来应该是昨晚写的，但是昨晚去和搬出去的两个室友吃了顿饭。大家聚在一起的时间越来越少了，所以要珍惜这样不多的机会了。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=21758226&auto=1&height=66\"></iframe>\n\n<p>吃的时候聊的也都是以前的一些事，相互也调侃一下各自的近况，当然我是被调侃最多的😂。反正三个大男人就那么做了好久，都没怎么吃。吃完走到图书馆，我就和他们分开了。虽然不是再见，但是我们的人生已经开始都慢慢划出了一条新的线，都为对方高兴吧！</p>\n\n<p>好了，扯了点有用没用的，开始写这部刚看完的日记《爱情洗牌》。这也是个脑洞挺大的故事，但是如往常的日剧一样，脑洞给我们带来了对于生活的思考和感动。</p>\n\n<p>大致讲的是同住高级公寓同一层的人，一天同时在电梯被困，从此相互认识。在相互的交谈中，大家对于自己现在的爱情都觉得不满意，于是谷原叔演的医生就提议了爱情洗牌。大致就是每人每周抽牌分配自己的恋人，然后找到真爱或者回归原来的恋人。在经过两轮的爱情洗牌之后（过程还是挺戏剧性的，编剧任性），宏爷饰演的启和爱爱在了一起，绵羊则和吉高妹子在了一起，谕吉和芽衣在了一起。配对成功了三对，真是不可思议！但是确实最后每个人都跟更加适合自己的人在一起了。</p>\n\n<p>我们的经历也是如此吧，爱情会经历像启和芽衣那样的从闪闪发光到渐渐被抹去光芒；也会有出于爱爱对谕吉的那种同情；但是真正能够支撑相互走下去的是什么，应该不是第一眼的闪闪发光、也不是一时的同情，而是相互理解相互依赖吧！</p>\n\n<p>哎，这些不该从我嘴里出来的！毕竟昨天被莫名其妙地冠名了‘国民负心汉’🙄。开玩笑的！</p>\n\n<p>最后，编剧给了我们一个意料之中的甜蜜结局！下面是看的时候的一些截图，大多数是最后一集的甜蜜镜头，还有几张是笑喷我的，over，新的一天开始！</p>\n\n<p>可爱的吉高妹子😁：\n<img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f7zq2l6umfj30zk0k0dp1.jpg\" alt=\"\" /></p>\n\n<p>绵羊调皮了：\n<img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f7zq2fkzguj30zk0k0q7i.jpg\" alt=\"\" /></p>\n\n<p>宏爷乱入：\n<img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f7zq2ky451j30zk0k0n5w.jpg\" alt=\"\" /></p>\n\n<p>心疼宏爷：\n<img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f7zq2jabbpj30zk0k0jxa.jpg\" alt=\"\" /></p>\n\n<p>经典的画面：\n<img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f7zq2nw0dqj30zk0k0thy.jpg\" alt=\"\" /></p>\n\n<p>经典的画面：\n<img src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f7zq2ptsjuj30zk0k0k0o.jpg\" alt=\"\" /></p>\n\n<p>闪闪发光的启：\n<img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f7zq2qbdnlj30zk0k0n8w.jpg\" alt=\"\" /></p>\n\n<p>全剧终：\n<img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f7zq2iu7jqj30zk0k0wjg.jpg\" alt=\"\" /></p>","image":"/content/images/2016/09/697679ec54e736d16115e77d98504fc2d562693d.png","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474242590630,"created_by":1,"updated_at":1474332090708,"updated_by":1,"published_at":1474330075920,"published_by":1},{"id":71,"uuid":"6d4d2299-9faf-4645-982c-e850e9386744","title":"编译原理入门——语法分析","slug":"bian-yi-yuan-li-ru-men-yu-fa-fen-xi","markdown":"语法分析是编译过程的核心部分，其基本任务是根据语言的语法规则进行语法分析，若不存在语法错误则给出正确的语法结构并为语义分析和代码生成做准备。在描述程序语言语法结构时，需借助上下文无关文法，而文法是描述程序语言的依据。\n\n#### 文法和语言\n\n> 话外音：这玩意就是读es5文档第五章把我卡住的东西，要好好看看哇！\n\n文法是程序语言的生成系统，而自动机则是程序语言的识别系统：用文法可以精确地定义一个语言，并依据该文法构造出识别这个语言的自动机。如：程序语言的词法可以用正规文法描述；语法可以用上下文无关文法描述；语义则需要上下午有关文法描述。有意思哇！确实想想也是，语法应当是上下文无关的，语义则需要和上下文关联。\n\n##### 基本概念\n\n###### 语言\n\n- 通常我们用 Σ 表示字母表，程序语言的字母表通常是 ASCLL 字符集。\n- 由字母表中字符组成的有穷序列为字符串或字。\n- 字母表上的所有字符串的集合用 Σ* 表示。\n- 那么 Σ* 的任意一个子集称为语言，记为 L 。\n- L 中的字符串则成为语言 L 的一个语句。\n\n###### 文法\n\n文法通常表示成四元组 G[S] = (Vt,Vn,S,𝞷)，其中：\n\n1. Vt 为终结符号集，非空有限集；\n2. Vn 为非终结符号集，非空有限集；\n3. S 为一文法开始符，是一个特殊的非终结符，即 S∈Vn ；\n4. 𝞷 是产生式的非空有限集，通常写作 α → β 或  α::=β。读作‘α是β’或者‘α定义为β’。α和β是由终结符和非终结符组成的字符串，其中α至少有一个非终结符。\n\n这么多概念，是不是蒙了，握草，什么是终结符、什么是非终结符、什么是产生式、是不是翻译错了，这就是当时读es5文档时的感受😂。下面先举一个例子，然后根据例子来解释这些概念。\n\n还是熟悉的标识符，标识符是以字母开头的字母数字串，我们用 L 表示字母类非终结符；D 表示数字类非终结符；T 表示数字字母类非终结符，则有：\n\n```\nL → a|b|...|z\nD → 0|1|...|9\nT → L|D\n```\n\n接下来定义数字字母串 S，S → T|ST 有一种递归的意思，数字字母串可以是单个字符 T ，也可以是 T 左边加上一个数字字母串 S：\n\n```\nS → T|ST\n```\n\n最后推导出标识符的非终结符 I，以字母 L 开头，后面可以空也可以是数字字母串：\n\n```\nI → L|LS\n```\n\n文法 G[I] = ({a,b,...,z,0,...9},{I,S,T,L,D},I,𝞷) 注：𝞷 为上面五个式子。\n\n很好理解吧！那么现在再来看看终结符、非终结符、产生式的概念吧。\n\n终结符就是语言不可再分的基本符号，通常是语言的字母表或者字母表的子集吧！就像例子中 {a,b,...,z,0,...9} 这样。\n\n非终结符也称语法变量，它代表一个一定的语法概念。就像上面的例子中 S 非终结符，它代表的就是数字字母串这样一个确定的语法概念。\n\n产生式呢，更好理解了，就是一个推导式子，用来表示某个非终结符或者非终结符加终结符这种结构的确定意义，说到这里 α 必须包含一个非终结符也就很好理解了，因为终结符已经是最小的语法元素了，没有进行推导的必要了。\n\n#### 形式语言分类\n\n1956 年伟大的语言学家 Noam Chomsky 首先建立了形式语言的描述，定义了四类文法及相应的形式语言，分别与相应的识别系统相联系。\n\n###### 0型文法（图灵机）\n\n规则：α → β 产生式左边 α 至少含有一个非终结符。它的识别系统是图灵机。\n\n###### 1型文法（线性界线自动机、自然语言）\n\n在 0 型文法的基础上增加了字符长度上的限制。αA𝞭 → αβ𝞭，这里的 A 是非终结符号，而 α、β 和 𝞭 是包含非终结符号与终结符号的字串，它显然满足之前的长度限制。并且能够表示出只有在α和β的上下文内，A 才能够替换为 β。所以1型文法也叫作上下文有关文法。\n\n###### 2型文法（下推自动机、程序语言）\n\n规则：A → α，A为非终结符号，α为可空的非终结符和终结符组合串。2型文法也叫作上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。\n\n###### 3型文法（有限自动机）\n\n规则：A → α 或 A → αB 或 A → Bα，AB为非终结符，α为可空终结符字串。\n\n###### 关系区别\n\n从0到3，限制在增加，1-3型文法都属于0型；2、3型不一定属于1型；3型属于2型。*不是简单的包含关系。*写到这对于这四类文法还是比较模糊啊！！先继续看下去吧！\n\n###### 正规表达式与上下文无关文法\n\n正规表达式和上下文无关文法是可以相互转换的，转换方法略。另外上下文无关文法即可以描述程序语言的词法也可以描述语法，但是相对于正规表达式来说，还是通常使用后者来描述词法，后者简单、直观、效率高。\n\n> 编译原理及语法分析的内容还很多，不过仅仅是为了读es5的文档补充知识并且 js 解释执行没有后面的几步，所以本系列只到语法分析的这一部分，后面的语法树、抽象语法树等到有必要的时候在进行了解了！\n\n参考资料：\n\n1. 《编译原理（第三版）》科学出版社\n2. [编译原理学习周入门教程](http://blog.csdn.net/lovesummerforever/article/category/1438807)\n3. 传说中好像还有龙虎鲸三本经典，然而图书馆并没有🙄\n","html":"<p>语法分析是编译过程的核心部分，其基本任务是根据语言的语法规则进行语法分析，若不存在语法错误则给出正确的语法结构并为语义分析和代码生成做准备。在描述程序语言语法结构时，需借助上下文无关文法，而文法是描述程序语言的依据。</p>\n\n<h4 id=\"\">文法和语言</h4>\n\n<blockquote>\n  <p>话外音：这玩意就是读es5文档第五章把我卡住的东西，要好好看看哇！</p>\n</blockquote>\n\n<p>文法是程序语言的生成系统，而自动机则是程序语言的识别系统：用文法可以精确地定义一个语言，并依据该文法构造出识别这个语言的自动机。如：程序语言的词法可以用正规文法描述；语法可以用上下文无关文法描述；语义则需要上下午有关文法描述。有意思哇！确实想想也是，语法应当是上下文无关的，语义则需要和上下文关联。</p>\n\n<h5 id=\"\">基本概念</h5>\n\n<h6 id=\"\">语言</h6>\n\n<ul>\n<li>通常我们用 Σ 表示字母表，程序语言的字母表通常是 ASCLL 字符集。</li>\n<li>由字母表中字符组成的有穷序列为字符串或字。</li>\n<li>字母表上的所有字符串的集合用 Σ* 表示。</li>\n<li>那么 Σ* 的任意一个子集称为语言，记为 L 。</li>\n<li>L 中的字符串则成为语言 L 的一个语句。</li>\n</ul>\n\n<h6 id=\"\">文法</h6>\n\n<p>文法通常表示成四元组 G[S] = (Vt,Vn,S,𝞷)，其中：</p>\n\n<ol>\n<li>Vt 为终结符号集，非空有限集；  </li>\n<li>Vn 为非终结符号集，非空有限集；  </li>\n<li>S 为一文法开始符，是一个特殊的非终结符，即 S∈Vn ；  </li>\n<li>𝞷 是产生式的非空有限集，通常写作 α → β 或  α::=β。读作‘α是β’或者‘α定义为β’。α和β是由终结符和非终结符组成的字符串，其中α至少有一个非终结符。</li>\n</ol>\n\n<p>这么多概念，是不是蒙了，握草，什么是终结符、什么是非终结符、什么是产生式、是不是翻译错了，这就是当时读es5文档时的感受😂。下面先举一个例子，然后根据例子来解释这些概念。</p>\n\n<p>还是熟悉的标识符，标识符是以字母开头的字母数字串，我们用 L 表示字母类非终结符；D 表示数字类非终结符；T 表示数字字母类非终结符，则有：</p>\n\n<pre><code>L → a|b|...|z  \nD → 0|1|...|9  \nT → L|D  \n</code></pre>\n\n<p>接下来定义数字字母串 S，S → T|ST 有一种递归的意思，数字字母串可以是单个字符 T ，也可以是 T 左边加上一个数字字母串 S：</p>\n\n<pre><code>S → T|ST  \n</code></pre>\n\n<p>最后推导出标识符的非终结符 I，以字母 L 开头，后面可以空也可以是数字字母串：</p>\n\n<pre><code>I → L|LS  \n</code></pre>\n\n<p>文法 G[I] = ({a,b,...,z,0,...9},{I,S,T,L,D},I,𝞷) 注：𝞷 为上面五个式子。</p>\n\n<p>很好理解吧！那么现在再来看看终结符、非终结符、产生式的概念吧。</p>\n\n<p>终结符就是语言不可再分的基本符号，通常是语言的字母表或者字母表的子集吧！就像例子中 {a,b,...,z,0,...9} 这样。</p>\n\n<p>非终结符也称语法变量，它代表一个一定的语法概念。就像上面的例子中 S 非终结符，它代表的就是数字字母串这样一个确定的语法概念。</p>\n\n<p>产生式呢，更好理解了，就是一个推导式子，用来表示某个非终结符或者非终结符加终结符这种结构的确定意义，说到这里 α 必须包含一个非终结符也就很好理解了，因为终结符已经是最小的语法元素了，没有进行推导的必要了。</p>\n\n<h4 id=\"\">形式语言分类</h4>\n\n<p>1956 年伟大的语言学家 Noam Chomsky 首先建立了形式语言的描述，定义了四类文法及相应的形式语言，分别与相应的识别系统相联系。</p>\n\n<h6 id=\"0\">0型文法（图灵机）</h6>\n\n<p>规则：α → β 产生式左边 α 至少含有一个非终结符。它的识别系统是图灵机。</p>\n\n<h6 id=\"1\">1型文法（线性界线自动机、自然语言）</h6>\n\n<p>在 0 型文法的基础上增加了字符长度上的限制。αA𝞭 → αβ𝞭，这里的 A 是非终结符号，而 α、β 和 𝞭 是包含非终结符号与终结符号的字串，它显然满足之前的长度限制。并且能够表示出只有在α和β的上下文内，A 才能够替换为 β。所以1型文法也叫作上下文有关文法。</p>\n\n<h6 id=\"2\">2型文法（下推自动机、程序语言）</h6>\n\n<p>规则：A → α，A为非终结符号，α为可空的非终结符和终结符组合串。2型文法也叫作上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。</p>\n\n<h6 id=\"3\">3型文法（有限自动机）</h6>\n\n<p>规则：A → α 或 A → αB 或 A → Bα，AB为非终结符，α为可空终结符字串。</p>\n\n<h6 id=\"\">关系区别</h6>\n\n<p>从0到3，限制在增加，1-3型文法都属于0型；2、3型不一定属于1型；3型属于2型。<em>不是简单的包含关系。</em>写到这对于这四类文法还是比较模糊啊！！先继续看下去吧！</p>\n\n<h6 id=\"\">正规表达式与上下文无关文法</h6>\n\n<p>正规表达式和上下文无关文法是可以相互转换的，转换方法略。另外上下文无关文法即可以描述程序语言的词法也可以描述语法，但是相对于正规表达式来说，还是通常使用后者来描述词法，后者简单、直观、效率高。</p>\n\n<blockquote>\n  <p>编译原理及语法分析的内容还很多，不过仅仅是为了读es5的文档补充知识并且 js 解释执行没有后面的几步，所以本系列只到语法分析的这一部分，后面的语法树、抽象语法树等到有必要的时候在进行了解了！</p>\n</blockquote>\n\n<p>参考资料：</p>\n\n<ol>\n<li>《编译原理（第三版）》科学出版社  </li>\n<li><a href=\"http://blog.csdn.net/lovesummerforever/article/category/1438807\">编译原理学习周入门教程</a>  </li>\n<li>传说中好像还有龙虎鲸三本经典，然而图书馆并没有🙄</li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474242612596,"created_by":1,"updated_at":1474336692849,"updated_by":1,"published_at":1474249659205,"published_by":1},{"id":72,"uuid":"5d8c5247-3161-4797-ac18-5e6314692f7f","title":"转：js 词法","slug":"zhuan-js-ci-fa","markdown":"补充了部分编译原理的知识，回过头来再看 es5 标准的五到七章，总算大致能够看明白了，主要是还是非终结符、产生式这些东西。然后看到博客园的这篇[Javascript词法](http://www.cnblogs.com/winter-cn/archive/2012/04/17/2454229.html)，感觉总结的还不错，就用markdown改写了一下，转过来了！当然自己也稍微加了点料子。对应了标准的第七章。\n\n#### InputElement 输入元素\n\n输入元素是 js 词法扫描程序拿到的最基本元素了，也就是 js 程序源代码中表达特定意义的\"单词\"。输入元素共分为四种：\n\n```\nInputElement ::\n    WhiteSpace\n    Comment\n    Token\n    LineTerminator\n```\n\n另外值得注意的是，ES5 规范里面其实定义了两种InputElement ，如下所示：\n\n```\nInputElementDiv ::\n    WhiteSpace\n    Comment\n    Token\n    LineTerminator\n    DivPunctuator\n```\n\n```\nInputElementRegExp ::\n    WhiteSpace\n    Comment\n    Token\n    LineTerminator\n    RegularExpressionLiteral\n```\n\n这么做是因为JS的除法运算符和正则表达式直接量都使用了 / 字符，在词法分析阶段，是无法区分二者的。所以 js 的词法分析有两种状态，一种状态是扫描 InputElementDiv，另一种状态是扫描InputElementRegExp，又所以，js的词法分析器应该有两种状态，由语法分析器来设置，js 的词法分析和语法分析必须交错进行。\n\n下面的一个例子说明了除法和正则表达式写法的冲突问题：\n\n```\nif(a+b)/a/g;\n(a+b)/a/g;\n```\n\n可以看到完全相同的/a/g（而且前面一段字符也相同），可能被理解为除法或者正则表达式。因为必须区分所处的语法环境，所以单单靠词法分析无论如何也无法决定该用除法还是正则表达式来理解。\n\n因为基本上没有任何编辑环境会对文本做语法分析，这个问题也造成了很多语法着色系统无法很好地处理 js 正则表达式。以非语言实现者的角度，完全应该按照最上面一段产生式去理解 js 的词法。\n\n#### WhiteSpace 空白符\n\n这个词相信不用细说，所有 js 程序员都比较熟悉。js 接受5种 ASCII 字符为空白符，BOM 以及 Unicode 分类中所有属于 whitespace 分类的字符也可以作为空白符使用：\n\n```\nWhiteSpace ::\n    <TAB>\n    <VT>\n    <FF>\n    <SP>\n    <NBSP>\n    <BOM>\n    <USP>\n```\n\n其中，<TAB>是U+0009，是缩进TAB符，也就是字符串中写的'\\t'。\n\n<VT>是U+000B，也就是垂直方向的TAB符'\\v'，这个字符在键盘上很难打出来，所以很少用到。\n\n<FF>是U+000C，Form Feed，分页符，字符串直接量中写作'\\f'，现代已经很少有打印源程序的事情发生了，所以这个字符在JS源代码中很少用到。\n\n<SP>是U+0020，就是最普通的空格了。\n\n<NBSP>是U+00A0，非断行空格，它是SP的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的JS编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）\n\n<BOM>是U+FEFF，这是ES5新加入的空白符，是Unicode中的零宽非断行空格，在以UTF格式编码的文件中，常常在文件首插入一个额外的U+FEFF，解析UTF文件的程序可以根据U+FEFF的表示方法猜测文件采用哪种UTF编码方式。这个字符也叫做\"bit order mark\"。\n\n<USP>表示Unicode中所有的\"separator, space(Zs)\"分类中的字符，包括（原文中有，不过不是很重要，本文省略了）。\n\t　\n> 注意虽然 js 规范承认这些字符可以被用做空白字符，但是除非对源代码的打印、排版有特别的需求，还是应该尽量使用<SP>，尤其是考虑到，相当一批字体无法支持<USP>中的全部字符。\n\n根据一些团队的编码规范，<TAB>常常用于缩进。编程语言中关于用<TAB>还是四个<SP>做缩进的争论从未停止过，此处就不加讨论了。\n\njs中，WhiteSpace 的大部分用途是分隔 token 和保持代码整齐美观，基本上词法分析器产生的 WhiteSpace 都会被语法分析器直接丢弃。\n\n所以一些 WhiteSpace 能够被去掉而完全不影响程序的执行效果。但是也有一些 WhiteSpace 必须存在的情况，考虑下面代码：\n\n```\n1 .toString();\n1.toString(); //报错\n```\n\n上面一段代码中，空白符分隔了1和.，因此它们被理解为两个token。[具体解释](http://stackoverflow.com/questions/38968598/what-happened-inside-of-1-tostring-and-1-tostring-in-javascript)\n\n```\n1.[\"toString\"]();\n1 .[\"toString\"](); //报错\n```\n相反的情况。\n\n#### LineTerminator 行终结符\n\n这个也是一个非常常见的概念了，js 中只提供了4种字符作为换行符：\n\n```\nLineTerminator ::\n    <LF>\n    <CR>\n    <LS>\n    <PS>\n```\n\n其中，<LF>是U+000A，就是最正常换行符，在字符串中的'\\n'。\n\n<CR>是U+000D，这个字符真正意义上的\"回车\"，在字符串中是'\\r'，在一部分Windows风格文本编辑器中，换行是两个字符\\r\\n。\n\n<LS>是U+2028，是Unicode中的行分隔符。\n\n<PS>是U+2029，是Unicode中的段落分隔符。\n\n大部分 LineTerminator 在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响 js 的两个重要语法特性：自动插入分号和\"no line terminator\"规则。\n\n> \"no line terminator\"规则：如果产生式的右侧出现“[no LineTerminator here]”，那么它表示此产生式是个受限的产生式：如果 LineTerminator 在输入流的指定位置出现，那么此产生式将不会被适用。例如，产生式：\nThrowStatement : throw [no LineTerminator here] Expression ;\n\n考虑下面三段代码：\n\n```\nvar a = 1 , b = 1;\na\n++\nb\n```\n按照 js 语法的自动插入分号规则，代码解释可能产生歧义。但是因为后自增运算符有no line terminator的限制，所以实际结果等价于：\n\n```\nvar a = 1 , b = 1;\na;\n++b;\n```\n\n考虑以下两段代码：\n\n```\nreturn\n    123;\nreturn 123;\n```\n\n因为return有 no line terminator 的限制,所以第一段代码实际等同于\n\n```\nreturn;\n123;\n```\n\n#### Comment 注释\nJS的注释分为单行注释和多行注释两种： \n\n```\nComment :: \n    MultiLineComment \n    SingleLineComment\n```\n\n多行注释定义如下：\n\n```\nMultiLineComment :: \n    /* MultiLineCommentCharsopt */ \nMultiLineCommentChars :: \n    MultiLineNotAsteriskChar MultiLineCommentCharsopt \n    * PostAsteriskCommentCharsopt \nPostAsteriskCommentChars :: \n    MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentCharsopt \n    * PostAsteriskCommentCharsopt \nMultiLineNotAsteriskChar :: \n    SourceCharacter but not asterisk * \nMultiLineNotForwardSlashOrAsteriskChar :: \n    SourceCharacter but not forward-slash / orasterisk *\n```\n\n这个定义略微有些复杂，实际上这就是我们所熟知的 js 多行注释语法的严格描述。\n\n多行注释中允许自由地出现MultiLineNotAsteriskChar ，也就是除了*之外的所有字符。而每一个*之后，不能出现正斜杠符/\n\n单行注释则比较简单：\n\n```\nSingleLineComment ::\n    // SingleLineCommentCharsopt\nSingleLineCommentChars ::\n    SingleLineCommentChar SingleLineCommentCharsopt\nSingleLineCommentChar ::\n    SourceCharacter but not LineTerminator\n```\n\n除了四种LineTerminator之外，所有字符都可以作为单行注释。\n\n一般情况下，不论是单行还是多行注释都不会影响程序的意义，但是含有LineTerminator的多行注释会影响到自动插入分号规则：\n\n```\nreturn/*\n    */123;\n```\n\n```\nreturn /**/ 123;\n```\n\n两者会产生不同的效果。\n\n#### Token\nToken 是 js 中所有能被引擎理解的最小语义单元。\n\njs 中有4种Token：\n\n```\nToken ::\n    IdentifierName \n    Punctuator \n    NumericLiteral \n    StringLiteral\n```\n\n如果不考虑除法和正则的冲突问题，Token还应该包括RegularExpressionLiteral，而Punctuator中也应该添加 / 和 /= 两种符号。\n\n###### IdentifierName 标识符名\nIdentifierName的定义为：\n\n```\nIdentifierName ::\n    IdentifierStart\n    IdentifierName IdentifierPart\nIdentifierStart ::\n    UnicodeLetter\n    $\n    _ \n    \\ UnicodeEscapeSequence\nIdentifierPart ::\n    IdentifierStart\n    UnicodeCombiningMark\n    UnicodeDigit\n    UnicodeConnectorPunctuation\n    <ZWNJ>\n    <ZWJ>\n```\n\nIdentifierName 可以以美元符$下划线_ 或者Unicode字母开始，除了开始字符以外，IdentifierName 中还可以使用 Unicode 中的连接标记、数字、以及连接符号。\n\nIdentifierName 的任意字符可以使用 js 的 Unicode 转义写法，使用Unicode 转义写法时，没有任何字符限制。\n\nIdentifierName 可以是 Identifier、NullLiteral、BooleanLiteral 或者 keyword ，在 ObjectLiteral 中，IdentifierName 还可以被直接当做属性名称使用。\n\n仅当不是保留字的时候，IdentifierName 会被解析为 Identifier 。\n\nUnicodeLetter, UnicodeCombiningMark, UnicodeDigit, UnicodeConnectorPunctuation 各自对应几个 Unicode 的分类。\n\n![](https://ws4.sinaimg.cn/large/006bH5BKgw1f7yypaauqsj30nw0fidi6.jpg)\n\n> 注意<ZWNJ>和<ZWJ>是ES5新加入的两个格式控制字符，但是目前为止实测还没有浏览器支持。\n\nJS中的关键字有:\n\n```\nKeyword :: one of\n    break do instanceof typeof case else new var catch finally return void continue for switch while debugger function this with default if throw delete in try\n```\n\n还有7个为了未来使用而保留的关键字: \n\n```\nFutureReservedKeyword :: one of\n    class enum extends super const export import\n```\n\n在严格模式下,有一些额外的为未来使用而保留的关键字:\n\n```\nimplements let private public interface package protected static yield\n```\n\n除了这些之外，NullLiteral： \n\n```\nNullLiteral ::\n    null\n```\n\n和BooleanLiteral：\n\n```\nBooleanLiteral ::\n    true false\n```\n\n也是保留字，不能用于Identifier。\n\n###### Punctuator\n\njs 使用48个运算符，因为前面提到的除法和正则问题，/和/=两个运算符被拆分为DivPunctuator。其余的运算符为：\n\n```\n Punctuator :: one of\n    { } ( ) [ ] . ; , < > <= >= == != === !== + - * % ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= <<= >>= >>>= &= |= ^=\n```\n\n所有运算符在语法分析器中作为不同的 symbol 出现。\n\n###### NumericLiteral 数字字面量\n\njs 规范中规定的数字直接量可以支持两种写法：十进制和十六进制整数，尽管标准中没有提到，但是大部分 js 实现还支持以0开头的八进制整数写法。\n\n所以实际上 js 的 NumericLiteral 产生式应该是这样的：\n\n```\nNumericLiteral :: \n    DecimalLiteral\n    HexIntegerLiteral\n    OctalIntegerLiteralnot-standard \n```\n\n只有十进制可以表示浮点数，DecimalLiteral 定义如下:\n\n```\nDecimalLiteral ::\n    DecimalIntegerLiteral . DecimalDigitsopt ExponentPartopt\n    . DecimalDigits ExponentPartopt\n    DecimalIntegerLiteral ExponentPartopt\nDecimalIntegerLiteral ::\n    0 \n    NonZeroDigit DecimalDigitsopt\nDecimalDigits ::\n    DecimalDigit\n    DecimalDigits DecimalDigit\nDecimalDigit :: one of\n    0 1 2 3 4 5 6 7 8 9\nNonZeroDigit:: one of\n    1 2 3 4 5 6 7 8 9\nExponentPart::\n    ExponentIndicator SignedInteger\nExponentIndicator :: one of\n    e E\nSignedInteger ::\n    DecimalDigits\n    + DecimalDigits\n    - DecimalDigits\n```\n\n十进制数的小数点前和小数点后均可以省略， 所以 1. 和 .1 都是合法的数字直接量，特别地，除了0之外，十进制数不能以0开头（这其实是为了八进制整数预留的）。\n\n.同时还是一个 Punctuator ，在词法分析阶段，.123 应该优先被尝试理解为 NumericLiteral ，而非 Punctuator NumericLiteral。\n\n十六进制整数产生式如下：\n\n```\nHexIntegerLiteral ::\n    0x HexDigit\n    0X HexDigit\n    HexIntegerLiteral HexDigit\nHexDigit :: one of\n    0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F\n```\n\njs 中支持0x标记的大小写形式，十六进制数字中的大小写也可以任意使用。\n\n八进制整数是非标准的，但是大多数引擎都支持（严格模式下是禁止的）：\n\n```\nOctalIntegerLiteral :: \n    0 OctalDigit\n    OctalIntegerLiteral OctalDigit \nOctalDigit :: one of\n    0 1 2 3 4 5 6 7\n```\n\n###### StringLiteral 字符串字面量\n\njs 中的 StringLiteral 支持单引号和双引号两种写法。\n\n```\nStringLiteral ::\n    \" DoubleStringCharactersopt \"\n    ' SingleStringCharactersopt '\n```\n\n单双引号的区别仅仅在于写法，在双引号字符串直接量中，双引号必须转义，在单引号字符串直接量中，单引号必须转义\n\n```\nDoubleStringCharacters ::\n    DoubleStringCharacter DoubleStringCharactersopt\nSingleStringCharacters ::\n    SingleStringCharacter SingleStringCharactersopt\nDoubleStringCharacter ::\n    SourceCharacter but not double-quote \" or backslash \\ or LineTerminator\n    \\ EscapeSequence\n    LineContinuation\nSingleStringCharacter ::\n    SourceCharacter but not single-quote ' orbackslash \\ or LineTerminator\n    \\ EscapeSequence\n    LineContinuation\n```\n\n字符串中其他必须转义的字符是 \\ 和所有换行符。\n\njs 中支持四种转义形式，还有一种虽然标准没有定义，但是大部分实现都支持的八进制转义\n\n```\nEscapeSequence ::\n    CharacterEscapeSequence\n    0 [lookahead no DecimalDigit]\n    HexEscapeSequence\n    UnicodeEscapeSequence\n    OctalEscapeSequencenot-standard \n```\n\n第一种是单字符转义。即一个反斜杠 \\ 后面跟一个字符这种形式。\n\n```\nCharacterEscapeSequence ::\n    SingleEscapeCharacter\n    NonEscapeCharacter\nSingleEscapeCharacter :: one of\n    ' \" \\ b f n r t v\nNonEscapeCharacter ::\n    SourceCharacter but notEscapeCharacter or LineTerminator\n```\n\n有特别意义的字符包括有 SingleEscapeCharacter 所定义的9种。除了这9种字符、数字、x和u以及所有的换行符之外，其它字符经过\\转义都是自身。\n\n十六进制转义只支持两位，也就是说，这种写法只支持ASCII字符：\n\n```\nHexEscapeSequence ::\n    x HexDigit HexDigit\n```\n\nUnicode转义可以支持BMP中的所有字符：\n\n```\nUnicodeEscapeSequence ::\n    u HexDigit HexDigit HexDigit HexDigit\n```\n\nLineContinuation 可以被理解为一种特别的转义。写字符串直接量时灵活使用 LineContinuation 可以增加可读性。\n\n```\nLineContinuation ::\n    \\ LineTerminatorSequence\nLineTerminatorSequence ::\n    <LF>\n    <CR> [lookahead no <LF> ]\n    <LS>\n    <PS>\n    <CR>\n    <CR> <LF>    \n```\n\n为了适应 Windows 风格的文本，js 把\"\\r\\n\"作为一个换行符使用。\n\n> 注意因为 CR 在某些 Windows 风格的编辑器中没法显示出来，所以乱用的话会产生奇怪的效果。\n\n###### RegularExpressionLiteral 正则字面量\n\n正则表达式由Body和Flags两部分组成：\n\n```\nRegularExpressionLiteral ::\n    / RegularExpressionBody / RegularExpressionFlags\n```\n\n其中 Body 部分至少有一个字符，第一个字符不能是*\n（因为/*跟多行注释有词法冲突。）\n\n```\nRegularExpressionBody ::\n    RegularExpressionFirstChar RegularExpressionChars\nRegularExpressionChars ::\n    [empty]\n    RegularExpressionChars RegularExpressionChar\nRegularExpressionFirstChar ::\n    RegularExpressionNonTerminator but not * or \\ or / or [ \n    RegularExpressionBackslashSequence\n    RegularExpressionClass\nRegularExpressionChar ::\n    RegularExpressionNonTerminator but not \\ or / or [ \n    RegularExpressionBackslashSequence\n    RegularExpressionClass\n```\n\n除了\\  / 和 [ 三个字符之外，js 正则表达式中的字符都是普通字符。\n\n```\nRegularExpressionBackslashSequence ::\n    \\ RegularExpressionNonTerminator\nRegularExpressionNonTerminator ::\n    SourceCharacter but not LineTerminator\n```\n\n用 \\和一个非换行符可以组成一个RegularExpressionBackslashSequence，这种方式可以用于表示正则表达式中的有特殊意义的字符。\n\n```\nRegularExpressionClass ::\n    [ RegularExpressionClassChars ]\n```\n\n正则表达式中，用一对方括号表示class。class中的特殊字符仅仅为]和\\。\n\nclass允许为空。class中也支持转义。\n\n```\nRegularExpressionClassChars ::\n    [empty]\n    RegularExpressionClassChars RegularExpressionClassChar\nRegularExpressionClassChar ::\n    RegularExpressionNonTerminator but not ] or \\ \n    RegularExpressionBackslashSequence\n```\n\n正则表达式中的 flag 在词法阶段不会限制字符，虽然只有 ig 几个是有效的，但是任何 IdentifierPart 序列在词法阶段都会被认为是合法的。\n\n```\nRegularExpressionFlags ::\n    [empty]\n    RegularExpressionFlags IdentifierPart    \n```  ","html":"<p>补充了部分编译原理的知识，回过头来再看 es5 标准的五到七章，总算大致能够看明白了，主要是还是非终结符、产生式这些东西。然后看到博客园的这篇<a href=\"http://www.cnblogs.com/winter-cn/archive/2012/04/17/2454229.html\">Javascript词法</a>，感觉总结的还不错，就用markdown改写了一下，转过来了！当然自己也稍微加了点料子。对应了标准的第七章。</p>\n\n<h4 id=\"inputelement\">InputElement 输入元素</h4>\n\n<p>输入元素是 js 词法扫描程序拿到的最基本元素了，也就是 js 程序源代码中表达特定意义的\"单词\"。输入元素共分为四种：</p>\n\n<pre><code>InputElement ::  \n    WhiteSpace\n    Comment\n    Token\n    LineTerminator\n</code></pre>\n\n<p>另外值得注意的是，ES5 规范里面其实定义了两种InputElement ，如下所示：</p>\n\n<pre><code>InputElementDiv ::  \n    WhiteSpace\n    Comment\n    Token\n    LineTerminator\n    DivPunctuator\n</code></pre>\n\n<pre><code>InputElementRegExp ::  \n    WhiteSpace\n    Comment\n    Token\n    LineTerminator\n    RegularExpressionLiteral\n</code></pre>\n\n<p>这么做是因为JS的除法运算符和正则表达式直接量都使用了 / 字符，在词法分析阶段，是无法区分二者的。所以 js 的词法分析有两种状态，一种状态是扫描 InputElementDiv，另一种状态是扫描InputElementRegExp，又所以，js的词法分析器应该有两种状态，由语法分析器来设置，js 的词法分析和语法分析必须交错进行。</p>\n\n<p>下面的一个例子说明了除法和正则表达式写法的冲突问题：</p>\n\n<pre><code>if(a+b)/a/g;  \n(a+b)/a/g;\n</code></pre>\n\n<p>可以看到完全相同的/a/g（而且前面一段字符也相同），可能被理解为除法或者正则表达式。因为必须区分所处的语法环境，所以单单靠词法分析无论如何也无法决定该用除法还是正则表达式来理解。</p>\n\n<p>因为基本上没有任何编辑环境会对文本做语法分析，这个问题也造成了很多语法着色系统无法很好地处理 js 正则表达式。以非语言实现者的角度，完全应该按照最上面一段产生式去理解 js 的词法。</p>\n\n<h4 id=\"whitespace\">WhiteSpace 空白符</h4>\n\n<p>这个词相信不用细说，所有 js 程序员都比较熟悉。js 接受5种 ASCII 字符为空白符，BOM 以及 Unicode 分类中所有属于 whitespace 分类的字符也可以作为空白符使用：</p>\n\n<pre><code>WhiteSpace ::  \n    &lt;TAB&gt;\n    &lt;VT&gt;\n    &lt;FF&gt;\n    &lt;SP&gt;\n    &lt;NBSP&gt;\n    &lt;BOM&gt;\n    &lt;USP&gt;\n</code></pre>\n\n<p>其中，<TAB>是U+0009，是缩进TAB符，也就是字符串中写的'\\t'。</p>\n\n<p><VT>是U+000B，也就是垂直方向的TAB符'\\v'，这个字符在键盘上很难打出来，所以很少用到。</p>\n\n<p><FF>是U+000C，Form Feed，分页符，字符串直接量中写作'\\f'，现代已经很少有打印源程序的事情发生了，所以这个字符在JS源代码中很少用到。</p>\n\n<p><SP>是U+0020，就是最普通的空格了。</p>\n\n<p><NBSP>是U+00A0，非断行空格，它是SP的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的JS编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）</p>\n\n<p><BOM>是U+FEFF，这是ES5新加入的空白符，是Unicode中的零宽非断行空格，在以UTF格式编码的文件中，常常在文件首插入一个额外的U+FEFF，解析UTF文件的程序可以根据U+FEFF的表示方法猜测文件采用哪种UTF编码方式。这个字符也叫做\"bit order mark\"。</p>\n\n<p><USP>表示Unicode中所有的\"separator, space(Zs)\"分类中的字符，包括（原文中有，不过不是很重要，本文省略了）。 <br />\n    　</p>\n\n<blockquote>\n  <p>注意虽然 js 规范承认这些字符可以被用做空白字符，但是除非对源代码的打印、排版有特别的需求，还是应该尽量使用<SP>，尤其是考虑到，相当一批字体无法支持<USP>中的全部字符。</p>\n</blockquote>\n\n<p>根据一些团队的编码规范，<TAB>常常用于缩进。编程语言中关于用<TAB>还是四个<SP>做缩进的争论从未停止过，此处就不加讨论了。</p>\n\n<p>js中，WhiteSpace 的大部分用途是分隔 token 和保持代码整齐美观，基本上词法分析器产生的 WhiteSpace 都会被语法分析器直接丢弃。</p>\n\n<p>所以一些 WhiteSpace 能够被去掉而完全不影响程序的执行效果。但是也有一些 WhiteSpace 必须存在的情况，考虑下面代码：</p>\n\n<pre><code>1 .toString();  \n1.toString(); //报错  \n</code></pre>\n\n<p>上面一段代码中，空白符分隔了1和.，因此它们被理解为两个token。<a href=\"http://stackoverflow.com/questions/38968598/what-happened-inside-of-1-tostring-and-1-tostring-in-javascript\">具体解释</a></p>\n\n<pre><code>1.[\"toString\"]();  \n1 .[\"toString\"](); //报错  \n</code></pre>\n\n<p>相反的情况。</p>\n\n<h4 id=\"lineterminator\">LineTerminator 行终结符</h4>\n\n<p>这个也是一个非常常见的概念了，js 中只提供了4种字符作为换行符：</p>\n\n<pre><code>LineTerminator ::  \n    &lt;LF&gt;\n    &lt;CR&gt;\n    &lt;LS&gt;\n    &lt;PS&gt;\n</code></pre>\n\n<p>其中，<LF>是U+000A，就是最正常换行符，在字符串中的'\\n'。</p>\n\n<p><CR>是U+000D，这个字符真正意义上的\"回车\"，在字符串中是'\\r'，在一部分Windows风格文本编辑器中，换行是两个字符\\r\\n。</p>\n\n<p><LS>是U+2028，是Unicode中的行分隔符。</p>\n\n<p><PS>是U+2029，是Unicode中的段落分隔符。</p>\n\n<p>大部分 LineTerminator 在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响 js 的两个重要语法特性：自动插入分号和\"no line terminator\"规则。</p>\n\n<blockquote>\n  <p>\"no line terminator\"规则：如果产生式的右侧出现“[no LineTerminator here]”，那么它表示此产生式是个受限的产生式：如果 LineTerminator 在输入流的指定位置出现，那么此产生式将不会被适用。例如，产生式：\n  ThrowStatement : throw [no LineTerminator here] Expression ;</p>\n</blockquote>\n\n<p>考虑下面三段代码：</p>\n\n<pre><code>var a = 1 , b = 1;  \na  \n++\nb  \n</code></pre>\n\n<p>按照 js 语法的自动插入分号规则，代码解释可能产生歧义。但是因为后自增运算符有no line terminator的限制，所以实际结果等价于：</p>\n\n<pre><code>var a = 1 , b = 1;  \na;  \n++b;\n</code></pre>\n\n<p>考虑以下两段代码：</p>\n\n<pre><code>return  \n    123;\nreturn 123;  \n</code></pre>\n\n<p>因为return有 no line terminator 的限制,所以第一段代码实际等同于</p>\n\n<pre><code>return;  \n123;  \n</code></pre>\n\n<h4 id=\"comment\">Comment 注释</h4>\n\n<p>JS的注释分为单行注释和多行注释两种： </p>\n\n<pre><code>Comment ::  \n    MultiLineComment \n    SingleLineComment\n</code></pre>\n\n<p>多行注释定义如下：</p>\n\n<pre><code>MultiLineComment ::  \n    /* MultiLineCommentCharsopt */ \nMultiLineCommentChars ::  \n    MultiLineNotAsteriskChar MultiLineCommentCharsopt \n    * PostAsteriskCommentCharsopt \nPostAsteriskCommentChars ::  \n    MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentCharsopt \n    * PostAsteriskCommentCharsopt \nMultiLineNotAsteriskChar ::  \n    SourceCharacter but not asterisk * \nMultiLineNotForwardSlashOrAsteriskChar ::  \n    SourceCharacter but not forward-slash / orasterisk *\n</code></pre>\n\n<p>这个定义略微有些复杂，实际上这就是我们所熟知的 js 多行注释语法的严格描述。</p>\n\n<p>多行注释中允许自由地出现MultiLineNotAsteriskChar ，也就是除了<em>之外的所有字符。而每一个</em>之后，不能出现正斜杠符/</p>\n\n<p>单行注释则比较简单：</p>\n\n<pre><code>SingleLineComment ::  \n    // SingleLineCommentCharsopt\nSingleLineCommentChars ::  \n    SingleLineCommentChar SingleLineCommentCharsopt\nSingleLineCommentChar ::  \n    SourceCharacter but not LineTerminator\n</code></pre>\n\n<p>除了四种LineTerminator之外，所有字符都可以作为单行注释。</p>\n\n<p>一般情况下，不论是单行还是多行注释都不会影响程序的意义，但是含有LineTerminator的多行注释会影响到自动插入分号规则：</p>\n\n<pre><code>return/*  \n    */123;\n</code></pre>\n\n<pre><code>return /**/ 123;  \n</code></pre>\n\n<p>两者会产生不同的效果。</p>\n\n<h4 id=\"token\">Token</h4>\n\n<p>Token 是 js 中所有能被引擎理解的最小语义单元。</p>\n\n<p>js 中有4种Token：</p>\n\n<pre><code>Token ::  \n    IdentifierName \n    Punctuator \n    NumericLiteral \n    StringLiteral\n</code></pre>\n\n<p>如果不考虑除法和正则的冲突问题，Token还应该包括RegularExpressionLiteral，而Punctuator中也应该添加 / 和 /= 两种符号。</p>\n\n<h6 id=\"identifiername\">IdentifierName 标识符名</h6>\n\n<p>IdentifierName的定义为：</p>\n\n<pre><code>IdentifierName ::  \n    IdentifierStart\n    IdentifierName IdentifierPart\nIdentifierStart ::  \n    UnicodeLetter\n    $\n    _ \n    \\ UnicodeEscapeSequence\nIdentifierPart ::  \n    IdentifierStart\n    UnicodeCombiningMark\n    UnicodeDigit\n    UnicodeConnectorPunctuation\n    &lt;ZWNJ&gt;\n    &lt;ZWJ&gt;\n</code></pre>\n\n<p>IdentifierName 可以以美元符$下划线_ 或者Unicode字母开始，除了开始字符以外，IdentifierName 中还可以使用 Unicode 中的连接标记、数字、以及连接符号。</p>\n\n<p>IdentifierName 的任意字符可以使用 js 的 Unicode 转义写法，使用Unicode 转义写法时，没有任何字符限制。</p>\n\n<p>IdentifierName 可以是 Identifier、NullLiteral、BooleanLiteral 或者 keyword ，在 ObjectLiteral 中，IdentifierName 还可以被直接当做属性名称使用。</p>\n\n<p>仅当不是保留字的时候，IdentifierName 会被解析为 Identifier 。</p>\n\n<p>UnicodeLetter, UnicodeCombiningMark, UnicodeDigit, UnicodeConnectorPunctuation 各自对应几个 Unicode 的分类。</p>\n\n<p><img src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f7yypaauqsj30nw0fidi6.jpg\" alt=\"\" /></p>\n\n<blockquote>\n  <p>注意<ZWNJ>和<ZWJ>是ES5新加入的两个格式控制字符，但是目前为止实测还没有浏览器支持。</p>\n</blockquote>\n\n<p>JS中的关键字有:</p>\n\n<pre><code>Keyword :: one of  \n    break do instanceof typeof case else new var catch finally return void continue for switch while debugger function this with default if throw delete in try\n</code></pre>\n\n<p>还有7个为了未来使用而保留的关键字: </p>\n\n<pre><code>FutureReservedKeyword :: one of  \n    class enum extends super const export import\n</code></pre>\n\n<p>在严格模式下,有一些额外的为未来使用而保留的关键字:</p>\n\n<pre><code>implements let private public interface package protected static yield  \n</code></pre>\n\n<p>除了这些之外，NullLiteral： </p>\n\n<pre><code>NullLiteral ::  \n    null\n</code></pre>\n\n<p>和BooleanLiteral：</p>\n\n<pre><code>BooleanLiteral ::  \n    true false\n</code></pre>\n\n<p>也是保留字，不能用于Identifier。</p>\n\n<h6 id=\"punctuator\">Punctuator</h6>\n\n<p>js 使用48个运算符，因为前面提到的除法和正则问题，/和/=两个运算符被拆分为DivPunctuator。其余的运算符为：</p>\n\n<pre><code> Punctuator :: one of\n    { } ( ) [ ] . ; , &lt; &gt; &lt;= &gt;= == != === !== + - * % ++ -- &lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ! ~ &amp;&amp; || ? : = += -= *= %= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= |= ^=\n</code></pre>\n\n<p>所有运算符在语法分析器中作为不同的 symbol 出现。</p>\n\n<h6 id=\"numericliteral\">NumericLiteral 数字字面量</h6>\n\n<p>js 规范中规定的数字直接量可以支持两种写法：十进制和十六进制整数，尽管标准中没有提到，但是大部分 js 实现还支持以0开头的八进制整数写法。</p>\n\n<p>所以实际上 js 的 NumericLiteral 产生式应该是这样的：</p>\n\n<pre><code>NumericLiteral ::  \n    DecimalLiteral\n    HexIntegerLiteral\n    OctalIntegerLiteralnot-standard \n</code></pre>\n\n<p>只有十进制可以表示浮点数，DecimalLiteral 定义如下:</p>\n\n<pre><code>DecimalLiteral ::  \n    DecimalIntegerLiteral . DecimalDigitsopt ExponentPartopt\n    . DecimalDigits ExponentPartopt\n    DecimalIntegerLiteral ExponentPartopt\nDecimalIntegerLiteral ::  \n    0 \n    NonZeroDigit DecimalDigitsopt\nDecimalDigits ::  \n    DecimalDigit\n    DecimalDigits DecimalDigit\nDecimalDigit :: one of  \n    0 1 2 3 4 5 6 7 8 9\nNonZeroDigit:: one of  \n    1 2 3 4 5 6 7 8 9\nExponentPart::  \n    ExponentIndicator SignedInteger\nExponentIndicator :: one of  \n    e E\nSignedInteger ::  \n    DecimalDigits\n    + DecimalDigits\n    - DecimalDigits\n</code></pre>\n\n<p>十进制数的小数点前和小数点后均可以省略， 所以 1. 和 .1 都是合法的数字直接量，特别地，除了0之外，十进制数不能以0开头（这其实是为了八进制整数预留的）。</p>\n\n<p>.同时还是一个 Punctuator ，在词法分析阶段，.123 应该优先被尝试理解为 NumericLiteral ，而非 Punctuator NumericLiteral。</p>\n\n<p>十六进制整数产生式如下：</p>\n\n<pre><code>HexIntegerLiteral ::  \n    0x HexDigit\n    0X HexDigit\n    HexIntegerLiteral HexDigit\nHexDigit :: one of  \n    0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F\n</code></pre>\n\n<p>js 中支持0x标记的大小写形式，十六进制数字中的大小写也可以任意使用。</p>\n\n<p>八进制整数是非标准的，但是大多数引擎都支持（严格模式下是禁止的）：</p>\n\n<pre><code>OctalIntegerLiteral ::  \n    0 OctalDigit\n    OctalIntegerLiteral OctalDigit \nOctalDigit :: one of  \n    0 1 2 3 4 5 6 7\n</code></pre>\n\n<h6 id=\"stringliteral\">StringLiteral 字符串字面量</h6>\n\n<p>js 中的 StringLiteral 支持单引号和双引号两种写法。</p>\n\n<pre><code>StringLiteral ::  \n    \" DoubleStringCharactersopt \"\n    ' SingleStringCharactersopt '\n</code></pre>\n\n<p>单双引号的区别仅仅在于写法，在双引号字符串直接量中，双引号必须转义，在单引号字符串直接量中，单引号必须转义</p>\n\n<pre><code>DoubleStringCharacters ::  \n    DoubleStringCharacter DoubleStringCharactersopt\nSingleStringCharacters ::  \n    SingleStringCharacter SingleStringCharactersopt\nDoubleStringCharacter ::  \n    SourceCharacter but not double-quote \" or backslash \\ or LineTerminator\n    \\ EscapeSequence\n    LineContinuation\nSingleStringCharacter ::  \n    SourceCharacter but not single-quote ' orbackslash \\ or LineTerminator\n    \\ EscapeSequence\n    LineContinuation\n</code></pre>\n\n<p>字符串中其他必须转义的字符是 \\ 和所有换行符。</p>\n\n<p>js 中支持四种转义形式，还有一种虽然标准没有定义，但是大部分实现都支持的八进制转义</p>\n\n<pre><code>EscapeSequence ::  \n    CharacterEscapeSequence\n    0 [lookahead no DecimalDigit]\n    HexEscapeSequence\n    UnicodeEscapeSequence\n    OctalEscapeSequencenot-standard \n</code></pre>\n\n<p>第一种是单字符转义。即一个反斜杠 \\ 后面跟一个字符这种形式。</p>\n\n<pre><code>CharacterEscapeSequence ::  \n    SingleEscapeCharacter\n    NonEscapeCharacter\nSingleEscapeCharacter :: one of  \n    ' \" \\ b f n r t v\nNonEscapeCharacter ::  \n    SourceCharacter but notEscapeCharacter or LineTerminator\n</code></pre>\n\n<p>有特别意义的字符包括有 SingleEscapeCharacter 所定义的9种。除了这9种字符、数字、x和u以及所有的换行符之外，其它字符经过\\转义都是自身。</p>\n\n<p>十六进制转义只支持两位，也就是说，这种写法只支持ASCII字符：</p>\n\n<pre><code>HexEscapeSequence ::  \n    x HexDigit HexDigit\n</code></pre>\n\n<p>Unicode转义可以支持BMP中的所有字符：</p>\n\n<pre><code>UnicodeEscapeSequence ::  \n    u HexDigit HexDigit HexDigit HexDigit\n</code></pre>\n\n<p>LineContinuation 可以被理解为一种特别的转义。写字符串直接量时灵活使用 LineContinuation 可以增加可读性。</p>\n\n<pre><code>LineContinuation ::  \n    \\ LineTerminatorSequence\nLineTerminatorSequence ::  \n    &lt;LF&gt;\n    &lt;CR&gt; [lookahead no &lt;LF&gt; ]\n    &lt;LS&gt;\n    &lt;PS&gt;\n    &lt;CR&gt;\n    &lt;CR&gt; &lt;LF&gt;    \n</code></pre>\n\n<p>为了适应 Windows 风格的文本，js 把\"\\r\\n\"作为一个换行符使用。</p>\n\n<blockquote>\n  <p>注意因为 CR 在某些 Windows 风格的编辑器中没法显示出来，所以乱用的话会产生奇怪的效果。</p>\n</blockquote>\n\n<h6 id=\"regularexpressionliteral\">RegularExpressionLiteral 正则字面量</h6>\n\n<p>正则表达式由Body和Flags两部分组成：</p>\n\n<pre><code>RegularExpressionLiteral ::  \n    / RegularExpressionBody / RegularExpressionFlags\n</code></pre>\n\n<p>其中 Body 部分至少有一个字符，第一个字符不能是*\n（因为/*跟多行注释有词法冲突。）</p>\n\n<pre><code>RegularExpressionBody ::  \n    RegularExpressionFirstChar RegularExpressionChars\nRegularExpressionChars ::  \n    [empty]\n    RegularExpressionChars RegularExpressionChar\nRegularExpressionFirstChar ::  \n    RegularExpressionNonTerminator but not * or \\ or / or [ \n    RegularExpressionBackslashSequence\n    RegularExpressionClass\nRegularExpressionChar ::  \n    RegularExpressionNonTerminator but not \\ or / or [ \n    RegularExpressionBackslashSequence\n    RegularExpressionClass\n</code></pre>\n\n<p>除了\\  / 和 [ 三个字符之外，js 正则表达式中的字符都是普通字符。</p>\n\n<pre><code>RegularExpressionBackslashSequence ::  \n    \\ RegularExpressionNonTerminator\nRegularExpressionNonTerminator ::  \n    SourceCharacter but not LineTerminator\n</code></pre>\n\n<p>用 \\和一个非换行符可以组成一个RegularExpressionBackslashSequence，这种方式可以用于表示正则表达式中的有特殊意义的字符。</p>\n\n<pre><code>RegularExpressionClass ::  \n    [ RegularExpressionClassChars ]\n</code></pre>\n\n<p>正则表达式中，用一对方括号表示class。class中的特殊字符仅仅为]和\\。</p>\n\n<p>class允许为空。class中也支持转义。</p>\n\n<pre><code>RegularExpressionClassChars ::  \n    [empty]\n    RegularExpressionClassChars RegularExpressionClassChar\nRegularExpressionClassChar ::  \n    RegularExpressionNonTerminator but not ] or \\ \n    RegularExpressionBackslashSequence\n</code></pre>\n\n<p>正则表达式中的 flag 在词法阶段不会限制字符，虽然只有 ig 几个是有效的，但是任何 IdentifierPart 序列在词法阶段都会被认为是合法的。</p>\n\n<pre><code>RegularExpressionFlags ::  \n    [empty]\n    RegularExpressionFlags IdentifierPart    \n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474267630475,"created_by":1,"updated_at":1475051237723,"updated_by":1,"published_at":1474274830533,"published_by":1},{"id":73,"uuid":"66447ca1-fc70-4f87-b1bd-d3e8c9bf2aff","title":"js 自动分号插入(ASI)机制","slug":"js-asi-ji-zhi","markdown":"前一篇《js 词法》一文基本以及把规范的第七章介绍了一遍，不过漏下了7.9自动插入这一节。虽然只是一些小细节，但还是有必要记一下，因为通过此改善编码习惯很重要。\n\n我们在写 java 和 c 时，必须要在语句后加分号，否则编译通不过。而 js 不同，存在自动分好插入机制，下文简称 ASI。它会给源代码的 token 流自动插入分号。\n\n#### 规范理论\n\nes5 标准定义了自动分号插入规则，包括以下三个基本规则加两个前置条件：\n\n###### 前置条件\n\n- 如果插入分号后解析结果是空语句，那么不会自动插入分号。\n\n例子：（空语句，else 前不加分好）\n```\nif (a > b)\nelse c = d\n```\n\n- 如果插入分号后它成为 for 语句头部的两个分号之一，那么不会自动插入分号。\n\n例子：（不会加分号）\n```\nfor (a; b\n)\n```\n\n###### 基本规则\n\n- 左到右解析程序，当遇到一个不符合任何文法产生式的 token（叫做 违规 token(offending token)），那么只要满足下面条件之一就在违规 token 前面自动插入分号。\n - 至少一个 LineTerminator 分割了违规 token 和前一个 token。\n - 违规 token 是 }。\n\n例子：（1、2不符合任何产生式，并且之间存在 LineTerminator，因此在违规 token 2前加了分好，2和}则是因为违规 token 是 }所以加了分号）\n\n```\n{ 1\n2 } 3\n```\n\n```\n{ 1\n;2 ;} 3;\n```\n\n- 左到右解析程序，tokens 输入流已经结束，当解析器无法将输入 token 流解析成单个完整 ECMAScript 程序 ，那么就在输入流的结束位置自动插入分号。\n-  对于受限产生式，也就是下面的5个，我们把产生式 [no LineTerminator here]后面的 token 叫做受限 token，如果在 token 和 受限 token 间存在了至少一个 LineTerminator，那么会在受限 token 前自动加上 token。\n\n受限的产生式只限如下5个：\n\n```\nPostfixExpression : \nLeftHandSideExpression [no LineTerminator here] ++ LeftHandSideExpression [no LineTerminator here] --\n```\n\n```\nContinueStatement : \ncontinue [no LineTerminator here] Identifier; \n```\n\n```\nBreakStatement : \nbreak [no LineTerminator here] Identifier; \n```\n\n```\nReturnStatement : \nreturn [no LineTerminator here] Expression; \n```\n\n```\nThrowStatement : throw [no LineTerminator here] Expression;\n```\n\n#### 归纳\n\n###### 避免 ASI 带来的问题\n\n- 后缀运算符 ++ 或 -- 和它的操作数应该出现在同一行。\n- return 或 throw 语句的表达式开始位置应该和 return 或 throw token 同一行。\n- break 或 continue 语句的标示符应该和 break 或 continue token 同一行。\n\n###### 何时加分号\n\n无分号党（懒人党）想要不加分号，那么就需要知道什么时候应该要加分号。[JS魔法堂：ASI(自动分号插入机制)和前置分号](http://www.cnblogs.com/fsjohnhuang/p/4154503.html)归纳了 NO ASI 并且会出现错误的几种情况，在这几种情况下我们是要加分号的。下面是对应的描述（具体了解为什么点击那篇文章）：\n\n> 在以 ([/+- 开头的语句前加分号(由于正常写法均不会出现以 .,*% 作为语句开头，因此只需记住前面5个即可，你看能懒则懒哦)\n\n不过这里只考虑了换行的情况，其实 ASI 还存在不换行的情况，这就要根据标准里的三条规则行事了！\n\n知道了这点，其实我们就可以省略大部分的分号了。但是也不强求，因为这还是要根据个人习惯以及团队风格走的。\n\n###### 小补充\n\n为什么自执行函数前要加分号？\n\n主要是应对代码合并压缩时，由于缺少分号；带来的错误。知道了上面的规则，在 ( 开头的行前加分号就可以避免错误了。\n\n\n","html":"<p>前一篇《js 词法》一文基本以及把规范的第七章介绍了一遍，不过漏下了7.9自动插入这一节。虽然只是一些小细节，但还是有必要记一下，因为通过此改善编码习惯很重要。</p>\n\n<p>我们在写 java 和 c 时，必须要在语句后加分号，否则编译通不过。而 js 不同，存在自动分好插入机制，下文简称 ASI。它会给源代码的 token 流自动插入分号。</p>\n\n<h4 id=\"\">规范理论</h4>\n\n<p>es5 标准定义了自动分号插入规则，包括以下三个基本规则加两个前置条件：</p>\n\n<h6 id=\"\">前置条件</h6>\n\n<ul>\n<li>如果插入分号后解析结果是空语句，那么不会自动插入分号。</li>\n</ul>\n\n<p>例子：（空语句，else 前不加分好）</p>\n\n<pre><code>if (a &gt; b)  \nelse c = d  \n</code></pre>\n\n<ul>\n<li>如果插入分号后它成为 for 语句头部的两个分号之一，那么不会自动插入分号。</li>\n</ul>\n\n<p>例子：（不会加分号）</p>\n\n<pre><code>for (a; b  \n)\n</code></pre>\n\n<h6 id=\"\">基本规则</h6>\n\n<ul>\n<li>左到右解析程序，当遇到一个不符合任何文法产生式的 token（叫做 违规 token(offending token)），那么只要满足下面条件之一就在违规 token 前面自动插入分号。\n<ul><li>至少一个 LineTerminator 分割了违规 token 和前一个 token。</li>\n<li>违规 token 是 }。</li></ul></li>\n</ul>\n\n<p>例子：（1、2不符合任何产生式，并且之间存在 LineTerminator，因此在违规 token 2前加了分好，2和}则是因为违规 token 是 }所以加了分号）</p>\n\n<pre><code>{ 1\n2 } 3  \n</code></pre>\n\n<pre><code>{ 1\n;2 ;} 3;\n</code></pre>\n\n<ul>\n<li>左到右解析程序，tokens 输入流已经结束，当解析器无法将输入 token 流解析成单个完整 ECMAScript 程序 ，那么就在输入流的结束位置自动插入分号。</li>\n<li>对于受限产生式，也就是下面的5个，我们把产生式 [no LineTerminator here]后面的 token 叫做受限 token，如果在 token 和 受限 token 间存在了至少一个 LineTerminator，那么会在受限 token 前自动加上 token。</li>\n</ul>\n\n<p>受限的产生式只限如下5个：</p>\n\n<pre><code>PostfixExpression :  \nLeftHandSideExpression [no LineTerminator here] ++ LeftHandSideExpression [no LineTerminator here] --  \n</code></pre>\n\n<pre><code>ContinueStatement :  \ncontinue [no LineTerminator here] Identifier;  \n</code></pre>\n\n<pre><code>BreakStatement :  \nbreak [no LineTerminator here] Identifier;  \n</code></pre>\n\n<pre><code>ReturnStatement :  \nreturn [no LineTerminator here] Expression;  \n</code></pre>\n\n<pre><code>ThrowStatement : throw [no LineTerminator here] Expression;  \n</code></pre>\n\n<h4 id=\"\">归纳</h4>\n\n<h6 id=\"asi\">避免 ASI 带来的问题</h6>\n\n<ul>\n<li>后缀运算符 ++ 或 -- 和它的操作数应该出现在同一行。</li>\n<li>return 或 throw 语句的表达式开始位置应该和 return 或 throw token 同一行。</li>\n<li>break 或 continue 语句的标示符应该和 break 或 continue token 同一行。</li>\n</ul>\n\n<h6 id=\"\">何时加分号</h6>\n\n<p>无分号党（懒人党）想要不加分号，那么就需要知道什么时候应该要加分号。<a href=\"http://www.cnblogs.com/fsjohnhuang/p/4154503.html\">JS魔法堂：ASI(自动分号插入机制)和前置分号</a>归纳了 NO ASI 并且会出现错误的几种情况，在这几种情况下我们是要加分号的。下面是对应的描述（具体了解为什么点击那篇文章）：</p>\n\n<blockquote>\n  <p>在以 ([/+- 开头的语句前加分号(由于正常写法均不会出现以 .,*% 作为语句开头，因此只需记住前面5个即可，你看能懒则懒哦)</p>\n</blockquote>\n\n<p>不过这里只考虑了换行的情况，其实 ASI 还存在不换行的情况，这就要根据标准里的三条规则行事了！</p>\n\n<p>知道了这点，其实我们就可以省略大部分的分号了。但是也不强求，因为这还是要根据个人习惯以及团队风格走的。</p>\n\n<h6 id=\"\">小补充</h6>\n\n<p>为什么自执行函数前要加分号？</p>\n\n<p>主要是应对代码合并压缩时，由于缺少分号；带来的错误。知道了上面的规则，在 ( 开头的行前加分号就可以避免错误了。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474275530868,"created_by":1,"updated_at":1475051224202,"updated_by":1,"published_at":1474290905445,"published_by":1},{"id":74,"uuid":"09f006ff-4962-4ba3-be43-8e80df2b9236","title":"js 类型系统","slug":"js-lei-xing","markdown":"这篇和前面的差不多，还是继续看 es5 的标准，然后对于存在疑问的地方加一些注释。这个系列应该叫做带你读 es5 标准，不过懒得改名字了！🙄而且暂时也没做百度的收录，看的人不多。\n\njs 中算法操作的值都有一个相关联的类型，这里的类型可以分为语言类型和规范类型。\n\n### 语言类型\n\n语言类型是我们使用 ECMAScript 语言直接操作的值对应的类型。它包括了未定义（Undefined）、空值（Null）、布尔值（Boolean）、字符串 （String）、数值 （Number）、对象 （Object）。\n\n#### 原始类型\n\njs 包括\n\n##### Undefined 类型\n\nUndefined 类型有且只有一个值，称为 undefined 。任何没有被赋值的变量都有 undefined 值。\n\n##### Null 类型\n\nNull 类型有且只有一个值，称为 null 。\n\n> undefined 和 null 以及 void 的区别有必要知道，本文不展开，自行百度。\n\n##### Boolean 类型\n\nBoolean 类型表示逻辑实体，有两个值，称为 true 和 false。\n\n##### String 类型\n\nString 是有限有序的字符序列。在 js 内部，这些字符都是使用 UTF-16 两个字节存储的（更确切地说应该是 USC-2，UTF-16 之前的版本，因为 js 出现在 UTF-16 之前）。String 的长度也是按2字节来算的。String 还可以根据数组那样根据所在序列的位置进行引用。\n\n> 关于unicode和js的故事，阮老师也写了一篇很不错的文章，[传送门](http://www.ruanyifeng.com/blog/2014/12/unicode.html)，以及ES6对于 unicode 的增强也有写到。\n\n##### Number 类型\n\njs 的所有数字只有一种类型，双精度浮点数，并且符合 IEEE754 标准。大部分的 js 引擎会在内部做优化并区分浮点数和整数。\n\n简单介绍一下 IEEE754 标准双精度64位浮点数的表示。它规定了如下式子：\n\n```\n(-1)^sign * (1 + 尾数) * 2^ 阶码\n```\n\n其中sign占一位，尾数占52位，阶码占11位。精度也可以算出来2^52=4503599627370496，一共16位，所以双精度浮点数的精度是15-16位。\n\n另外还要讲一下 js 的整型，先讲一下范围安全整型的范围是53位，字符码是16位，其余的包括数组、位运算则是32位。\n\n整型在 js 内部有两种表示，第一，大多数的 js 引擎将一个足够小的没有十进制分数的数字存储成一个整型， 并将这种表示形式持续尽可能长的时间。如果数字大小增加地太大或者出现了十进制的分数，它们就不得不回到浮点的表示形式。（这段书上的，暂时没能够理解😅😅）\n\n整型的浮点数表示很简单，就不详细介绍了！\n\n> 更加具体的解释建此文[传送门](http://jser.it/blog/2014/07/07/numbers-in-javascript/)，这篇文章对es5规范中与 IEEE754 定义有出入的内容进行了解释，很详细。\n\n另外除了上面5中原始类型，ES6又引入了一种新的原始数据类型Symbol，表示独一无二的值。它是js语言的第七种数据类型，想了解可以看阮老师的《es6入门》，本文限于es5 。\n\n#### 对象类型\n\n##### Object 类型\n\nObject 是一个属性的集合。每个属性既可以是一个命名的数据属性，也可以是一个命名的访问器属性，或是一个内部属性：\n\n- 命名的数据属性（named data property）由一个名字与一个 ECMAScript 语言值和一个 Boolean 属性集合组成\n- 命名的访问器属性（named accessor property）由一个名字与一个或两个访问器函数，和一个 Boolean 属性集合组成。访问器函数用于存取一个与该属性相关联的 ECMAScript 语言值\n- 内部属性（internal property）没有名字，且不能直接通过 ECMAScript 语言操作。内部属性的存在纯粹为了规范的目的。\n\n###### 命名数据属性\n\n命名数据属性包含一个数据值的位置。在这个位置可以读取和写入值。\n\n命名数据属性有四个描述其行为的特性(attribute)\n\n- [[Configurable]]  布尔值，表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。直接在对象上定义的属性，默认为true\n- [[Enumerable]]  布尔值，能否通过for-in循环返回属性。\n- [[Writable]]        布尔值,表明能否修改属性的值。（即是否是只读的）\n- [[Value]]            属性值\n\n###### 命名访问器属性\n\n访问器属性不包含数据值；它们包含一对getter和setter函数（不过，这两个函数都不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。命名访问器属性也有四个特性：\n\n- [[Configurable]]  布尔值，表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。直接在对象上定义的属性，默认为true\n- [[Enumerable]]  布尔值，能否通过for-in循环返回属性。\n- [[Get]]  在读取这个属性时调用的函数。   getter函数\n- [[Set]]   在为这个属性赋值时调用的函数。  setter函数\n\n###### 内部属性\n\n有一些属性仅仅是为规范所用的，称之为内部属性，因为它们无法通过JavaScript直接访问到，但是它们的确存在，并且影响着程序的表现。内部属性的名称比较特殊，它们都被两个中括号包围着。\n\n> 常见的差不多都记了下，还是挺有用的，比如内部属性[[Class]]用于区分对象的种类，只有Object.prototype.toString可以访问，所以很多库就会使用Object.prototype.toString来判断对象类型。[传送门](http://yanhaijing.com/es5/#79)\n\n###### 默认值\n\n如果你不明确的指定某个特性的值,则它们会被赋一个默认值:\n\n- [[Value]]                 undefined\n\n- [[Get]]                    undefined\n\n- [[Set]]                     undefined\n\n- [[Writable]]              false\n\n- [[Enumerable]]         false\n\n- [[Configurable]]        false\n\n> 另外还有一些与属性描述符相关的操作，[这里有介绍](http://www.cnblogs.com/oneplace/p/5492476.html)\n\n### 规范类型\n\n规范类型是描述 ECMAScript 语言构造与 ECMAScript 语言类型语意的算法所用的元值对应的类型。简单讲就是语言内部实现时用到的类型，如前面讲过的词法环境。规范类型可用来描述 ECMAScript 表式运算的中途结果，但是这些值不能存成对象的变量或是 ECMAScript 语言变量的值。\n\n#### 引用规范类型\n\n一个 引用 (Reference) 是个已解决的命名绑定。一个引用由三部分组成， 基 (base) 值， 引用名称（referenced name） 和布尔值 严格引用 (strict reference) 标志。基值是 undefined、一个 Object、一个 Boolean、一个 String、一个 Number、一个 environment record 中的任意一个。基值是 undefined 表示此引用可以不解决一个绑定。引用名称是一个字符串。\n\n本规范中使用以下抽象操作接近引用的组件：\n\n- GetBase(V)。 返回引用值 V 的基值组件。\n- GetReferencedName(V)。 返回引用值 V 的引用名称组件。\n- IsStrictReference(V)。 返回引用值 V 的严格引用组件。\n- HasPrimitiveBase(V)。 如果基值是 Boolean, String, Number，那么返回 true。\n- IsPropertyReference(V)。 如果基值是个对象或 HasPrimitiveBase(V) 是 true，那么返回 true；否则返回 false。\n- IsUnresolvableReference(V)。 如果基值是 undefined 那么返回 true，否则返回 false。\n\n本规范使用以下抽象操作来操作引用：\n\n##### GetValue(v)\n\n 1. 如果 Type(V) 不是引用 , 返回 V。\n 2. 令 base 为调用 GetBase(V) 的返回值。\n 3. 如果 IsUnresolvableReference(V), 抛出一个 ReferenceError    异常。\n 4. 如果 IsPropertyReference(V), 那么如果 HasPrimitiveBase(V) 是 false, 那么令 get 为 base 的 [[Get]] 内部方法 , 否则令 get 为下面定义的特殊的 [[Get]] 内部方法。将 base 作为 this 值，传递 GetReferencedName(V) 为参数，调用 get 内部方法，返回结果。\n 5. 否则 , base 必须是一个 environment record。\n 6. 传递 GetReferencedName(V) 和 IsStrictReference(V) 为参数调用 base 的 GetBindingValue( 见 10.2.1) 具体方法，返回结果。\n\nGetValue 中的 V 是原始基值的 属性引用 时使用下面的 [[Get]] 内部方法。它用 base 作为他的 this 值，其中属性 P 是它的参数。采用以下步骤：\n\n1. 令 O 为 ToObject(base)。\n2. 令 desc 为用属性名 P 调用 O 的 [[GetProperty]] 内部方法的返回值。\n3. 如果 desc 是 undefined，返回 undefined。\n4. 如果 IsDataDescriptor(desc) 是 true，返回 desc.[[Value]]。\n5. 否则 IsAccessorDescriptor(desc) 必须是 true，令 getter 为 desc.[[Get]]。\n6. 如果 getter 是 undefined，返回 undefined。\n7. 提供 base 作为 this 值，无参数形式调用 getter 的 [[Call]] 内部方法，返回结果。\n\n##### PutValue(v,w)\n\n1. 如果 Type(V) 不是引用，抛出一个 ReferenceError 异常。\n2. 令 base 为调用 GetBase(V) 的结果。\n3. 如果 IsUnresolvableReference(V)，那么\n - 如果 IsStrictReference(V) 是 true，那么\n抛出 ReferenceError 异常。\n - 用 GetReferencedName(V)，W，false 作为参数调用全局对象的 [[Put]] 内部方法。\n4. 否则如果 IsPropertyReference(V)，那么\n - 如果 HasPrimitiveBase(V) 是 false，那么令 put 为 base 的 [[Put]] 内部方法，否则令 put 为下面定义的特殊的 [[Put]] 内部方法。\n - 用 base 作为 this 值，用 GetReferencedName(V)，W，IsStrictReference(V) 作为参数调用 put 内部方法。\n5. 否则 base 必定是 environment record 作为 base 的引用。所以，\n - 用 GetReferencedName(V), W, IsStrictReference(V) 作为参数调用 base 的 SetMutableBinding (10.2.1) 具体方法。\n6. 返回。\n\nPutValue 中的 V 是原始基值的属性引用时使用下面的 [[Put]] 内部方法。用 base 作为 this 值，用属性 P，值 W，布尔标志 Throw 作为参数调用它。采用以下步骤：\n\n1. 令 O 为 ToObject(base)。\n2. 如果用 P 作为参数调用 O 的 [[CanPut]] 内部方法的结果是 false，那么\n - 如果 Throw 是 true，那么抛出一个 TypeError 异常。\n - 否则返回。\n3. 令 ownDesc 为用 P 作为参数调用 O 的 [[GetOwnProperty]] 内部方法的结果。\n4. 如果 IsDataDescriptor(ownDesc) 是 true，那么\n - 如果 Throw 是 true，那么抛出一个 TypeError 异常。\n - 否则返回。\n5. 令 desc 为用 P 作为参数调用 O 的 [[GetProperty]] 内部方法的结果。这可能是一个自身或继承的访问器属性描述或是一个继承的数据属性描述。\n6. 如果 IsAccessorDescriptor(desc) 是 true，那么\n - 令 setter 为 desc.Set，他不能是 undefined。\n - 用 base 作为 this 值，用只由 W 组成的列表作为参数调用 setter 的 [[Call]] 内部方法。\n7. 否则，这是要在临时对象 O 上创建自身属性的请求。\n8. 如果 Throw 是 true，抛出一个 TypeErroe 异常。\n返回。\n\n> 都是些内部的操作，没有一步步记住的必要。但是要知道，比如this的判断就与base属性有关，1..toString与getValue有关。\n\n#### 列表规范类型\n\n列表类型用来解释new 表达式、函数调用以及别的需要一个简单值列表的算法中的argument lists的评估。列表类型的元素是有序的，可以是任意长度。\n\n#### 完结规范类型\n\n完结类型用于说明执行将控制转移到外部的声明 (break, continue, return, throw) 的行为。完结类型的值是由三部分组成，形如（type，value，target），其中 type 是 normal, break, continue, return, throw 之一，value 是任何 ECMASCript 语言值或 empty，target 是任何 ECMAScript 标识符或 empty。\n\n#### 属性描述符及属性标识符规范类型\n\n属性标识符类型用于关联属性名称与属性描述符。属性标识符类型的值是 (name, descriptor) 形式的一对值，其中 name 是一个字符串和 descriptor 是一个属性描述符值。\n\n几个抽象方法用来操作属性描述符值，主要是判断描述符值得类型及对象和属性描述符的转换，具体方法名和过程查看文档。\n\n#### 词法环境和环境记录项规范类型\n\n词法环境和环境记录项类型用于说明在嵌套的函数或块中的名称解析行为。词法环境和环境记录项的具体定义在之前的执行环境一文已经做了介绍。\n\n标准中还有一章《对象内部方法的算法》，比较麻烦，而且用不太到，就不一大段贴过来了。\n\n### 小结\n\n本文把es5的6种语言类型及5种规范类型做了简单的介绍，作为开发人员，主要要掌握的是语言类型，但是了解一部分规范类型有助于我们了解语言内部的机制，所以看看也挺好。\n\n一天一章，速度有点慢，但是不急，稳扎稳打吧！回去跑步算了。\n\n\n\n\n\n\n\n","html":"<p>这篇和前面的差不多，还是继续看 es5 的标准，然后对于存在疑问的地方加一些注释。这个系列应该叫做带你读 es5 标准，不过懒得改名字了！🙄而且暂时也没做百度的收录，看的人不多。</p>\n\n<p>js 中算法操作的值都有一个相关联的类型，这里的类型可以分为语言类型和规范类型。</p>\n\n<h3 id=\"\">语言类型</h3>\n\n<p>语言类型是我们使用 ECMAScript 语言直接操作的值对应的类型。它包括了未定义（Undefined）、空值（Null）、布尔值（Boolean）、字符串 （String）、数值 （Number）、对象 （Object）。</p>\n\n<h4 id=\"\">原始类型</h4>\n\n<p>js 包括</p>\n\n<h5 id=\"undefined\">Undefined 类型</h5>\n\n<p>Undefined 类型有且只有一个值，称为 undefined 。任何没有被赋值的变量都有 undefined 值。</p>\n\n<h5 id=\"null\">Null 类型</h5>\n\n<p>Null 类型有且只有一个值，称为 null 。</p>\n\n<blockquote>\n  <p>undefined 和 null 以及 void 的区别有必要知道，本文不展开，自行百度。</p>\n</blockquote>\n\n<h5 id=\"boolean\">Boolean 类型</h5>\n\n<p>Boolean 类型表示逻辑实体，有两个值，称为 true 和 false。</p>\n\n<h5 id=\"string\">String 类型</h5>\n\n<p>String 是有限有序的字符序列。在 js 内部，这些字符都是使用 UTF-16 两个字节存储的（更确切地说应该是 USC-2，UTF-16 之前的版本，因为 js 出现在 UTF-16 之前）。String 的长度也是按2字节来算的。String 还可以根据数组那样根据所在序列的位置进行引用。</p>\n\n<blockquote>\n  <p>关于unicode和js的故事，阮老师也写了一篇很不错的文章，<a href=\"http://www.ruanyifeng.com/blog/2014/12/unicode.html\">传送门</a>，以及ES6对于 unicode 的增强也有写到。</p>\n</blockquote>\n\n<h5 id=\"number\">Number 类型</h5>\n\n<p>js 的所有数字只有一种类型，双精度浮点数，并且符合 IEEE754 标准。大部分的 js 引擎会在内部做优化并区分浮点数和整数。</p>\n\n<p>简单介绍一下 IEEE754 标准双精度64位浮点数的表示。它规定了如下式子：</p>\n\n<pre><code>(-1)^sign * (1 + 尾数) * 2^ 阶码\n</code></pre>\n\n<p>其中sign占一位，尾数占52位，阶码占11位。精度也可以算出来2^52=4503599627370496，一共16位，所以双精度浮点数的精度是15-16位。</p>\n\n<p>另外还要讲一下 js 的整型，先讲一下范围安全整型的范围是53位，字符码是16位，其余的包括数组、位运算则是32位。</p>\n\n<p>整型在 js 内部有两种表示，第一，大多数的 js 引擎将一个足够小的没有十进制分数的数字存储成一个整型， 并将这种表示形式持续尽可能长的时间。如果数字大小增加地太大或者出现了十进制的分数，它们就不得不回到浮点的表示形式。（这段书上的，暂时没能够理解😅😅）</p>\n\n<p>整型的浮点数表示很简单，就不详细介绍了！</p>\n\n<blockquote>\n  <p>更加具体的解释建此文<a href=\"http://jser.it/blog/2014/07/07/numbers-in-javascript/\">传送门</a>，这篇文章对es5规范中与 IEEE754 定义有出入的内容进行了解释，很详细。</p>\n</blockquote>\n\n<p>另外除了上面5中原始类型，ES6又引入了一种新的原始数据类型Symbol，表示独一无二的值。它是js语言的第七种数据类型，想了解可以看阮老师的《es6入门》，本文限于es5 。</p>\n\n<h4 id=\"\">对象类型</h4>\n\n<h5 id=\"object\">Object 类型</h5>\n\n<p>Object 是一个属性的集合。每个属性既可以是一个命名的数据属性，也可以是一个命名的访问器属性，或是一个内部属性：</p>\n\n<ul>\n<li>命名的数据属性（named data property）由一个名字与一个 ECMAScript 语言值和一个 Boolean 属性集合组成</li>\n<li>命名的访问器属性（named accessor property）由一个名字与一个或两个访问器函数，和一个 Boolean 属性集合组成。访问器函数用于存取一个与该属性相关联的 ECMAScript 语言值</li>\n<li>内部属性（internal property）没有名字，且不能直接通过 ECMAScript 语言操作。内部属性的存在纯粹为了规范的目的。</li>\n</ul>\n\n<h6 id=\"\">命名数据属性</h6>\n\n<p>命名数据属性包含一个数据值的位置。在这个位置可以读取和写入值。</p>\n\n<p>命名数据属性有四个描述其行为的特性(attribute)</p>\n\n<ul>\n<li>[[Configurable]]  布尔值，表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。直接在对象上定义的属性，默认为true</li>\n<li>[[Enumerable]]  布尔值，能否通过for-in循环返回属性。</li>\n<li>[[Writable]]        布尔值,表明能否修改属性的值。（即是否是只读的）</li>\n<li>[[Value]]            属性值</li>\n</ul>\n\n<h6 id=\"\">命名访问器属性</h6>\n\n<p>访问器属性不包含数据值；它们包含一对getter和setter函数（不过，这两个函数都不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。命名访问器属性也有四个特性：</p>\n\n<ul>\n<li>[[Configurable]]  布尔值，表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性。直接在对象上定义的属性，默认为true</li>\n<li>[[Enumerable]]  布尔值，能否通过for-in循环返回属性。</li>\n<li>[[Get]]  在读取这个属性时调用的函数。   getter函数</li>\n<li>[[Set]]   在为这个属性赋值时调用的函数。  setter函数</li>\n</ul>\n\n<h6 id=\"\">内部属性</h6>\n\n<p>有一些属性仅仅是为规范所用的，称之为内部属性，因为它们无法通过JavaScript直接访问到，但是它们的确存在，并且影响着程序的表现。内部属性的名称比较特殊，它们都被两个中括号包围着。</p>\n\n<blockquote>\n  <p>常见的差不多都记了下，还是挺有用的，比如内部属性[[Class]]用于区分对象的种类，只有Object.prototype.toString可以访问，所以很多库就会使用Object.prototype.toString来判断对象类型。<a href=\"http://yanhaijing.com/es5/#79\">传送门</a></p>\n</blockquote>\n\n<h6 id=\"\">默认值</h6>\n\n<p>如果你不明确的指定某个特性的值,则它们会被赋一个默认值:</p>\n\n<ul>\n<li><p>[[Value]]                 undefined</p></li>\n<li><p>[[Get]]                    undefined</p></li>\n<li><p>[[Set]]                     undefined</p></li>\n<li><p>[[Writable]]              false</p></li>\n<li><p>[[Enumerable]]         false</p></li>\n<li><p>[[Configurable]]        false</p></li>\n</ul>\n\n<blockquote>\n  <p>另外还有一些与属性描述符相关的操作，<a href=\"http://www.cnblogs.com/oneplace/p/5492476.html\">这里有介绍</a></p>\n</blockquote>\n\n<h3 id=\"\">规范类型</h3>\n\n<p>规范类型是描述 ECMAScript 语言构造与 ECMAScript 语言类型语意的算法所用的元值对应的类型。简单讲就是语言内部实现时用到的类型，如前面讲过的词法环境。规范类型可用来描述 ECMAScript 表式运算的中途结果，但是这些值不能存成对象的变量或是 ECMAScript 语言变量的值。</p>\n\n<h4 id=\"\">引用规范类型</h4>\n\n<p>一个 引用 (Reference) 是个已解决的命名绑定。一个引用由三部分组成， 基 (base) 值， 引用名称（referenced name） 和布尔值 严格引用 (strict reference) 标志。基值是 undefined、一个 Object、一个 Boolean、一个 String、一个 Number、一个 environment record 中的任意一个。基值是 undefined 表示此引用可以不解决一个绑定。引用名称是一个字符串。</p>\n\n<p>本规范中使用以下抽象操作接近引用的组件：</p>\n\n<ul>\n<li>GetBase(V)。 返回引用值 V 的基值组件。</li>\n<li>GetReferencedName(V)。 返回引用值 V 的引用名称组件。</li>\n<li>IsStrictReference(V)。 返回引用值 V 的严格引用组件。</li>\n<li>HasPrimitiveBase(V)。 如果基值是 Boolean, String, Number，那么返回 true。</li>\n<li>IsPropertyReference(V)。 如果基值是个对象或 HasPrimitiveBase(V) 是 true，那么返回 true；否则返回 false。</li>\n<li>IsUnresolvableReference(V)。 如果基值是 undefined 那么返回 true，否则返回 false。</li>\n</ul>\n\n<p>本规范使用以下抽象操作来操作引用：</p>\n\n<h5 id=\"getvaluev\">GetValue(v)</h5>\n\n<ol>\n<li>如果 Type(V) 不是引用 , 返回 V。</li>\n<li>令 base 为调用 GetBase(V) 的返回值。</li>\n<li>如果 IsUnresolvableReference(V), 抛出一个 ReferenceError    异常。</li>\n<li>如果 IsPropertyReference(V), 那么如果 HasPrimitiveBase(V) 是 false, 那么令 get 为 base 的 [[Get]] 内部方法 , 否则令 get 为下面定义的特殊的 [[Get]] 内部方法。将 base 作为 this 值，传递 GetReferencedName(V) 为参数，调用 get 内部方法，返回结果。</li>\n<li>否则 , base 必须是一个 environment record。</li>\n<li>传递 GetReferencedName(V) 和 IsStrictReference(V) 为参数调用 base 的 GetBindingValue( 见 10.2.1) 具体方法，返回结果。</li>\n</ol>\n\n<p>GetValue 中的 V 是原始基值的 属性引用 时使用下面的 [[Get]] 内部方法。它用 base 作为他的 this 值，其中属性 P 是它的参数。采用以下步骤：</p>\n\n<ol>\n<li>令 O 为 ToObject(base)。  </li>\n<li>令 desc 为用属性名 P 调用 O 的 [[GetProperty]] 内部方法的返回值。  </li>\n<li>如果 desc 是 undefined，返回 undefined。  </li>\n<li>如果 IsDataDescriptor(desc) 是 true，返回 desc.[[Value]]。  </li>\n<li>否则 IsAccessorDescriptor(desc) 必须是 true，令 getter 为 desc.[[Get]]。  </li>\n<li>如果 getter 是 undefined，返回 undefined。  </li>\n<li>提供 base 作为 this 值，无参数形式调用 getter 的 [[Call]] 内部方法，返回结果。</li>\n</ol>\n\n<h5 id=\"putvaluevw\">PutValue(v,w)</h5>\n\n<ol>\n<li>如果 Type(V) 不是引用，抛出一个 ReferenceError 异常。  </li>\n<li>令 base 为调用 GetBase(V) 的结果。  </li>\n<li>如果 IsUnresolvableReference(V)，那么 <br />\n<ul><li>如果 IsStrictReference(V) 是 true，那么\n抛出 ReferenceError 异常。</li>\n<li>用 GetReferencedName(V)，W，false 作为参数调用全局对象的 [[Put]] 内部方法。</li></ul></li>\n<li>否则如果 IsPropertyReference(V)，那么 <br />\n<ul><li>如果 HasPrimitiveBase(V) 是 false，那么令 put 为 base 的 [[Put]] 内部方法，否则令 put 为下面定义的特殊的 [[Put]] 内部方法。</li>\n<li>用 base 作为 this 值，用 GetReferencedName(V)，W，IsStrictReference(V) 作为参数调用 put 内部方法。</li></ul></li>\n<li>否则 base 必定是 environment record 作为 base 的引用。所以， <br />\n<ul><li>用 GetReferencedName(V), W, IsStrictReference(V) 作为参数调用 base 的 SetMutableBinding (10.2.1) 具体方法。</li></ul></li>\n<li>返回。</li>\n</ol>\n\n<p>PutValue 中的 V 是原始基值的属性引用时使用下面的 [[Put]] 内部方法。用 base 作为 this 值，用属性 P，值 W，布尔标志 Throw 作为参数调用它。采用以下步骤：</p>\n\n<ol>\n<li>令 O 为 ToObject(base)。  </li>\n<li>如果用 P 作为参数调用 O 的 [[CanPut]] 内部方法的结果是 false，那么 <br />\n<ul><li>如果 Throw 是 true，那么抛出一个 TypeError 异常。</li>\n<li>否则返回。</li></ul></li>\n<li>令 ownDesc 为用 P 作为参数调用 O 的 [[GetOwnProperty]] 内部方法的结果。  </li>\n<li>如果 IsDataDescriptor(ownDesc) 是 true，那么 <br />\n<ul><li>如果 Throw 是 true，那么抛出一个 TypeError 异常。</li>\n<li>否则返回。</li></ul></li>\n<li>令 desc 为用 P 作为参数调用 O 的 [[GetProperty]] 内部方法的结果。这可能是一个自身或继承的访问器属性描述或是一个继承的数据属性描述。  </li>\n<li>如果 IsAccessorDescriptor(desc) 是 true，那么 <br />\n<ul><li>令 setter 为 desc.Set，他不能是 undefined。</li>\n<li>用 base 作为 this 值，用只由 W 组成的列表作为参数调用 setter 的 [[Call]] 内部方法。</li></ul></li>\n<li>否则，这是要在临时对象 O 上创建自身属性的请求。  </li>\n<li>如果 Throw 是 true，抛出一个 TypeErroe 异常。 <br />\n返回。</li>\n</ol>\n\n<blockquote>\n  <p>都是些内部的操作，没有一步步记住的必要。但是要知道，比如this的判断就与base属性有关，1..toString与getValue有关。</p>\n</blockquote>\n\n<h4 id=\"\">列表规范类型</h4>\n\n<p>列表类型用来解释new 表达式、函数调用以及别的需要一个简单值列表的算法中的argument lists的评估。列表类型的元素是有序的，可以是任意长度。</p>\n\n<h4 id=\"\">完结规范类型</h4>\n\n<p>完结类型用于说明执行将控制转移到外部的声明 (break, continue, return, throw) 的行为。完结类型的值是由三部分组成，形如（type，value，target），其中 type 是 normal, break, continue, return, throw 之一，value 是任何 ECMASCript 语言值或 empty，target 是任何 ECMAScript 标识符或 empty。</p>\n\n<h4 id=\"\">属性描述符及属性标识符规范类型</h4>\n\n<p>属性标识符类型用于关联属性名称与属性描述符。属性标识符类型的值是 (name, descriptor) 形式的一对值，其中 name 是一个字符串和 descriptor 是一个属性描述符值。</p>\n\n<p>几个抽象方法用来操作属性描述符值，主要是判断描述符值得类型及对象和属性描述符的转换，具体方法名和过程查看文档。</p>\n\n<h4 id=\"\">词法环境和环境记录项规范类型</h4>\n\n<p>词法环境和环境记录项类型用于说明在嵌套的函数或块中的名称解析行为。词法环境和环境记录项的具体定义在之前的执行环境一文已经做了介绍。</p>\n\n<p>标准中还有一章《对象内部方法的算法》，比较麻烦，而且用不太到，就不一大段贴过来了。</p>\n\n<h3 id=\"\">小结</h3>\n\n<p>本文把es5的6种语言类型及5种规范类型做了简单的介绍，作为开发人员，主要要掌握的是语言类型，但是了解一部分规范类型有助于我们了解语言内部的机制，所以看看也挺好。</p>\n\n<p>一天一章，速度有点慢，但是不急，稳扎稳打吧！回去跑步算了。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474332170924,"created_by":1,"updated_at":1475051207673,"updated_by":1,"published_at":1474361751861,"published_by":1},{"id":75,"uuid":"10c1e449-0add-4078-82f6-1bfd681fec48","title":"爱你就像爱生命","slug":"ai-ni-jiu-xiang-ai-sheng-ming","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=427016671&auto=1&height=66\"></iframe>\n\n昨天在b站重新又看了一遍猪队友小Y的《那些特立独行的猪》，然后刚好之后又听到了房东的猫的新歌《爱你就像爱生命》，然后就想到了王小波。看他的《黄金时代》已是中学时代的事了，现在早就忘得差不多了。\n\n于是一时兴起想要读读《一只特立独行的猪》和《爱你就像爱生命》。走到图书馆二楼，找到了下面这本皱巴巴的《爱你就像爱生命》，看来很多人读过了哇！\n\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f80x00atowj30go0m8420.jpg)\n\n不过看来是我选错了，《爱你就像爱生命》就是一本他与李银河的书信集，尽是一些肉麻的话。我这不是自己找狗粮吃嘛！😂但是作为一个单身文艺男青年，还是能学到好多的哇！开玩笑开玩笑！\n\n反正十几篇书信看下来，王小波在李银河面前真像个孩子，在真的爱的人面前才能够把自己最柔软的那一面表现出来吧！王小波同学还是个大情种，基本是每天一封，佩服！王小波同学真的是把所思所念都写进去了啊！我恐怕是做不到了吧！不要丧气，努力努力！😜\n\n> 你好哇，XXX！\n\n> 做梦也想不到我把信写到五线谱上吧？五线谱是偶然来的，你也是偶然来的。不过我给你的信值得写在五线谱里呢。但愿我和你，是一直唱不完的歌。\n\n最喜欢这段了，不像其它的那么肉麻、直白，却真的能写进人的心里！撩妹小技巧，get到了吗？\n\n书最终没看完就还了回去，因为已经了解到了王小波对于李银河的爱，但是我终究是无法理解王小波对于李银河的爱的。至少现在的我不行吧！\n\n哎呀！想起来了，这篇的封面是暑假追到现在的一部剧《有喜欢的人》，因为剧情一般吧（话外音：但是颜值可以），所以没必要开一篇新的来写了！祝贺贤贤和吧花在剧中又在一起了，也心疼翔平小天使又输给了会做蛋包饭的男人！over，新的一天开始了！\n\n","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=427016671&auto=1&height=66\"></iframe>\n\n<p>昨天在b站重新又看了一遍猪队友小Y的《那些特立独行的猪》，然后刚好之后又听到了房东的猫的新歌《爱你就像爱生命》，然后就想到了王小波。看他的《黄金时代》已是中学时代的事了，现在早就忘得差不多了。</p>\n\n<p>于是一时兴起想要读读《一只特立独行的猪》和《爱你就像爱生命》。走到图书馆二楼，找到了下面这本皱巴巴的《爱你就像爱生命》，看来很多人读过了哇！</p>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f80x00atowj30go0m8420.jpg\" alt=\"\" /></p>\n\n<p>不过看来是我选错了，《爱你就像爱生命》就是一本他与李银河的书信集，尽是一些肉麻的话。我这不是自己找狗粮吃嘛！😂但是作为一个单身文艺男青年，还是能学到好多的哇！开玩笑开玩笑！</p>\n\n<p>反正十几篇书信看下来，王小波在李银河面前真像个孩子，在真的爱的人面前才能够把自己最柔软的那一面表现出来吧！王小波同学还是个大情种，基本是每天一封，佩服！王小波同学真的是把所思所念都写进去了啊！我恐怕是做不到了吧！不要丧气，努力努力！😜</p>\n\n<blockquote>\n  <p>你好哇，XXX！</p>\n  \n  <p>做梦也想不到我把信写到五线谱上吧？五线谱是偶然来的，你也是偶然来的。不过我给你的信值得写在五线谱里呢。但愿我和你，是一直唱不完的歌。</p>\n</blockquote>\n\n<p>最喜欢这段了，不像其它的那么肉麻、直白，却真的能写进人的心里！撩妹小技巧，get到了吗？</p>\n\n<p>书最终没看完就还了回去，因为已经了解到了王小波对于李银河的爱，但是我终究是无法理解王小波对于李银河的爱的。至少现在的我不行吧！</p>\n\n<p>哎呀！想起来了，这篇的封面是暑假追到现在的一部剧《有喜欢的人》，因为剧情一般吧（话外音：但是颜值可以），所以没必要开一篇新的来写了！祝贺贤贤和吧花在剧中又在一起了，也心疼翔平小天使又输给了会做蛋包饭的男人！over，新的一天开始了！</p>","image":"/content/images/2016/09/389276-1474376978.png","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474370976562,"created_by":1,"updated_at":1474418710130,"updated_by":1,"published_at":1474418625094,"published_by":1},{"id":76,"uuid":"76b25d47-fae2-41c1-8195-97922441423a","title":"js 类型转换","slug":"js-lei-xing-zhuan-huan","markdown":"已经读到了第九章，这一章主要讲的是类型转换与测试，定义了一些转换运算符，不过这些不是语言的一部分，主要是定义语言内部的实现规范，因此在介绍内部的实现规范前，还是要找点资料讲讲语言相关的东西。\n\njs 是一种动态弱类型的语言，这在昨天的类型系统没有讲到，但是扯到了类型转换就必须把这几个概念弄清楚。知乎上有关于这几个概念的讨论，[传送门](https://www.zhihu.com/question/19918532)，个人觉得姚培森大神等人给出的解释过于理论化，所以选择了vczh大神的比较好理解的回答来解释，想要深入了解，点击传送门。\n\n#### 强类型 、弱类型\n\n强类型，弱类型没有严格定义。一般来说，强类型语言更易抛出错误。下面是我觉得比较好的判断策略。\n\n- 强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double。\n- 弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double。\n\n#### 静态类型 、动态类型\n\n- 静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。\n- 动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。\n\n根据上面的定义，js应该是动态弱类型的语言。因为编译时它的类型是不确定的，并且容忍隐式类型转换。做完了这部分知识的铺垫，我们来看一下js的显式类型转换和隐式类型转换。\n\n#### 显式类型转换\n\n没找到比较好的，就按我的理解来了。显式转换就是显式地调用`Boolean()`、`Number()`、`String()`和`Object()`进行类型的转换。\n\n##### Boolean()\n\n> Boolean([value]) 根据 value 的值返回一个布尔值\n返回 false 的 value 值（共6种）：false、””（空字符串）、0、NaN、null、undefined。实际中会有一些变形的情况，不过其实记住这几个值就可以了。\n\n##### Number()\n\n- undefined 转换成 NaN\n- null 转换成 0\n- false 转换成0，true转换成1\n- 字符串会被解析，解析规则见下文\n- 对象先转换成原始值，再转为数字（见下文）\n\n> 数字的转换还有parseInt，parseFloat，es6前是全局的，es6下转移到了Number对象上。和Number的主要区别在于Number不支持部分的转换。\n\n```\nNumber(\"123.1.2.3\")       // NaN\nparseInt(\"123.1.2.3\",10)  // 123\nparseFloat(\"123.1.2.3\")   // 123.1\n```\n\n##### String()\n\n原始值转换结果显而易见，对于对象也会先转换成原始值，然后转换成字符串。\n\n##### Object()\n\n对象转换为自身，undefined和null转换为空对象，而原始值会转换为对应的包装对象。\n\n#### 隐式类型转换\n\n事实上我们比较少会遇到需要显式类型转换的情况，因为 js 是弱类型的，它很多情况下都帮我们隐式的转换掉了。但是偶尔也会出现一些错误或者与预期不一致的情况，这就需要我们对于内部的隐式转换有一定的了解，本小节将对 js 的隐式类型转换做介绍。\n\n##### 一元 + 运算符\n\n一元+运算符将其操作数转换为Number类型。`ToNumber(GetValue(expr))`\n\n##### 一元 - 运算符\n\n一元-运算符将其操作数转换为Number类型并反转其正负。注意负的+0产生-0，负的-0产生+0。`ToNumber(GetValue(expr))`\n\n##### 按位非运算符\n\n返回按位取反的结果。结果为 32 位有符号整数。`ToInt32(GetValue(expr))`\n\n##### 逻辑非运算符\n\n`ToBoolean(GetValue(expr))`\n\n##### 乘法运算符（*、/、%）\n\n左右两边都会调用 `ToNumber(value)`。\n\n##### 加号运算符\n\n如果两边有一个是字符串，则都调用 `ToString`，否则都调用 `ToNumber`。\n\n##### 减号运算符\n\n左右两边都会调用 `ToNumber(value)`。\n\n##### 位运算移位运算符\n\n返回按位取反的结果。结果为 32 位有符号整数。`ToInt32(GetValue(expr))`\n\n##### 比较运算符\n\n首先会`ToPrimitive(x, hint Number)`，如果是数字类型，则 `ToNumber(px)`，字符串类型好像不会再转了。\n\n##### 不严格等值运算符\n\n对于类型不同的情况下，x和y会做以下的操作：\n\n1. 若Type(x) 为 Number 且 Type(y)为String， 返回比较 x = = ToNumber(y)的结果。\n2. 若Type(x) 为 String 且 Type(y)为Number，返回比较ToNumber(x) = = y的结果。\n3. 若Type(x)为Boolean， 返回比较ToNumber(x) = = y的结果。\n4. 若Type(y)为Boolean， 返回比较x = = ToNumber(y)的结果。\n5. 若Type(x)为String或Number，且Type(y)为Object，返回比较x = = ToPrimitive(y)的结果。\n6. 若Type(x)为Object且Type(y)为String或Number， 返回比较ToPrimitive(x) = = y的结果。\n\n>  按以上相等之定义：\n>\n字符串比较可以按这种方式强制执行: \"\" + a = = \"\" + b 。\n>\n数值比较可以按这种方式强制执行: +a = = +b 。\n>\n布尔值比较可以按这种方式强制执行: !a = = !b 。\n\n##### 二进制位运算符（|、^、&）\n\n两边 `ToInt32(val)`。\n\n##### 二元逻辑运算符（&&和||）\n\n执行过程内部会调用`ToBoolean`，但返回的还是表达式未转换的值。\n\n##### if、while、do while、for 语句\n\nif、while、do while、for 的条件会调用 `ToBoolean`\n\n##### with 语句\n\n对内容 `ToObject(GetValue(val))`。\n\n《这部分与后面的操作符有关，看到一个来这里加一个。。。，基本就上面这些了》\n\n#### 规范内部实现\n\n##### ToPrimitive\n\n在上文，显式转换的Number()和String()关于对象我们留了一个问号？我们当时只讲了对象先转为原始值，但是是没有讲具体的过程。而ToPrimitive这个规范内部的转换运算符就是对应的实现。下面我们来介绍一下ToPrimitive的算法：\n\n```\n// input表示转换的内容，PreferredType表示目标对象\nToPrimitive(input, PreferredType)\n```\n\n因为对于输入类型Object以外的情况，规范都定义不转换，因此此处的算法只针对输入类型为Object，如果PreferredType是Number：\n\n1. 调用input.valueOf()，如果结果是原始值，则返回；\n2. 否则调用input.toString()，如果结果是原始值，则返回；\n3. 否则抛出一个TypeError错误。\n\n如果PreferredType是String，则把1、2两步交换。这一算法本质上是对象的内部方法[[DefaultValue]]的过程。另外就是覆盖了对象的valueOf()方法或者toString()方法会对结果产生影响，有兴趣的可以下去研究一下。\n\n##### ToBoolean\n\n转换运算符 ToBoolean 的规则和 Boolean 函数相同，可以理解为是 Boolean 在语言内部的实现吧！\n\n##### ToNumber\n\n转换运算符 ToNumber 的规则和 Number 函数相同，对于 String 的解析规则下面马上就来了，对于 Object，ToPrimitive 求得的原始值还需要调用一次 ToNumber。\n\n###### ToNumber 字符串的解析（不复杂，就是产生式多了点）\n\n需要注意到「字符串数值常量」和 「数值常量」 语法上的不同：\n\n- 「字符串数值常量」之前和、或之后可以有空白和／或行结束符。\n- 十进制的「字符串数值常量」可有任意位数的 0 在前头。\n- 十进制的「字符串数值常量」可有指示其符号的 + 或 - 前缀。\n- 空的，或只包含空白的「字符串值常量」會被转换为 +0。\n\n字符串到数字值的转换，大体上类似于判定数值常量的数字值，不过有些细节上的不同，所以，这里给出了把字符串数值常量转换为数值类型的值的全部过程。这个值分两步来判定：首先，从字符串数值常量中导出数学值；第二步，以下面所描述的方式对该数学值进行舍入。（其实就是对符合字符串数值常量的产生式进行检测，并求值吧，真是多，其实一看也看得出来，或者记住上面的几条规则就好了）\n\n- 「字符串整数常量 ::: [empty]」的数学值是 0。\n- 「字符串整数常量 ::: 串空白」的数学值是 0。\n- 不管有没有空白「字符串整数常量 ::: 串空白 opt 串数值常量 串空白 opt」的数学值是「串数值常量」的数学值\n- 「串数值常量 ::: 串十进制常量」的数学值是「串十进制常量」的数学值\n- 「串数值常量 ::: 十六进制整数常量」的数学值是「十六进制整数常量」的数学值\n- 「串十进制常量 ::: 串无符号整数常量」的数学值是「串无符号整数常量」的数学值\n- 「串十进制常量 ::: + 串无符号整数常量」的数学值是「串无符号整数常量」的数学值。\n- 「串十进制常量 ::: - 串无符号整数常量」的数学值是「串无符号整数常量」的数学值的负数。 （需要注意的是，如果「串无符号整数常量」的数学值是 0, 其负数也是 0。下面中描述的舍入规则会合适地处理小于数学零到浮点数 +0 或 -0 的变换。）\n- 「串无符号整数常量 ::: Infinity」的数学值是 1010000（一个大到会舍入为 +∞ 的值过大的值会返回为 ）。\n- 「串无符号整数常量 ::: 十进制数 .」的数学值是「十进制数」的数学值。\n- 「串无符号整数常量 ::: 十进制数 . 十进制数」的数学值是第一个「十进制数」的数学值加（第二个「十进制数」的数学值乘以 10-n），这里的 n 是 the number of characters in the 第二个「十进制数」字符数。\n- 「串无符号整数常量 ::: 十进制数 . 指数部分」的数学值是「十进制数」的数学值乘以 10e, 这里的 e 是「指数部分」的数学值\n- 「串无符号整数常量 ::: 十进制数 . 十进制数 指数部分」的数学值是（第一个「十进制数」的数学值加（第二个「十进制数」的数学值乘以 10-n））乘以 10e，这里的 n 是 第二个「十进制数」中的字符个数，e 是「指数部分」的数学值。\n- 「串无符号整数常量 ::: . 十进制数」的数学值是「十进制数」的数学值乘以 10-n，这里的 n 是「十进制数」中的字符个数。\n- 「串无符号整数常量 ::: . 十进制数 指数部分」的数学值是「十进制数」的数学值乘以 10e-n，这里的 n 是「十进制数」中的字符个数，e 是「指数部分」的数学值\n- 「串无符号整数常量 ::: 十进制数」的数学值是「十进制数」的数学值\n- 「串无符号整数常量 ::: 十进制数 指数部分」的数学值是「十进制数」的数学值乘以 10e，这里的 e 是「指数部分」的数学值\n- 「十进制数 ::: 十进制数字」是「十进制数字」的数学值\n- 「十进制数 ::: 十进制数 十进制数字」的数学值是（「十进制数」的数学值乘以 10）加「十进制数字」的数学值\n- 「指数部分 ::: 幂指示符 有符号整数」的数学值是「有符号整数」的数学值\n- 「有符号整数 ::: 十进制数」的数学值是「十进制数」的数学值\n- 「有符号整数 ::: + 十进制数」的数学值是「十进制数」的数学值\n「有符号整数 ::: - 十进制数」是「十进制数」的数学值的负数。\n- 「十进制数字 ::: 0」或「十六进制数字 ::: 0」的数学值是 0。\n- 「十进制数字 ::: 1」或「十六进制数字 ::: 1」的数学值是 1。\n- 「十进制数字 ::: 2」或「十六进制数字 ::: 2」的数学值是 2。\n- 「十进制数字 ::: 3」或「十六进制数字 ::: 3」的数学值是 3。\n- 「十进制数字 ::: 4」或「十六进制数字 ::: 4」的数学值是 4。\n- 「十进制数字 ::: 5」或「十六进制数字 ::: 5」的数学值是 5。\n- 「十进制数字 ::: 6」或「十六进制数字 ::: 6」的数学值是 6。\n- 「十进制数字 ::: 7」或「十六进制数字 ::: 7」的数学值是 7。\n- 「十进制数字 ::: 8」或「十六进制数字 ::: 8」的数学值是 8。\n- 「十进制数字 ::: 9」或「十六进制数字 ::: 9」的数学值是 9。\n- 「十六进制数字 ::: a」或「十六进制数字 ::: A」的数学值是 10。\n- 「十六进制数字 ::: b」或「十六进制数字 ::: B」的数学值是 11。\n- 「十六进制数字 ::: c」或「十六进制数字 ::: C」的数学值是 12。\n- 「十六进制数字 ::: d」或「十六进制数字 ::: D」的数学值是 13。\n- 「十六进制数字 ::: e」或「十六进制数字 ::: E」的数学值是 14。\n- 「十六进制数字 ::: f」或「十六进制数字 ::: F」的数学值是 15。\n- 「十六进制整数常量 ::: 0x 十六进制数字」的数学值是「十六进制数字」的数学值。\n- 「十六进制整数常量 ::: 0X 十六进制数字」的数学值是「十六进制数字」的数学值。\n- 「十六进制整数常量 ::: 十六进制整数常量 十六进制数字」的数学值是（「十六进制整数常量」的数学值乘以 16）加「十六进制数字」的数学值。\n\n##### ToInteger\n\n ToInteger 运算符将其参数转换为整数值。此运算符功能如下所示：\n\n1. 对输入参数调用 ToNumber 。\n2. 如果 Result(1) 是 NaN，返回 +0。\n3. 如果 Result(1) 是 +0 ，-0，+∞，或 -∞，返回 Result(1)。\n4. 计算 sign(Result(1)) * floor(abs(Result(1)))。\n5. 返回 Result(4)。\n\n> 内部是用floor哦，就是向下取整。\n\n##### ToInt32\n\nToInt32 运算符将其在 -231 到 231-1 闭区间内的参数转换为 232 个整数值之一。此运算符功能如下所示：\n\n1. 对输入参数调用 ToNumber 。\n2. 如果 Result(1) 是 +0 ，-0，+∞，或 -∞，返回 +0。\n3. 计算 sign(Result(1)) * floor(abs(Result(1)))。\n4. 计算 Result(3) modulo 232 ；也就是说，数值类型的有限整数值 k 为正，且小于 232 ，规模相对于 Result(3) 的数学值差异 ，232 是 k 的整数倍。\n5. 如果 Result(4) 是大于等于 231 的整数，返回 Result(4) - 232 ，否则返回 Result(4)。\n\n> 上一篇讲过，位运算时语言内部就会调用 ToInt32 将操作数转化为32位整数，其他可能还有场景，看到了后会补充在隐式转换的里面。\n\n##### ToUint32\n\n和 ToInt32 类似，不重复了，详见文档。\n\n##### ToUint16\n\n过程和 ToInt32 类似，但是要额外讲一下会在那里遇到，也是在类型系统一文中有提到的，就是字符码中，UTF-16码。平时也用不到，但要知道。\n\n##### ToString\n\n转换运算符 ToString 的规则和 String 函数相同，可以理解为是 String 在语言内部的实现吧！\n\n##### ToObject\n\n转换运算符 ToObject 的规则和 Object 函数相同，可以理解为是 Object 在语言内部的实现吧！\n\n##### CheckObjectCoercible\n\n抽象操作 CheckObjectCoercible 在其参数无法用 ToObject 转换成对象的情况下抛出一个异常，规范定义的是在null和undefined时抛出 TypeError 异常。\n\n##### IsCallable\n\n抽象操作 IsCallable 确定其必须是 ECMAScript 语言值的参数是否是一个可调用对象。只有 Object 并且对象包含一个Call内部方法，则返回 true，否则返回 false。\n\n##### SameValue 算法\n\n内部严格比较操作 SameValue(x,y)，x 和 y 为 ECMAScript 语言中的值，需要产出 true 或 false。比较过程如下：\n\n1. 如果 Type(x) 与 Type(y) 的结果不一致，返回 false，否则\n2. 如果 Type(x) 结果为 Undefined，返回 true\n3. 如果 Type(x) 结果为 Null，返回 true\n4. 如果 Type(x) 结果为 Number，则\n 1. 如果 x 为 NaN，且 y 也为 NaN，返回 true\n 2. 如果 x 为 +0，y 为 -0，返回 false\n 3. 如果 x 为 -0，y 为 +0，返回 false\n 4. 如果 x 与 y 为同一个数字，返回 true\n 5. 返回 false\n5. 如果 Type(x) 结果为 String，如果 x 与 y 为完全相同的字符序列（相同的长度和相同的字符对应相同的位置），返回 true，否则，返回 false\n6. 如果 Type(x) 结果为 Boolean，如果 x 与 y 都为 true 或 false，则返回 true，否则，返回 false\n7. 如果 x 和 y 引用到同一个 Object 对象，返回 true，否则，返回 false\n\n> 乍一看，`NaN === NaN` 是 true ？事实上，这个算法并不是 `===` 使用的算法，标准在介绍 `===` 算法时提到了两者的区别就是 NaN 和 正负0的比较。\n","html":"<p>已经读到了第九章，这一章主要讲的是类型转换与测试，定义了一些转换运算符，不过这些不是语言的一部分，主要是定义语言内部的实现规范，因此在介绍内部的实现规范前，还是要找点资料讲讲语言相关的东西。</p>\n\n<p>js 是一种动态弱类型的语言，这在昨天的类型系统没有讲到，但是扯到了类型转换就必须把这几个概念弄清楚。知乎上有关于这几个概念的讨论，<a href=\"https://www.zhihu.com/question/19918532\">传送门</a>，个人觉得姚培森大神等人给出的解释过于理论化，所以选择了vczh大神的比较好理解的回答来解释，想要深入了解，点击传送门。</p>\n\n<h4 id=\"\">强类型 、弱类型</h4>\n\n<p>强类型，弱类型没有严格定义。一般来说，强类型语言更易抛出错误。下面是我觉得比较好的判断策略。</p>\n\n<ul>\n<li>强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double。</li>\n<li>弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double。</li>\n</ul>\n\n<h4 id=\"\">静态类型 、动态类型</h4>\n\n<ul>\n<li>静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。</li>\n<li>动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。</li>\n</ul>\n\n<p>根据上面的定义，js应该是动态弱类型的语言。因为编译时它的类型是不确定的，并且容忍隐式类型转换。做完了这部分知识的铺垫，我们来看一下js的显式类型转换和隐式类型转换。</p>\n\n<h4 id=\"\">显式类型转换</h4>\n\n<p>没找到比较好的，就按我的理解来了。显式转换就是显式地调用<code>Boolean()</code>、<code>Number()</code>、<code>String()</code>和<code>Object()</code>进行类型的转换。</p>\n\n<h5 id=\"boolean\">Boolean()</h5>\n\n<blockquote>\n  <p>Boolean([value]) 根据 value 的值返回一个布尔值\n  返回 false 的 value 值（共6种）：false、””（空字符串）、0、NaN、null、undefined。实际中会有一些变形的情况，不过其实记住这几个值就可以了。</p>\n</blockquote>\n\n<h5 id=\"number\">Number()</h5>\n\n<ul>\n<li>undefined 转换成 NaN</li>\n<li>null 转换成 0</li>\n<li>false 转换成0，true转换成1</li>\n<li>字符串会被解析，解析规则见下文</li>\n<li>对象先转换成原始值，再转为数字（见下文）</li>\n</ul>\n\n<blockquote>\n  <p>数字的转换还有parseInt，parseFloat，es6前是全局的，es6下转移到了Number对象上。和Number的主要区别在于Number不支持部分的转换。</p>\n</blockquote>\n\n<pre><code>Number(\"123.1.2.3\")       // NaN  \nparseInt(\"123.1.2.3\",10)  // 123  \nparseFloat(\"123.1.2.3\")   // 123.1  \n</code></pre>\n\n<h5 id=\"string\">String()</h5>\n\n<p>原始值转换结果显而易见，对于对象也会先转换成原始值，然后转换成字符串。</p>\n\n<h5 id=\"object\">Object()</h5>\n\n<p>对象转换为自身，undefined和null转换为空对象，而原始值会转换为对应的包装对象。</p>\n\n<h4 id=\"\">隐式类型转换</h4>\n\n<p>事实上我们比较少会遇到需要显式类型转换的情况，因为 js 是弱类型的，它很多情况下都帮我们隐式的转换掉了。但是偶尔也会出现一些错误或者与预期不一致的情况，这就需要我们对于内部的隐式转换有一定的了解，本小节将对 js 的隐式类型转换做介绍。</p>\n\n<h5 id=\"\">一元 + 运算符</h5>\n\n<p>一元+运算符将其操作数转换为Number类型。<code>ToNumber(GetValue(expr))</code></p>\n\n<h5 id=\"\">一元 - 运算符</h5>\n\n<p>一元-运算符将其操作数转换为Number类型并反转其正负。注意负的+0产生-0，负的-0产生+0。<code>ToNumber(GetValue(expr))</code></p>\n\n<h5 id=\"\">按位非运算符</h5>\n\n<p>返回按位取反的结果。结果为 32 位有符号整数。<code>ToInt32(GetValue(expr))</code></p>\n\n<h5 id=\"\">逻辑非运算符</h5>\n\n<p><code>ToBoolean(GetValue(expr))</code></p>\n\n<h5 id=\"\">乘法运算符（*、/、%）</h5>\n\n<p>左右两边都会调用 <code>ToNumber(value)</code>。</p>\n\n<h5 id=\"\">加号运算符</h5>\n\n<p>如果两边有一个是字符串，则都调用 <code>ToString</code>，否则都调用 <code>ToNumber</code>。</p>\n\n<h5 id=\"\">减号运算符</h5>\n\n<p>左右两边都会调用 <code>ToNumber(value)</code>。</p>\n\n<h5 id=\"\">位运算移位运算符</h5>\n\n<p>返回按位取反的结果。结果为 32 位有符号整数。<code>ToInt32(GetValue(expr))</code></p>\n\n<h5 id=\"\">比较运算符</h5>\n\n<p>首先会<code>ToPrimitive(x, hint Number)</code>，如果是数字类型，则 <code>ToNumber(px)</code>，字符串类型好像不会再转了。</p>\n\n<h5 id=\"\">不严格等值运算符</h5>\n\n<p>对于类型不同的情况下，x和y会做以下的操作：</p>\n\n<ol>\n<li>若Type(x) 为 Number 且 Type(y)为String， 返回比较 x = = ToNumber(y)的结果。  </li>\n<li>若Type(x) 为 String 且 Type(y)为Number，返回比较ToNumber(x) = = y的结果。  </li>\n<li>若Type(x)为Boolean， 返回比较ToNumber(x) = = y的结果。  </li>\n<li>若Type(y)为Boolean， 返回比较x = = ToNumber(y)的结果。  </li>\n<li>若Type(x)为String或Number，且Type(y)为Object，返回比较x = = ToPrimitive(y)的结果。  </li>\n<li>若Type(x)为Object且Type(y)为String或Number， 返回比较ToPrimitive(x) = = y的结果。</li>\n</ol>\n\n<blockquote>\n  <p>按以上相等之定义：</p>\n  \n  <p>字符串比较可以按这种方式强制执行: \"\" + a = = \"\" + b 。</p>\n  \n  <p>数值比较可以按这种方式强制执行: +a = = +b 。</p>\n  \n  <p>布尔值比较可以按这种方式强制执行: !a = = !b 。</p>\n</blockquote>\n\n<h5 id=\"\">二进制位运算符（|、^、&amp;）</h5>\n\n<p>两边 <code>ToInt32(val)</code>。</p>\n\n<h5 id=\"\">二元逻辑运算符（&amp;&amp;和||）</h5>\n\n<p>执行过程内部会调用<code>ToBoolean</code>，但返回的还是表达式未转换的值。</p>\n\n<h5 id=\"ifwhiledowhilefor\">if、while、do while、for 语句</h5>\n\n<p>if、while、do while、for 的条件会调用 <code>ToBoolean</code></p>\n\n<h5 id=\"with\">with 语句</h5>\n\n<p>对内容 <code>ToObject(GetValue(val))</code>。</p>\n\n<p>《这部分与后面的操作符有关，看到一个来这里加一个。。。，基本就上面这些了》</p>\n\n<h4 id=\"\">规范内部实现</h4>\n\n<h5 id=\"toprimitive\">ToPrimitive</h5>\n\n<p>在上文，显式转换的Number()和String()关于对象我们留了一个问号？我们当时只讲了对象先转为原始值，但是是没有讲具体的过程。而ToPrimitive这个规范内部的转换运算符就是对应的实现。下面我们来介绍一下ToPrimitive的算法：</p>\n\n<pre><code>// input表示转换的内容，PreferredType表示目标对象\nToPrimitive(input, PreferredType)  \n</code></pre>\n\n<p>因为对于输入类型Object以外的情况，规范都定义不转换，因此此处的算法只针对输入类型为Object，如果PreferredType是Number：</p>\n\n<ol>\n<li>调用input.valueOf()，如果结果是原始值，则返回；  </li>\n<li>否则调用input.toString()，如果结果是原始值，则返回；  </li>\n<li>否则抛出一个TypeError错误。</li>\n</ol>\n\n<p>如果PreferredType是String，则把1、2两步交换。这一算法本质上是对象的内部方法[[DefaultValue]]的过程。另外就是覆盖了对象的valueOf()方法或者toString()方法会对结果产生影响，有兴趣的可以下去研究一下。</p>\n\n<h5 id=\"toboolean\">ToBoolean</h5>\n\n<p>转换运算符 ToBoolean 的规则和 Boolean 函数相同，可以理解为是 Boolean 在语言内部的实现吧！</p>\n\n<h5 id=\"tonumber\">ToNumber</h5>\n\n<p>转换运算符 ToNumber 的规则和 Number 函数相同，对于 String 的解析规则下面马上就来了，对于 Object，ToPrimitive 求得的原始值还需要调用一次 ToNumber。</p>\n\n<h6 id=\"tonumber\">ToNumber 字符串的解析（不复杂，就是产生式多了点）</h6>\n\n<p>需要注意到「字符串数值常量」和 「数值常量」 语法上的不同：</p>\n\n<ul>\n<li>「字符串数值常量」之前和、或之后可以有空白和／或行结束符。</li>\n<li>十进制的「字符串数值常量」可有任意位数的 0 在前头。</li>\n<li>十进制的「字符串数值常量」可有指示其符号的 + 或 - 前缀。</li>\n<li>空的，或只包含空白的「字符串值常量」會被转换为 +0。</li>\n</ul>\n\n<p>字符串到数字值的转换，大体上类似于判定数值常量的数字值，不过有些细节上的不同，所以，这里给出了把字符串数值常量转换为数值类型的值的全部过程。这个值分两步来判定：首先，从字符串数值常量中导出数学值；第二步，以下面所描述的方式对该数学值进行舍入。（其实就是对符合字符串数值常量的产生式进行检测，并求值吧，真是多，其实一看也看得出来，或者记住上面的几条规则就好了）</p>\n\n<ul>\n<li>「字符串整数常量 ::: [empty]」的数学值是 0。</li>\n<li>「字符串整数常量 ::: 串空白」的数学值是 0。</li>\n<li>不管有没有空白「字符串整数常量 ::: 串空白 opt 串数值常量 串空白 opt」的数学值是「串数值常量」的数学值</li>\n<li>「串数值常量 ::: 串十进制常量」的数学值是「串十进制常量」的数学值</li>\n<li>「串数值常量 ::: 十六进制整数常量」的数学值是「十六进制整数常量」的数学值</li>\n<li>「串十进制常量 ::: 串无符号整数常量」的数学值是「串无符号整数常量」的数学值</li>\n<li>「串十进制常量 ::: + 串无符号整数常量」的数学值是「串无符号整数常量」的数学值。</li>\n<li>「串十进制常量 ::: - 串无符号整数常量」的数学值是「串无符号整数常量」的数学值的负数。 （需要注意的是，如果「串无符号整数常量」的数学值是 0, 其负数也是 0。下面中描述的舍入规则会合适地处理小于数学零到浮点数 +0 或 -0 的变换。）</li>\n<li>「串无符号整数常量 ::: Infinity」的数学值是 1010000（一个大到会舍入为 +∞ 的值过大的值会返回为 ）。</li>\n<li>「串无符号整数常量 ::: 十进制数 .」的数学值是「十进制数」的数学值。</li>\n<li>「串无符号整数常量 ::: 十进制数 . 十进制数」的数学值是第一个「十进制数」的数学值加（第二个「十进制数」的数学值乘以 10-n），这里的 n 是 the number of characters in the 第二个「十进制数」字符数。</li>\n<li>「串无符号整数常量 ::: 十进制数 . 指数部分」的数学值是「十进制数」的数学值乘以 10e, 这里的 e 是「指数部分」的数学值</li>\n<li>「串无符号整数常量 ::: 十进制数 . 十进制数 指数部分」的数学值是（第一个「十进制数」的数学值加（第二个「十进制数」的数学值乘以 10-n））乘以 10e，这里的 n 是 第二个「十进制数」中的字符个数，e 是「指数部分」的数学值。</li>\n<li>「串无符号整数常量 ::: . 十进制数」的数学值是「十进制数」的数学值乘以 10-n，这里的 n 是「十进制数」中的字符个数。</li>\n<li>「串无符号整数常量 ::: . 十进制数 指数部分」的数学值是「十进制数」的数学值乘以 10e-n，这里的 n 是「十进制数」中的字符个数，e 是「指数部分」的数学值</li>\n<li>「串无符号整数常量 ::: 十进制数」的数学值是「十进制数」的数学值</li>\n<li>「串无符号整数常量 ::: 十进制数 指数部分」的数学值是「十进制数」的数学值乘以 10e，这里的 e 是「指数部分」的数学值</li>\n<li>「十进制数 ::: 十进制数字」是「十进制数字」的数学值</li>\n<li>「十进制数 ::: 十进制数 十进制数字」的数学值是（「十进制数」的数学值乘以 10）加「十进制数字」的数学值</li>\n<li>「指数部分 ::: 幂指示符 有符号整数」的数学值是「有符号整数」的数学值</li>\n<li>「有符号整数 ::: 十进制数」的数学值是「十进制数」的数学值</li>\n<li>「有符号整数 ::: + 十进制数」的数学值是「十进制数」的数学值\n「有符号整数 ::: - 十进制数」是「十进制数」的数学值的负数。</li>\n<li>「十进制数字 ::: 0」或「十六进制数字 ::: 0」的数学值是 0。</li>\n<li>「十进制数字 ::: 1」或「十六进制数字 ::: 1」的数学值是 1。</li>\n<li>「十进制数字 ::: 2」或「十六进制数字 ::: 2」的数学值是 2。</li>\n<li>「十进制数字 ::: 3」或「十六进制数字 ::: 3」的数学值是 3。</li>\n<li>「十进制数字 ::: 4」或「十六进制数字 ::: 4」的数学值是 4。</li>\n<li>「十进制数字 ::: 5」或「十六进制数字 ::: 5」的数学值是 5。</li>\n<li>「十进制数字 ::: 6」或「十六进制数字 ::: 6」的数学值是 6。</li>\n<li>「十进制数字 ::: 7」或「十六进制数字 ::: 7」的数学值是 7。</li>\n<li>「十进制数字 ::: 8」或「十六进制数字 ::: 8」的数学值是 8。</li>\n<li>「十进制数字 ::: 9」或「十六进制数字 ::: 9」的数学值是 9。</li>\n<li>「十六进制数字 ::: a」或「十六进制数字 ::: A」的数学值是 10。</li>\n<li>「十六进制数字 ::: b」或「十六进制数字 ::: B」的数学值是 11。</li>\n<li>「十六进制数字 ::: c」或「十六进制数字 ::: C」的数学值是 12。</li>\n<li>「十六进制数字 ::: d」或「十六进制数字 ::: D」的数学值是 13。</li>\n<li>「十六进制数字 ::: e」或「十六进制数字 ::: E」的数学值是 14。</li>\n<li>「十六进制数字 ::: f」或「十六进制数字 ::: F」的数学值是 15。</li>\n<li>「十六进制整数常量 ::: 0x 十六进制数字」的数学值是「十六进制数字」的数学值。</li>\n<li>「十六进制整数常量 ::: 0X 十六进制数字」的数学值是「十六进制数字」的数学值。</li>\n<li>「十六进制整数常量 ::: 十六进制整数常量 十六进制数字」的数学值是（「十六进制整数常量」的数学值乘以 16）加「十六进制数字」的数学值。</li>\n</ul>\n\n<h5 id=\"tointeger\">ToInteger</h5>\n\n<p>ToInteger 运算符将其参数转换为整数值。此运算符功能如下所示：</p>\n\n<ol>\n<li>对输入参数调用 ToNumber 。  </li>\n<li>如果 Result(1) 是 NaN，返回 +0。  </li>\n<li>如果 Result(1) 是 +0 ，-0，+∞，或 -∞，返回 Result(1)。  </li>\n<li>计算 sign(Result(1)) * floor(abs(Result(1)))。  </li>\n<li>返回 Result(4)。</li>\n</ol>\n\n<blockquote>\n  <p>内部是用floor哦，就是向下取整。</p>\n</blockquote>\n\n<h5 id=\"toint32\">ToInt32</h5>\n\n<p>ToInt32 运算符将其在 -231 到 231-1 闭区间内的参数转换为 232 个整数值之一。此运算符功能如下所示：</p>\n\n<ol>\n<li>对输入参数调用 ToNumber 。  </li>\n<li>如果 Result(1) 是 +0 ，-0，+∞，或 -∞，返回 +0。  </li>\n<li>计算 sign(Result(1)) * floor(abs(Result(1)))。  </li>\n<li>计算 Result(3) modulo 232 ；也就是说，数值类型的有限整数值 k 为正，且小于 232 ，规模相对于 Result(3) 的数学值差异 ，232 是 k 的整数倍。  </li>\n<li>如果 Result(4) 是大于等于 231 的整数，返回 Result(4) - 232 ，否则返回 Result(4)。</li>\n</ol>\n\n<blockquote>\n  <p>上一篇讲过，位运算时语言内部就会调用 ToInt32 将操作数转化为32位整数，其他可能还有场景，看到了后会补充在隐式转换的里面。</p>\n</blockquote>\n\n<h5 id=\"touint32\">ToUint32</h5>\n\n<p>和 ToInt32 类似，不重复了，详见文档。</p>\n\n<h5 id=\"touint16\">ToUint16</h5>\n\n<p>过程和 ToInt32 类似，但是要额外讲一下会在那里遇到，也是在类型系统一文中有提到的，就是字符码中，UTF-16码。平时也用不到，但要知道。</p>\n\n<h5 id=\"tostring\">ToString</h5>\n\n<p>转换运算符 ToString 的规则和 String 函数相同，可以理解为是 String 在语言内部的实现吧！</p>\n\n<h5 id=\"toobject\">ToObject</h5>\n\n<p>转换运算符 ToObject 的规则和 Object 函数相同，可以理解为是 Object 在语言内部的实现吧！</p>\n\n<h5 id=\"checkobjectcoercible\">CheckObjectCoercible</h5>\n\n<p>抽象操作 CheckObjectCoercible 在其参数无法用 ToObject 转换成对象的情况下抛出一个异常，规范定义的是在null和undefined时抛出 TypeError 异常。</p>\n\n<h5 id=\"iscallable\">IsCallable</h5>\n\n<p>抽象操作 IsCallable 确定其必须是 ECMAScript 语言值的参数是否是一个可调用对象。只有 Object 并且对象包含一个Call内部方法，则返回 true，否则返回 false。</p>\n\n<h5 id=\"samevalue\">SameValue 算法</h5>\n\n<p>内部严格比较操作 SameValue(x,y)，x 和 y 为 ECMAScript 语言中的值，需要产出 true 或 false。比较过程如下：</p>\n\n<ol>\n<li>如果 Type(x) 与 Type(y) 的结果不一致，返回 false，否则  </li>\n<li>如果 Type(x) 结果为 Undefined，返回 true  </li>\n<li>如果 Type(x) 结果为 Null，返回 true  </li>\n<li>如果 Type(x) 结果为 Number，则 <br />\n<ol><li>如果 x 为 NaN，且 y 也为 NaN，返回 true</li>\n<li>如果 x 为 +0，y 为 -0，返回 false</li>\n<li>如果 x 为 -0，y 为 +0，返回 false</li>\n<li>如果 x 与 y 为同一个数字，返回 true</li>\n<li>返回 false</li></ol></li>\n<li>如果 Type(x) 结果为 String，如果 x 与 y 为完全相同的字符序列（相同的长度和相同的字符对应相同的位置），返回 true，否则，返回 false  </li>\n<li>如果 Type(x) 结果为 Boolean，如果 x 与 y 都为 true 或 false，则返回 true，否则，返回 false  </li>\n<li>如果 x 和 y 引用到同一个 Object 对象，返回 true，否则，返回 false</li>\n</ol>\n\n<blockquote>\n  <p>乍一看，<code>NaN === NaN</code> 是 true ？事实上，这个算法并不是 <code>===</code> 使用的算法，标准在介绍 <code>===</code> 算法时提到了两者的区别就是 NaN 和 正负0的比较。</p>\n</blockquote>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474419326814,"created_by":1,"updated_at":1475051182646,"updated_by":1,"published_at":1474450732628,"published_by":1},{"id":77,"uuid":"9d03d21e-24f0-4e25-8dc0-264a8b2b28de","title":"js 原始值的包装对象","slug":"js-yuan-shi-zhi-de-bao-zhuang-dui-xiang","markdown":"java 有包装类，用来增强基本类型。同样 js 也为布尔值、数字、字符串三种原始值增加了包装对象。我们可以使用 Boolean、Number、String 来创建包装对象（作为构造函数）或者将值转换为原始值（作为函数）。\n\n> 避免包装对象被认为是一种最佳实践，因为除了修改属性外，没有包装类型可以做而原始值不能做的。\n\n#### 包装与去包装\n有一种使用包装对象的场景，就是要对一个原始类型增加属性时：\n\n```\n// 通过调用构造函数对原始值进行包装\nnew Boolean(true)\nnew Number(123)\nnew String('abc')\n```\n\n通过每个对象都有的 valueOf 方法获得原始值：\n\n```\nnew Boolean(true).valueOf()\nnew Number(123).valueOf()\nnew String('abc').valueOf()\n```\n\n将包装对象转换为原始值不能正确提取布尔值：\n\n```\nBoolean(new Booolean(false)) // true\n```\n\n#### 借调方法\n\n包装对象最有用的就是上面的方法了，但是在 js 中原始值是可以借调包装类型中的方法的，因此包装类型能做的原始值大都能做。\n\n```\n'abc'.charAt === String.prototype.charAt\n```\n\n需要注意的是严格模式和非严格模式下，借调的方式是有区别的：\n\n```\nString.prototype.info = function() {\n    console.log(typeof this); // object\n    console.log(this instanceof String); // true\n}\n\nString.prototype.strictInfo = function() {\n    'use strict'\n    console.log(typeof this); // string\n    console.log(this instanceof String); // false\n}\n\n''.info();\n''.strictInfo();\n```\n\n可以从上面的例子看到，严格模式下调用时透明的，非严格模式下原始值在运行过程中会转换为包装对象。\n\n","html":"<p>java 有包装类，用来增强基本类型。同样 js 也为布尔值、数字、字符串三种原始值增加了包装对象。我们可以使用 Boolean、Number、String 来创建包装对象（作为构造函数）或者将值转换为原始值（作为函数）。</p>\n\n<blockquote>\n  <p>避免包装对象被认为是一种最佳实践，因为除了修改属性外，没有包装类型可以做而原始值不能做的。</p>\n</blockquote>\n\n<h4 id=\"\">包装与去包装</h4>\n\n<p>有一种使用包装对象的场景，就是要对一个原始类型增加属性时：</p>\n\n<pre><code>// 通过调用构造函数对原始值进行包装\nnew Boolean(true)  \nnew Number(123)  \nnew String('abc')  \n</code></pre>\n\n<p>通过每个对象都有的 valueOf 方法获得原始值：</p>\n\n<pre><code>new Boolean(true).valueOf()  \nnew Number(123).valueOf()  \nnew String('abc').valueOf()  \n</code></pre>\n\n<p>将包装对象转换为原始值不能正确提取布尔值：</p>\n\n<pre><code>Boolean(new Booolean(false)) // true  \n</code></pre>\n\n<h4 id=\"\">借调方法</h4>\n\n<p>包装对象最有用的就是上面的方法了，但是在 js 中原始值是可以借调包装类型中的方法的，因此包装类型能做的原始值大都能做。</p>\n\n<pre><code>'abc'.charAt === String.prototype.charAt  \n</code></pre>\n\n<p>需要注意的是严格模式和非严格模式下，借调的方式是有区别的：</p>\n\n<pre><code>String.prototype.info = function() {  \n    console.log(typeof this); // object\n    console.log(this instanceof String); // true\n}\n\nString.prototype.strictInfo = function() {  \n    'use strict'\n    console.log(typeof this); // string\n    console.log(this instanceof String); // false\n}\n\n''.info();  \n''.strictInfo();  \n</code></pre>\n\n<p>可以从上面的例子看到，严格模式下调用时透明的，非严格模式下原始值在运行过程中会转换为包装对象。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474419703372,"created_by":1,"updated_at":1474421519176,"updated_by":1,"published_at":1474421519177,"published_by":1},{"id":78,"uuid":"f6ecb7b4-b613-42f0-824f-bd963f7fdace","title":"一只特立独行的猪","slug":"yi-zhi-te-li-du-xing-de","markdown":"刚才想好从哪写起的，现在却忘了。\n\n<audio autoplay=\"autoplay\">\n  <source src=\"http://96.f.1ting.com/57ec6b6b/0a33fb05553803f6b8accdb17cc2b165/zzzzzmp3/2011dApr/21C/21gaoqiaoyou/10.mp3\" />\n</audio>\n\n昨天晚上跑完步回寝路上，军哥哥跟我讲到自己经过最近三周有些收获，但是之后他又感叹道自己只不过是从一个小的牢笼跳到了一个大的牢笼。他说，以前当兵的时候，以为回到学校就自由了，现在发现仅仅是从一个小的牢笼，到了一个大点的牢笼。这一点我表示了认同，然后我说除非你能够丢下那些外界的束缚，那你就自由了，可是自由的终点是孤独啊！\n\n我们都笑了笑！\n\n他继续说，怎么可能！我没能回答，因为我做不到！曾经在电影《荒野求生》里有人去做了，但是电影的结局是他留下了这么一张照片死去了。\n\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f836s8arn4j30go06rt95.jpg)\n\n我原本想象的并不是电影里这样的远离人群的自由，这种自由不光是孤独的，它在一开始就让人望而却步。我想象的是那种处在人群之中，但是仍能够独立、自由地生存，也不用在意那些本身就坏掉的条条框框。现在的我就是这么做着，虽然身后有什么在拉着我，但是我不想要回头，我不想成为王小波《一只特立独行的猪》中写道的那些可怜的东西！\n\n回到《一只特立独行的猪》这篇文章，因为刚刚找了来，读了一番。王小波用一只猪来描述那么一种存在，真是讽刺啊！猪做到了人做不到的，而人却因为此要杀了他。好在王小波给我们了一个好的结局，这只猪逃走了，过上了自由的生活！他最后讲到：\n\n> 我已经四十岁了，除了这只猪，还没见过谁敢于如此无视对生活的设置。相反，我倒见过很多想要设置别人生活的人，还有对被设置的生活安之若素的人。因为这个原故，我一直怀念这只特立独行的猪。\n\n此刻，这只特立独行的猪也进入了我的闹钟，四十岁的某一天也许我也会怀念起他来，因为他是我们每个人心中曾想要成为的样子。\n\n还有什么要写的，不过这篇文章就让他到这里吧，有什么以后再写！对了音乐版权问题，没有外链，只好放到阿里云oos上自己做了一个外链，但是是会过期的。","html":"<p>刚才想好从哪写起的，现在却忘了。</p>\n\n<audio autoplay=\"autoplay\">  \n  <source src=\"http://96.f.1ting.com/57ec6b6b/0a33fb05553803f6b8accdb17cc2b165/zzzzzmp3/2011dApr/21C/21gaoqiaoyou/10.mp3\" />\n</audio>\n\n<p>昨天晚上跑完步回寝路上，军哥哥跟我讲到自己经过最近三周有些收获，但是之后他又感叹道自己只不过是从一个小的牢笼跳到了一个大的牢笼。他说，以前当兵的时候，以为回到学校就自由了，现在发现仅仅是从一个小的牢笼，到了一个大点的牢笼。这一点我表示了认同，然后我说除非你能够丢下那些外界的束缚，那你就自由了，可是自由的终点是孤独啊！</p>\n\n<p>我们都笑了笑！</p>\n\n<p>他继续说，怎么可能！我没能回答，因为我做不到！曾经在电影《荒野求生》里有人去做了，但是电影的结局是他留下了这么一张照片死去了。</p>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f836s8arn4j30go06rt95.jpg\" alt=\"\" /></p>\n\n<p>我原本想象的并不是电影里这样的远离人群的自由，这种自由不光是孤独的，它在一开始就让人望而却步。我想象的是那种处在人群之中，但是仍能够独立、自由地生存，也不用在意那些本身就坏掉的条条框框。现在的我就是这么做着，虽然身后有什么在拉着我，但是我不想要回头，我不想成为王小波《一只特立独行的猪》中写道的那些可怜的东西！</p>\n\n<p>回到《一只特立独行的猪》这篇文章，因为刚刚找了来，读了一番。王小波用一只猪来描述那么一种存在，真是讽刺啊！猪做到了人做不到的，而人却因为此要杀了他。好在王小波给我们了一个好的结局，这只猪逃走了，过上了自由的生活！他最后讲到：</p>\n\n<blockquote>\n  <p>我已经四十岁了，除了这只猪，还没见过谁敢于如此无视对生活的设置。相反，我倒见过很多想要设置别人生活的人，还有对被设置的生活安之若素的人。因为这个原故，我一直怀念这只特立独行的猪。</p>\n</blockquote>\n\n<p>此刻，这只特立独行的猪也进入了我的闹钟，四十岁的某一天也许我也会怀念起他来，因为他是我们每个人心中曾想要成为的样子。</p>\n\n<p>还有什么要写的，不过这篇文章就让他到这里吧，有什么以后再写！对了音乐版权问题，没有外链，只好放到阿里云oos上自己做了一个外链，但是是会过期的。</p>","image":"/content/images/2016/09/466feb8af40e67ccb6c4160843a12f25.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474455551712,"created_by":1,"updated_at":1475111810278,"updated_by":1,"published_at":1474589434505,"published_by":1},{"id":79,"uuid":"877e1b0d-fd5c-4cdf-bf9f-5b036619e6d8","title":"js 表达式","slug":"js-biao-da-shi","markdown":"因为第十章《可执行代码与执行环境》前面已经写过了，所以直接到第十一章《表达式》。看不下去，刚去逛了一圈，借了《权威指南》过来，看到《权威指南》的目录和规范目录差不多，但是一些表述上与规范出现了冲突，所以仅供参考。\n\n#### 主值表达式\n\n语法：\n```\nPrimaryExpression : \nthis \nIdentifier \nLiteral \nArrayLiteral \nObjectLiteral \n( Expression )\n```\n\n表达式的最小单位，也就是不在包含其它表达式。（这个表述是《权威指南》上的，但是个人对其保持怀疑态度，因为规范把 ArrayLiteral、ObjectLiteral 、( Expression )放在里面，就与这个表述冲突了）。如上面的产生式，它包含了this、标识符、字面量、数组字面量、对象字面量和分组表达式。\n\n下面主要要讲三点：分组表达式、数组初始化、对象初始化。\n\n###### 数组初始化（其实就是数组字面量）\n\n> 《权威指南》把数组初始化和对象初始化从主值表达式排除，理由是数组成员是子表达式。而规范定义主值表达式是使用产生式来定义的，并没有规定主值表达式是最小的语法单位。\n\n数组初始化是一个以字面量的形式书写的描述数组对象的初始化的表达式。它是一个零个或者多个表达式的序列，其中每一个表示一个数组元素，并且用方括号括起来。元素并不一定要是字面量，每次数组初始化执行时它们都会被执行一次。\n\n数组元素可能在元素列表的开始、结束，或者中间位置被省略。当元素列表中的一个逗号没有被 AssignmentExpression 优先处理（如，一个逗号在另一个逗号之前。）的情况下，缺失的数组元素仍然会对数组长度有贡献，并且增加后续元素的索引值。省略数组元素是没有定义的。假如元素在数组末尾被省略，那么元素不会贡献数组长度。\n\n> 相关的产生式理解了好久，都是递归的产生式，不过记住上面的就够了！\n\n###### 对象初始化（其实就是对象字面量）\n\n对象初始化是一个以直接量的方式描述对象的初始化过程的表达式。它是用花括号括起来的由零或者多对属性名 / 关联值组成的列表，值不需要是直接量，每次对象初始化被执行到时他们会执行一次。产生式也不写了。\n\n这里有一个问题是 new 的创建和字面量的创建有什么区别：\n\n> Return a new object created as if by the expression new Object() where Object is the standard built-in constructor with that name.\n\n从规范中看不太出区别。我们知道 new 的创建分三步，第一步就是创建空对象，然后是挂载prototype，第三步是以这个对象为this，调用构造函数。那字面量就不用挂载原型了？显然不是！stackover上也有很多关于这个问题的讨论。已知的是new Object 对 Number 和 String 进行了代理，new Object(1) 得到的是Number 类型的对象。说明内部的实现比起字面量会复杂，因为字面量不需要考虑这些情况！所以字面量会快吧！\n\n总结一下就是字面量的写法简洁、比构造函数快，建议使用字面量初始化对象。\n\n> 数组的话 new Array(100) 的方式会比 var a = [],a[100] = undefined 的方式快。\n\n###### 分组表达式 \n\n产生式 \n```\nPrimaryExpression : ( Expression ) \n```\n按照下面的过程执行 :\n\n- 返回执行Expression的结果，它可能是Reference类型。\n\n> 这一算法并不会作用GetValue于执行Expression的结果。这样做的原则是确保delete和typeof这样的运算符可以作用于括号括起来的表达式。\n\n#### 左值表达式\n\n左值是什么，抓狂😫！哦，不就是可读可写，右值只可读不可写。所谓左值，简单点说就是可以被赋值的表达式，在ES规范中是用内部类型引用(Reference) 描述的，其作用为存放数据空间，且存放是允许的。记住左值表达式的求值结果是引用类型这一点。\n\n```\nLeftHandSideExpression : \nNewExpression \n  MemberExpression \n    PrimaryExpression \n    FunctionExpression \n    MemberExpression [ Expression ] \n    MemberExpression . IdentifierName \n    new MemberExpression Arguments\n  new NewExpression\nCallExpression\n  MemberExpression Arguments \n  CallExpression Arguments \n  CallExpression [ Expression ] \n  CallExpression . IdentifierName\n```\n\n压缩了一下产生式，但是这里很多地方让我不解！为何有这么多产生式，而且好多产生式在运行时是会报错的。举个例子：\n\n```\nnew Object = 1;\n```\n\n根据产生式，左边是一个合法的左值表达式，但是不能够解析成引用类型，所以运行是会报错的。\n\n```\n(new Object).x = 1;\n```\n\n这个左边同样符合左值表达式，并且能够解析成引用类型，运行正常。\n\n如果能够从下面两个独立的点来看待，问题将会变得明朗。\n\n1. Is it a valid LeftHandSideExpression?\n2. Is it a valid reference?\n\n首先问题一是在语法分析阶段处理的，而问题二是在语义分析阶段处理的。而产生式是语法分析的内容，我们在真正考虑的时候还需要对第二个问题进行判断。最好能够回到《js 类型系统》一文把引用规范类型在看一遍，会有新的收获。\n\n弄清了这个问题，接下了就把左值表达式的几个符合第二个条件的用法介绍一下：\n\n###### 属性访问\n\n属性是通过 name 来访问的，可以使用点表示法访问\n\n```\nMemberExpression . IdentifierName \nCallExpression . IdentifierName \n```\n\n或者括号表示法访问\n\n```\nMemberExpression [ Expression ] \nCallExpression [ Expression ]\n```\n\n产生式 \n```\nMemberExpression : \nMemberExpression [ Expression ] \n```\n被如下评估：\n\n1. 令 baseReference 为解释执行 MemberExpression 的结果 .\n2. 令 baseValue 为 GetValue(baseReference).\n3. 令 propertyNameReference 为解释执行 Expression 的结果 .\n4. 令 propertyNameValue 为 GetValue(propertyNameReference).\n5. 调用 CheckObjectCoercible(baseValue).\n6. 令 propertyNameString 为 ToString(propertyNameValue).\n7. 如果正在执行中的语法产生式包含在严格模式代码当中，令 strict 为 true, 否则令 strict 为 false.\n8. 返回一个值类型的引用，其基值为 baseValue 且其引用名为 propertyNameString, 严格模式标记为 strict.\n\n产生式 `CallExpression : CallExpression [ Expression ]` \n以完全相同的方式执行，除了第1步执行的是其中的CallExpression。\n\n###### new 运算符\n\n如上，实际有效的 new 产生式有下面两个。\n\n产生式 \n```\nNewExpression : new NewExpression \n```\n\n它对应了没有括号的调用方式，即`obj = new Foo`。按照下面的过程执行：\n\n1. 令 ref 为解释执行 NewExpression 的结果。（内部引用）\n2. 令 constructor 为 GetValue(ref)。（真实的f）\n3. 如果 Type(constructor) is not Object ，抛出一个 TypeError 异常。\n4. 如果 constructor 没有实现 [[Construct]] 内置方法 ，抛出一个 TypeError 异常。\n5. 返回调用 constructor 的 [[Construct]] 内置方法的结果，传入按无参数传入参数列表 ( 就是一个空的参数列表 )。\n\n> [[Construct]]是函数的内置方法，大致的执行过程和前文写到的new的执行过程类似。\n \n产生式 \n```\nMemberExpression : new MemberExpression Arguments \n```\n它对应了有括号的调用方式，即`obj = new Foo(参数可有可无)`。按照下面的过程执行：\n\n1. 令 ref 为解释执行 MemberExpression 的结果。\n2. 令 constructor 为 GetValue(ref)。\n3. 令 argList 为解释执行 Arguments 的结果，产生一个由参数值构成的内部列表类型 (11.2.4)。\n4. 如果 Type(constructor) is not Object，抛出一个 TypeError 异常。\n5. 如果 constructor 没有实现 [[Construct]] 内置方法，抛出一个 TypeError 异常。\n6. 返回以 argList 为参数调用 constructor 的 [[Construct]] 内置方法的结果。\n\n###### 函数调用\n\n产生式 \n```\nCallExpression : MemberExpression Arguments \n```\n\n按照下面的过程执行：（这就是函数调用 this 的确定过程啊）\n\n1. 令 ref 为解释执行 MemberExpression 的结果。\n2. 令 func 为 GetValue(ref)。\n3. 令 argList 为解释执行 Arguments 的结果，产生参数值们的内部列表。\n4. 如果 Type(func) is not Object ，抛出一个 TypeError 异常。\n5. 如果 IsCallable(func) is false ，抛出一个 TypeError 异常。\n6. 如果 Type(ref) 为 Reference，那么 \n 1. 如果IsPropertyReference(ref) 为 true，那么 令 thisValue 为 GetBase(ref)。\n 2. 否则，ref 的基值是一个环境记录项 令 thisValue 为调用 GetBase(ref) 的 ImplicitThisValue 具体方法的结果。\n7. 否则，假如 Type(ref) 不是 Reference。令 thisValue 为 undefined。\n8. 返回调用 func 的 [[Call]] 内置方法的结果，传入 thisValue 作为 this 值和列表 argList 作为参数列表。\n\n产生式 `CallExpression : CallExpression Arguments`以完全相同的方式执行，除了第1步执行的是其中的CallExpression。\n\n> 假如func是一个原生的ECMAScript对象，返回的结果永远不会是Reference类型，调用一个宿主对象是否返回一个Reference类型的值由实现决定。 若一Reference值返回，则它必须是一个非严格的属性引用。（这一段还不是很理解）\n\n###### 函数表达式\n\n产生式 \n```\nMemberExpression : FunctionExpression \n```\n按照下面的过程执行 :\n\n- 返回解释执行 FunctionExpression 的结果。\n\n#### 后缀表达式\n\n语法：\n\n```\nPostfixExpression : \nLeftHandSideExpression \nLeftHandSideExpression [no LineTerminator] ++\nLeftHandSideExpression [no LineTerminator] --\n```\n\n###### 后缀自增运算符\n\n产生式 \n```\nPostfixExpression : \nLeftHandSideExpression [no LineTerminator] ++ \n```\n\n按照下面的过程执行 :\n\n1. 令 lhs 为解释执行 LeftH 和 SideExpression 的结果 .\n2. 假如以下所有条件都为 true，抛出一个 SyntaxError 异常 :\n 1. Type(lhs) 为 Reference\n 2. IsStrictReference(lhs) 为 true\n 3. Type(GetBase(lhs)) 为环境记录项\n 4. GetReferencedName(lhs) 为 \"eval\" 或 \"arguments\"\n\n###### 后缀自减运算符\n\n基本同后缀自增运算符，参照后缀自增运算符，不重复。\n\n#### 小结\n\n表达式这一章算是踩了不少坑，但是最后还是啃了下来！\n\n","html":"<p>因为第十章《可执行代码与执行环境》前面已经写过了，所以直接到第十一章《表达式》。看不下去，刚去逛了一圈，借了《权威指南》过来，看到《权威指南》的目录和规范目录差不多，但是一些表述上与规范出现了冲突，所以仅供参考。</p>\n\n<h4 id=\"\">主值表达式</h4>\n\n<p>语法：</p>\n\n<pre><code>PrimaryExpression :  \nthis  \nIdentifier  \nLiteral  \nArrayLiteral  \nObjectLiteral  \n( Expression )\n</code></pre>\n\n<p>表达式的最小单位，也就是不在包含其它表达式。（这个表述是《权威指南》上的，但是个人对其保持怀疑态度，因为规范把 ArrayLiteral、ObjectLiteral 、( Expression )放在里面，就与这个表述冲突了）。如上面的产生式，它包含了this、标识符、字面量、数组字面量、对象字面量和分组表达式。</p>\n\n<p>下面主要要讲三点：分组表达式、数组初始化、对象初始化。</p>\n\n<h6 id=\"\">数组初始化（其实就是数组字面量）</h6>\n\n<blockquote>\n  <p>《权威指南》把数组初始化和对象初始化从主值表达式排除，理由是数组成员是子表达式。而规范定义主值表达式是使用产生式来定义的，并没有规定主值表达式是最小的语法单位。</p>\n</blockquote>\n\n<p>数组初始化是一个以字面量的形式书写的描述数组对象的初始化的表达式。它是一个零个或者多个表达式的序列，其中每一个表示一个数组元素，并且用方括号括起来。元素并不一定要是字面量，每次数组初始化执行时它们都会被执行一次。</p>\n\n<p>数组元素可能在元素列表的开始、结束，或者中间位置被省略。当元素列表中的一个逗号没有被 AssignmentExpression 优先处理（如，一个逗号在另一个逗号之前。）的情况下，缺失的数组元素仍然会对数组长度有贡献，并且增加后续元素的索引值。省略数组元素是没有定义的。假如元素在数组末尾被省略，那么元素不会贡献数组长度。</p>\n\n<blockquote>\n  <p>相关的产生式理解了好久，都是递归的产生式，不过记住上面的就够了！</p>\n</blockquote>\n\n<h6 id=\"\">对象初始化（其实就是对象字面量）</h6>\n\n<p>对象初始化是一个以直接量的方式描述对象的初始化过程的表达式。它是用花括号括起来的由零或者多对属性名 / 关联值组成的列表，值不需要是直接量，每次对象初始化被执行到时他们会执行一次。产生式也不写了。</p>\n\n<p>这里有一个问题是 new 的创建和字面量的创建有什么区别：</p>\n\n<blockquote>\n  <p>Return a new object created as if by the expression new Object() where Object is the standard built-in constructor with that name.</p>\n</blockquote>\n\n<p>从规范中看不太出区别。我们知道 new 的创建分三步，第一步就是创建空对象，然后是挂载prototype，第三步是以这个对象为this，调用构造函数。那字面量就不用挂载原型了？显然不是！stackover上也有很多关于这个问题的讨论。已知的是new Object 对 Number 和 String 进行了代理，new Object(1) 得到的是Number 类型的对象。说明内部的实现比起字面量会复杂，因为字面量不需要考虑这些情况！所以字面量会快吧！</p>\n\n<p>总结一下就是字面量的写法简洁、比构造函数快，建议使用字面量初始化对象。</p>\n\n<blockquote>\n  <p>数组的话 new Array(100) 的方式会比 var a = [],a[100] = undefined 的方式快。</p>\n</blockquote>\n\n<h6 id=\"\">分组表达式</h6>\n\n<p>产生式 </p>\n\n<pre><code>PrimaryExpression : ( Expression )  \n</code></pre>\n\n<p>按照下面的过程执行 :</p>\n\n<ul>\n<li>返回执行Expression的结果，它可能是Reference类型。</li>\n</ul>\n\n<blockquote>\n  <p>这一算法并不会作用GetValue于执行Expression的结果。这样做的原则是确保delete和typeof这样的运算符可以作用于括号括起来的表达式。</p>\n</blockquote>\n\n<h4 id=\"\">左值表达式</h4>\n\n<p>左值是什么，抓狂😫！哦，不就是可读可写，右值只可读不可写。所谓左值，简单点说就是可以被赋值的表达式，在ES规范中是用内部类型引用(Reference) 描述的，其作用为存放数据空间，且存放是允许的。记住左值表达式的求值结果是引用类型这一点。</p>\n\n<pre><code>LeftHandSideExpression :  \nNewExpression  \n  MemberExpression \n    PrimaryExpression \n    FunctionExpression \n    MemberExpression [ Expression ] \n    MemberExpression . IdentifierName \n    new MemberExpression Arguments\n  new NewExpression\nCallExpression  \n  MemberExpression Arguments \n  CallExpression Arguments \n  CallExpression [ Expression ] \n  CallExpression . IdentifierName\n</code></pre>\n\n<p>压缩了一下产生式，但是这里很多地方让我不解！为何有这么多产生式，而且好多产生式在运行时是会报错的。举个例子：</p>\n\n<pre><code>new Object = 1;  \n</code></pre>\n\n<p>根据产生式，左边是一个合法的左值表达式，但是不能够解析成引用类型，所以运行是会报错的。</p>\n\n<pre><code>(new Object).x = 1;\n</code></pre>\n\n<p>这个左边同样符合左值表达式，并且能够解析成引用类型，运行正常。</p>\n\n<p>如果能够从下面两个独立的点来看待，问题将会变得明朗。</p>\n\n<ol>\n<li>Is it a valid LeftHandSideExpression?  </li>\n<li>Is it a valid reference?</li>\n</ol>\n\n<p>首先问题一是在语法分析阶段处理的，而问题二是在语义分析阶段处理的。而产生式是语法分析的内容，我们在真正考虑的时候还需要对第二个问题进行判断。最好能够回到《js 类型系统》一文把引用规范类型在看一遍，会有新的收获。</p>\n\n<p>弄清了这个问题，接下了就把左值表达式的几个符合第二个条件的用法介绍一下：</p>\n\n<h6 id=\"\">属性访问</h6>\n\n<p>属性是通过 name 来访问的，可以使用点表示法访问</p>\n\n<pre><code>MemberExpression . IdentifierName  \nCallExpression . IdentifierName  \n</code></pre>\n\n<p>或者括号表示法访问</p>\n\n<pre><code>MemberExpression [ Expression ]  \nCallExpression [ Expression ]  \n</code></pre>\n\n<p>产生式 </p>\n\n<pre><code>MemberExpression :  \nMemberExpression [ Expression ]  \n</code></pre>\n\n<p>被如下评估：</p>\n\n<ol>\n<li>令 baseReference 为解释执行 MemberExpression 的结果 .  </li>\n<li>令 baseValue 为 GetValue(baseReference).  </li>\n<li>令 propertyNameReference 为解释执行 Expression 的结果 .  </li>\n<li>令 propertyNameValue 为 GetValue(propertyNameReference).  </li>\n<li>调用 CheckObjectCoercible(baseValue).  </li>\n<li>令 propertyNameString 为 ToString(propertyNameValue).  </li>\n<li>如果正在执行中的语法产生式包含在严格模式代码当中，令 strict 为 true, 否则令 strict 为 false.  </li>\n<li>返回一个值类型的引用，其基值为 baseValue 且其引用名为 propertyNameString, 严格模式标记为 strict.</li>\n</ol>\n\n<p>产生式 <code>CallExpression : CallExpression [ Expression ]</code> \n以完全相同的方式执行，除了第1步执行的是其中的CallExpression。</p>\n\n<h6 id=\"new\">new 运算符</h6>\n\n<p>如上，实际有效的 new 产生式有下面两个。</p>\n\n<p>产生式 </p>\n\n<pre><code>NewExpression : new NewExpression  \n</code></pre>\n\n<p>它对应了没有括号的调用方式，即<code>obj = new Foo</code>。按照下面的过程执行：</p>\n\n<ol>\n<li>令 ref 为解释执行 NewExpression 的结果。（内部引用）  </li>\n<li>令 constructor 为 GetValue(ref)。（真实的f）  </li>\n<li>如果 Type(constructor) is not Object ，抛出一个 TypeError 异常。  </li>\n<li>如果 constructor 没有实现 [[Construct]] 内置方法 ，抛出一个 TypeError 异常。  </li>\n<li>返回调用 constructor 的 [[Construct]] 内置方法的结果，传入按无参数传入参数列表 ( 就是一个空的参数列表 )。</li>\n</ol>\n\n<blockquote>\n  <p>[[Construct]]是函数的内置方法，大致的执行过程和前文写到的new的执行过程类似。</p>\n</blockquote>\n\n<p>产生式 </p>\n\n<pre><code>MemberExpression : new MemberExpression Arguments  \n</code></pre>\n\n<p>它对应了有括号的调用方式，即<code>obj = new Foo(参数可有可无)</code>。按照下面的过程执行：</p>\n\n<ol>\n<li>令 ref 为解释执行 MemberExpression 的结果。  </li>\n<li>令 constructor 为 GetValue(ref)。  </li>\n<li>令 argList 为解释执行 Arguments 的结果，产生一个由参数值构成的内部列表类型 (11.2.4)。  </li>\n<li>如果 Type(constructor) is not Object，抛出一个 TypeError 异常。  </li>\n<li>如果 constructor 没有实现 [[Construct]] 内置方法，抛出一个 TypeError 异常。  </li>\n<li>返回以 argList 为参数调用 constructor 的 [[Construct]] 内置方法的结果。</li>\n</ol>\n\n<h6 id=\"\">函数调用</h6>\n\n<p>产生式 </p>\n\n<pre><code>CallExpression : MemberExpression Arguments  \n</code></pre>\n\n<p>按照下面的过程执行：（这就是函数调用 this 的确定过程啊）</p>\n\n<ol>\n<li>令 ref 为解释执行 MemberExpression 的结果。  </li>\n<li>令 func 为 GetValue(ref)。  </li>\n<li>令 argList 为解释执行 Arguments 的结果，产生参数值们的内部列表。  </li>\n<li>如果 Type(func) is not Object ，抛出一个 TypeError 异常。  </li>\n<li>如果 IsCallable(func) is false ，抛出一个 TypeError 异常。  </li>\n<li>如果 Type(ref) 为 Reference，那么 <br />\n<ol><li>如果IsPropertyReference(ref) 为 true，那么 令 thisValue 为 GetBase(ref)。</li>\n<li>否则，ref 的基值是一个环境记录项 令 thisValue 为调用 GetBase(ref) 的 ImplicitThisValue 具体方法的结果。</li></ol></li>\n<li>否则，假如 Type(ref) 不是 Reference。令 thisValue 为 undefined。  </li>\n<li>返回调用 func 的 [[Call]] 内置方法的结果，传入 thisValue 作为 this 值和列表 argList 作为参数列表。</li>\n</ol>\n\n<p>产生式 <code>CallExpression : CallExpression Arguments</code>以完全相同的方式执行，除了第1步执行的是其中的CallExpression。</p>\n\n<blockquote>\n  <p>假如func是一个原生的ECMAScript对象，返回的结果永远不会是Reference类型，调用一个宿主对象是否返回一个Reference类型的值由实现决定。 若一Reference值返回，则它必须是一个非严格的属性引用。（这一段还不是很理解）</p>\n</blockquote>\n\n<h6 id=\"\">函数表达式</h6>\n\n<p>产生式 </p>\n\n<pre><code>MemberExpression : FunctionExpression  \n</code></pre>\n\n<p>按照下面的过程执行 :</p>\n\n<ul>\n<li>返回解释执行 FunctionExpression 的结果。</li>\n</ul>\n\n<h4 id=\"\">后缀表达式</h4>\n\n<p>语法：</p>\n\n<pre><code>PostfixExpression :  \nLeftHandSideExpression  \nLeftHandSideExpression [no LineTerminator] ++  \nLeftHandSideExpression [no LineTerminator] --  \n</code></pre>\n\n<h6 id=\"\">后缀自增运算符</h6>\n\n<p>产生式 </p>\n\n<pre><code>PostfixExpression :  \nLeftHandSideExpression [no LineTerminator] ++  \n</code></pre>\n\n<p>按照下面的过程执行 :</p>\n\n<ol>\n<li>令 lhs 为解释执行 LeftH 和 SideExpression 的结果 .  </li>\n<li>假如以下所有条件都为 true，抛出一个 SyntaxError 异常 : <br />\n<ol><li>Type(lhs) 为 Reference</li>\n<li>IsStrictReference(lhs) 为 true</li>\n<li>Type(GetBase(lhs)) 为环境记录项</li>\n<li>GetReferencedName(lhs) 为 \"eval\" 或 \"arguments\"</li></ol></li>\n</ol>\n\n<h6 id=\"\">后缀自减运算符</h6>\n\n<p>基本同后缀自增运算符，参照后缀自增运算符，不重复。</p>\n\n<h4 id=\"\">小结</h4>\n\n<p>表达式这一章算是踩了不少坑，但是最后还是啃了下来！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474456538094,"created_by":1,"updated_at":1475051157103,"updated_by":1,"published_at":1474462893638,"published_by":1},{"id":80,"uuid":"5957507e-ed3e-4fe6-a0ec-9e70139f4a84","title":"js 运算符","slug":"js-yun-suan-fu","markdown":"前一篇表达式已经把我弄得心力憔悴，所以把标准的第十一章的后面表达式部分拆了出来，单独为一篇，内容也不少哦。🙄前半篇是昨天写的，不过今天病了，后面以边看边抄为主了！\n\n#### 一元运算符\n\n语法：\n```\nUnaryExpression : \nPostfixExpression \ndelete UnaryExpression \nvoid UnaryExpression \ntypeof UnaryExpression \n++ UnaryExpression \n-- UnaryExpression \n+ UnaryExpression \n- UnaryExpression \n~ UnaryExpression  \n! UnaryExpression\n```\n\n###### delete 运算符\n\n一般比较少会用到这东西吧！产生式 `UnaryExpression : delete UnaryExpression` 按照下面的过程执行 :\n\n1. 令 ref 为解释执行 UnaryExpression 的结果。\n2. 如果 Type(ref) 不是 Reference，返回 true。（只处理左值）\n3. 若 IsUnresolvableReference(ref) 则 , 如果 IsStrictReference(ref) 为 true ，抛出一个 SyntaxError 异常。 否则，返回 true。（在严格模式下，base为undefined抛出错误）\n4. 如果 IsPropertyReference(ref) 为 true 则： 返回以 GetReferencedName(ref) 和 IsStrictReference(ref) 做为参数调用 ToObject(GetBase(ref)) 的 [[Delete]] 内置方法的结果。（属性引用则会调用[[Delete]]方法，内部判断[[Configurable]]属性，严格模式下抛出错误）\n5. 否则 , ref 是到环境记录项绑定的 Reference，所以： 如果 IsStrictReference(ref) 为 true ，抛出一个 SyntaxError 异常 . 令 bindings 为 GetBase(ref). 返回以 GetReferencedName(ref) 为参数调用绑定的 DeleteBinding 具体方法的结果。\n\n> 在ECMAScript 6中，通过 const 或 let 声明指定的 \"temporal dead zone\" (TDZ) 对 delete 操作符也会起作用。在暂时性死区 delete 会抛出错误。\n\n> 在IE以及FIreFox下表现不符合规范。\n\n###### void 运算符\n\n产生式 `UnaryExpression : void UnaryExpression` 按照下面的过程执行 :\n\n1. 令 expr 为解释执行 UnaryExpression 的结果 .\n2. 调用 GetValue(expr).\n3. 返回 undefined.\n \n> GetValue一定要调用，即使它的值无用，但是可能会有可见的附加效果。\n\n###### typeof 运算符\n\n产生式 `UnaryExpression : typeof UnaryExpression` 按照下面的过程执行 :\n\n1. 令 val 为解释执行 UnaryExpression 的结果 .\n2. 如果 Type(val) 为 Reference，则： 如果 IsUnresolvableReference(val) 为 true，返回 \"undefined\"。 令 val 为 GetValue(val).\n3. 返回根据下图由 Type(val) 决定的字符串。\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f82kmdboezj317i0dwn0k.jpg)\n\n> 在 IE 6, 7 和 8 中，大多数的宿主对象是对象，而不是函数，例如：alert。\n\n###### 前自增运算符\n\n产生式 `UnaryExpression : ++ UnaryExpression` 按照下面的过程执行 :\n\n1. 令 expr 为解释执行 UnaryExpression 的结果。\n2. 抛出一个 SyntaxError 异常当以下条件全部为真：\n 1. Type(expr) 为 Reference\n 2. IsStrictReference(expr) 为 true\n 3. Type(GetBase(expr)) 为环境记录项\n 4. GetReferencedName(expr) 是 \"eval\" 或 \"arguments\"\n\n###### 前自减运算符\n\n同上。\n\n###### 一元 + 运算符\n\n一元+运算符将其操作数转换为Number类型。\n\n产生式 `UnaryExpression : + UnaryExpression` 按照下面的过程执行：\n\n1. 令 expr 为解释执行 UnaryExpression 的结果。\n2. 返回 ToNumber(GetValue(expr))。\n\n###### 一元 - 运算符\n\n一元-运算符将其操作数转换为Number类型并反转其正负。注意负的+0产生-0，负的-0产生+0。\n\n产生式 `UnaryExpression : - UnaryExpression` 按照下面的过程执行 :\n\n1. 令 expr 为解释执行 UnaryExpression 的结果。\n2. 令 oldValue 为 ToNumber(GetValue(expr))。\n3. 如果 oldValue is NaN ，return NaN。\n4. 返回 oldValue 取负（即，算出一个数字相同但是符号相反的值）的结果。\n\n###### 按位非运算符\n\n产生式 `UnaryExpression : ~ UnaryExpression` 按照下面的过程执行：\n\n1. 令 expr 为解释执行 UnaryExpression 的结果。\n2. 令 oldValue 为 ToInt32(GetValue(expr))。\n3. 返回 oldValue 按位取反的结果。结果为 32 位有符号整数。\n\n###### 逻辑非运算符\n\n产生式 `UnaryExpression : ! UnaryExpression` 按照下面的过程执行：\n\n1. 令 expr 为解释执行 UnaryExpression 的结果。\n2. 令 oldValue 为 ToBoolean(GetValue(expr))。\n3. 如果 oldValue 为 true ，返回 false。\n4. 返回 true。\n\n#### 乘法运算符\n\n语法：\n\n```\nMultiplicativeExpression : \nUnaryExpression \nMultiplicativeExpression * UnaryExpression MultiplicativeExpression / UnaryExpression MultiplicativeExpression % UnaryExpression\n```\n\n语义：\n\n产生式 `MultiplicativeExpression : 'MultiplicativeExpression'@ 'UnaryExpression`， 其中 @ 表示上面定义中的运算符之一，按照下面的过程执行：\n\n1. 令 left 为解释执行 MultiplicativeExpression 的结果。\n2. 令 leftValue 为 GetValue(left)。\n3. 令 right 为解释执行 UnaryExpression 的结果。\n4. 令 rightValue 为 GetValue(right)。\n5. 令 leftNum 为 ToNumber(leftValue)。\n6. 令 rightNum 为 ToNumber(rightValue)。\n7. 返回将特定运算符 (*, /, or %) 作用于 leftNum 和 rightNum 的结果。\n\n> 浮点数的乘法、除法、取余遵循IEEE 754二进制双精度幅度浮点算法规则，具体规则查看文档。\n\n#### 加法运算符\n\n语法：\n\n```\nAdditiveExpression : \nMultiplicativeExpression \nAdditiveExpression + MultiplicativeExpression AdditiveExpression - MultiplicativeExpression\n```\n\n###### 加号运算符\n\n加法包括了字符串和数字的加法。产生式 `AdditiveExpression : AdditiveExpression + MultiplicativeExpression` 按照下面的过程执行：\n\n1. 令 lref 为解释执行 AdditiveExpression 的结果。\n2. 令 lval 为 GetValue(lref)。\n3. 令 rref 为解释执行 MultiplicativeExpression 的结果。\n4. 令 rval 为 GetValue(rref)。\n5. 令 lprim 为 ToPrimitive(lval)。\n6. 令 rprim 为 ToPrimitive(rval)。\n7. 如果 Type(lprim) 为 String 或者 Type(rprim) 为 String，则： 返回由 ToString(lprim) 和 ToString(rprim) 连接而成的字符串。\n8. 返回将加法运算作用于 ToNumber(lprim) 和 ToNumber(rprim) 的结果。\n\n###### 减号运算符\n\n同加法，只是去掉了字符串相关的部分。\n\n> 加法遵循IEEE 754二进制双精度幅度浮点算法规则，规则见标准。\n\n#### 位运算移位运算符\n\n语法：\n\n```\nShiftExpression : \nAdditiveExpression \nShiftExpression << AdditiveExpression \nShiftExpression >> AdditiveExpression \nShiftExpression >>> AdditiveExpression\n```\n\n> 用的不多，略了。虽然据说比起乘法要快，毕竟是直接操作二进制。另外位操作会将操作数转为32位整数。\n\n#### 比较运算符\n\n语法：\n\n```\nRelationalExpression : \nShiftExpression \nRelationalExpression < ShiftExpression RelationalExpression > ShiftExpression RelationalExpression <= ShiftExpression RelationalExpression >= ShiftExpression RelationalExpression instanceof ShiftExpression RelationalExpression in ShiftExpression\n```\n```\nRelationalExpressionNoIn : \nShiftExpression \nRelationalExpressionNoIn < ShiftExpression RelationalExpressionNoIn > ShiftExpression RelationalExpressionNoIn <= ShiftExpression RelationalExpressionNoIn >= ShiftExpression RelationalExpressionNoIn instanceof ShiftExpression\n```\n\n> “NoIn”变体用以避免混淆关系表达式中的in运算符和for语句中的in运算符。\n\n执行关系比较运算符的结果总是Boolean类型。表示是否由运算符指定的关系对两操作数成立。\n\nRelationalExpressionNoIn跟RelationalExpression完全按相同的方式执行，出了RelationalExpressionNoIn要代RelationalExpression被执行。\n\n###### 抽象关系比较算法\n\n对于前四种，主要要了解抽象关系比较算法。以 x 和 y 为值进行小于比较（x < y 的比较），会产生的结果可为 true，false或 undefined（这说明 x、y 中最少有一个操作数是 NaN）。除了 x 和 y，这个算法另外需要一个名为 LeftFirst 的布尔值标记作为参数。这个标记用于解析顺序的控制，因为操作数 x 和 y 在执行的时候会有潜在可见的副作用。LeftFirst 标志是必须的，因为 ECMAScript 规定了表达式是从左到右顺序执行的。LeftFirst 的默认值是 true，这表明在相关的表达式中，参数 x 出现在参数 y 之前。如果 LeftFirst 值是 false，情况会相反，操作数的执行必须是先 y 后 x。这样的一个小于比较的执行步骤如下：\n\n1. 如果 LeftFirst 标志是 true，那么\n 1. 让 px 为调用 ToPrimitive(x, hint Number) 的结果。\n 2. 让 py 为调用 ToPrimitive(y, hint Number) 的结果。\n2. 否则解释执行的顺序需要反转，从而保证从左到右的执行顺序\n 1. 让 py 为调用 ToPrimitive(y, hint Number) 的结果。\n 2. 让 px 为调用 ToPrimitive(x, hint Number) 的结果。\n3. 如果 Type(px) 和 Type(py) 得到的结果不都是 String 类型，那么\n 1. 让 nx 为调用 ToNumber(px) 的结果。因为 px 和 py 都已经是基本数据类型（primitive values 也作原始值），其执行顺序并不重要。\n 2. 让 ny 为调用 ToNumber(py) 的结果。\n 3. 如果 nx 是 NaN，返回 undefined\n 4. 如果 ny 是 NaN，返回 undefined\n 5. 如果 nx 和 ny 的数字值相同，返回 false\n 6. 如果 nx 是 +0 且 ny 是 -0，返回 flase\n 7. 如果 nx 是 -0 且 ny 是 +0，返回 false\n 8. 如果 nx 是 +∞，返回 fasle\n 9. 如果 ny 是 +∞，返回 true\n 10. 如果 ny 是 -∞，返回 flase\n 11. 如果 nx 是 -∞，返回 true\n 12. 如果 nx 数学上的值小于 ny 数学上的值（注意这些数学值都不能是无限的且不能都为 0），返回 ture。否则返回 false。\n4. 否则，px 和 py 都是 Strings 类型\n 1. 如果 py 是 px 的一个前缀，返回 false。（当字符串 q 的值可以是字符串 p 和一个其他的字符串 r 拼接而成时，字符串 p 就是 q 的前缀。注意：任何字符串都是自己的前缀，因为 r 可能是空字符串。）\n 2. 如果 px 是 py 的前缀，返回 true。\n让 k 成为最小的非负整数，能使得在 px 字符串中位置 k 的字符与字符串 py 字符串中位置 k 的字符不相同。（这里必须有一个 k，使得互相都不是对方的前缀）\n 3. 让 m 成为字符串 px 中位置 k 的字符的编码单元值。\n 4. 让 n 成为字符串 py 中位置 k 的字符的编码单元值。\n 5. 如果 n < m，返回 true。否则，返回 false。\n \n> String 类型的比较使用了其编码单元值的作为一个简单的词法表序列去比较。这里不打算使用更复杂的、语义化的字符或字符串序列，和 Unicode 规范的整理序列进行比较。因此，字符串的值和其对应的 Unicode 标准的值是不相同的。实际上，这个算法假定了所有字符串已经是正常化的格式。同时要注意，对于字符串拼接追加的字符的时候，UTF-16 编码单元值的词法表序列是不同于代码点值的序列的。\n\n###### The instanceof operator\n\n产生式 `RelationalExpression : RelationalExpression in ShiftExpression` 按照下面的过程执行：\n\n1. 令 lref 为解释执行 RelationalExpression 的结果。\n2. 令 lval 为 GetValue(lref)。\n3. 令 rref 为解释执行 ShiftExpression 的结果。\n4. 令 rval 为 GetValue(rref)。\n5. 如果 Type(rval) 不是 Object ，抛出一个 TypeError 异常。\n返回以参数 ToString(lval)。调用 rval 的 [[HasProperty]] 内置方法的结果。\n\n函数的内部方法：[[HasInstance]] (V)\n\n设 F 是个函数对象。当以 V 作为参数调用 F 的 [[HasInstance]] 内部方法，采用如下步骤：\n\n1. 如果 V 不是个对象 , 返回 false。\n2. 令 O 为用属性名 \"prototype\" 调用 F 的 [[Get]] 内部方法的结果。\n3. 如果 Type(O) 不是 Object, 抛出一个 TypeError 异常。\n4. 重复\n 1. 令 V 为 V 的 [[Prototype]] 内部属性值。\n 2。 如果 V 是 null, 返回 false.\n 3. 如果 O 和 V 指向相同对象，返回 true。\n\n> 用 Function.prototype.bind 创建的函数对象拥有的不同的 [[HasInstance]] 实现。\n\n###### The in operator\n\n产生式 `RelationalExpression : RelationalExpression in ShiftExpression` 按照下面的过程执行 :\n\n1. 令 lref 为解释执行 RelationalExpression 的结果。\n2. 令 lval 为 GetValue(lref)。\n3. 令 rref 为解释执行 ShiftExpression 的结果。\n4. 令 rval 为 GetValue(rref)。\n5. 如果 Type(rval) 不是 Object ，抛出一个 TypeError 异常。\n6. 返回以参数 ToString(lval)。调用 rval 的 [[HasProperty]] 内置方法的结果。\n\n#### 等值运算符\n\n这部分主要涉及两个算法：抽象相等比较算法和严格等于比较算法。（平时建议使用严格比较，另外es6的Object.is在NaN和正负0的表现上刚好相反）\n\n###### 抽象相等比较算法\n\n比较运算 x = = y , 其中x和 y是值，产生true或者false。这样的比较按如下方式进行：\n\n1. 若Type(x)与Type(y)相同， 则\n 1. 若Type(x)为Undefined， 返回true。\n 2. 若Type(x)为Null， 返回true。\n 3. 若Type(x)为Number， 则若x为NaN， 返回false。若y为NaN， 返回false。若x与y为相等数值， 返回true。若x 为 +0 且 y为−0， 返回true。若x 为 −0 且 y为+0， 返回true。返回false。\n 4. 若Type(x)为String, 则当x和y为完全相同的字符序列（长度相等且相同字符在相同位置）时返回true。 否则， 返回false。\n 5. 若Type(x)为Boolean, 当x和y为同为true或者同为false时返回true。 否则， 返回false。\n 6. 当x和y为引用同一对象时返回true。否则，返回false。\n2. 若x为null且y为undefined， 返回true。\n3. 若x为undefined且y为null， 返回true。\n4. 若Type(x) 为 Number 且 Type(y)为String， 返回比较 x = = ToNumber(y)的结果。\n5. 若Type(x) 为 String 且 Type(y)为Number，返回比较ToNumber(x) = = y的结果。\n6. 若Type(x)为Boolean， 返回比较ToNumber(x) = = y的结果。\n7. 若Type(y)为Boolean， 返回比较x = = ToNumber(y)的结果。\n8. 若Type(x)为String或Number，且Type(y)为Object，返回比较x = = ToPrimitive(y)的结果。\n9. 若Type(x)为Object且Type(y)为String或Number， 返回比较ToPrimitive(x) = = y的结果。\n10. 返回false。\n\n>  按以上相等之定义：\n>\n字符串比较可以按这种方式强制执行: \"\" + a = = \"\" + b 。\n>\n数值比较可以按这种方式强制执行: +a = = +b 。\n>\n布尔值比较可以按这种方式强制执行: !a = = !b 。\n\n###### 严格等于比较算法\n\n比较 x===y，x 和 y 为值，需要产出 true 或 false。比较过程如下：\n\n1. 如果 Type(x) 与 Type(y) 的结果不一致，返回 false，否则\n2. 如果 Type(x) 结果为 Undefined，返回 true\n3. 如果 Type(x) 结果为 Null，返回 true\n4. 如果 Type(x) 结果为 Number，则\n 1. 如果 x 为 NaN，返回 false\n 2. 如果 y 为 NaN，返回 false\n 3. 如果 x 与 y 为同一个数字，返回 true\n 4. 如果 x 为 +0，y 为 -0，返回 true\n 5. 如果 x 为 -0，y 为 +0，返回 true\n 6. 返回 false\n5. 如果 Type(x) 结果为 String，如果 x 与 y 为完全相同的字符序列（相同的长度和相同的字符对应相同的位置），返回 true，否则，返回 false\n6. 如果 Type(x) 结果为 Boolean，如果 x 与 y 都为 true 或 false，则返回 true，否则，返回 false\n7. 如果 x 和 y 引用到同一个 Object 对象，返回 true，否则，返回 false\n\n> 此算法与 SameValue 算法在对待有符号的零和 NaN 上表现不同。\n\n#### 二进制位运算符（|、^、&）\n\n产生式 `A : A' @ 'B`，其中 @ 是上述产生式中的位运算符之一，按照下面的过程执行：\n\n1. 令 lref 为解释执行 A 的结果 。\n2. 令 lval 为 GetValue(lref)。\n3. 令 rref 为解释执行 B 的结果。\n4. 令 rval 为 GetValue(rref)。\n5. 令 lnum 为 ToInt32(lval)。\n6. 令 rnum 为 ToInt32(rval)。\n7. 返回作用位运算符 @ 到 lnum 和 rnum. 结果是 32 位有符号整数。\n\n#### 二元逻辑运算符（&&和||）\n\n产生式 `LogicalANDExpression : LogicalANDExpression && BitwiseORExpression` 按照下面的过程执行：\n\n1. 令 lref 为解释执行 LogicalANDExpression 的结果。\n2. 令 lval 为 GetValue(lref)。\n3. 如果 ToBoolean(lval) 为 false ，返回 lval。\n4. 令 rref 为解释执行 BitwiseORExpression 的结果 。\n5. 返回 GetValue(rref)。\n \n产生式 `LogicalORExpression : LogicalORExpression || LogicalANDExpression` 按照下面的过程执行：\n\n1. 令 lref 为解释执行 LogicalORExpression 的结果。\n2. 令 lval 为 GetValue(lref)。\n3. 如果 ToBoolean(lval) 为 true ，返回 lval。\n4. 令 rref 为解释执行 LogicalANDExpression 的结果。\n5. 返回 GetValue(rref)。\n\n> 由&& 或者||运算符产生的值不是必须为Boolean类型，产生的值始终为两个运算表达式的结果之一。根据上面的过程，我们可以得出，&&返回的是第一个表达式ToBoolean转换为false的表达式的值；||返回的是第一个表达式ToBoolean转换为true的表达式的值。利用这个特点通常可以用||来设置默认值。\n\n#### 条件运算符\n\n产生式 `ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression` 按照下面的过程执行：\n\n1. 令 lref 为解释执行 LogicalORExpression 的结果。\n2. 如果 ToBoolean(GetValue(lref)) 为 true ，那么： 令 trueRef 为解释执行第一个 AssignmentExpression 的结果。返回 GetValue(trueRef)。\n3. Else 令 falseRef 为解释执行第二个 AssignmentExpression 的结果 。返回 GetValue(falseRef)。\n\n#### 赋值运算符\n\n###### 简单赋值\n\n产生式 `AssignmentExpression : LeftHandSideExpression = AssignmentExpression` 按照下面的过程执行：\n\n1. 令 lref 为解释执行 LeftHandSideExpression 的结果。\n2. 令 rref 为解释执行 AssignmentExpression 的结果。\n3. 令 rval 为 GetValue(rref)。\n4. 抛出一个 SyntaxError 异常，当以下条件都成立：\n 1. Type(lref) 为 Reference\n 2. IsStrictReference(lref) 为 true\n 3. Type(GetBase(lref)) 为环境记录项\n 4. GetReferencedName(lref) 为 \"eval\" 或 \"arguments\"\n5. 调用 PutValue(lref, rval)。\n6. 返回 rval。\n\n关于连续赋值这里要分析一下，因为前天看到了[一道题](https://segmentfault.com/q/1010000002637728)。\n\n```\nvar a = {n:1};  \nvar b = a; // 持有a，以回查  \na.x = a = {n:2};  \nalert(a.x);// --> undefined  \nalert(b.x);// --> {n:2}\n```\n\n两点，首先连等使用的是右结合律，其次在赋值前，会先计算得右值在内部的真实引用，也就是上面的第一步，它返回的应当是规范内部的一个引用类型。[详解](http://www.th7.cn/web/js/201601/149861.shtml)\n\n###### 组合赋值\n\n不具体介绍了。\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f83qdf7xrcj30j60m0n0k.jpg)\n\n#### 逗号运算符\n\n当你想要在期望一个表达式的位置包含多个表达式时，可以使用逗号操作符。这个操作符最常用的一种情况是：for 循环中提供多个参数。\n\n另一个使用逗号操作符的例子是在返回值前处理一些操作。如同下面的代码，只有最后一个表达式被返回，其他的都只是被求值。\n\n```\nfunction myFunc () {\n  var x = 0;\n\n  return (x += 1, x); // the same of return ++x;\n}\n```\n\n#### 优先级\n\n从上到下，降低：\n\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f83rgucy6gj312o0z2n2q.jpg)\n\n\n\n","html":"<p>前一篇表达式已经把我弄得心力憔悴，所以把标准的第十一章的后面表达式部分拆了出来，单独为一篇，内容也不少哦。🙄前半篇是昨天写的，不过今天病了，后面以边看边抄为主了！</p>\n\n<h4 id=\"\">一元运算符</h4>\n\n<p>语法：</p>\n\n<pre><code>UnaryExpression :  \nPostfixExpression  \ndelete UnaryExpression  \nvoid UnaryExpression  \ntypeof UnaryExpression  \n++ UnaryExpression \n-- UnaryExpression \n+ UnaryExpression \n- UnaryExpression \n~ UnaryExpression  \n! UnaryExpression\n</code></pre>\n\n<h6 id=\"delete\">delete 运算符</h6>\n\n<p>一般比较少会用到这东西吧！产生式 <code>UnaryExpression : delete UnaryExpression</code> 按照下面的过程执行 :</p>\n\n<ol>\n<li>令 ref 为解释执行 UnaryExpression 的结果。  </li>\n<li>如果 Type(ref) 不是 Reference，返回 true。（只处理左值）  </li>\n<li>若 IsUnresolvableReference(ref) 则 , 如果 IsStrictReference(ref) 为 true ，抛出一个 SyntaxError 异常。 否则，返回 true。（在严格模式下，base为undefined抛出错误）  </li>\n<li>如果 IsPropertyReference(ref) 为 true 则： 返回以 GetReferencedName(ref) 和 IsStrictReference(ref) 做为参数调用 ToObject(GetBase(ref)) 的 [[Delete]] 内置方法的结果。（属性引用则会调用[[Delete]]方法，内部判断[[Configurable]]属性，严格模式下抛出错误）  </li>\n<li>否则 , ref 是到环境记录项绑定的 Reference，所以： 如果 IsStrictReference(ref) 为 true ，抛出一个 SyntaxError 异常 . 令 bindings 为 GetBase(ref). 返回以 GetReferencedName(ref) 为参数调用绑定的 DeleteBinding 具体方法的结果。</li>\n</ol>\n\n<blockquote>\n  <p>在ECMAScript 6中，通过 const 或 let 声明指定的 \"temporal dead zone\" (TDZ) 对 delete 操作符也会起作用。在暂时性死区 delete 会抛出错误。</p>\n  \n  <p>在IE以及FIreFox下表现不符合规范。</p>\n</blockquote>\n\n<h6 id=\"void\">void 运算符</h6>\n\n<p>产生式 <code>UnaryExpression : void UnaryExpression</code> 按照下面的过程执行 :</p>\n\n<ol>\n<li>令 expr 为解释执行 UnaryExpression 的结果 .  </li>\n<li>调用 GetValue(expr).  </li>\n<li>返回 undefined.</li>\n</ol>\n\n<blockquote>\n  <p>GetValue一定要调用，即使它的值无用，但是可能会有可见的附加效果。</p>\n</blockquote>\n\n<h6 id=\"typeof\">typeof 运算符</h6>\n\n<p>产生式 <code>UnaryExpression : typeof UnaryExpression</code> 按照下面的过程执行 :</p>\n\n<ol>\n<li>令 val 为解释执行 UnaryExpression 的结果 .  </li>\n<li>如果 Type(val) 为 Reference，则： 如果 IsUnresolvableReference(val) 为 true，返回 \"undefined\"。 令 val 为 GetValue(val).  </li>\n<li>返回根据下图由 Type(val) 决定的字符串。</li>\n</ol>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f82kmdboezj317i0dwn0k.jpg\" alt=\"\" /></p>\n\n<blockquote>\n  <p>在 IE 6, 7 和 8 中，大多数的宿主对象是对象，而不是函数，例如：alert。</p>\n</blockquote>\n\n<h6 id=\"\">前自增运算符</h6>\n\n<p>产生式 <code>UnaryExpression : ++ UnaryExpression</code> 按照下面的过程执行 :</p>\n\n<ol>\n<li>令 expr 为解释执行 UnaryExpression 的结果。  </li>\n<li>抛出一个 SyntaxError 异常当以下条件全部为真： <br />\n<ol><li>Type(expr) 为 Reference</li>\n<li>IsStrictReference(expr) 为 true</li>\n<li>Type(GetBase(expr)) 为环境记录项</li>\n<li>GetReferencedName(expr) 是 \"eval\" 或 \"arguments\"</li></ol></li>\n</ol>\n\n<h6 id=\"\">前自减运算符</h6>\n\n<p>同上。</p>\n\n<h6 id=\"\">一元 + 运算符</h6>\n\n<p>一元+运算符将其操作数转换为Number类型。</p>\n\n<p>产生式 <code>UnaryExpression : + UnaryExpression</code> 按照下面的过程执行：</p>\n\n<ol>\n<li>令 expr 为解释执行 UnaryExpression 的结果。  </li>\n<li>返回 ToNumber(GetValue(expr))。</li>\n</ol>\n\n<h6 id=\"\">一元 - 运算符</h6>\n\n<p>一元-运算符将其操作数转换为Number类型并反转其正负。注意负的+0产生-0，负的-0产生+0。</p>\n\n<p>产生式 <code>UnaryExpression : - UnaryExpression</code> 按照下面的过程执行 :</p>\n\n<ol>\n<li>令 expr 为解释执行 UnaryExpression 的结果。  </li>\n<li>令 oldValue 为 ToNumber(GetValue(expr))。  </li>\n<li>如果 oldValue is NaN ，return NaN。  </li>\n<li>返回 oldValue 取负（即，算出一个数字相同但是符号相反的值）的结果。</li>\n</ol>\n\n<h6 id=\"\">按位非运算符</h6>\n\n<p>产生式 <code>UnaryExpression : ~ UnaryExpression</code> 按照下面的过程执行：</p>\n\n<ol>\n<li>令 expr 为解释执行 UnaryExpression 的结果。  </li>\n<li>令 oldValue 为 ToInt32(GetValue(expr))。  </li>\n<li>返回 oldValue 按位取反的结果。结果为 32 位有符号整数。</li>\n</ol>\n\n<h6 id=\"\">逻辑非运算符</h6>\n\n<p>产生式 <code>UnaryExpression : ! UnaryExpression</code> 按照下面的过程执行：</p>\n\n<ol>\n<li>令 expr 为解释执行 UnaryExpression 的结果。  </li>\n<li>令 oldValue 为 ToBoolean(GetValue(expr))。  </li>\n<li>如果 oldValue 为 true ，返回 false。  </li>\n<li>返回 true。</li>\n</ol>\n\n<h4 id=\"\">乘法运算符</h4>\n\n<p>语法：</p>\n\n<pre><code>MultiplicativeExpression :  \nUnaryExpression  \nMultiplicativeExpression * UnaryExpression MultiplicativeExpression / UnaryExpression MultiplicativeExpression % UnaryExpression  \n</code></pre>\n\n<p>语义：</p>\n\n<p>产生式 <code>MultiplicativeExpression : 'MultiplicativeExpression'@ 'UnaryExpression</code>， 其中 @ 表示上面定义中的运算符之一，按照下面的过程执行：</p>\n\n<ol>\n<li>令 left 为解释执行 MultiplicativeExpression 的结果。  </li>\n<li>令 leftValue 为 GetValue(left)。  </li>\n<li>令 right 为解释执行 UnaryExpression 的结果。  </li>\n<li>令 rightValue 为 GetValue(right)。  </li>\n<li>令 leftNum 为 ToNumber(leftValue)。  </li>\n<li>令 rightNum 为 ToNumber(rightValue)。  </li>\n<li>返回将特定运算符 (*, /, or %) 作用于 leftNum 和 rightNum 的结果。</li>\n</ol>\n\n<blockquote>\n  <p>浮点数的乘法、除法、取余遵循IEEE 754二进制双精度幅度浮点算法规则，具体规则查看文档。</p>\n</blockquote>\n\n<h4 id=\"\">加法运算符</h4>\n\n<p>语法：</p>\n\n<pre><code>AdditiveExpression :  \nMultiplicativeExpression  \nAdditiveExpression + MultiplicativeExpression AdditiveExpression - MultiplicativeExpression  \n</code></pre>\n\n<h6 id=\"\">加号运算符</h6>\n\n<p>加法包括了字符串和数字的加法。产生式 <code>AdditiveExpression : AdditiveExpression + MultiplicativeExpression</code> 按照下面的过程执行：</p>\n\n<ol>\n<li>令 lref 为解释执行 AdditiveExpression 的结果。  </li>\n<li>令 lval 为 GetValue(lref)。  </li>\n<li>令 rref 为解释执行 MultiplicativeExpression 的结果。  </li>\n<li>令 rval 为 GetValue(rref)。  </li>\n<li>令 lprim 为 ToPrimitive(lval)。  </li>\n<li>令 rprim 为 ToPrimitive(rval)。  </li>\n<li>如果 Type(lprim) 为 String 或者 Type(rprim) 为 String，则： 返回由 ToString(lprim) 和 ToString(rprim) 连接而成的字符串。  </li>\n<li>返回将加法运算作用于 ToNumber(lprim) 和 ToNumber(rprim) 的结果。</li>\n</ol>\n\n<h6 id=\"\">减号运算符</h6>\n\n<p>同加法，只是去掉了字符串相关的部分。</p>\n\n<blockquote>\n  <p>加法遵循IEEE 754二进制双精度幅度浮点算法规则，规则见标准。</p>\n</blockquote>\n\n<h4 id=\"\">位运算移位运算符</h4>\n\n<p>语法：</p>\n\n<pre><code>ShiftExpression :  \nAdditiveExpression  \nShiftExpression &lt;&lt; AdditiveExpression  \nShiftExpression &gt;&gt; AdditiveExpression  \nShiftExpression &gt;&gt;&gt; AdditiveExpression  \n</code></pre>\n\n<blockquote>\n  <p>用的不多，略了。虽然据说比起乘法要快，毕竟是直接操作二进制。另外位操作会将操作数转为32位整数。</p>\n</blockquote>\n\n<h4 id=\"\">比较运算符</h4>\n\n<p>语法：</p>\n\n<pre><code>RelationalExpression :  \nShiftExpression  \nRelationalExpression &lt; ShiftExpression RelationalExpression &gt; ShiftExpression RelationalExpression &lt;= ShiftExpression RelationalExpression &gt;= ShiftExpression RelationalExpression instanceof ShiftExpression RelationalExpression in ShiftExpression  \n</code></pre>\n\n<pre><code>RelationalExpressionNoIn :  \nShiftExpression  \nRelationalExpressionNoIn &lt; ShiftExpression RelationalExpressionNoIn &gt; ShiftExpression RelationalExpressionNoIn &lt;= ShiftExpression RelationalExpressionNoIn &gt;= ShiftExpression RelationalExpressionNoIn instanceof ShiftExpression  \n</code></pre>\n\n<blockquote>\n  <p>“NoIn”变体用以避免混淆关系表达式中的in运算符和for语句中的in运算符。</p>\n</blockquote>\n\n<p>执行关系比较运算符的结果总是Boolean类型。表示是否由运算符指定的关系对两操作数成立。</p>\n\n<p>RelationalExpressionNoIn跟RelationalExpression完全按相同的方式执行，出了RelationalExpressionNoIn要代RelationalExpression被执行。</p>\n\n<h6 id=\"\">抽象关系比较算法</h6>\n\n<p>对于前四种，主要要了解抽象关系比较算法。以 x 和 y 为值进行小于比较（x &lt; y 的比较），会产生的结果可为 true，false或 undefined（这说明 x、y 中最少有一个操作数是 NaN）。除了 x 和 y，这个算法另外需要一个名为 LeftFirst 的布尔值标记作为参数。这个标记用于解析顺序的控制，因为操作数 x 和 y 在执行的时候会有潜在可见的副作用。LeftFirst 标志是必须的，因为 ECMAScript 规定了表达式是从左到右顺序执行的。LeftFirst 的默认值是 true，这表明在相关的表达式中，参数 x 出现在参数 y 之前。如果 LeftFirst 值是 false，情况会相反，操作数的执行必须是先 y 后 x。这样的一个小于比较的执行步骤如下：</p>\n\n<ol>\n<li>如果 LeftFirst 标志是 true，那么 <br />\n<ol><li>让 px 为调用 ToPrimitive(x, hint Number) 的结果。</li>\n<li>让 py 为调用 ToPrimitive(y, hint Number) 的结果。</li></ol></li>\n<li>否则解释执行的顺序需要反转，从而保证从左到右的执行顺序 <br />\n<ol><li>让 py 为调用 ToPrimitive(y, hint Number) 的结果。</li>\n<li>让 px 为调用 ToPrimitive(x, hint Number) 的结果。</li></ol></li>\n<li>如果 Type(px) 和 Type(py) 得到的结果不都是 String 类型，那么 <br />\n<ol><li>让 nx 为调用 ToNumber(px) 的结果。因为 px 和 py 都已经是基本数据类型（primitive values 也作原始值），其执行顺序并不重要。</li>\n<li>让 ny 为调用 ToNumber(py) 的结果。</li>\n<li>如果 nx 是 NaN，返回 undefined</li>\n<li>如果 ny 是 NaN，返回 undefined</li>\n<li>如果 nx 和 ny 的数字值相同，返回 false</li>\n<li>如果 nx 是 +0 且 ny 是 -0，返回 flase</li>\n<li>如果 nx 是 -0 且 ny 是 +0，返回 false</li>\n<li>如果 nx 是 +∞，返回 fasle</li>\n<li>如果 ny 是 +∞，返回 true</li>\n<li>如果 ny 是 -∞，返回 flase</li>\n<li>如果 nx 是 -∞，返回 true</li>\n<li>如果 nx 数学上的值小于 ny 数学上的值（注意这些数学值都不能是无限的且不能都为 0），返回 ture。否则返回 false。</li></ol></li>\n<li>否则，px 和 py 都是 Strings 类型 <br />\n<ol><li>如果 py 是 px 的一个前缀，返回 false。（当字符串 q 的值可以是字符串 p 和一个其他的字符串 r 拼接而成时，字符串 p 就是 q 的前缀。注意：任何字符串都是自己的前缀，因为 r 可能是空字符串。）</li>\n<li>如果 px 是 py 的前缀，返回 true。\n让 k 成为最小的非负整数，能使得在 px 字符串中位置 k 的字符与字符串 py 字符串中位置 k 的字符不相同。（这里必须有一个 k，使得互相都不是对方的前缀）</li>\n<li>让 m 成为字符串 px 中位置 k 的字符的编码单元值。</li>\n<li>让 n 成为字符串 py 中位置 k 的字符的编码单元值。</li>\n<li>如果 n &lt; m，返回 true。否则，返回 false。</li></ol></li>\n</ol>\n\n<blockquote>\n  <p>String 类型的比较使用了其编码单元值的作为一个简单的词法表序列去比较。这里不打算使用更复杂的、语义化的字符或字符串序列，和 Unicode 规范的整理序列进行比较。因此，字符串的值和其对应的 Unicode 标准的值是不相同的。实际上，这个算法假定了所有字符串已经是正常化的格式。同时要注意，对于字符串拼接追加的字符的时候，UTF-16 编码单元值的词法表序列是不同于代码点值的序列的。</p>\n</blockquote>\n\n<h6 id=\"theinstanceofoperator\">The instanceof operator</h6>\n\n<p>产生式 <code>RelationalExpression : RelationalExpression in ShiftExpression</code> 按照下面的过程执行：</p>\n\n<ol>\n<li>令 lref 为解释执行 RelationalExpression 的结果。  </li>\n<li>令 lval 为 GetValue(lref)。  </li>\n<li>令 rref 为解释执行 ShiftExpression 的结果。  </li>\n<li>令 rval 为 GetValue(rref)。  </li>\n<li>如果 Type(rval) 不是 Object ，抛出一个 TypeError 异常。 <br />\n返回以参数 ToString(lval)。调用 rval 的 [[HasProperty]] 内置方法的结果。</li>\n</ol>\n\n<p>函数的内部方法：[[HasInstance]] (V)</p>\n\n<p>设 F 是个函数对象。当以 V 作为参数调用 F 的 [[HasInstance]] 内部方法，采用如下步骤：</p>\n\n<ol>\n<li>如果 V 不是个对象 , 返回 false。  </li>\n<li>令 O 为用属性名 \"prototype\" 调用 F 的 [[Get]] 内部方法的结果。  </li>\n<li>如果 Type(O) 不是 Object, 抛出一个 TypeError 异常。  </li>\n<li>重复 <br />\n<ol><li>令 V 为 V 的 [[Prototype]] 内部属性值。\n2。 如果 V 是 null, 返回 false.</li>\n<li>如果 O 和 V 指向相同对象，返回 true。</li></ol></li>\n</ol>\n\n<blockquote>\n  <p>用 Function.prototype.bind 创建的函数对象拥有的不同的 [[HasInstance]] 实现。</p>\n</blockquote>\n\n<h6 id=\"theinoperator\">The in operator</h6>\n\n<p>产生式 <code>RelationalExpression : RelationalExpression in ShiftExpression</code> 按照下面的过程执行 :</p>\n\n<ol>\n<li>令 lref 为解释执行 RelationalExpression 的结果。  </li>\n<li>令 lval 为 GetValue(lref)。  </li>\n<li>令 rref 为解释执行 ShiftExpression 的结果。  </li>\n<li>令 rval 为 GetValue(rref)。  </li>\n<li>如果 Type(rval) 不是 Object ，抛出一个 TypeError 异常。  </li>\n<li>返回以参数 ToString(lval)。调用 rval 的 [[HasProperty]] 内置方法的结果。</li>\n</ol>\n\n<h4 id=\"\">等值运算符</h4>\n\n<p>这部分主要涉及两个算法：抽象相等比较算法和严格等于比较算法。（平时建议使用严格比较，另外es6的Object.is在NaN和正负0的表现上刚好相反）</p>\n\n<h6 id=\"\">抽象相等比较算法</h6>\n\n<p>比较运算 x = = y , 其中x和 y是值，产生true或者false。这样的比较按如下方式进行：</p>\n\n<ol>\n<li>若Type(x)与Type(y)相同， 则 <br />\n<ol><li>若Type(x)为Undefined， 返回true。</li>\n<li>若Type(x)为Null， 返回true。</li>\n<li>若Type(x)为Number， 则若x为NaN， 返回false。若y为NaN， 返回false。若x与y为相等数值， 返回true。若x 为 +0 且 y为−0， 返回true。若x 为 −0 且 y为+0， 返回true。返回false。</li>\n<li>若Type(x)为String, 则当x和y为完全相同的字符序列（长度相等且相同字符在相同位置）时返回true。 否则， 返回false。</li>\n<li>若Type(x)为Boolean, 当x和y为同为true或者同为false时返回true。 否则， 返回false。</li>\n<li>当x和y为引用同一对象时返回true。否则，返回false。</li></ol></li>\n<li>若x为null且y为undefined， 返回true。  </li>\n<li>若x为undefined且y为null， 返回true。  </li>\n<li>若Type(x) 为 Number 且 Type(y)为String， 返回比较 x = = ToNumber(y)的结果。  </li>\n<li>若Type(x) 为 String 且 Type(y)为Number，返回比较ToNumber(x) = = y的结果。  </li>\n<li>若Type(x)为Boolean， 返回比较ToNumber(x) = = y的结果。  </li>\n<li>若Type(y)为Boolean， 返回比较x = = ToNumber(y)的结果。  </li>\n<li>若Type(x)为String或Number，且Type(y)为Object，返回比较x = = ToPrimitive(y)的结果。  </li>\n<li>若Type(x)为Object且Type(y)为String或Number， 返回比较ToPrimitive(x) = = y的结果。  </li>\n<li>返回false。</li>\n</ol>\n\n<blockquote>\n  <p>按以上相等之定义：</p>\n  \n  <p>字符串比较可以按这种方式强制执行: \"\" + a = = \"\" + b 。</p>\n  \n  <p>数值比较可以按这种方式强制执行: +a = = +b 。</p>\n  \n  <p>布尔值比较可以按这种方式强制执行: !a = = !b 。</p>\n</blockquote>\n\n<h6 id=\"\">严格等于比较算法</h6>\n\n<p>比较 x===y，x 和 y 为值，需要产出 true 或 false。比较过程如下：</p>\n\n<ol>\n<li>如果 Type(x) 与 Type(y) 的结果不一致，返回 false，否则  </li>\n<li>如果 Type(x) 结果为 Undefined，返回 true  </li>\n<li>如果 Type(x) 结果为 Null，返回 true  </li>\n<li>如果 Type(x) 结果为 Number，则 <br />\n<ol><li>如果 x 为 NaN，返回 false</li>\n<li>如果 y 为 NaN，返回 false</li>\n<li>如果 x 与 y 为同一个数字，返回 true</li>\n<li>如果 x 为 +0，y 为 -0，返回 true</li>\n<li>如果 x 为 -0，y 为 +0，返回 true</li>\n<li>返回 false</li></ol></li>\n<li>如果 Type(x) 结果为 String，如果 x 与 y 为完全相同的字符序列（相同的长度和相同的字符对应相同的位置），返回 true，否则，返回 false  </li>\n<li>如果 Type(x) 结果为 Boolean，如果 x 与 y 都为 true 或 false，则返回 true，否则，返回 false  </li>\n<li>如果 x 和 y 引用到同一个 Object 对象，返回 true，否则，返回 false</li>\n</ol>\n\n<blockquote>\n  <p>此算法与 SameValue 算法在对待有符号的零和 NaN 上表现不同。</p>\n</blockquote>\n\n<h4 id=\"\">二进制位运算符（|、^、&amp;）</h4>\n\n<p>产生式 <code>A : A' @ 'B</code>，其中 @ 是上述产生式中的位运算符之一，按照下面的过程执行：</p>\n\n<ol>\n<li>令 lref 为解释执行 A 的结果 。  </li>\n<li>令 lval 为 GetValue(lref)。  </li>\n<li>令 rref 为解释执行 B 的结果。  </li>\n<li>令 rval 为 GetValue(rref)。  </li>\n<li>令 lnum 为 ToInt32(lval)。  </li>\n<li>令 rnum 为 ToInt32(rval)。  </li>\n<li>返回作用位运算符 @ 到 lnum 和 rnum. 结果是 32 位有符号整数。</li>\n</ol>\n\n<h4 id=\"\">二元逻辑运算符（&amp;&amp;和||）</h4>\n\n<p>产生式 <code>LogicalANDExpression : LogicalANDExpression &amp;&amp; BitwiseORExpression</code> 按照下面的过程执行：</p>\n\n<ol>\n<li>令 lref 为解释执行 LogicalANDExpression 的结果。  </li>\n<li>令 lval 为 GetValue(lref)。  </li>\n<li>如果 ToBoolean(lval) 为 false ，返回 lval。  </li>\n<li>令 rref 为解释执行 BitwiseORExpression 的结果 。  </li>\n<li>返回 GetValue(rref)。</li>\n</ol>\n\n<p>产生式 <code>LogicalORExpression : LogicalORExpression || LogicalANDExpression</code> 按照下面的过程执行：</p>\n\n<ol>\n<li>令 lref 为解释执行 LogicalORExpression 的结果。  </li>\n<li>令 lval 为 GetValue(lref)。  </li>\n<li>如果 ToBoolean(lval) 为 true ，返回 lval。  </li>\n<li>令 rref 为解释执行 LogicalANDExpression 的结果。  </li>\n<li>返回 GetValue(rref)。</li>\n</ol>\n\n<blockquote>\n  <p>由&amp;&amp; 或者||运算符产生的值不是必须为Boolean类型，产生的值始终为两个运算表达式的结果之一。根据上面的过程，我们可以得出，&amp;&amp;返回的是第一个表达式ToBoolean转换为false的表达式的值；||返回的是第一个表达式ToBoolean转换为true的表达式的值。利用这个特点通常可以用||来设置默认值。</p>\n</blockquote>\n\n<h4 id=\"\">条件运算符</h4>\n\n<p>产生式 <code>ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression</code> 按照下面的过程执行：</p>\n\n<ol>\n<li>令 lref 为解释执行 LogicalORExpression 的结果。  </li>\n<li>如果 ToBoolean(GetValue(lref)) 为 true ，那么： 令 trueRef 为解释执行第一个 AssignmentExpression 的结果。返回 GetValue(trueRef)。  </li>\n<li>Else 令 falseRef 为解释执行第二个 AssignmentExpression 的结果 。返回 GetValue(falseRef)。</li>\n</ol>\n\n<h4 id=\"\">赋值运算符</h4>\n\n<h6 id=\"\">简单赋值</h6>\n\n<p>产生式 <code>AssignmentExpression : LeftHandSideExpression = AssignmentExpression</code> 按照下面的过程执行：</p>\n\n<ol>\n<li>令 lref 为解释执行 LeftHandSideExpression 的结果。  </li>\n<li>令 rref 为解释执行 AssignmentExpression 的结果。  </li>\n<li>令 rval 为 GetValue(rref)。  </li>\n<li>抛出一个 SyntaxError 异常，当以下条件都成立： <br />\n<ol><li>Type(lref) 为 Reference</li>\n<li>IsStrictReference(lref) 为 true</li>\n<li>Type(GetBase(lref)) 为环境记录项</li>\n<li>GetReferencedName(lref) 为 \"eval\" 或 \"arguments\"</li></ol></li>\n<li>调用 PutValue(lref, rval)。  </li>\n<li>返回 rval。</li>\n</ol>\n\n<p>关于连续赋值这里要分析一下，因为前天看到了<a href=\"https://segmentfault.com/q/1010000002637728\">一道题</a>。</p>\n\n<pre><code>var a = {n:1};  \nvar b = a; // 持有a，以回查  \na.x = a = {n:2};  \nalert(a.x);// --&gt; undefined  \nalert(b.x);// --&gt; {n:2}  \n</code></pre>\n\n<p>两点，首先连等使用的是右结合律，其次在赋值前，会先计算得右值在内部的真实引用，也就是上面的第一步，它返回的应当是规范内部的一个引用类型。<a href=\"http://www.th7.cn/web/js/201601/149861.shtml\">详解</a></p>\n\n<h6 id=\"\">组合赋值</h6>\n\n<p>不具体介绍了。</p>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f83qdf7xrcj30j60m0n0k.jpg\" alt=\"\" /></p>\n\n<h4 id=\"\">逗号运算符</h4>\n\n<p>当你想要在期望一个表达式的位置包含多个表达式时，可以使用逗号操作符。这个操作符最常用的一种情况是：for 循环中提供多个参数。</p>\n\n<p>另一个使用逗号操作符的例子是在返回值前处理一些操作。如同下面的代码，只有最后一个表达式被返回，其他的都只是被求值。</p>\n\n<pre><code>function myFunc () {  \n  var x = 0;\n\n  return (x += 1, x); // the same of return ++x;\n}\n</code></pre>\n\n<h4 id=\"\">优先级</h4>\n\n<p>从上到下，降低：</p>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f83rgucy6gj312o0z2n2q.jpg\" alt=\"\" /></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474534247476,"created_by":1,"updated_at":1475051143921,"updated_by":1,"published_at":1474620063762,"published_by":1},{"id":81,"uuid":"db635e72-b3ed-412d-bf66-d49a5376e414","title":"有生之年系列之——生病","slug":"you-sheng-zhi-nian-xi-lie-sheng-bing","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=27566680&auto=1&height=66\"></iframe>\n\n好久没写有生之年系列了，今天生病了就来扯两句！算了明天早上写，现在看会早上借的《水仙已乘鲤鱼去》，然后就回寝室了！\n\n现在病已经好了，可是真的没有病了吗？现在的感觉并有比昨天好一些！是该吃药了！\n\n图书馆前那几十盆花没了，从图书馆地下车库出来，能够第一眼看到的就是那些花，看到的时候给人一种奇妙的感觉。可惜当时一犹豫没有拍下来。\n\n其实前天到那些花的时候已经枯了，但是没想到今天甚至都看不到了！\n\n我是在可怜那些花吗？顶着生病的名字，写着那些毫无相关的花，这才是病啊！","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=27566680&auto=1&height=66\"></iframe>\n\n<p>好久没写有生之年系列了，今天生病了就来扯两句！算了明天早上写，现在看会早上借的《水仙已乘鲤鱼去》，然后就回寝室了！</p>\n\n<p>现在病已经好了，可是真的没有病了吗？现在的感觉并有比昨天好一些！是该吃药了！</p>\n\n<p>图书馆前那几十盆花没了，从图书馆地下车库出来，能够第一眼看到的就是那些花，看到的时候给人一种奇妙的感觉。可惜当时一犹豫没有拍下来。</p>\n\n<p>其实前天到那些花的时候已经枯了，但是没想到今天甚至都看不到了！</p>\n\n<p>我是在可怜那些花吗？顶着生病的名字，写着那些毫无相关的花，这才是病啊！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474631896458,"created_by":1,"updated_at":1474702554112,"updated_by":1,"published_at":1474632300710,"published_by":1},{"id":82,"uuid":"a283c203-7f76-4ff8-9814-8a82f09a203a","title":"js 语句","slug":"js-yu-ju","markdown":"大风大浪都过来了，语句算什么！操一上来又是这么一堆！另外有必要把编译原理的语义分析也看一下，因为标准中很多涉及语义的地方其实给我造成了比较大阅读上的障碍。\n\n语法：\n\n```\nStatement : \nBlock \nVariableStatement \nEmptyStatement \nExpressionStatement \nIfStatement \nIterationStatement \nContinueStatement \nBreakStatement \nReturnStatement \nWithStatement \nLabelledStatement \nSwitchStatement \nThrowStatement \nTryStatement \nDebuggerStatement\n```\n\n语义\n\n一个 Statement 可以是 LabelledStatement 的一部分，这个 LabelledStatement 自身也可以是 LabelledStatement 的一部分，以此类推。当描述个别语句时引入标签的这种方式统称为“当前标签组”。一个 LabelledStatement 介绍了一个标签到一个标签组，此外没有其他语义。一个 IterationStatement 或 SwitchStatement 的标签组最初包含单个 空元素。任何其他语句的标签组最初是空的。\n\n> 后面一句话的意思暂时没理解。\n\n#### 块\n\n标准中这部分语法产生式、语义算法写了一大通，简单概括就是执行块中的每一条语句，如果出现异常，则直接返回，否则返回最后一个产生值的Statement的值。\n\n> 在 es6 之前是语句块是不会创建的新的作用域的，创建作用域需要通过函数，es6 引入块状作用域后，一个语句块将会存在一个新的作用域。\n\n#### 变量语句\n\n语法比较简单，又是有几个需要注意的问题：\n\n###### 声明变量和非声明变量\n\n1. 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。\n2. 声明变量在任何代码执行前创建，而非声明变量只有在执行赋值操作的时候才会被创建。\n3. 声明变量是它所在上下文环境的不可配置属性（non-configurable property），非声明变量是可配置的（例如非声明变量可以被删除）。\n\n###### 变量声明提升（var hoisting）\n\n首先非声明变量是不存在变量提升的，而声明变量的声明部分会提到声明顶部，具体的过程可以看《可执行代码和执行环境》中绑定上下文一部分。\n\n```\nconsole.log(a);\t// error\nconsole.log(b); // undefined\n\na = 1;\nvar b = 1;\n```\n\n###### 多变量初始化\n\n```\nvar x = 0;\n\nfunction f(){\n  var x = y = 1; // x在函数内部声明，y不是！\n}\nf();\n\nconsole.log(x, y); // 0, 1\n// x是全局变量。\n// y是隐式声明的全局变量。\n``` \n\n###### 隐式全局变量和外部函数作用域\n\n看起来像是隐式全局作用域的变量也有可能是其外部函数变量的引用。（我猜测还是沿着作用域往上找的）\n\n```\nvar x = 0;  // x是全局变量，并且赋值为0。\n\nconsole.log(typeof z); // undefined，因为z还不存在。\n\nfunction a() { // 当a被调用时，\n  var y = 2;   // y被声明成函数a作用域的变量，然后赋值成2。\n\n  console.log(x, y);   // 0 2 \n\n  function b() {       // 当b被调用时，\n    x = 3;  // 全局变量x被赋值为3，不生成全局变量。\n    y = 4;  // 已存在的外部函数的y变量被赋值为4，不生成新的全局变量。\n    z = 5;  // 创建新的全局变量z，并且给z赋值为5。 \n  }         // (在严格模式下（strict mode）抛出ReferenceError)\n\n  b();     // 调用b时创建了全局变量z。\n  console.log(x, y, z);  // 3 4 5\n}\n\na();                   // 调用a时同时调用了b。\nconsole.log(x, z);     // 3 5\nconsole.log(typeof y); // undefined，因为y是a函数的本地（local）变量。\n```\n\n###### 严格模式的限制\n\n如果一个 VariableDeclaration 或 VariableDeclarationNoIn 出现在 严格模式代码 里并且其 Identifier 是 \"eval\" 或 \"arguments\"，那么这是个 SyntaxError。\n\n#### 空语句\n\n语法 :\n\n```\nEmptyStatement : ;\n```\n\n#### 表达式语句\n\n语法：\n\n```\nExpressionStatement : [lookahead ∉ {{, function}]Expression ; \n```\n\n> 一个 ExpressionStatement 不能用一个开大括号开始，因为这可能会使它和 Block 混淆。此外，ExpressionStatement 不能用 function 关键字开始，因为这可能会使它和FunctionDeclaration 混淆。\n\n这也就是为什么自执行函数表达式要用!+()这些字符开头的原因了，也是为什么我们用eval解析json的时候要加上()的原因。因为函数表达式和字面量，在解析的时候会存在二义性，因此才有了这样的做法。\n\n#### if 语句\n\n略\n\n#### 迭代语句\n\nfor、while、do while 略\n\n###### for in\n\n迭代包括原型链上的可枚举属性。如果你只要考虑对象本身的属性，而不是它的原型，那么使用 getOwnPropertyNames() 或执行  hasOwnProperty() 来确定某属性是否是对象本身的属性 (也能使用propertyIsEnumerable)。另外，如果你知道外部不存在任何的干扰代码，你可以扩展内置原型与检查方法。\n\n对于数组，数组索引仅是可枚举的整数名，其他方面和别的普通对象属性没有什么区别。for...in 并不能够保证返回的是按一定顺序的索引，但是它会返回所有可枚举属性，包括非整数名称的和继承的。所以不要用 for...in 来遍历数组。\n\n#### continue 语句\n\n主要介绍带 label 的 continue 语句。注意在 continue 和 label 之间没有换行符，这是 AST 里的内容了。\n\n在下面的例子中，被标记为 checkiandj 的语句包含一个被标记为 checkj 的语句。当遇到continue 语句时，程序回到 checkj 语句的开始继续执行。每次遇到 continue 时，再次执行 checkj ，直到条件判断返回 false 。之后完成 checkiandj 语句剩下的部分。\n\n但如果 continue 的标号被改为 checkiandj ，那程序将会从 checkiandj 语句的开始继续运行。\n\n```\nvar i = 0, \n    j = 8;\n\ncheckiandj: while (i < 4) {\n   console.log(\"i: \" + i);\n   i += 1;\n\n   checkj: while (j > 4) {\n      console.log(\"j: \"+ j);\n      j -= 1;\n      if ((j % 2) == 0)\n         continue checkj;\n      console.log(j + \" is odd.\");\n   }\n   console.log(\"i = \" + i);\n   console.log(\"j = \" + j);\n}\n```\n\n#### break 语句\n\n和 continue 类似，略。\n\n#### return 语句\n\n在一个 ECMAScript 程序中包含的 return 语句没有在 FunctionBody 里面，那么就是语法错误的。一个 return 语句导致函数停止执行，并返回一个值给调用者。如果省略Expression，返回值是 undefined。否则，返回值是 Expression 的值。\n\nreturn 和返回的内容之间没哟换行符。\n\n#### with 语句\n\n语法：\n\nwith 之前也讲了很多了，这里就看一下它的执行过程：\n\n1. 令 val 为解释执行 Expression 的结果。\n2. 令 obj 为 ToObject(GetValue(val))。\n3. 令 oldEnv 为运行中的执行环境的 LexicalEnvironment。\n4. 令 newEnv 为以 obj 和 oldEnv 为参数调用 NewObjectEnvironment 的结果。\n5. 设定 newEnv 的 provideThis 标志为 true。\n6. 设定运行中的执行环境的 LexicalEnvironment 为 newEnv。\n7. 令 C 为解释执行 Statement 的结果，但如果解释执行是由异常抛出，则令 C 为 (throw, V, empty)，这里的 V 是异常。( 现在继续执行，仿佛没有抛出异常。)\n8. 设定运行中的执行环境的 LexicalEnvironment 为 oldEnv.\n9. 返回 C。\n\n> 无论控制是从嵌入的 Statement 怎样离开的，不论是正常离开还是以 非常规完结 或异常，LexicalEnvironment 总是恢复到它之前的状态。\n\n###### 严格模式的限制\n\n严格模式代码中不能包含 WithStatement。出现 WithStatement 的上下文被当作一个 SyntaxError。\n\n#### switch 语句\n\n略\n\n#### label 语句\n\n见 break、continue，因为破坏了程序的可读性，不建议使用。\n\n#### throw 语句\n\n语法：\n\n```\nThrowStatement : throw [no LineTerminator here] Expression ; \n```\n\n语义：\n\n产生式 `ThrowStatement : throw [no LineTerminator here] Expression` 按照下面的过程执行：\n\n1. 令 exprRef 为解释执行 Expression 的结果。\n2. 返回 (throw, GetValue(exprRef), empty)。\n\n#### try 语句\n\n这部分重点是 catch 作用域的创建过程：\n\n 产生式 Catch : catch ( Identifier ) Block 按照下面的过程执行 ：\n\n1. 令 C 为传给这个产生式的参数。\n2. 令 oldEnv 为运行中执行环境的 LexicalEnvironment。\n3. 令 catchEnv 为以 oldEnv 为参数调用 NewDeclarativeEnvironment 的结果。\n4. 以 Identifier 字符串值为参数调用 catchEnv 的 CreateMutableBinding 具体方法。\n5. 以 Identifier, C, false 为参数调用 catchEnv 的 SetMutableBinding 具体方法。注：这种情况下最后一个参数无关紧要。\n6. 设定运行中执行环境的 LexicalEnvironment 为 catchEnv。\n7. 令 B 为解释执行 Block 的结果。\n8. 设定运行中执行环境的 LexicalEnvironment 为 oldEnv。\n9. 返回 B。\n\n#### debugger 语句\n\n解释执行 DebuggerStatement 产生式可允许让一个实现在调试器下运行时设置断点。如果调试器不存在或是非激活状态，这个语句没有可观测效果。\n\n#### 小结\n\n这一片写得有点敷衍了，打算先停一下，把前面写得那些总结归纳一下！因为实质上语言部分已经结束了，剩下的就是过一遍原生对象了。","html":"<p>大风大浪都过来了，语句算什么！操一上来又是这么一堆！另外有必要把编译原理的语义分析也看一下，因为标准中很多涉及语义的地方其实给我造成了比较大阅读上的障碍。</p>\n\n<p>语法：</p>\n\n<pre><code>Statement :  \nBlock  \nVariableStatement  \nEmptyStatement  \nExpressionStatement  \nIfStatement  \nIterationStatement  \nContinueStatement  \nBreakStatement  \nReturnStatement  \nWithStatement  \nLabelledStatement  \nSwitchStatement  \nThrowStatement  \nTryStatement  \nDebuggerStatement  \n</code></pre>\n\n<p>语义</p>\n\n<p>一个 Statement 可以是 LabelledStatement 的一部分，这个 LabelledStatement 自身也可以是 LabelledStatement 的一部分，以此类推。当描述个别语句时引入标签的这种方式统称为“当前标签组”。一个 LabelledStatement 介绍了一个标签到一个标签组，此外没有其他语义。一个 IterationStatement 或 SwitchStatement 的标签组最初包含单个 空元素。任何其他语句的标签组最初是空的。</p>\n\n<blockquote>\n  <p>后面一句话的意思暂时没理解。</p>\n</blockquote>\n\n<h4 id=\"\">块</h4>\n\n<p>标准中这部分语法产生式、语义算法写了一大通，简单概括就是执行块中的每一条语句，如果出现异常，则直接返回，否则返回最后一个产生值的Statement的值。</p>\n\n<blockquote>\n  <p>在 es6 之前是语句块是不会创建的新的作用域的，创建作用域需要通过函数，es6 引入块状作用域后，一个语句块将会存在一个新的作用域。</p>\n</blockquote>\n\n<h4 id=\"\">变量语句</h4>\n\n<p>语法比较简单，又是有几个需要注意的问题：</p>\n\n<h6 id=\"\">声明变量和非声明变量</h6>\n\n<ol>\n<li>声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。  </li>\n<li>声明变量在任何代码执行前创建，而非声明变量只有在执行赋值操作的时候才会被创建。  </li>\n<li>声明变量是它所在上下文环境的不可配置属性（non-configurable property），非声明变量是可配置的（例如非声明变量可以被删除）。</li>\n</ol>\n\n<h6 id=\"varhoisting\">变量声明提升（var hoisting）</h6>\n\n<p>首先非声明变量是不存在变量提升的，而声明变量的声明部分会提到声明顶部，具体的过程可以看《可执行代码和执行环境》中绑定上下文一部分。</p>\n\n<pre><code>console.log(a);    // error  \nconsole.log(b); // undefined\n\na = 1;  \nvar b = 1;  \n</code></pre>\n\n<h6 id=\"\">多变量初始化</h6>\n\n<pre><code>var x = 0;\n\nfunction f(){  \n  var x = y = 1; // x在函数内部声明，y不是！\n}\nf();\n\nconsole.log(x, y); // 0, 1  \n// x是全局变量。\n// y是隐式声明的全局变量。\n</code></pre>\n\n<h6 id=\"\">隐式全局变量和外部函数作用域</h6>\n\n<p>看起来像是隐式全局作用域的变量也有可能是其外部函数变量的引用。（我猜测还是沿着作用域往上找的）</p>\n\n<pre><code>var x = 0;  // x是全局变量，并且赋值为0。\n\nconsole.log(typeof z); // undefined，因为z还不存在。\n\nfunction a() { // 当a被调用时，  \n  var y = 2;   // y被声明成函数a作用域的变量，然后赋值成2。\n\n  console.log(x, y);   // 0 2 \n\n  function b() {       // 当b被调用时，\n    x = 3;  // 全局变量x被赋值为3，不生成全局变量。\n    y = 4;  // 已存在的外部函数的y变量被赋值为4，不生成新的全局变量。\n    z = 5;  // 创建新的全局变量z，并且给z赋值为5。 \n  }         // (在严格模式下（strict mode）抛出ReferenceError)\n\n  b();     // 调用b时创建了全局变量z。\n  console.log(x, y, z);  // 3 4 5\n}\n\na();                   // 调用a时同时调用了b。  \nconsole.log(x, z);     // 3 5  \nconsole.log(typeof y); // undefined，因为y是a函数的本地（local）变量。  \n</code></pre>\n\n<h6 id=\"\">严格模式的限制</h6>\n\n<p>如果一个 VariableDeclaration 或 VariableDeclarationNoIn 出现在 严格模式代码 里并且其 Identifier 是 \"eval\" 或 \"arguments\"，那么这是个 SyntaxError。</p>\n\n<h4 id=\"\">空语句</h4>\n\n<p>语法 :</p>\n\n<pre><code>EmptyStatement : ;  \n</code></pre>\n\n<h4 id=\"\">表达式语句</h4>\n\n<p>语法：</p>\n\n<pre><code>ExpressionStatement : [lookahead ∉ {{, function}]Expression ;  \n</code></pre>\n\n<blockquote>\n  <p>一个 ExpressionStatement 不能用一个开大括号开始，因为这可能会使它和 Block 混淆。此外，ExpressionStatement 不能用 function 关键字开始，因为这可能会使它和FunctionDeclaration 混淆。</p>\n</blockquote>\n\n<p>这也就是为什么自执行函数表达式要用!+()这些字符开头的原因了，也是为什么我们用eval解析json的时候要加上()的原因。因为函数表达式和字面量，在解析的时候会存在二义性，因此才有了这样的做法。</p>\n\n<h4 id=\"if\">if 语句</h4>\n\n<p>略</p>\n\n<h4 id=\"\">迭代语句</h4>\n\n<p>for、while、do while 略</p>\n\n<h6 id=\"forin\">for in</h6>\n\n<p>迭代包括原型链上的可枚举属性。如果你只要考虑对象本身的属性，而不是它的原型，那么使用 getOwnPropertyNames() 或执行  hasOwnProperty() 来确定某属性是否是对象本身的属性 (也能使用propertyIsEnumerable)。另外，如果你知道外部不存在任何的干扰代码，你可以扩展内置原型与检查方法。</p>\n\n<p>对于数组，数组索引仅是可枚举的整数名，其他方面和别的普通对象属性没有什么区别。for...in 并不能够保证返回的是按一定顺序的索引，但是它会返回所有可枚举属性，包括非整数名称的和继承的。所以不要用 for...in 来遍历数组。</p>\n\n<h4 id=\"continue\">continue 语句</h4>\n\n<p>主要介绍带 label 的 continue 语句。注意在 continue 和 label 之间没有换行符，这是 AST 里的内容了。</p>\n\n<p>在下面的例子中，被标记为 checkiandj 的语句包含一个被标记为 checkj 的语句。当遇到continue 语句时，程序回到 checkj 语句的开始继续执行。每次遇到 continue 时，再次执行 checkj ，直到条件判断返回 false 。之后完成 checkiandj 语句剩下的部分。</p>\n\n<p>但如果 continue 的标号被改为 checkiandj ，那程序将会从 checkiandj 语句的开始继续运行。</p>\n\n<pre><code>var i = 0,  \n    j = 8;\n\ncheckiandj: while (i &lt; 4) {  \n   console.log(\"i: \" + i);\n   i += 1;\n\n   checkj: while (j &gt; 4) {\n      console.log(\"j: \"+ j);\n      j -= 1;\n      if ((j % 2) == 0)\n         continue checkj;\n      console.log(j + \" is odd.\");\n   }\n   console.log(\"i = \" + i);\n   console.log(\"j = \" + j);\n}\n</code></pre>\n\n<h4 id=\"break\">break 语句</h4>\n\n<p>和 continue 类似，略。</p>\n\n<h4 id=\"return\">return 语句</h4>\n\n<p>在一个 ECMAScript 程序中包含的 return 语句没有在 FunctionBody 里面，那么就是语法错误的。一个 return 语句导致函数停止执行，并返回一个值给调用者。如果省略Expression，返回值是 undefined。否则，返回值是 Expression 的值。</p>\n\n<p>return 和返回的内容之间没哟换行符。</p>\n\n<h4 id=\"with\">with 语句</h4>\n\n<p>语法：</p>\n\n<p>with 之前也讲了很多了，这里就看一下它的执行过程：</p>\n\n<ol>\n<li>令 val 为解释执行 Expression 的结果。  </li>\n<li>令 obj 为 ToObject(GetValue(val))。  </li>\n<li>令 oldEnv 为运行中的执行环境的 LexicalEnvironment。  </li>\n<li>令 newEnv 为以 obj 和 oldEnv 为参数调用 NewObjectEnvironment 的结果。  </li>\n<li>设定 newEnv 的 provideThis 标志为 true。  </li>\n<li>设定运行中的执行环境的 LexicalEnvironment 为 newEnv。  </li>\n<li>令 C 为解释执行 Statement 的结果，但如果解释执行是由异常抛出，则令 C 为 (throw, V, empty)，这里的 V 是异常。( 现在继续执行，仿佛没有抛出异常。)  </li>\n<li>设定运行中的执行环境的 LexicalEnvironment 为 oldEnv.  </li>\n<li>返回 C。</li>\n</ol>\n\n<blockquote>\n  <p>无论控制是从嵌入的 Statement 怎样离开的，不论是正常离开还是以 非常规完结 或异常，LexicalEnvironment 总是恢复到它之前的状态。</p>\n</blockquote>\n\n<h6 id=\"\">严格模式的限制</h6>\n\n<p>严格模式代码中不能包含 WithStatement。出现 WithStatement 的上下文被当作一个 SyntaxError。</p>\n\n<h4 id=\"switch\">switch 语句</h4>\n\n<p>略</p>\n\n<h4 id=\"label\">label 语句</h4>\n\n<p>见 break、continue，因为破坏了程序的可读性，不建议使用。</p>\n\n<h4 id=\"throw\">throw 语句</h4>\n\n<p>语法：</p>\n\n<pre><code>ThrowStatement : throw [no LineTerminator here] Expression ;  \n</code></pre>\n\n<p>语义：</p>\n\n<p>产生式 <code>ThrowStatement : throw [no LineTerminator here] Expression</code> 按照下面的过程执行：</p>\n\n<ol>\n<li>令 exprRef 为解释执行 Expression 的结果。  </li>\n<li>返回 (throw, GetValue(exprRef), empty)。</li>\n</ol>\n\n<h4 id=\"try\">try 语句</h4>\n\n<p>这部分重点是 catch 作用域的创建过程：</p>\n\n<p>产生式 Catch : catch ( Identifier ) Block 按照下面的过程执行 ：</p>\n\n<ol>\n<li>令 C 为传给这个产生式的参数。  </li>\n<li>令 oldEnv 为运行中执行环境的 LexicalEnvironment。  </li>\n<li>令 catchEnv 为以 oldEnv 为参数调用 NewDeclarativeEnvironment 的结果。  </li>\n<li>以 Identifier 字符串值为参数调用 catchEnv 的 CreateMutableBinding 具体方法。  </li>\n<li>以 Identifier, C, false 为参数调用 catchEnv 的 SetMutableBinding 具体方法。注：这种情况下最后一个参数无关紧要。  </li>\n<li>设定运行中执行环境的 LexicalEnvironment 为 catchEnv。  </li>\n<li>令 B 为解释执行 Block 的结果。  </li>\n<li>设定运行中执行环境的 LexicalEnvironment 为 oldEnv。  </li>\n<li>返回 B。</li>\n</ol>\n\n<h4 id=\"debugger\">debugger 语句</h4>\n\n<p>解释执行 DebuggerStatement 产生式可允许让一个实现在调试器下运行时设置断点。如果调试器不存在或是非激活状态，这个语句没有可观测效果。</p>\n\n<h4 id=\"\">小结</h4>\n\n<p>这一片写得有点敷衍了，打算先停一下，把前面写得那些总结归纳一下！因为实质上语言部分已经结束了，剩下的就是过一遍原生对象了。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474692514559,"created_by":1,"updated_at":1475051118990,"updated_by":1,"published_at":1474696623567,"published_by":1},{"id":83,"uuid":"08600565-3da6-4015-8bd9-122189ad11fd","title":"水仙已乘鲤鱼去","slug":"shui-xian-yi-cheng-li-yu-qu","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=30903454&auto=1&height=66\"></iframe>\n\n昨天早上一口气把这本书看完了，前半段挺吸引我的，但是后半段总感觉处理的一般，但是对我来说还是耐看的那种。\n\n先说说作者吧，张悦然，算80后的代表性作家了吧。记得以前看过她的《黑猫不睡》、《誓鸟》、《鲤系列》吧，挺合我的口味的，前几天看的伊恩麦克尤恩的《最初的爱情，最后的仪式》也是在《鲤系列》中了解到的，才记住借来看的。怎么说呢，纯好感吧，觉得是一类人！包括这本《水仙已乘鲤鱼去》，也是给我亲近感的。\n\n再来说说题目“水仙已乘鲤鱼去”，由胡兰成改自李商隐的诗《板桥晓别》中的“水仙欲上鲤鱼去，一夜芙蓉红泪多”。大致表达了离别不惜之情！胡兰成查了下原来就是张爱玲的丈夫，不过后来抛弃了张爱玲，还当了汉奸。不做评价，毕竟了解不多。\n\n其实感觉这一本和《为了N》有着某些共有的东西，也与我有着一些共有的东西。也就是我们都经历过那么一些看起来不那么好的事，我们都有过一些那么不堪的时刻，只是只有我们自己知道！当有人把这些东西写下来的时候，正因为这种共有，我们之间有了联系甚至是默契。\n\n也正是这种默契感，我喜欢书中的杉下、璟，并着了迷一样地读完了！真是奇妙的事啊！\n\n最后来点温暖的话吧，毕竟小说有些残酷了，而现实还有很多美好事物值得我们去追求去幻想：\n\n> 我似极力地在遥望北方，可是我始终找不到北。 \n\n> 我一直在南方。在暖和的地方。可我却寒冷得很。 \n\n> 水仙已乘鲤鱼去。我亦开始遥望自己的幸福和温暖。幻想我的王子带我离开。\n\n对了封面就是书上拍下来的张悦然的照片，那个眼神，和我想象中的璟一模一样！","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=30903454&auto=1&height=66\"></iframe>\n\n<p>昨天早上一口气把这本书看完了，前半段挺吸引我的，但是后半段总感觉处理的一般，但是对我来说还是耐看的那种。</p>\n\n<p>先说说作者吧，张悦然，算80后的代表性作家了吧。记得以前看过她的《黑猫不睡》、《誓鸟》、《鲤系列》吧，挺合我的口味的，前几天看的伊恩麦克尤恩的《最初的爱情，最后的仪式》也是在《鲤系列》中了解到的，才记住借来看的。怎么说呢，纯好感吧，觉得是一类人！包括这本《水仙已乘鲤鱼去》，也是给我亲近感的。</p>\n\n<p>再来说说题目“水仙已乘鲤鱼去”，由胡兰成改自李商隐的诗《板桥晓别》中的“水仙欲上鲤鱼去，一夜芙蓉红泪多”。大致表达了离别不惜之情！胡兰成查了下原来就是张爱玲的丈夫，不过后来抛弃了张爱玲，还当了汉奸。不做评价，毕竟了解不多。</p>\n\n<p>其实感觉这一本和《为了N》有着某些共有的东西，也与我有着一些共有的东西。也就是我们都经历过那么一些看起来不那么好的事，我们都有过一些那么不堪的时刻，只是只有我们自己知道！当有人把这些东西写下来的时候，正因为这种共有，我们之间有了联系甚至是默契。</p>\n\n<p>也正是这种默契感，我喜欢书中的杉下、璟，并着了迷一样地读完了！真是奇妙的事啊！</p>\n\n<p>最后来点温暖的话吧，毕竟小说有些残酷了，而现实还有很多美好事物值得我们去追求去幻想：</p>\n\n<blockquote>\n  <p>我似极力地在遥望北方，可是我始终找不到北。 </p>\n  \n  <p>我一直在南方。在暖和的地方。可我却寒冷得很。 </p>\n  \n  <p>水仙已乘鲤鱼去。我亦开始遥望自己的幸福和温暖。幻想我的王子带我离开。</p>\n</blockquote>\n\n<p>对了封面就是书上拍下来的张悦然的照片，那个眼神，和我想象中的璟一模一样！</p>","image":"/content/images/2016/09/IMG_20160924_120213.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474702596441,"created_by":1,"updated_at":1474764188193,"updated_by":1,"published_at":1474764040186,"published_by":1},{"id":84,"uuid":"806b9b7c-aec6-4486-a8f5-aa5706c46e90","title":"js 编译过程","slug":"js-complie","markdown":"es文档只剩下内置对象了，语言核心部分差不多看完了，接下来几篇会是对于之前的内容的整理，并回答一些困扰大家的问题！\n\n总所周知 js 是一种解释性脚本语言，早期是把源代码转变成抽象语法树，在抽象语法树上解释执行。随着技术的发展，为了提高效率，JavascriptCore 引擎的做法是将抽象语法树转成平台无关字节码。而 V8 的做法更加激进，利用 JIT 直接从抽象语法树生成本地代码。\n\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f85lestfnxj30er096t9p.jpg)\n\n说了这么多没什么卵用，科普一下而已！js 的代码的执行我猜测分编译（就是生成抽象语法树，或者字节码或者本地代码）、预解析（执行环境的创建，我不喜欢把它叫预编译，因为我觉得这一步其实是在编译之后的，因为没有词法分析、语法分析执行进行预编译是不现实的）、执行（执行代码）三个阶段，当然这里的编译和传统的不太一样，但是如果是 V8 这种的话，我觉得和传统的编译差不多。\n","html":"<p>es文档只剩下内置对象了，语言核心部分差不多看完了，接下来几篇会是对于之前的内容的整理，并回答一些困扰大家的问题！</p>\n\n<p>总所周知 js 是一种解释性脚本语言，早期是把源代码转变成抽象语法树，在抽象语法树上解释执行。随着技术的发展，为了提高效率，JavascriptCore 引擎的做法是将抽象语法树转成平台无关字节码。而 V8 的做法更加激进，利用 JIT 直接从抽象语法树生成本地代码。</p>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f85lestfnxj30er096t9p.jpg\" alt=\"\" /></p>\n\n<p>说了这么多没什么卵用，科普一下而已！js 的代码的执行我猜测分编译（就是生成抽象语法树，或者字节码或者本地代码）、预解析（执行环境的创建，我不喜欢把它叫预编译，因为我觉得这一步其实是在编译之后的，因为没有词法分析、语法分析执行进行预编译是不现实的）、执行（执行代码）三个阶段，当然这里的编译和传统的不太一样，但是如果是 V8 这种的话，我觉得和传统的编译差不多。</p>","image":null,"featured":0,"page":0,"status":"draft","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474764309119,"created_by":1,"updated_at":1474770554828,"updated_by":1,"published_at":null,"published_by":null},{"id":85,"uuid":"9a820a86-5b19-4dda-a57b-751554d3e3a1","title":"从js函数执行过程看this","slug":"js-thisxiao-jie","markdown":"> 本文是在读完 es5.1 规范前14章后对于this的总结，不过更像是对整个函数调用过程的整理，懒得改了，看之前最好对于规范引用类型、词法环境等名词有一定的了解。\n\n在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。下面是完整过程：\n\n#### 函数调用\n\n产生式` CallExpression : MemberExpression Arguments `如下执行：\n\n1. 令 ref 为解释执行 MemberExpression 的结果。\n2. 令 func 为 GetValue(ref)。（得到函数的引用）\n3. 令 argList 为解释执行 Arguments 的结果，产生参数值们的内部列表。\n4. 如果 Type(func) is not Object，抛出一个 TypeError 异常。\n5. 如果 IsCallable(func) is false，抛出一个 TypeError 异常。\n6. 如果 Type(ref) 为 Reference，那么如果IsPropertyReference(ref) 为 true，那么令 thisValue 为 GetBase(ref)。否则，ref 的基值是一个环境记录项令 thisValue 为调用 GetBase(ref) 的 ImplicitThisValue 具体方法的结果\n7. 否则，假如 Type(ref) 不是 Reference。令 thisValue 为 undefined。\n8. 返回调用 func 的 [[Call]] 内置方法的结果，传入 thisValue 作为 this 值和列表 argList 作为参数列表。\n\n这是函数调用产生式真正的执行过程，它确定了 this 和 argments，然后传入函数的 [[Call]] 进行调用，[[Call]] 类似于我们平时使用的 ` Function.prototype.call `，我猜测就是` Function.prototype.call `的内部实现。\n\n然后我们来看看 this 在上面的过程是如何确定的，分两类情况：ref是规范内部引用对象或者不是内部引用对象。\n\n> 规范内部引用对象，由三部分组成，基（base）值，引用名称（referenced name）和布尔值严格引用 (strict reference) 标志。通过 getValue 方法可以得到基值上的对应引用名称的真实值。\n\n如果是引用对象，并且 base 是一个对象，那么 this 就是这个 base，如果 base 是一个环境记录项，那么 this 就是环境记录的ImplicitThisValue 方法的返回值。\n\n> ImplicitThisValue 方法在 with 以外的时候都是 undefined。\n\n如果不是引用对象，那么 this 就是 undefined。\n\n其实到这里 this 已经确定了，但是我还想看看后面发生了什么？\n\n#### [[call]]\n\n当用一个 this 值，一个参数列表调用函数对象 F 的 [[Call]] 内部方法，采用以下步骤：\n\n1. 用 F 的 [[FormalParameters]] 内部属性值，参数列表 args， this 值来建立函数代码的一个新执行环境，令 funcCtx 为其结果。\n2. 令 result 为 FunctionBody（也就是 F 的 [[Code]] 内部属性）解释执行的结果。如果 F 没有 [[Code]] 内部属性或其值是空的 FunctionBody，则 result 是 (normal, undefined, empty)。\n3. 退出 funcCtx 执行环境，恢复到之前的执行环境。\n4. 如果 result.type 是 throw 则抛出 result.value。\n5. 如果 result.type 是 return 则返回 result.value。\n6. 否则 result.type 必定是 normal。返回 undefined。\n\n#### 函数执行环境的建立\n\n从 [[call]] 的执行过程可以看到，在真正执行函数代码前，要建立执行环境，也就是网上很多博客所说的预编译，个人认为用预编译来称呼不是很合适，这应该是和执行阶段串联起来的一个过程。\n\n当控制流根据一个函数对象 F、调用者提供的 thisArg 以及调用者提供的 argumentList，进入函数代码的执行环境时，执行以下步骤：\n\n1. 如果函数代码是严格模式下的代码，设 this 绑定为 thisArg。\n2. 否则如果 thisArg 是 null 或 undefined，则设 this 绑定为 全局对象 。\n3. 否则如果 Type(thisArg) 的结果不为 Object，则设 this 绑定为 ToObject(thisArg)。\n4. 否则设 this 绑定为 thisArg。\n5. 以 F 的 [[Scope]] 内部属性为参数调用 NewDeclarativeEnvironment，并令 localEnv 为调用的结果。\n6. 设词法环境为 localEnv。\n7. 设变量环境为 localEnv。\n8. 令 code 为 F 的 [[Code]] 内部属性的值。\n9. 使用函数代码 code 和 argumentList 执行定义绑定初始化。\n\n看了上面的过程，知道为什么 this 会从 undefined 变成全局变量了吧！也知道为什么严格模式下，是如何做到不变的全局变量的了吧！\n\n#### 初始化绑定\n\n这个过程很多，简单的描述就是如下顺序：\n\n1. 参数绑定及初始化；\n2. 函数声明绑定及初始化；\n3. 变量声明绑定。\n\n具体过程很复杂，可以通过[传送门](http://yanhaijing.com/es5/#151)看。\n\n#### 小结\n\n1. 函数调用(确定this和arguments) → 调用内部函数 [[call]] → [[call]]在执行代码前创建函数执行上下文。\n\n2. this在函数调用阶段确定，确定规则见上文。","html":"<blockquote>\n  <p>本文是在读完 es5.1 规范前14章后对于this的总结，不过更像是对整个函数调用过程的整理，懒得改了，看之前最好对于规范引用类型、词法环境等名词有一定的了解。</p>\n</blockquote>\n\n<p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。下面是完整过程：</p>\n\n<h4 id=\"\">函数调用</h4>\n\n<p>产生式<code>CallExpression : MemberExpression Arguments</code>如下执行：</p>\n\n<ol>\n<li>令 ref 为解释执行 MemberExpression 的结果。  </li>\n<li>令 func 为 GetValue(ref)。（得到函数的引用）  </li>\n<li>令 argList 为解释执行 Arguments 的结果，产生参数值们的内部列表。  </li>\n<li>如果 Type(func) is not Object，抛出一个 TypeError 异常。  </li>\n<li>如果 IsCallable(func) is false，抛出一个 TypeError 异常。  </li>\n<li>如果 Type(ref) 为 Reference，那么如果IsPropertyReference(ref) 为 true，那么令 thisValue 为 GetBase(ref)。否则，ref 的基值是一个环境记录项令 thisValue 为调用 GetBase(ref) 的 ImplicitThisValue 具体方法的结果  </li>\n<li>否则，假如 Type(ref) 不是 Reference。令 thisValue 为 undefined。  </li>\n<li>返回调用 func 的 [[Call]] 内置方法的结果，传入 thisValue 作为 this 值和列表 argList 作为参数列表。</li>\n</ol>\n\n<p>这是函数调用产生式真正的执行过程，它确定了 this 和 argments，然后传入函数的 [[Call]] 进行调用，[[Call]] 类似于我们平时使用的 <code>Function.prototype.call</code>，我猜测就是<code>Function.prototype.call</code>的内部实现。</p>\n\n<p>然后我们来看看 this 在上面的过程是如何确定的，分两类情况：ref是规范内部引用对象或者不是内部引用对象。</p>\n\n<blockquote>\n  <p>规范内部引用对象，由三部分组成，基（base）值，引用名称（referenced name）和布尔值严格引用 (strict reference) 标志。通过 getValue 方法可以得到基值上的对应引用名称的真实值。</p>\n</blockquote>\n\n<p>如果是引用对象，并且 base 是一个对象，那么 this 就是这个 base，如果 base 是一个环境记录项，那么 this 就是环境记录的ImplicitThisValue 方法的返回值。</p>\n\n<blockquote>\n  <p>ImplicitThisValue 方法在 with 以外的时候都是 undefined。</p>\n</blockquote>\n\n<p>如果不是引用对象，那么 this 就是 undefined。</p>\n\n<p>其实到这里 this 已经确定了，但是我还想看看后面发生了什么？</p>\n\n<h4 id=\"call\">[[call]]</h4>\n\n<p>当用一个 this 值，一个参数列表调用函数对象 F 的 [[Call]] 内部方法，采用以下步骤：</p>\n\n<ol>\n<li>用 F 的 [[FormalParameters]] 内部属性值，参数列表 args， this 值来建立函数代码的一个新执行环境，令 funcCtx 为其结果。  </li>\n<li>令 result 为 FunctionBody（也就是 F 的 [[Code]] 内部属性）解释执行的结果。如果 F 没有 [[Code]] 内部属性或其值是空的 FunctionBody，则 result 是 (normal, undefined, empty)。  </li>\n<li>退出 funcCtx 执行环境，恢复到之前的执行环境。  </li>\n<li>如果 result.type 是 throw 则抛出 result.value。  </li>\n<li>如果 result.type 是 return 则返回 result.value。  </li>\n<li>否则 result.type 必定是 normal。返回 undefined。</li>\n</ol>\n\n<h4 id=\"\">函数执行环境的建立</h4>\n\n<p>从 [[call]] 的执行过程可以看到，在真正执行函数代码前，要建立执行环境，也就是网上很多博客所说的预编译，个人认为用预编译来称呼不是很合适，这应该是和执行阶段串联起来的一个过程。</p>\n\n<p>当控制流根据一个函数对象 F、调用者提供的 thisArg 以及调用者提供的 argumentList，进入函数代码的执行环境时，执行以下步骤：</p>\n\n<ol>\n<li>如果函数代码是严格模式下的代码，设 this 绑定为 thisArg。  </li>\n<li>否则如果 thisArg 是 null 或 undefined，则设 this 绑定为 全局对象 。  </li>\n<li>否则如果 Type(thisArg) 的结果不为 Object，则设 this 绑定为 ToObject(thisArg)。  </li>\n<li>否则设 this 绑定为 thisArg。  </li>\n<li>以 F 的 [[Scope]] 内部属性为参数调用 NewDeclarativeEnvironment，并令 localEnv 为调用的结果。  </li>\n<li>设词法环境为 localEnv。  </li>\n<li>设变量环境为 localEnv。  </li>\n<li>令 code 为 F 的 [[Code]] 内部属性的值。  </li>\n<li>使用函数代码 code 和 argumentList 执行定义绑定初始化。</li>\n</ol>\n\n<p>看了上面的过程，知道为什么 this 会从 undefined 变成全局变量了吧！也知道为什么严格模式下，是如何做到不变的全局变量的了吧！</p>\n\n<h4 id=\"\">初始化绑定</h4>\n\n<p>这个过程很多，简单的描述就是如下顺序：</p>\n\n<ol>\n<li>参数绑定及初始化；  </li>\n<li>函数声明绑定及初始化；  </li>\n<li>变量声明绑定。</li>\n</ol>\n\n<p>具体过程很复杂，可以通过<a href=\"http://yanhaijing.com/es5/#151\">传送门</a>看。</p>\n\n<h4 id=\"\">小结</h4>\n\n<ol>\n<li><p>函数调用(确定this和arguments) → 调用内部函数 [[call]] → [[call]]在执行代码前创建函数执行上下文。</p></li>\n<li><p>this在函数调用阶段确定，确定规则见上文。</p></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474770566648,"created_by":1,"updated_at":1474773491951,"updated_by":1,"published_at":1474772963286,"published_by":1},{"id":86,"uuid":"471ad43a-23c1-45fa-a2fe-fba8f01a68b7","title":"js 左值与引用规范类型","slug":"js-zuo-zhi-yu-yin-yong-gui-fan-lei-xing","markdown":"引用规范类型是规范内部的规范类型，不是网上那些文章中所写到的引用类型。因为在规范中这是一个很重要的东西，所以需要单独拿出来总结一下！\n\n先看规范哪些地方出现了 Reference：\n\n1. 只有作为宿主的可调用对象才可能返回引用值。\n2. 标识符解析的结果总是一个 Reference 类型的值。\n3. 分组表达式：返回执行 Expression 的结果，它可能是 Reference 类型。\n4. 属性访问的 MemberExpression 和 CallExpression 必须返回一个 Reference 类型。\n5. 函数调用中 this 来自引用类型的 base，当然也有不存在引用类型的情况，下面会提到。\n6. delete 运算符只处理 Reference 类型，不是 Reference 类型直接返回 true。\n7. typeof 好像不止支持 Reference 类型，不过有关系，先记在这里。\n8. 自增、自减、赋值、组合赋值，如果操作对象是 Reference 类型，并且是严格模式下，标识符为 eval 或 arguments 则抛出 ReferenceError。\n\n搜了下整个标准文档，基本就是这些了。在进行分类，什么东西是 Reference 类型，而什么地方需要 Reference 类型。\n\n标准说道：引用类型用来说明 delete，typeof，赋值运算符这些运算符的行为。另外根据第一条，只有宿主的可调用对象才可能返回引用值，也就是普通函数和用户自定义函数都不可能返回一个引用类型的值。\n\n那什么东西能够返回引用类型的值呢？根据上面的八条，可以看到只有标识符。变量、属性访问（这个应该不能算，但是也类似的）、函数名这些其实都是标识符的范畴。\n\n而所谓左值，在ES规范中是用内部类型引用(Reference)描述的。本质上来讲左值就是引用值，左值表达式就是能够产生引用类型的表达式。\n\n而用到 Reference 类型地方，现在看来已经不只是上面那些了，其实只要存在标识符的解析，就存在引用类型。\n\n标识符的解析过程这里不讲了，在前面的文章讲过了，大致就是在词法环境中找，找不到再向外部词法环境找，直到作用域顶部的null，找到则返回一个引用对象。\n\n最后我打算分析两个问题（在上面的总结过后能够更好地理解了）：\n\n```\nvar foo = {\n  bar: function () {\n    alert(this);\n  }\n};\n \nfoo.bar(); // Reference, OK => foo\n(foo.bar)(); // Reference, OK => foo\n \n(foo.bar = foo.bar)(); // global?\n(false || foo.bar)(); // global?\n(foo.bar, foo.bar)(); // global?\n```\n\n对于1和2，第一个是标识符，解析结果为引用类型，第二个是分组表达式，解析结果也是引用类型，所以this最后指向的都是foo。而对于3、4、5来说，这些运算符都对这些标识符进行了getValue操作，得到的是函数对象，而不是引用值，所以this是global。\n\n第二个例子：\n\n```\nvar a = {n: 1};\nvar b = a;\na.x = a = {n: 2};\nalert(a.x); // --> undefined\nalert(b.x); // --> {n: 2}\n```\n\n虽然标准没有讲到连等的解析规则，但是根据右结合律和引用类型来理解这题是比较正确的。在解析赋值时第一步如下：Let lref be the result of evaluating LeftHandSideExpression.也就是会解析左边的表达式，因此a.x和a都会解析得到一个引用类型，所以赋值操作实际针对的是引用类型来讲的。\n\n\n\n","html":"<p>引用规范类型是规范内部的规范类型，不是网上那些文章中所写到的引用类型。因为在规范中这是一个很重要的东西，所以需要单独拿出来总结一下！</p>\n\n<p>先看规范哪些地方出现了 Reference：</p>\n\n<ol>\n<li>只有作为宿主的可调用对象才可能返回引用值。  </li>\n<li>标识符解析的结果总是一个 Reference 类型的值。  </li>\n<li>分组表达式：返回执行 Expression 的结果，它可能是 Reference 类型。  </li>\n<li>属性访问的 MemberExpression 和 CallExpression 必须返回一个 Reference 类型。  </li>\n<li>函数调用中 this 来自引用类型的 base，当然也有不存在引用类型的情况，下面会提到。  </li>\n<li>delete 运算符只处理 Reference 类型，不是 Reference 类型直接返回 true。  </li>\n<li>typeof 好像不止支持 Reference 类型，不过有关系，先记在这里。  </li>\n<li>自增、自减、赋值、组合赋值，如果操作对象是 Reference 类型，并且是严格模式下，标识符为 eval 或 arguments 则抛出 ReferenceError。</li>\n</ol>\n\n<p>搜了下整个标准文档，基本就是这些了。在进行分类，什么东西是 Reference 类型，而什么地方需要 Reference 类型。</p>\n\n<p>标准说道：引用类型用来说明 delete，typeof，赋值运算符这些运算符的行为。另外根据第一条，只有宿主的可调用对象才可能返回引用值，也就是普通函数和用户自定义函数都不可能返回一个引用类型的值。</p>\n\n<p>那什么东西能够返回引用类型的值呢？根据上面的八条，可以看到只有标识符。变量、属性访问（这个应该不能算，但是也类似的）、函数名这些其实都是标识符的范畴。</p>\n\n<p>而所谓左值，在ES规范中是用内部类型引用(Reference)描述的。本质上来讲左值就是引用值，左值表达式就是能够产生引用类型的表达式。</p>\n\n<p>而用到 Reference 类型地方，现在看来已经不只是上面那些了，其实只要存在标识符的解析，就存在引用类型。</p>\n\n<p>标识符的解析过程这里不讲了，在前面的文章讲过了，大致就是在词法环境中找，找不到再向外部词法环境找，直到作用域顶部的null，找到则返回一个引用对象。</p>\n\n<p>最后我打算分析两个问题（在上面的总结过后能够更好地理解了）：</p>\n\n<pre><code>var foo = {  \n  bar: function () {\n    alert(this);\n  }\n};\n\nfoo.bar(); // Reference, OK =&gt; foo  \n(foo.bar)(); // Reference, OK =&gt; foo\n\n(foo.bar = foo.bar)(); // global?\n(false || foo.bar)(); // global?\n(foo.bar, foo.bar)(); // global?\n</code></pre>\n\n<p>对于1和2，第一个是标识符，解析结果为引用类型，第二个是分组表达式，解析结果也是引用类型，所以this最后指向的都是foo。而对于3、4、5来说，这些运算符都对这些标识符进行了getValue操作，得到的是函数对象，而不是引用值，所以this是global。</p>\n\n<p>第二个例子：</p>\n\n<pre><code>var a = {n: 1};  \nvar b = a;  \na.x = a = {n: 2};  \nalert(a.x); // --&gt; undefined  \nalert(b.x); // --&gt; {n: 2}  \n</code></pre>\n\n<p>虽然标准没有讲到连等的解析规则，但是根据右结合律和引用类型来理解这题是比较正确的。在解析赋值时第一步如下：Let lref be the result of evaluating LeftHandSideExpression.也就是会解析左边的表达式，因此a.x和a都会解析得到一个引用类型，所以赋值操作实际针对的是引用类型来讲的。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474783654974,"created_by":1,"updated_at":1474797076624,"updated_by":1,"published_at":1474792844868,"published_by":1},{"id":87,"uuid":"30883eb8-43a2-4cc6-b326-a4748d1a74bd","title":"js 全局对象","slug":"js-quan-ju-dui-xiang","markdown":"这是读 es5.1 标准最后一章的内容，会把标准的原生对象、内置对象都介绍一遍！本文的重点是全局对象，不过在介绍全局对象前，先铺垫一些东西，以便能够更好地理解这接下来的一系列文章。\n\n#### 原生、内置、宿主对象\n\n##### 原生对象\n\nECMAScript 实现中，并非由宿主环境，而是完全由本规范定义其语义的对象。指的就是 Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError等。\n\n##### 内置对象\n\n由 ECMAScript 实现提供，独立于宿主环境的对象，ECMAScript 程序开始执行时就存在。其实就是 Global 和 Math，他们不需要我们创建，在程序开始时就已经存在了。（它们也是原生对象，根据定义，每个内置对象都是原生对象）。个人觉得 JSON 也算内置对象，后面查一查，因为文档中没写到。\n\n##### 宿主对象\n\n由宿主环境提供的对象，用于完善 ECMAScript 执行环境。比如浏览器宿主环境提供的 XMLHttpRequest 就是典型的宿主对象。\n\n#### 全局对象\n\n全局对象，也是全局词法环境，是所有词法环境的根，它的外部词法环境就是 null。\n\n全局对象在进入任何执行环境之前就已经创建，与它一起被创建的还有作为其属性的内置对象 Math。\n\n除非另外指明，全局对象的标准内置属性拥有特性 {[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}。\n\n全局对象没有 [[Construct]] 内部属性；全局对象不可能当做构造器用 new 运算符调用。\n\n全局对象没有 [[Call]] 内部属性，全局对象不可能当做函数来调用。\n\n全局对象的 [[Prototype]] 和 [[Class]] 内部属性值是依赖于实现的。\n\n除了本规范定义的属性之外，全局对象还可以拥有额外的宿主定义的属性。全局对象可包含一个值是全局对象自身的属性；例如，在 HTML 文档对象模型中全局对象的 window 属性是全局对象自身。\n\n规范对于全局对象的介绍就这么一些，所以直接看规范在它下面定义了那些东西。\n\n##### 值属性\n\n###### NaN\n\nNaN 的值是 NaN。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n###### Infinity\n\nInfinity 的值是 +∞。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n###### undefined\n\nundefined 的值是 undefined。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n##### 函数属性\n\n###### eval()\n\n之前也讲过eval，但是当时讲得不是很好，这里再总结一下：\n\n首先，还是看看执行过程吧，这样比较好理解：\n\n1. 如果 Type(x) 不是 String，返回 x。\n2. 令 prog 为 ECMAScript 代码，它是将 x 作为一个程序解析的结果。如果解析失败，抛出一个 SyntaxError 异常。\n3. 令 evalCtx 为给 eval 代码 prog 建立的新执行环境。\n 1. 如果没有调用环境，或者 eval 代码并非通过直接调用 eval 函数进行评估的，则按描述的初始化全局执行环境的方案，以 eval 代码作为 C 来初始化执行环境。\n 2. 否则将 this 绑定设置为当前执行环境下的 this 绑定。将词法环境设置为当前执行环境下的词法环境。将变量环境设置为当前执行环境下的变量环境。\n 3. 如果 eval 代码 是 严格模式下的代码 ，则令 strictVarEnv 为以词法环境为参数调用 NewDeclarativeEnvironment 得到的结果。设置词法环境为 strictVarEnv。设置变量环境为 strictVarEnv。\n 4. 执行定义绑定初始化步骤。\n4. 令 result 为解释执行程序 prog 的结果。\n5. 退出执行环境 evalCtx，恢复到之前的执行环境。\n6. 如果 result.type 是 normal 并且其完结类型值是 V，则返回 V 值 。\n7. 如果 result.type 是 normal 并且其完结类型值是 empty，则返回 undefined 值。\n8. 否则，result.type 必定是 throw。将 result.value 作为异常抛出。\n\n最主要的是要来讨论一下执行环境，首先在严格模式下很简单，它会创建一个独立的执行环境，而对于非严格模式下，存在两种情况，直接调用和非直接调用。\n\n直接调用值得是调用产生式的左边的 MemberExpression 的解析结果是一个引用，并且拥有一个环境记录项作为其基值，并且这个引用的名称是 \"eval\"。举几个例子就下下面这些情况：\n\n```\neval('...')\n(eval)('...')\n(((eval)))('...')\n(function() { return eval('...') })()\neval('eval(\"...\")')\n(function(eval) { return eval('...'); })(eval)\nwith({ eval: eval }) eval('...')\nwith(window) eval('...')\n```\n\n直接调用会将 this 绑定设置为当前执行环境下的 this 绑定。而什么是非直接调用，下面一些例子：\n\n```\n(1, eval)('...')\n(eval, eval)('...')\n(1 ? eval : 0)('...')\n(__ = eval)('...')\nvar e = eval; e('...')\n```\n\n非直接调用的后果，就是会和全局环境进行绑定。\n\n然后我们来看看 eval 的一些缺陷，已及我们在什么情况下可能会要使用到 eval。\n\n1. 性能差，慢肯定会慢，但是多少不好说，有人说10倍，也有人测试说没那么多；\n2. 不安全；\n3. 调试不方便；\n4. 从上面看到其内部还是比较复杂的，很容易造成误解和无用。\n\n上面是主要的问题，下面来看看常用的一些地方，不知道会不会有惊喜：\n\n1. 解析 JSON，前段日子有个学长给我看段代码，让我帮他改改，我看到他在用 eval 解析 JSON，我叫他最好不要用 eval。用 JSON.parse 代替，后来看了一些网上的说法，主要还是建议用 JSON.parse 来做，兼容性的话需要加个腻子。\n\n2. 另外在 stackoverflow 上看到一个问题，`(function(){ return this || (0,eval)('this'); }()).doT = doT;`，借助间接调用来获取全局对象。\n\n其它的暂时也没有想到，eval 先这样，少用就好，用之前想想是否可以被替代！\n\n###### parseInt(string, radix)\n\n这个不多说，但是要注意的是使用 parseInt 存在的一个问题：\n\n```\nparseInt(1000000000000000000000.5, 10); // 1\n```\n\nparseInt 的第一个类型是字符串，所以会将传入的参数转换成字符串，也就是String(1000000000000000000000.5) 的结果为 '1e+21'。parseInt 并没有将 'e' 视为一个数字，所以在转换到 1 后就停止了。因此不要使用 parseInt 来转换整数。\n\n那我们转换整数用什么呢？Math 上面的几个 floor、ceil、round 这几个，再根据使用情况封装。\n\n> es6 已经把这个方法从全局对象移到了 Number 对象上。\n\n###### parseFloat\n\nparseFloat 和 Number 的区别个人认为主要就是前面讲到的整串转换还是部分转换的问题了。\n\n> es6 已经把这个方法从全局对象移到了 Number 对象上。\n\n###### isNaN\n\n如果指定参数为 NaN，则返回 true，否则返回 false。\n\n1. 如果 ToNumber(number) 是 NaN，返回 true。\n2. 否，返回 false。\n\n简单来说只要利用 NaN 是唯一一个不等于自身的值来判断就行了。然而像underscore 和 lodash 这类工具库给了自己的 isNaN，主要区别在，underscore 和 lodash 要求判断的首先是一个 Number 类型的值，而不允许 undefined 变成 NaN。因为实际上 NaN 的定义也是如此，它包含的是 2^53 - 2 个值。\n\n```\n// _.isNaN(new Number(0)) => true 存在缺陷\n_.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n};\n// 目前的最新版本修复了上面的问题\n_.isNaN = function(obj) {\n    return _.isNumber(obj) && isNaN(obj);\n};\n```\n\n> es6 已经把这个方法从全局对象移到了 Number 对象上。\n\n###### isFinite (number)\n\n如果指定参数为 NaN 或 +∞或−∞，则返回 false，否则返回 true。\n\n> es6 已经把这个方法从全局对象移到了 Number 对象上。\n\n##### 处理 URI 的函数属性\n\nencodeURI 和 decodeURI 函数操作的是完整的 URI；这俩函数假定 URI 中的任何保留字符都有特殊意义，所有不会编码它们。encodeURIComponent 和 decodeURIComponent 函数操作的是组成 URI 的个别组件；这俩函数假定任何保留字符都代表普通文本，所以必须编码它们，所以它们出现在组成一个完整 URI 的组件里面时不会解释成保留字符了。\n\n简单的讲就是 encodeURI 用来编码 URL，而 encodeURIComponent 用来编码编码参数。这些暂时够了，等要用再做深入的了解！\n\n###### 全局对象的构造器属性\n\n见后面的文章。这些就是上面讲的原生对象，作为全局对象的属性存在。\n\n###### 全局对象的其他属性\n\nMath 和 JSON 可以不用 new 就可以以使用！他们在进入执行环境前就被初始化为全局对象的属性！也在后面扯了！\n\n\n\n\n\n","html":"<p>这是读 es5.1 标准最后一章的内容，会把标准的原生对象、内置对象都介绍一遍！本文的重点是全局对象，不过在介绍全局对象前，先铺垫一些东西，以便能够更好地理解这接下来的一系列文章。</p>\n\n<h4 id=\"\">原生、内置、宿主对象</h4>\n\n<h5 id=\"\">原生对象</h5>\n\n<p>ECMAScript 实现中，并非由宿主环境，而是完全由本规范定义其语义的对象。指的就是 Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError等。</p>\n\n<h5 id=\"\">内置对象</h5>\n\n<p>由 ECMAScript 实现提供，独立于宿主环境的对象，ECMAScript 程序开始执行时就存在。其实就是 Global 和 Math，他们不需要我们创建，在程序开始时就已经存在了。（它们也是原生对象，根据定义，每个内置对象都是原生对象）。个人觉得 JSON 也算内置对象，后面查一查，因为文档中没写到。</p>\n\n<h5 id=\"\">宿主对象</h5>\n\n<p>由宿主环境提供的对象，用于完善 ECMAScript 执行环境。比如浏览器宿主环境提供的 XMLHttpRequest 就是典型的宿主对象。</p>\n\n<h4 id=\"\">全局对象</h4>\n\n<p>全局对象，也是全局词法环境，是所有词法环境的根，它的外部词法环境就是 null。</p>\n\n<p>全局对象在进入任何执行环境之前就已经创建，与它一起被创建的还有作为其属性的内置对象 Math。</p>\n\n<p>除非另外指明，全局对象的标准内置属性拥有特性 {[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}。</p>\n\n<p>全局对象没有 [[Construct]] 内部属性；全局对象不可能当做构造器用 new 运算符调用。</p>\n\n<p>全局对象没有 [[Call]] 内部属性，全局对象不可能当做函数来调用。</p>\n\n<p>全局对象的 [[Prototype]] 和 [[Class]] 内部属性值是依赖于实现的。</p>\n\n<p>除了本规范定义的属性之外，全局对象还可以拥有额外的宿主定义的属性。全局对象可包含一个值是全局对象自身的属性；例如，在 HTML 文档对象模型中全局对象的 window 属性是全局对象自身。</p>\n\n<p>规范对于全局对象的介绍就这么一些，所以直接看规范在它下面定义了那些东西。</p>\n\n<h5 id=\"\">值属性</h5>\n\n<h6 id=\"nan\">NaN</h6>\n\n<p>NaN 的值是 NaN。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h6 id=\"infinity\">Infinity</h6>\n\n<p>Infinity 的值是 +∞。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h6 id=\"undefined\">undefined</h6>\n\n<p>undefined 的值是 undefined。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h5 id=\"\">函数属性</h5>\n\n<h6 id=\"eval\">eval()</h6>\n\n<p>之前也讲过eval，但是当时讲得不是很好，这里再总结一下：</p>\n\n<p>首先，还是看看执行过程吧，这样比较好理解：</p>\n\n<ol>\n<li>如果 Type(x) 不是 String，返回 x。  </li>\n<li>令 prog 为 ECMAScript 代码，它是将 x 作为一个程序解析的结果。如果解析失败，抛出一个 SyntaxError 异常。  </li>\n<li>令 evalCtx 为给 eval 代码 prog 建立的新执行环境。 <br />\n<ol><li>如果没有调用环境，或者 eval 代码并非通过直接调用 eval 函数进行评估的，则按描述的初始化全局执行环境的方案，以 eval 代码作为 C 来初始化执行环境。</li>\n<li>否则将 this 绑定设置为当前执行环境下的 this 绑定。将词法环境设置为当前执行环境下的词法环境。将变量环境设置为当前执行环境下的变量环境。</li>\n<li>如果 eval 代码 是 严格模式下的代码 ，则令 strictVarEnv 为以词法环境为参数调用 NewDeclarativeEnvironment 得到的结果。设置词法环境为 strictVarEnv。设置变量环境为 strictVarEnv。</li>\n<li>执行定义绑定初始化步骤。</li></ol></li>\n<li>令 result 为解释执行程序 prog 的结果。  </li>\n<li>退出执行环境 evalCtx，恢复到之前的执行环境。  </li>\n<li>如果 result.type 是 normal 并且其完结类型值是 V，则返回 V 值 。  </li>\n<li>如果 result.type 是 normal 并且其完结类型值是 empty，则返回 undefined 值。  </li>\n<li>否则，result.type 必定是 throw。将 result.value 作为异常抛出。</li>\n</ol>\n\n<p>最主要的是要来讨论一下执行环境，首先在严格模式下很简单，它会创建一个独立的执行环境，而对于非严格模式下，存在两种情况，直接调用和非直接调用。</p>\n\n<p>直接调用值得是调用产生式的左边的 MemberExpression 的解析结果是一个引用，并且拥有一个环境记录项作为其基值，并且这个引用的名称是 \"eval\"。举几个例子就下下面这些情况：</p>\n\n<pre><code>eval('...')  \n(eval)('...')\n(((eval)))('...')\n(function() { return eval('...') })()\neval('eval(\"...\")')  \n(function(eval) { return eval('...'); })(eval)\nwith({ eval: eval }) eval('...')  \nwith(window) eval('...')  \n</code></pre>\n\n<p>直接调用会将 this 绑定设置为当前执行环境下的 this 绑定。而什么是非直接调用，下面一些例子：</p>\n\n<pre><code>(1, eval)('...')\n(eval, eval)('...')\n(1 ? eval : 0)('...')\n(__ = eval)('...')\nvar e = eval; e('...')  \n</code></pre>\n\n<p>非直接调用的后果，就是会和全局环境进行绑定。</p>\n\n<p>然后我们来看看 eval 的一些缺陷，已及我们在什么情况下可能会要使用到 eval。</p>\n\n<ol>\n<li>性能差，慢肯定会慢，但是多少不好说，有人说10倍，也有人测试说没那么多；  </li>\n<li>不安全；  </li>\n<li>调试不方便；  </li>\n<li>从上面看到其内部还是比较复杂的，很容易造成误解和无用。</li>\n</ol>\n\n<p>上面是主要的问题，下面来看看常用的一些地方，不知道会不会有惊喜：</p>\n\n<ol>\n<li><p>解析 JSON，前段日子有个学长给我看段代码，让我帮他改改，我看到他在用 eval 解析 JSON，我叫他最好不要用 eval。用 JSON.parse 代替，后来看了一些网上的说法，主要还是建议用 JSON.parse 来做，兼容性的话需要加个腻子。</p></li>\n<li><p>另外在 stackoverflow 上看到一个问题，<code>(function(){ return this || (0,eval)('this'); }()).doT = doT;</code>，借助间接调用来获取全局对象。</p></li>\n</ol>\n\n<p>其它的暂时也没有想到，eval 先这样，少用就好，用之前想想是否可以被替代！</p>\n\n<h6 id=\"parseintstringradix\">parseInt(string, radix)</h6>\n\n<p>这个不多说，但是要注意的是使用 parseInt 存在的一个问题：</p>\n\n<pre><code>parseInt(1000000000000000000000.5, 10); // 1  \n</code></pre>\n\n<p>parseInt 的第一个类型是字符串，所以会将传入的参数转换成字符串，也就是String(1000000000000000000000.5) 的结果为 '1e+21'。parseInt 并没有将 'e' 视为一个数字，所以在转换到 1 后就停止了。因此不要使用 parseInt 来转换整数。</p>\n\n<p>那我们转换整数用什么呢？Math 上面的几个 floor、ceil、round 这几个，再根据使用情况封装。</p>\n\n<blockquote>\n  <p>es6 已经把这个方法从全局对象移到了 Number 对象上。</p>\n</blockquote>\n\n<h6 id=\"parsefloat\">parseFloat</h6>\n\n<p>parseFloat 和 Number 的区别个人认为主要就是前面讲到的整串转换还是部分转换的问题了。</p>\n\n<blockquote>\n  <p>es6 已经把这个方法从全局对象移到了 Number 对象上。</p>\n</blockquote>\n\n<h6 id=\"isnan\">isNaN</h6>\n\n<p>如果指定参数为 NaN，则返回 true，否则返回 false。</p>\n\n<ol>\n<li>如果 ToNumber(number) 是 NaN，返回 true。  </li>\n<li>否，返回 false。</li>\n</ol>\n\n<p>简单来说只要利用 NaN 是唯一一个不等于自身的值来判断就行了。然而像underscore 和 lodash 这类工具库给了自己的 isNaN，主要区别在，underscore 和 lodash 要求判断的首先是一个 Number 类型的值，而不允许 undefined 变成 NaN。因为实际上 NaN 的定义也是如此，它包含的是 2^53 - 2 个值。</p>\n\n<pre><code>// _.isNaN(new Number(0)) =&gt; true 存在缺陷\n_.isNaN = function(obj) {  \n    return _.isNumber(obj) &amp;&amp; obj !== +obj;\n};\n// 目前的最新版本修复了上面的问题\n_.isNaN = function(obj) {  \n    return _.isNumber(obj) &amp;&amp; isNaN(obj);\n};\n</code></pre>\n\n<blockquote>\n  <p>es6 已经把这个方法从全局对象移到了 Number 对象上。</p>\n</blockquote>\n\n<h6 id=\"isfinitenumber\">isFinite (number)</h6>\n\n<p>如果指定参数为 NaN 或 +∞或−∞，则返回 false，否则返回 true。</p>\n\n<blockquote>\n  <p>es6 已经把这个方法从全局对象移到了 Number 对象上。</p>\n</blockquote>\n\n<h5 id=\"uri\">处理 URI 的函数属性</h5>\n\n<p>encodeURI 和 decodeURI 函数操作的是完整的 URI；这俩函数假定 URI 中的任何保留字符都有特殊意义，所有不会编码它们。encodeURIComponent 和 decodeURIComponent 函数操作的是组成 URI 的个别组件；这俩函数假定任何保留字符都代表普通文本，所以必须编码它们，所以它们出现在组成一个完整 URI 的组件里面时不会解释成保留字符了。</p>\n\n<p>简单的讲就是 encodeURI 用来编码 URL，而 encodeURIComponent 用来编码编码参数。这些暂时够了，等要用再做深入的了解！</p>\n\n<h6 id=\"\">全局对象的构造器属性</h6>\n\n<p>见后面的文章。这些就是上面讲的原生对象，作为全局对象的属性存在。</p>\n\n<h6 id=\"\">全局对象的其他属性</h6>\n\n<p>Math 和 JSON 可以不用 new 就可以以使用！他们在进入执行环境前就被初始化为全局对象的属性！也在后面扯了！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474854835190,"created_by":1,"updated_at":1475051104971,"updated_by":1,"published_at":1474879264829,"published_by":1},{"id":88,"uuid":"bcea650d-cd51-4101-8a19-edb5b3f541bf","title":"js Object 对象","slug":"js-object-dui-xiang","markdown":"#### 作为函数调用 Object 构造器\n\n当把 Object 当做一个函数来调用，而不是一个构造器，它会执行一个类型转换。\n\nnull 和 undefined 转换为空对象；数字、字符串、布尔值转换为对应的包装对象；其余的则原样返回。这在类型转换篇中已经写过了。\n\n具体地，当以一个参数 value 或者无参数调用 Object 函数，采用如下步骤：\n\n1. 如果 value 是 null、undefined 或未指定，则创建并返回一个新 Object 对象，这个对象与仿佛用相同参数调用标准内置的 Object 构造器 (15.2.2.1) 的结果一样。\n2. 返回 ToObject(value)。（ToObject前面也写过了，实现的就是上面讲到的转换规则）\n\n#### Object 构造器\n\n当以一个参数 value 或者无参数调用 Object 构造器，采用如下步骤：\n\n1. 如果提供了 value，则\n 1. 如果 Type(value) 是 Object, 则\n如果 value 是个原生 ECMAScript 对象，不创建新对象，简单的返回 value。如果 value 是宿主对象，则采取动作和返回依赖实现的结果的方式可以使依赖于宿主对象的。\n 2. 如果 Type(value) 是 String，返回 ToObject(value)。\n 3. 如果 Type(value) 是 Boolean，返回 ToObject(value)。\n 4. 如果 Type(value) 是 Number，返回 ToObject(value)。\n2. 断言：未提供参数 value 或其类型是 Null 或 Undefined。\n3. 令 obj 为一个新创建的原生 ECMAScript 对象。\n4. 设定 obj 的 [[Prototype]] 内部属性为标准内置的 Object 的 prototype 对象。\n5. 设定 obj 的 [[Class]] 内部属性为 \"Object\"。\n6. 设定 obj 的 [[Extensible]] 内部属性为 true。\n7. 设定 obj 的前面指定的所有内部方法。\n8. 返回 obj。\n\n> 过程还是比较复杂的，既要负责类型的转换，还要设置内不是属性方法。我想这就是 new Object 比起字面量创建对象要慢的原因吧！ \n\n#### Object 构造器的属性\n\nObject 构造器的 [[Prototype]] 内部属性值是标准内置 Function 的 prototype 对象。\n\n除了内部属性和 length 属性（其值是 1）之外，Object 构造器拥有以下属性：\n\n##### Object.prototype\n\nObject.prototype 的初始值是标准内置 Object 的 prototype 对象。\n\n这个属性包含特性 {[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }\n\n##### Object.getPrototypeOf(O)\n\n当以参数 O 调用 getPrototypeOf 函数，采用如下步骤：\n\n1. 如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。\n2. 返回 O 的 [[Prototype]] 内部属性的值。\n\n> [[Prototype]] 内部属性就是平时我们所说的__proto__\n\n##### Object.getOwnPropertyDescriptor(O,P)\n\n得到对象的属性描述，当调用 getOwnPropertyDescriptor 函数，采用如下步骤：\n\n1. 如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。\n2. 令 name 为 ToString(P)。\n3. 令 desc 为以参数 name 调用 O 的 [[GetOwnProperty]] 内部方法的结果。\n4. 返回调用 FromPropertyDescriptor(desc) 的结果。\n\n##### Object.getOwnPropertyNames(O)\n\n当调用 getOwnPropertyNames 函数，采用如下步骤：\n\n1. 如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。\n2. 令 array 为仿佛是用表达式 new Array() 创建新对象的结果，这里的 Array 是标准内置构造器名。\n3. 令 n 为 0。\n4. 对 O 的每个自身属性 P。\n 1. 令 name 为值是 P 的名称的字符串。\n 2. 以 ToString(n) 和属性描述 {[[Value]]: name, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true} 和 false 为参数调用 array 的 [[DefineOwnProperty]] 内部方法。\n 3. n 递增 1。\n4. 返回 array。\n\n##### Object.create(O [, Properties])\n\ncreate 函数按照指定的原型创建一个新对象。当调用 create 函数，采用如下步骤：\n\n1. 如果 Type(O) 不是 Object 或 Null，则抛出一个 TypeError 异常 。\n2. 令 obj 为为仿佛是用表达式 new Object() 创建新对象的结果，这里的 Object 是标准内置构造器名。\n3. 设定 obj 的 [[Prototype]] 内部属性为 O。\n4. 如果传入了 Properties 参数并且不是 undefined, 则仿佛是用 obj 和 Properties 当作参数调用标准内置函数 Object.defineProperties 一样给 obj 添加自身属性。\n5. 返回 obj。\n\n对于 Object.create 来看看下面这段 Polyfill：\n\n```\nif (typeof Object.create != 'function') {\n  // Production steps of ECMA-262, Edition 5, 15.2.3.5\n  // Reference: http://es5.github.io/#x15.2.3.5\n  Object.create = (function() {\n    //为了节省内存，使用一个共享的构造器\n    function Temp() {}\n\n    // 使用 Object.prototype.hasOwnProperty 更安全的引用 \n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    return function (O) {\n      // 1. 如果 O 不是 Object 或 null，抛出一个 TypeError 异常。\n      if (typeof O != 'object') {\n        throw TypeError('Object prototype may only be an Object or null');\n      }\n\n      // 2. 使创建的一个新的对象为 obj ，就和通过\n      //    new Object() 表达式创建一个新对象一样，\n      //    Object是标准内置的构造器名\n      // 3. 设置 obj 的内部属性 [[Prototype]] 为 O。\n      Temp.prototype = O;\n      var obj = new Temp();\n      Temp.prototype = null; // 不要保持一个 O 的杂散引用（a stray reference）...\n\n      // 4. 如果存在参数 Properties ，而不是 undefined ，\n      //    那么就把参数的自身属性添加到 obj 上，就像调用\n      //    携带obj ，Properties两个参数的标准内置函数\n      //    Object.defineProperties() 一样。\n      if (arguments.length > 1) {\n        // Object.defineProperties does ToObject on its first argument.\n        var Properties = Object(arguments[1]);\n        for (var prop in Properties) {\n          if (hasOwn.call(Properties, prop)) {\n            obj[prop] = Properties[prop];\n          }\n        }\n      }\n\n      // 5. 返回 obj\n      return obj;\n    };\n  })();\n}\n```\n\n之前好像看的不是很懂，现在对着上面的步骤就很清楚了。\n\n##### Object.defineProperty(O,P,Attributes)\n\ndefineProperty 函数用于给一个对象添加一个自身属性并/或更新现有自身属性的特性。当调用 defineProperty 函数，采用如下步骤：\n\n1. 如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。\n2. 令 name 为 ToString(P)。\n3. 令 desc 为以 Attributes 作为参数调用 ToPropertyDescriptor 的结果。\n4. 以 name, desc, true 作为参数调用 O 的 [[DefineOwnProperty]] 内部方法。\n5. 返回 O。\n\n##### Object.defineProperties (O,Properties)\n\n这个过程不写了，贴一个例子：\n\n```\nvar obj = {};\nObject.defineProperties(obj, {\n  \"property1\": {\n    value: true,\n    writable: true\n  },\n  \"property2\": {\n    value: \"Hello\",\n    writable: false\n  }\n  // etc. etc.\n});\n```\n\n##### Object.seal(O)\n\nObject.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。\n\n它会将对象每个命名自身属性名的属性描述[[Configurable]]设置为false，同时将对象内部属性[[Extensible]]设置为false。\n\n> 所有 ECMASCript 对象都有一个 Boolean 值的 [[Extensible]] 内部属性，它控制是否可以给对象添加命名属性。如果 [[Extensible]] 内部属性的值是 false 那么不得给对象添加命名属性。此外，如果 [[Extensible]] 是 false 那么不得更改对象的 [[Class]] 和 [[Prototype]] 内部属性的值。一旦 [[Extensible]] 内部属性的值设为 false 之后无法再更改为 true。\n\n##### Object.freeze(O)\n\n这个就更过分了，除了会做Object.seal(O)做的设置，它还会把对象每个命名自身属性名的属性描述[[Writable]]设置为false。\n\n##### Object.preventExtensions(O)\n\n当调用 preventExtensions 函数，采用如下步骤：\n\n1. 如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。\n2. 设定 O 的 [[Extensible]] 内部属性为 false。\n3. 返回 O。\n\n##### Object.isSealed(O)\n\nObject.isSealed() 方法判断一个对象是否是密封的（sealed）。算法很简单，不说了。\n\n> 在 ES6 中， non-object 参数将被视为一个冻结的普通对象，因此会返回 true。\n\n##### Object.isFrozen (O)\n\nObject.isFrozen() 方法判断一个对象是否被冻结（frozen）。\n\n##### Object.isExtensible(O)\n\n返回 O 的 [[Extensible]] 内部属性布尔值。\n\n##### Object.keys(O)\n\n这是个很有用的方法，很多库的源码都用到了它。\n\nObject.keys() 方法会返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。\n\n##### 小结一下\n\nObject 的构造器属性，除了prototype和create外，主要功能还是提供对原型、属性、属性描述符的设置、访问、以及限制对象操作。\n\n#### Object 的 prototype 对象的属性\n\nObject 的 prototype 对象的 [[Prototype]] 内部属性的值是 null（原型链的终点），[[Class]] 内部属性的值是 \"Object\"，[[Extensible]] 内部属性的初始值是 true。\n\n##### Object.prototype.constructor\n\nObject.prototype.constructor 的初始值是标准内置的 Object 构造器。（在函数定义一文中写道，函数在创建时都会创建一个对象，这个对象只有constructor值为函数本身，并把这个对象设置到函数上）\n\n##### Object.prototype.toString()\n\n这个方法可有用了，它为我们提供了访问内部属性[[Class]]的唯一途径。我们通常使用它来判断对象的类型。看一下underscore用它干了点什么吧：\n\n```\n// Is a given value an array?\n// Delegates to ECMA5's native Array.isArray\n// 判断是否为数组\n_.isArray = nativeIsArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\n// Is a given variable an object?\n// 判断是否为对象\n// 这里的对象包括 function 和 object\n_.isObject = function(obj) {\n  var type = typeof obj;\n  return type === 'function' || type === 'object' && !!obj;\n};\n\n// Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n// 其他类型判断\n_.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n  _['is' + name] = function(obj) {\n    return toString.call(obj) === '[object ' + name + ']';\n  };\n});\n```\n\n##### Object.prototype.toLocaleString()\n\nObject's toLocaleString 返回调用 toString() 方法的结果。\n\n> 这个函数给所有 Object 对象提供一个通用的 toLocaleString 接口，即使并不是所有的都使用它。目前，Array, Number, Date 提供了它们自身的语言环境敏感的 toLocaleString 方法。\n\n##### Object.prototype.valueOf()\n\nvalueOf() 方法返回指定原始值。一般不用自己调用。\n\n##### Object.prototype.hasOwnProperty(V)\n\nhasOwnProperty() 方法用来判断某个对象是否含有指定的自身属性。hasOwnProperty 方法有可能被遮蔽，这也是为什么underscore等工具库会先把 Object.prototype.hasOwnProperty 缓存起来供后面调用。\n\n##### Object.prototype.isPrototypeOf(V)\n\n在 V 的原型链上找是否存在 Object.prototype。而 o instanceof F 是在 o 的原型链上找是否存在 F.prototype。\n\n##### Object.prototype.propertyIsEnumerable(V)\n\npropertyIsEnumerable() 方法返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性。\n\n##### 小结\n\nObject prototype 上的方法，主要是为所有的对象提供一些公共的属性和方法和。\n\n#### Object 的实例的属性\n\nObject 的实例除了拥从 Object 的 prototype 对象继承来的属性之外不包含特殊的属性。","html":"<h4 id=\"object\">作为函数调用 Object 构造器</h4>\n\n<p>当把 Object 当做一个函数来调用，而不是一个构造器，它会执行一个类型转换。</p>\n\n<p>null 和 undefined 转换为空对象；数字、字符串、布尔值转换为对应的包装对象；其余的则原样返回。这在类型转换篇中已经写过了。</p>\n\n<p>具体地，当以一个参数 value 或者无参数调用 Object 函数，采用如下步骤：</p>\n\n<ol>\n<li>如果 value 是 null、undefined 或未指定，则创建并返回一个新 Object 对象，这个对象与仿佛用相同参数调用标准内置的 Object 构造器 (15.2.2.1) 的结果一样。  </li>\n<li>返回 ToObject(value)。（ToObject前面也写过了，实现的就是上面讲到的转换规则）</li>\n</ol>\n\n<h4 id=\"object\">Object 构造器</h4>\n\n<p>当以一个参数 value 或者无参数调用 Object 构造器，采用如下步骤：</p>\n\n<ol>\n<li>如果提供了 value，则 <br />\n<ol><li>如果 Type(value) 是 Object, 则\n如果 value 是个原生 ECMAScript 对象，不创建新对象，简单的返回 value。如果 value 是宿主对象，则采取动作和返回依赖实现的结果的方式可以使依赖于宿主对象的。</li>\n<li>如果 Type(value) 是 String，返回 ToObject(value)。</li>\n<li>如果 Type(value) 是 Boolean，返回 ToObject(value)。</li>\n<li>如果 Type(value) 是 Number，返回 ToObject(value)。</li></ol></li>\n<li>断言：未提供参数 value 或其类型是 Null 或 Undefined。  </li>\n<li>令 obj 为一个新创建的原生 ECMAScript 对象。  </li>\n<li>设定 obj 的 [[Prototype]] 内部属性为标准内置的 Object 的 prototype 对象。  </li>\n<li>设定 obj 的 [[Class]] 内部属性为 \"Object\"。  </li>\n<li>设定 obj 的 [[Extensible]] 内部属性为 true。  </li>\n<li>设定 obj 的前面指定的所有内部方法。  </li>\n<li>返回 obj。</li>\n</ol>\n\n<blockquote>\n  <p>过程还是比较复杂的，既要负责类型的转换，还要设置内不是属性方法。我想这就是 new Object 比起字面量创建对象要慢的原因吧！ </p>\n</blockquote>\n\n<h4 id=\"object\">Object 构造器的属性</h4>\n\n<p>Object 构造器的 [[Prototype]] 内部属性值是标准内置 Function 的 prototype 对象。</p>\n\n<p>除了内部属性和 length 属性（其值是 1）之外，Object 构造器拥有以下属性：</p>\n\n<h5 id=\"objectprototype\">Object.prototype</h5>\n\n<p>Object.prototype 的初始值是标准内置 Object 的 prototype 对象。</p>\n\n<p>这个属性包含特性 {[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }</p>\n\n<h5 id=\"objectgetprototypeofo\">Object.getPrototypeOf(O)</h5>\n\n<p>当以参数 O 调用 getPrototypeOf 函数，采用如下步骤：</p>\n\n<ol>\n<li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。  </li>\n<li>返回 O 的 [[Prototype]] 内部属性的值。</li>\n</ol>\n\n<blockquote>\n  <p>[[Prototype]] 内部属性就是平时我们所说的<strong>proto</strong></p>\n</blockquote>\n\n<h5 id=\"objectgetownpropertydescriptorop\">Object.getOwnPropertyDescriptor(O,P)</h5>\n\n<p>得到对象的属性描述，当调用 getOwnPropertyDescriptor 函数，采用如下步骤：</p>\n\n<ol>\n<li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。  </li>\n<li>令 name 为 ToString(P)。  </li>\n<li>令 desc 为以参数 name 调用 O 的 [[GetOwnProperty]] 内部方法的结果。  </li>\n<li>返回调用 FromPropertyDescriptor(desc) 的结果。</li>\n</ol>\n\n<h5 id=\"objectgetownpropertynameso\">Object.getOwnPropertyNames(O)</h5>\n\n<p>当调用 getOwnPropertyNames 函数，采用如下步骤：</p>\n\n<ol>\n<li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。  </li>\n<li>令 array 为仿佛是用表达式 new Array() 创建新对象的结果，这里的 Array 是标准内置构造器名。  </li>\n<li>令 n 为 0。  </li>\n<li>对 O 的每个自身属性 P。 <br />\n<ol><li>令 name 为值是 P 的名称的字符串。</li>\n<li>以 ToString(n) 和属性描述 {[[Value]]: name, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true} 和 false 为参数调用 array 的 [[DefineOwnProperty]] 内部方法。</li>\n<li>n 递增 1。</li></ol></li>\n<li>返回 array。</li>\n</ol>\n\n<h5 id=\"objectcreateoproperties\">Object.create(O [, Properties])</h5>\n\n<p>create 函数按照指定的原型创建一个新对象。当调用 create 函数，采用如下步骤：</p>\n\n<ol>\n<li>如果 Type(O) 不是 Object 或 Null，则抛出一个 TypeError 异常 。  </li>\n<li>令 obj 为为仿佛是用表达式 new Object() 创建新对象的结果，这里的 Object 是标准内置构造器名。  </li>\n<li>设定 obj 的 [[Prototype]] 内部属性为 O。  </li>\n<li>如果传入了 Properties 参数并且不是 undefined, 则仿佛是用 obj 和 Properties 当作参数调用标准内置函数 Object.defineProperties 一样给 obj 添加自身属性。  </li>\n<li>返回 obj。</li>\n</ol>\n\n<p>对于 Object.create 来看看下面这段 Polyfill：</p>\n\n<pre><code>if (typeof Object.create != 'function') {  \n  // Production steps of ECMA-262, Edition 5, 15.2.3.5\n  // Reference: http://es5.github.io/#x15.2.3.5\n  Object.create = (function() {\n    //为了节省内存，使用一个共享的构造器\n    function Temp() {}\n\n    // 使用 Object.prototype.hasOwnProperty 更安全的引用 \n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    return function (O) {\n      // 1. 如果 O 不是 Object 或 null，抛出一个 TypeError 异常。\n      if (typeof O != 'object') {\n        throw TypeError('Object prototype may only be an Object or null');\n      }\n\n      // 2. 使创建的一个新的对象为 obj ，就和通过\n      //    new Object() 表达式创建一个新对象一样，\n      //    Object是标准内置的构造器名\n      // 3. 设置 obj 的内部属性 [[Prototype]] 为 O。\n      Temp.prototype = O;\n      var obj = new Temp();\n      Temp.prototype = null; // 不要保持一个 O 的杂散引用（a stray reference）...\n\n      // 4. 如果存在参数 Properties ，而不是 undefined ，\n      //    那么就把参数的自身属性添加到 obj 上，就像调用\n      //    携带obj ，Properties两个参数的标准内置函数\n      //    Object.defineProperties() 一样。\n      if (arguments.length &gt; 1) {\n        // Object.defineProperties does ToObject on its first argument.\n        var Properties = Object(arguments[1]);\n        for (var prop in Properties) {\n          if (hasOwn.call(Properties, prop)) {\n            obj[prop] = Properties[prop];\n          }\n        }\n      }\n\n      // 5. 返回 obj\n      return obj;\n    };\n  })();\n}\n</code></pre>\n\n<p>之前好像看的不是很懂，现在对着上面的步骤就很清楚了。</p>\n\n<h5 id=\"objectdefinepropertyopattributes\">Object.defineProperty(O,P,Attributes)</h5>\n\n<p>defineProperty 函数用于给一个对象添加一个自身属性并/或更新现有自身属性的特性。当调用 defineProperty 函数，采用如下步骤：</p>\n\n<ol>\n<li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。  </li>\n<li>令 name 为 ToString(P)。  </li>\n<li>令 desc 为以 Attributes 作为参数调用 ToPropertyDescriptor 的结果。  </li>\n<li>以 name, desc, true 作为参数调用 O 的 [[DefineOwnProperty]] 内部方法。  </li>\n<li>返回 O。</li>\n</ol>\n\n<h5 id=\"objectdefinepropertiesoproperties\">Object.defineProperties (O,Properties)</h5>\n\n<p>这个过程不写了，贴一个例子：</p>\n\n<pre><code>var obj = {};  \nObject.defineProperties(obj, {  \n  \"property1\": {\n    value: true,\n    writable: true\n  },\n  \"property2\": {\n    value: \"Hello\",\n    writable: false\n  }\n  // etc. etc.\n});\n</code></pre>\n\n<h5 id=\"objectsealo\">Object.seal(O)</h5>\n\n<p>Object.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。</p>\n\n<p>它会将对象每个命名自身属性名的属性描述[[Configurable]]设置为false，同时将对象内部属性[[Extensible]]设置为false。</p>\n\n<blockquote>\n  <p>所有 ECMASCript 对象都有一个 Boolean 值的 [[Extensible]] 内部属性，它控制是否可以给对象添加命名属性。如果 [[Extensible]] 内部属性的值是 false 那么不得给对象添加命名属性。此外，如果 [[Extensible]] 是 false 那么不得更改对象的 [[Class]] 和 [[Prototype]] 内部属性的值。一旦 [[Extensible]] 内部属性的值设为 false 之后无法再更改为 true。</p>\n</blockquote>\n\n<h5 id=\"objectfreezeo\">Object.freeze(O)</h5>\n\n<p>这个就更过分了，除了会做Object.seal(O)做的设置，它还会把对象每个命名自身属性名的属性描述[[Writable]]设置为false。</p>\n\n<h5 id=\"objectpreventextensionso\">Object.preventExtensions(O)</h5>\n\n<p>当调用 preventExtensions 函数，采用如下步骤：</p>\n\n<ol>\n<li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。  </li>\n<li>设定 O 的 [[Extensible]] 内部属性为 false。  </li>\n<li>返回 O。</li>\n</ol>\n\n<h5 id=\"objectissealedo\">Object.isSealed(O)</h5>\n\n<p>Object.isSealed() 方法判断一个对象是否是密封的（sealed）。算法很简单，不说了。</p>\n\n<blockquote>\n  <p>在 ES6 中， non-object 参数将被视为一个冻结的普通对象，因此会返回 true。</p>\n</blockquote>\n\n<h5 id=\"objectisfrozeno\">Object.isFrozen (O)</h5>\n\n<p>Object.isFrozen() 方法判断一个对象是否被冻结（frozen）。</p>\n\n<h5 id=\"objectisextensibleo\">Object.isExtensible(O)</h5>\n\n<p>返回 O 的 [[Extensible]] 内部属性布尔值。</p>\n\n<h5 id=\"objectkeyso\">Object.keys(O)</h5>\n\n<p>这是个很有用的方法，很多库的源码都用到了它。</p>\n\n<p>Object.keys() 方法会返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。</p>\n\n<h5 id=\"\">小结一下</h5>\n\n<p>Object 的构造器属性，除了prototype和create外，主要功能还是提供对原型、属性、属性描述符的设置、访问、以及限制对象操作。</p>\n\n<h4 id=\"objectprototype\">Object 的 prototype 对象的属性</h4>\n\n<p>Object 的 prototype 对象的 [[Prototype]] 内部属性的值是 null（原型链的终点），[[Class]] 内部属性的值是 \"Object\"，[[Extensible]] 内部属性的初始值是 true。</p>\n\n<h5 id=\"objectprototypeconstructor\">Object.prototype.constructor</h5>\n\n<p>Object.prototype.constructor 的初始值是标准内置的 Object 构造器。（在函数定义一文中写道，函数在创建时都会创建一个对象，这个对象只有constructor值为函数本身，并把这个对象设置到函数上）</p>\n\n<h5 id=\"objectprototypetostring\">Object.prototype.toString()</h5>\n\n<p>这个方法可有用了，它为我们提供了访问内部属性[[Class]]的唯一途径。我们通常使用它来判断对象的类型。看一下underscore用它干了点什么吧：</p>\n\n<pre><code>// Is a given value an array?\n// Delegates to ECMA5's native Array.isArray\n// 判断是否为数组\n_.isArray = nativeIsArray || function(obj) {  \n  return toString.call(obj) === '[object Array]';\n};\n\n// Is a given variable an object?\n// 判断是否为对象\n// 这里的对象包括 function 和 object\n_.isObject = function(obj) {  \n  var type = typeof obj;\n  return type === 'function' || type === 'object' &amp;&amp; !!obj;\n};\n\n// Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n// 其他类型判断\n_.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {  \n  _['is' + name] = function(obj) {\n    return toString.call(obj) === '[object ' + name + ']';\n  };\n});\n</code></pre>\n\n<h5 id=\"objectprototypetolocalestring\">Object.prototype.toLocaleString()</h5>\n\n<p>Object's toLocaleString 返回调用 toString() 方法的结果。</p>\n\n<blockquote>\n  <p>这个函数给所有 Object 对象提供一个通用的 toLocaleString 接口，即使并不是所有的都使用它。目前，Array, Number, Date 提供了它们自身的语言环境敏感的 toLocaleString 方法。</p>\n</blockquote>\n\n<h5 id=\"objectprototypevalueof\">Object.prototype.valueOf()</h5>\n\n<p>valueOf() 方法返回指定原始值。一般不用自己调用。</p>\n\n<h5 id=\"objectprototypehasownpropertyv\">Object.prototype.hasOwnProperty(V)</h5>\n\n<p>hasOwnProperty() 方法用来判断某个对象是否含有指定的自身属性。hasOwnProperty 方法有可能被遮蔽，这也是为什么underscore等工具库会先把 Object.prototype.hasOwnProperty 缓存起来供后面调用。</p>\n\n<h5 id=\"objectprototypeisprototypeofv\">Object.prototype.isPrototypeOf(V)</h5>\n\n<p>在 V 的原型链上找是否存在 Object.prototype。而 o instanceof F 是在 o 的原型链上找是否存在 F.prototype。</p>\n\n<h5 id=\"objectprototypepropertyisenumerablev\">Object.prototype.propertyIsEnumerable(V)</h5>\n\n<p>propertyIsEnumerable() 方法返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性。</p>\n\n<h5 id=\"\">小结</h5>\n\n<p>Object prototype 上的方法，主要是为所有的对象提供一些公共的属性和方法和。</p>\n\n<h4 id=\"object\">Object 的实例的属性</h4>\n\n<p>Object 的实例除了拥从 Object 的 prototype 对象继承来的属性之外不包含特殊的属性。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474884983526,"created_by":1,"updated_at":1475051079613,"updated_by":1,"published_at":1474893502042,"published_by":1},{"id":89,"uuid":"767b6bd0-ebe3-4588-bcb9-836213560c83","title":"哈利路亚，chance","slug":"qiu-hun-da-zuo-zhan","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=22781103&auto=1&height=66\"></iframe>\n\n> 明日晴れるかな 被版权保护了，可以光明正大的放小小恋歌了！\n\n前天刷完的《求婚大作战》，又是部脑洞极大的片子！\n\n早有耳闻是部神剧，最近剧荒才开始看。\n\n故事很简单，山p来参加青梅竹马的麻酱的婚礼，教堂的妖怪看出了山p的不甘心，于是帮山p根据婚礼上幻灯片播放的照片回到过去，来挽回麻酱。\n\n会到过去的山p，改变了很多，他让照片中哭着的麻酱、不开心的麻酱变得高兴，但是他唯一没能够改变的是亲口说出对于麻酱的喜欢之情。\n\n所以到最后他也没有能够改变麻酱要和多田老师结婚的事实。他无法再回到过去了，他只知道当下的自己还是喜欢麻酱的，并且他拥有的只有现在，能改变未来的是现在。于是，他在婚礼的致辞上说出了过去14年都没能够说出口的话，不对小时候的他说了出来。\n\n麻酱逃婚，两个人最终在了一起。真正的求婚是在sp当中，不剧透了，反正是美好的结局😜。\n\n如果我能够有哈利路亚，chance，我会不停地选择回去吗？我也不知道，因为有些事自己也无法确定了！不过如果真得有一个麻酱那样之于山p的人，我想我会毫不犹豫地回去的。\n\n当然，回去只是一种幻想，真的回到过去我们也未必能够改变现在的结果。我们能够做的还是在当下做好自己，凭着心意，热诚地活下去，让未来的自己不后悔！编剧套路了10集，到最后就是要告诉我们这个吧！\n\n虽然曾经的自己已经让现在的我感到那么不堪，我亦不知道现在的自己是否能够让未来的自己满意，但是认真做每一件想做的事，爱每一个喜欢的人，这就是通向未来的哈利路亚，chance！明天再做的人是笨蛋！\n\n最后照老规矩是剧照分享：\n\n羞耻的哈利路亚，chance😅\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f87urw1yygj30g4092glv.jpg)\n\n妖精神助攻\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f87uty5fvzj30dc07ht8y.jpg)\n\n好朋友\n\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f87uuvn172j30zk0k041o.jpg)\n\n夏天就是花火 浴衣 长泽雅美\n\n![](https://ws4.sinaimg.cn/large/006bH5BKgw1f87uw79nwej30fj0dy0vk.jpg)\n\n我的后半生拜托你了\n\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f87uzudzotj30bx07vdgl.jpg)\n\n最后一张\n\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f87ux9gqvbj313o0xk46n.jpg)\n\n彩蛋，哈哈哈\n\n![](https://ws4.sinaimg.cn/large/006bH5BKgw1f87v3e33qij30zk0k0jx9.jpg)\n\n","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=22781103&auto=1&height=66\"></iframe>\n\n<blockquote>\n  <p>明日晴れるかな 被版权保护了，可以光明正大的放小小恋歌了！</p>\n</blockquote>\n\n<p>前天刷完的《求婚大作战》，又是部脑洞极大的片子！</p>\n\n<p>早有耳闻是部神剧，最近剧荒才开始看。</p>\n\n<p>故事很简单，山p来参加青梅竹马的麻酱的婚礼，教堂的妖怪看出了山p的不甘心，于是帮山p根据婚礼上幻灯片播放的照片回到过去，来挽回麻酱。</p>\n\n<p>会到过去的山p，改变了很多，他让照片中哭着的麻酱、不开心的麻酱变得高兴，但是他唯一没能够改变的是亲口说出对于麻酱的喜欢之情。</p>\n\n<p>所以到最后他也没有能够改变麻酱要和多田老师结婚的事实。他无法再回到过去了，他只知道当下的自己还是喜欢麻酱的，并且他拥有的只有现在，能改变未来的是现在。于是，他在婚礼的致辞上说出了过去14年都没能够说出口的话，不对小时候的他说了出来。</p>\n\n<p>麻酱逃婚，两个人最终在了一起。真正的求婚是在sp当中，不剧透了，反正是美好的结局😜。</p>\n\n<p>如果我能够有哈利路亚，chance，我会不停地选择回去吗？我也不知道，因为有些事自己也无法确定了！不过如果真得有一个麻酱那样之于山p的人，我想我会毫不犹豫地回去的。</p>\n\n<p>当然，回去只是一种幻想，真的回到过去我们也未必能够改变现在的结果。我们能够做的还是在当下做好自己，凭着心意，热诚地活下去，让未来的自己不后悔！编剧套路了10集，到最后就是要告诉我们这个吧！</p>\n\n<p>虽然曾经的自己已经让现在的我感到那么不堪，我亦不知道现在的自己是否能够让未来的自己满意，但是认真做每一件想做的事，爱每一个喜欢的人，这就是通向未来的哈利路亚，chance！明天再做的人是笨蛋！</p>\n\n<p>最后照老规矩是剧照分享：</p>\n\n<p>羞耻的哈利路亚，chance😅</p>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f87urw1yygj30g4092glv.jpg\" alt=\"\" /></p>\n\n<p>妖精神助攻</p>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f87uty5fvzj30dc07ht8y.jpg\" alt=\"\" /></p>\n\n<p>好朋友</p>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f87uuvn172j30zk0k041o.jpg\" alt=\"\" /></p>\n\n<p>夏天就是花火 浴衣 长泽雅美</p>\n\n<p><img src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f87uw79nwej30fj0dy0vk.jpg\" alt=\"\" /></p>\n\n<p>我的后半生拜托你了</p>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f87uzudzotj30bx07vdgl.jpg\" alt=\"\" /></p>\n\n<p>最后一张</p>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f87ux9gqvbj313o0xk46n.jpg\" alt=\"\" /></p>\n\n<p>彩蛋，哈哈哈</p>\n\n<p><img src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f87v3e33qij30zk0k0jx9.jpg\" alt=\"\" /></p>","image":"/content/images/2016/09/2059846-1474714676.png","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474893724290,"created_by":1,"updated_at":1474938626247,"updated_by":1,"published_at":1474937934431,"published_by":1},{"id":90,"uuid":"ba89a53a-3539-433f-9370-31019f4efd2d","title":"js Function 对象","slug":"js-function-dui-xiang","markdown":"#### 作为函数调用 Function 构造器\n\n当将 Function 作为函数来调用，而不是作为构造器，它会创建并初始化一个新函数对象。所以函数调用 Function(…) 与用相同参数的 new Function(…) 表达式创建的对象相同。\n\n#### Function 构造器\n\n与普通的函数对象创建的区别在于，构造器创建的函数对象，把全局环境作为 [[Scope]] 参数。\n\n#### Function 构造器的属性\n\nFunction 构造器自身是个函数对象，它的 [[Class]] 是 \"Function\"。（用Object.prototype.toString可以访问）Function 构造器的 [[Prototype]] 内部属性值是标准内置 Function 的 prototype 对象。\n\nFunction 构造器的 [[Extensible]] 内部属性值是 true.\n\n##### Function.prototype\n\nFunction.prototype 的初始值是标准内置 Function 的 prototype 对象。\n\n此属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n> 另外 V8 以及 SpiderMonkey 等引擎还实现了一些如 name、caller 的非标准属性，建议不要使用。\n\n##### Function.length\n\n这是个值为 1 的数据属性。此属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n#### Function 的 prototype 对象的属性\n\nFunction 的 prototype 对象自身是一个函数对象 ( 它的 [[Class]] 是 \"Function\")，调用这个函数对象时，接受任何参数并返回 undefined。\n\nFunction 的 prototype 对象的 [[Prototype]] 内部属性值是标准内置 Object 的 prototype 对象 (15.2.4)。Function 的 prototype 对象的 [[Extensible]] 内部属性的初始值是 true。\n\nFunction 的 prototype 对象自身没有 valueOf 属性 ; 但是，它从 Object 的 prototype 对象继承了 valueOf 属性。\n\nFunction 的 prototype 对象的 length 属性是 0。\n\n> 因为 Function.prototype.__proto__ === Object.prototype，因此 Function.prototype 从 Object.prototype 继承来了相关的方法。\n\n##### Function.prototype.constructor\n\nFunction.prototype.constructor 的初始值是内置 Function 构造器。\n\n##### Function.prototype.toString ( )\n\n此函数的返回值的表示是依赖于实现的。这个表示包含 FunctionDeclaration 的语法。特别注意，怎样在这个字符串表示中使用和放置空白，行终结符，分号是依赖于实现的。\n\n这个 toString 不是通用的；如果它的 this 值不是一个函数对象，它会抛出一个 TypeError 异常。因此，它不能当做方法来转移到其他类型的对象中。\n\n##### Function.prototype.apply(thisArg,argArray) \n\n调用内部方法[[call]]\n\n##### Function.prototype.call(thisArg [,arg1[,arg2, … ]])\n\n调用内部方法[[call]]\n\n>  在外面传入的 thisArg 值会修改并成为 this 值。thisArg 是 undefined 或 null 时它会被替换成全局对象，所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改。\n\n#####  Function.prototype.bind (thisArg [,arg1[,arg2, …]])\n\nbind 之前专门写了一篇讲过了。\n\n#### Function 的实例的属性\n\n除了必要的内部属性之外，每个函数实例还有一个 [[Call]] 内部属性（call、apply内部调用这个）并且在大多数情况下使用不同版本的 [[Get]] 内部属性。可能还有一个 [[HasInstance]] 内部属性（instanceof 内部调用这个）、一个 [[Scope]] 内部属性（外部作用域）、一个 [[Construct]] 内部属性（new 内部调用这个）、一个 [[FormalParameters]] 内部属性、一个 [[Code]] 内部属性（函数代码）、一个 [[TargetFunction]] 内部属性（目标函数，bind 实现用到了）、一个 [[BoundThis]] 内部属性（绑定的 this）、一个 [[BoundArgs]] 内部属性（绑定的参数）。\n\n[[Class]] 内部属性的值是 \"Function\"。\n\n对应于严格模式函数的函数实例和用 Function.prototype.bind 方法 创建的函数实例有名为“caller”和 “arguments”的属性时，抛出一个 TypeError 异常。一个 ECMAScript 实现不得为在严格模式函数代码里访问这些属性关联任何依赖实现的特定行为。\n\n##### length\n\nlength 属性值是个整数，它指出函数预期的“一般的”参数个数。然而，语言允许用其他数量的参数来调用函数。当以与函数的 length 属性指定的数量不同的参数个数调用函数时，它的行为依赖于函数自身。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n##### prototype\n\nprototype 属性的值用于初始化一个新创建对象的的 [[Prototype]] 内部属性，为了这个新创建对象要先将函数对象作为构造器调用。这个属性拥有特性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }。\n\n> 为了使得每个函数对象能够作为构造函数，所以函数实例都拥有 prototype 属性。用 Function.prototype.bind 创建的函数对象没有 prototype 属性，因为在用 new 调用 Function.prototype.bind 创建的函数对象时，内部实际上用的还是 [[TargetFunction]] 目标函数，使用的 prototype 也是目标函数上的。\n\n##### [[HasInstance]] (V)\n\n设 F 是个函数对象。\n\n当以 V 作为参数调用 F 的 [[HasInstance]] 内部方法，采用如下步骤：\n\n1. 如果 V 不是个对象 , 返回 false。\n2. 令 O 为用属性名 \"prototype\" 调用 F 的 [[Get]] 内部方法的结果。\n3. 如果 Type(O) 不是 Object, 抛出一个 TypeError 异常。\n重复\n4. 令 V 为 V 的 [[Prototype]] 内部属性值。\n5. 如果 V 是 null, 返回 false.\n6. 如果 O 和 V 指向相同对象，返回 true。\n\n##### [[Get]] (P)\n\n函数对象与其他原生 EMACScript 对象用不同的 [[Get]] 内部方法。\n\n设 F 是一个函数对象，当以属性名 P 调用 F 的 [[Get]] 内部方法 , 采用如下步骤：\n\n1. 令 v 为传入 P 作为属性名参数调用 F 的默认 [[Get]] 内部方法 (8.12.3) 的结果。\n2. 如果 P 是 \"caller\" 并且 v 是个严格模式函数对象 , 抛出一个 TypeError 异常。\n3. 返回 v。\n\n> 用 Function.prototype.bind 创建的函数对象使用默认的 [[Get]] 内部方法。","html":"<h4 id=\"function\">作为函数调用 Function 构造器</h4>\n\n<p>当将 Function 作为函数来调用，而不是作为构造器，它会创建并初始化一个新函数对象。所以函数调用 Function(…) 与用相同参数的 new Function(…) 表达式创建的对象相同。</p>\n\n<h4 id=\"function\">Function 构造器</h4>\n\n<p>与普通的函数对象创建的区别在于，构造器创建的函数对象，把全局环境作为 [[Scope]] 参数。</p>\n\n<h4 id=\"function\">Function 构造器的属性</h4>\n\n<p>Function 构造器自身是个函数对象，它的 [[Class]] 是 \"Function\"。（用Object.prototype.toString可以访问）Function 构造器的 [[Prototype]] 内部属性值是标准内置 Function 的 prototype 对象。</p>\n\n<p>Function 构造器的 [[Extensible]] 内部属性值是 true.</p>\n\n<h5 id=\"functionprototype\">Function.prototype</h5>\n\n<p>Function.prototype 的初始值是标准内置 Function 的 prototype 对象。</p>\n\n<p>此属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<blockquote>\n  <p>另外 V8 以及 SpiderMonkey 等引擎还实现了一些如 name、caller 的非标准属性，建议不要使用。</p>\n</blockquote>\n\n<h5 id=\"functionlength\">Function.length</h5>\n\n<p>这是个值为 1 的数据属性。此属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h4 id=\"functionprototype\">Function 的 prototype 对象的属性</h4>\n\n<p>Function 的 prototype 对象自身是一个函数对象 ( 它的 [[Class]] 是 \"Function\")，调用这个函数对象时，接受任何参数并返回 undefined。</p>\n\n<p>Function 的 prototype 对象的 [[Prototype]] 内部属性值是标准内置 Object 的 prototype 对象 (15.2.4)。Function 的 prototype 对象的 [[Extensible]] 内部属性的初始值是 true。</p>\n\n<p>Function 的 prototype 对象自身没有 valueOf 属性 ; 但是，它从 Object 的 prototype 对象继承了 valueOf 属性。</p>\n\n<p>Function 的 prototype 对象的 length 属性是 0。</p>\n\n<blockquote>\n  <p>因为 Function.prototype.<strong>proto</strong> === Object.prototype，因此 Function.prototype 从 Object.prototype 继承来了相关的方法。</p>\n</blockquote>\n\n<h5 id=\"functionprototypeconstructor\">Function.prototype.constructor</h5>\n\n<p>Function.prototype.constructor 的初始值是内置 Function 构造器。</p>\n\n<h5 id=\"functionprototypetostring\">Function.prototype.toString ( )</h5>\n\n<p>此函数的返回值的表示是依赖于实现的。这个表示包含 FunctionDeclaration 的语法。特别注意，怎样在这个字符串表示中使用和放置空白，行终结符，分号是依赖于实现的。</p>\n\n<p>这个 toString 不是通用的；如果它的 this 值不是一个函数对象，它会抛出一个 TypeError 异常。因此，它不能当做方法来转移到其他类型的对象中。</p>\n\n<h5 id=\"functionprototypeapplythisargargarray\">Function.prototype.apply(thisArg,argArray)</h5>\n\n<p>调用内部方法[[call]]</p>\n\n<h5 id=\"functionprototypecallthisargarg1arg2\">Function.prototype.call(thisArg [,arg1[,arg2, … ]])</h5>\n\n<p>调用内部方法[[call]]</p>\n\n<blockquote>\n  <p>在外面传入的 thisArg 值会修改并成为 this 值。thisArg 是 undefined 或 null 时它会被替换成全局对象，所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改。</p>\n</blockquote>\n\n<h5 id=\"functionprototypebindthisargarg1arg2\">Function.prototype.bind (thisArg [,arg1[,arg2, …]])</h5>\n\n<p>bind 之前专门写了一篇讲过了。</p>\n\n<h4 id=\"function\">Function 的实例的属性</h4>\n\n<p>除了必要的内部属性之外，每个函数实例还有一个 [[Call]] 内部属性（call、apply内部调用这个）并且在大多数情况下使用不同版本的 [[Get]] 内部属性。可能还有一个 [[HasInstance]] 内部属性（instanceof 内部调用这个）、一个 [[Scope]] 内部属性（外部作用域）、一个 [[Construct]] 内部属性（new 内部调用这个）、一个 [[FormalParameters]] 内部属性、一个 [[Code]] 内部属性（函数代码）、一个 [[TargetFunction]] 内部属性（目标函数，bind 实现用到了）、一个 [[BoundThis]] 内部属性（绑定的 this）、一个 [[BoundArgs]] 内部属性（绑定的参数）。</p>\n\n<p>[[Class]] 内部属性的值是 \"Function\"。</p>\n\n<p>对应于严格模式函数的函数实例和用 Function.prototype.bind 方法 创建的函数实例有名为“caller”和 “arguments”的属性时，抛出一个 TypeError 异常。一个 ECMAScript 实现不得为在严格模式函数代码里访问这些属性关联任何依赖实现的特定行为。</p>\n\n<h5 id=\"length\">length</h5>\n\n<p>length 属性值是个整数，它指出函数预期的“一般的”参数个数。然而，语言允许用其他数量的参数来调用函数。当以与函数的 length 属性指定的数量不同的参数个数调用函数时，它的行为依赖于函数自身。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h5 id=\"prototype\">prototype</h5>\n\n<p>prototype 属性的值用于初始化一个新创建对象的的 [[Prototype]] 内部属性，为了这个新创建对象要先将函数对象作为构造器调用。这个属性拥有特性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<blockquote>\n  <p>为了使得每个函数对象能够作为构造函数，所以函数实例都拥有 prototype 属性。用 Function.prototype.bind 创建的函数对象没有 prototype 属性，因为在用 new 调用 Function.prototype.bind 创建的函数对象时，内部实际上用的还是 [[TargetFunction]] 目标函数，使用的 prototype 也是目标函数上的。</p>\n</blockquote>\n\n<h5 id=\"hasinstancev\">[[HasInstance]] (V)</h5>\n\n<p>设 F 是个函数对象。</p>\n\n<p>当以 V 作为参数调用 F 的 [[HasInstance]] 内部方法，采用如下步骤：</p>\n\n<ol>\n<li>如果 V 不是个对象 , 返回 false。  </li>\n<li>令 O 为用属性名 \"prototype\" 调用 F 的 [[Get]] 内部方法的结果。  </li>\n<li>如果 Type(O) 不是 Object, 抛出一个 TypeError 异常。 <br />\n重复</li>\n<li>令 V 为 V 的 [[Prototype]] 内部属性值。  </li>\n<li>如果 V 是 null, 返回 false.  </li>\n<li>如果 O 和 V 指向相同对象，返回 true。</li>\n</ol>\n\n<h5 id=\"getp\">[[Get]] (P)</h5>\n\n<p>函数对象与其他原生 EMACScript 对象用不同的 [[Get]] 内部方法。</p>\n\n<p>设 F 是一个函数对象，当以属性名 P 调用 F 的 [[Get]] 内部方法 , 采用如下步骤：</p>\n\n<ol>\n<li>令 v 为传入 P 作为属性名参数调用 F 的默认 [[Get]] 内部方法 (8.12.3) 的结果。  </li>\n<li>如果 P 是 \"caller\" 并且 v 是个严格模式函数对象 , 抛出一个 TypeError 异常。  </li>\n<li>返回 v。</li>\n</ol>\n\n<blockquote>\n  <p>用 Function.prototype.bind 创建的函数对象使用默认的 [[Get]] 内部方法。</p>\n</blockquote>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474938316951,"created_by":1,"updated_at":1475051056265,"updated_by":1,"published_at":1474947899825,"published_by":1},{"id":91,"uuid":"977cba99-d8de-422d-8608-77d29cca3f6c","title":"重识原型链","slug":"chong-shi-yuan-xing-lian","markdown":"看了标准的 Object 对象和 Function 对象，对于原型链有点蒙，这里总结一下。\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f882z8xj08j30go0kq0ux.jpg)\n\n首先万事万物都是对象，根据上面这张经典的图，由 null 产生了 Object.prototype 这个对象，Object.prototype 构造出了所有的 prototype 对象，最重要的就是 Function.prototype。\n\nFunction.prototype 构造出了所有的函数对象（Object、Function、Array），因此所有的函数对象的 `__proto__` 都是 Function.prototype。Object.prototype 和 Function.prototype 仅仅是挂载在 Object 和 Function 函数对象之上。\n\n函数对象（除了bind产生的函数对象）外，都有一个 prototype 挂载到对应的函数对象之上，这些原型对象都是由 Object 构造，包含一个 constructor 属性指向自身。所以原型对象的 `__proto__` 指向的是 Object.prototype。\n\n函数对象作为构造器，创造了各式各样的实例对象，这些实例对象包含一个 `__proto__` 指向构造其的函数对象的原型对象。\n\n从上面的分析我们可以得到下面的结论：\n\n- 实例对象.`__proto__` -> 构造器（函数对象）.prototype\n- 函数对象.`__proto__` -> Function.prototype\n- 原型对象.`__proto__` -> Object.prototype\n- 实例对象、原型对象没有原型对象\n- 默认函数对象的原型对象 prototype = new Object()，prototype.contrustor = 函数对象本身。原生对象的 prototype 都是其自己的空实例。\n- 在继承场景中 new Object 可以是其它的对象，比如 Cat.prototype = new Dog，这样的原型对象相当于一个实例对象，此时 `__proto__` 不再是构造器（函数对象），而是实例对象，这个实例对象的 `__proto__` 指向构造器（函数对象）.prototype 或 实例对象，以此轮回形成了继承的原型链。\n\n这么看来其实实例对象和原型对象其实差不多，实例对象也可以作为原型对象，只不过默认的原型对象它的原型是 Object.prototype。用实例作为原型对象是为了继承。\n\n因为为了实现继承，我们通常会覆盖构造器函数对象的 prototype 属性，让它指向一个实例对象或直接指向另一个构造器函数对象的 prototype 属性。前一种情况而这个实例对象 `__proto__` 属性又指向了其构造器函数对象的 prototype，使得我们新创建的对象继承了来自这个 prototype 的属性和方法。后一种情况则是直接把 prototype 的属性进行了替换。\n\n上面第一种情况比较耗费内存；第二种情况导致两个 prototype 耦合。因此我们通常使用一个空中介的方式来实现继承。\n\n这样下来清楚多了！","html":"<p>看了标准的 Object 对象和 Function 对象，对于原型链有点蒙，这里总结一下。</p>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f882z8xj08j30go0kq0ux.jpg\" alt=\"\" /></p>\n\n<p>首先万事万物都是对象，根据上面这张经典的图，由 null 产生了 Object.prototype 这个对象，Object.prototype 构造出了所有的 prototype 对象，最重要的就是 Function.prototype。</p>\n\n<p>Function.prototype 构造出了所有的函数对象（Object、Function、Array），因此所有的函数对象的 <code>__proto__</code> 都是 Function.prototype。Object.prototype 和 Function.prototype 仅仅是挂载在 Object 和 Function 函数对象之上。</p>\n\n<p>函数对象（除了bind产生的函数对象）外，都有一个 prototype 挂载到对应的函数对象之上，这些原型对象都是由 Object 构造，包含一个 constructor 属性指向自身。所以原型对象的 <code>__proto__</code> 指向的是 Object.prototype。</p>\n\n<p>函数对象作为构造器，创造了各式各样的实例对象，这些实例对象包含一个 <code>__proto__</code> 指向构造其的函数对象的原型对象。</p>\n\n<p>从上面的分析我们可以得到下面的结论：</p>\n\n<ul>\n<li>实例对象.<code>__proto__</code> -> 构造器（函数对象）.prototype</li>\n<li>函数对象.<code>__proto__</code> -> Function.prototype</li>\n<li>原型对象.<code>__proto__</code> -> Object.prototype</li>\n<li>实例对象、原型对象没有原型对象</li>\n<li>默认函数对象的原型对象 prototype = new Object()，prototype.contrustor = 函数对象本身。原生对象的 prototype 都是其自己的空实例。</li>\n<li>在继承场景中 new Object 可以是其它的对象，比如 Cat.prototype = new Dog，这样的原型对象相当于一个实例对象，此时 <code>__proto__</code> 不再是构造器（函数对象），而是实例对象，这个实例对象的 <code>__proto__</code> 指向构造器（函数对象）.prototype 或 实例对象，以此轮回形成了继承的原型链。</li>\n</ul>\n\n<p>这么看来其实实例对象和原型对象其实差不多，实例对象也可以作为原型对象，只不过默认的原型对象它的原型是 Object.prototype。用实例作为原型对象是为了继承。</p>\n\n<p>因为为了实现继承，我们通常会覆盖构造器函数对象的 prototype 属性，让它指向一个实例对象或直接指向另一个构造器函数对象的 prototype 属性。前一种情况而这个实例对象 <code>__proto__</code> 属性又指向了其构造器函数对象的 prototype，使得我们新创建的对象继承了来自这个 prototype 的属性和方法。后一种情况则是直接把 prototype 的属性进行了替换。</p>\n\n<p>上面第一种情况比较耗费内存；第二种情况导致两个 prototype 耦合。因此我们通常使用一个空中介的方式来实现继承。</p>\n\n<p>这样下来清楚多了！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474951618994,"created_by":1,"updated_at":1475023846878,"updated_by":1,"published_at":1474957173992,"published_by":1},{"id":92,"uuid":"47271107-dc71-4224-a489-dc203edaadf2","title":"js Array 对象","slug":"js-array-dui-xiang","markdown":"首先啊，对一个属性名 P（字符串形式），当且仅当 ToString(ToUint32(P)) 等于 P 并且 ToUint32(P) 不等于 232−1 时，它是个数组索引。\n\n其次啊，当我们个数组对象的 length 赋值时，如果 length 大于现在的 length，那么就会在后面添加 undefined；小于则会把后面的元素都删掉。\n\n#### 作为函数调用 Array 构造器\n\n当将 Array 作为函数来调用，而不是作为构造器，它会创建并初始化一个新数组对象。所以函数调用 Array(…) 与用相同参数的 new Array(…) 表达式创建的对象相同。\n\n#### Array 构造器\n\n##### 参数不是一个\n\n当且仅当以无参数或至少两个参数调用 Array 构造器时，适用这里的描述。\n\n新构造对象的 [[Prototype]] 内部属性要设定为原始的数组原型对象，他是 Array.prototype 的初始值。\n\n新构造对象的 [[Class]] 内部属性要设定为 \"Array\"。\n\n新构造对象的 [[Extensible]] 内部属性要设定为 true。\n\n新构造对象的 length 属性要设定为参数的个数。\n\n新构造对象的 0 属性要设定为 item0( 如果提供了 ); 新构造对象的 1 属性要设定为 item1( 如果提供了 ); 更多的参数可应用普遍规律，新构造对象的 k 属性要设定为第 k 个参数，这里的 k 是从 0 开始的。所有这些属性都有特性 {[[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}。\n\n##### 只有一个参数\n\n新构造对象的 [[Prototype]] 内部属性要设定为原始的数组原型对象，他是 Array.prototype 的初始值。新构造对象的 [[Class]] 内部属性要设定为 \"Array\"。新构造对象的 [[Extensible]] 内部属性要设定为 true。\n\n如果参数 len 是个数字值并且 ToUint32(len) 等于 len，则新构造对象的 length 属性要设定为 ToUint32(len)。如果参数 len 是个数字值并且 ToUint32(len) 不等于 len，则抛出一个 RangeError 异常。\n\n如果参数 len 不是数字值，则新构造对象的 length 属性要设定为 1，并且新构造对象的 0 属性要设定为 len，设定它的特性为 {[[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}。\n\n#### Array 构造器的属性\n\nArray 构造器的 [[Prototype]] 内部属性值是函数原型对象。\n\nArray 构造器除了有一些内部属性和 length 属性（其值是 1）之外，还有如下属性：\n\n##### Array.prototype\n\nArray.prototype 的初始值是数组原型对象。\n\n此属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}。\n\n##### Array.isArray ( arg )\n\n根据 [[Class]] 内部属性值是 \"Array\" 来判断。\n\n#### 数组原型对象的属性\n\n数组原型对象的 [[Prototype]] 内部属性值是标准内置 Object 原型对象。\n\n数组原型对象自身是个数组；它的 [[Class]] 是 \"Array\"，它拥有一个 length 属性（初始值是 +0）和特殊的 [[DefineOwnProperty]] 内部方法。\n\n在以下的对数组原型对象的属性函数的描述中，短语“this 对象”指的是调用这个函数时的 this 值对象。允许 this 是 [[Class]] 内部属性值不是 \"Array\" 的对象。\n\n##### Array.prototype.constructor\n\nArray.prototype.constructor 的初始值是标准内置 Array 构造器。\n\n##### Array.prototype.toString ( )\n\n当调用 toString 方法，采用如下步骤：\n\n1. 令 array 为用 this 值调用 ToObject 的结果。\n2. 令 func 为以 \"join\" 作为参数调用 array 的 [[Get]] 内部方法的结果。\n3. 如果 IsCallable(func) 是 false, 则令 func 为标准内置方法 Object.prototype.toString。\n4. 提供 array 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法，返回结果。\n\n##### Array.prototype.toLocaleString()\n\ntoLocaleString() 返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 \",\"）隔开。\n\n```\nvar number = 1337;\nvar date = new Date();\nvar myArr = [number, date, \"foo\"];\n\nvar str = myArr.toLocaleString(); \n\nconsole.log(str); \n// 输出 \"1337,2015/2/27 下午8:29:04,foo\" \n// 假定运行在中文（zh-CN）环境，北京时区\n```\n\n##### Array.prototype.concat([item1 [,item2 [,…]]] )\n\nconcat() 方法将传入的数组或非数组值与原数组合并，组成一个新的数组并返回。\n\n##### Array.prototype.join(separator)\n\njoin() 方法将数组中的所有元素连接成一个字符串。separator 为连接符。\n\n> 性能要比 \"+\" 要好。\n\n##### Array.prototype.pop()\n\npop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。\n\n##### Array.prototype.push([item1 [, item2[, … ]]])\n\npush() 方法添加一个或多个元素到数组的末尾，并返回数组新的长度（length 属性值）。\n\n> push 遇到数组参数时，把整个数组参数作为一个元素；而 concat 则是拆开数组参数，一个元素一个元素地加进去。push 直接改变当前数组；concat 不改变当前数组。\n\n##### Array.prototype.reverse()\n\nreverse() 方法颠倒数组中元素的位置。第一个元素会成为最后一个，最后一个会成为第一个。返回该数组的引用。\n\n##### Array.prototype.shift()\n\nshift() 方法删除数组的第一个元素，并返回这个元素。该方法会改变数组的长度。\n\n##### Array.prototype.slice(start, end)\n\nslice() 方法会浅复制（shallow copy）数组的一部分到一个新的数组，并返回这个新数组。start 或 end 为负，表示倒数第几个，start 省略表示从0开始，end 省略表示到结尾。\n\n由于是浅复制，所以如果是引用类型，那么会相互影响，值类型则不会。\n\n最常用的用法就是把类数组对象转换为数组对象，例如 Arguments 对象。对于类数组对象，后面会专门写一篇来讲。\n\n##### Array.prototype.splice(start, deleteCount[, item1[, item2[, …]]])\n\nsplice() 方法用新元素替换旧元素，以此修改数组的内容。表示从第 start 开始删除 deleteCount 个元素，然后再插入第三个参数指定的内容，没有指定则只进行删除。\n\n##### Array.prototype.unshift([item1[, item2[, …]]])\n\nunshift() 方法在数组的开头添加一个或者多个元素，并返回数组新的 length 值。\n\n##### Array.prototype.indexOf(searchElement[, fromIndex])\n\nindexOf()方法返回给定元素能找在数组中找到的第一个索引值，否则返回-1。fromIndex 开始查找的下标，默认为0。searchElement 表示查找的元素。\n\n> 严格比较。\n\n##### Array.prototype.lastIndexOf(searchElement[, fromIndex])\n\nlastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。\n\n> 严格比较。\n\n##### 小结\n\n因为下面都是高阶函数，所以现在这里小结一下。\n\n我们可以看到 Array.prototype 的所有方法都被设计成通用的，也就是可以应用在类数组对象之上。\n\n其次这里要划分一下，哪些方法是会改变元素组，哪些是返回新数组。改变原数组的方法有以下几个：push、pop、shift、unshift、reverse、splice；返回新数组的有：concat、slice；其余的几个是获取数组的一些信息的。\n\n##### 高阶函数\n\n好，接下来继续讲高阶函数，因为 js 中函数是第一类对象，所以它既可以做参数、又可以当返回值。高阶函数就是以函数为参数的函数。es 引用了很多有用的高阶函数。\n\n##### Array.prototype.sort(comparefn)\n\nsort() 方法对数组的元素做原地的排序，并返回这个数组。sort 排序可能是不稳定的。（稳定与否指的是相同的元素在排序前后的相对位置是否改变）默认按照字符串的Unicode码位点（code point）排序。\n\n- 如果指明了 comparefn ，那么数组会按照调用该函数的返回值排序。记 a 和 b 是两个将要被比较的元素：\n- 如果 comparefn(a, b) 小于 0 ，那么 a 会被排列到 b 之前；\n- 如果 comparefn(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；\n- 如果 comparefn(a, b) 大于 0 ， b 会被排列到 a 之前。\n- comparefn(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。\n\n在网上看到一个面试题：js实现：一个数组，把奇数放到右边，偶数放到左边，不许使用额外空间。\n\n用 sort 一句话搞定：\n\n```\narr.sort((a,b) => { return a%2!=0 })\n```\n\n##### Array.prototype.every(callbackfn[, thisArg])\n\nevery() 方法测试数组的所有元素是否都通过了指定函数的测试。\n\nevery 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。\n\ncallback 被调用时传入三个参数：元素值，元素的索引，原数组。\n\n如果为 every 提供一个 thisArg 参数，在该参数为调用 callback 时的 this 值。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。\n\nevery 不会改变原数组。\n\nevery 遍历的元素范围在第一次调用 callback 之前就已确定了。在调用 every 之后添加到数组中的元素不会被 callback 访问到。如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。\n\n##### Array.prototype.some(callbackfn[, thisArg])\n\nsome 和 every类似，唯一的区别是 some 只要存在一个检测同过，返回的值就是 true。\n\n##### Array.prototype.forEach(callbackfn[, thisArg])\n\nforEach() 方法让数组的每一项都执行一次给定的函数。\n\nforEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者从未赋值的项将被跳过（但不包括哪些值为 undefined 的项）。\n\ncallback 函数会被依次传入三个参数：\n\n- 数组当前项的值\n- 数组当前项的索引\n- 数组对象本身\n\n如果给forEach传递了thisArg 参数，它将作为 callback 函数的执行上下文，类似执行如下函数callback.call(thisArg, element, index, array)。如果 thisArg 值为 undefined 或 null，函数的 this 值取决于当前执行环境是否为严格模式（严格模式下为 undefined，非严格模式下为全局对象）。\n\nforEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。\n\n> 在 node 下分别用 for 和 forEach 遍历长度不同长度的数组，发现小数组（万以内）forEach效率高，但是随着数组变大 forEach 下降特别厉害。因此我们平时的数据使用 forEach 较好。\n\n##### Array.prototype.map(callbackfn[, thisArg])\n\nmap() 方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。\n\n参数及规则和 forEach 类似。\n\n##### Array.prototype.filter(callbackfn[, thisArg])\n\nfilter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。\n\n参数及规则和 forEach 类似。\n\n##### Array.prototype.reduce(callbackfn[, initialValue])\n\nreduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。\n\nreduce 的 callbackfn 和前面的几个有些不同。\n\nreduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。\n\n回调函数第一次执行时，previousValue 和 currentValue 的取值有两种情况，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。\n\n如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。\n\n##### Array.prototype.reduceRight(callbackfn[, initialValue])\n\nreduceRight() 方法接受一个函数作为累加器（accumulator），让每个值（从右到左，亦即从尾到头）缩减为一个值。（与 reduce() 的执行方向相反）。除了方向其余和 reduce 相同。\n\n最早的一篇文章讲到 redux 中的 compose 组合函数，那时候提到过 reduceRight。来温故一下那段代码吧！\n\n```\nexport default function compose(...funcs) {\n  // 没有要组合的函数，则返回一个原样范围参数的函数\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  // 只有一个函数，则直接返回该函数\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  // 取出最后一个函数\n  const last = funcs[funcs.length - 1]\n  // 取出其余的函数，转为数组\n  const rest = funcs.slice(0, -1)\n  // 以最后一个函数调用参数为初始值，进行reduce，每次都会把右边的一个函数执行的结果传入当前的函数执行，一直重复，达到函数组合的目的\n  return (...args) => rest.reduceRight((composed, f) => f(composed), last(...args))\n}\n```\n\n##### 小结\n\n高阶函数同样也是通用设计，为类数组对象服务。\n\n其次在划分一下那些是会改动原数组的：sort。返回新数组：map、filter。forEach、every、some、reduce、reduceRight不会改动原数组，返回一个值。\n\n#### Array 实例的属性\n\nArray 实例从数组原型对象继承属性，Array 实例的 [[Class]] 内部属性是 \"Array\"。Array 实例还有以下属性。\n\n##### [[DefineOwnProperty]](P, Desc, Throw)\n\n略\n\n##### length\n\n数组对象的 length 属性是个数据属性，其值总是在数值上大于任何属性名是数组索引的可删除属性的属性名。\n\nlength 属性拥有的初始特性是 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","html":"<p>首先啊，对一个属性名 P（字符串形式），当且仅当 ToString(ToUint32(P)) 等于 P 并且 ToUint32(P) 不等于 232−1 时，它是个数组索引。</p>\n\n<p>其次啊，当我们个数组对象的 length 赋值时，如果 length 大于现在的 length，那么就会在后面添加 undefined；小于则会把后面的元素都删掉。</p>\n\n<h4 id=\"array\">作为函数调用 Array 构造器</h4>\n\n<p>当将 Array 作为函数来调用，而不是作为构造器，它会创建并初始化一个新数组对象。所以函数调用 Array(…) 与用相同参数的 new Array(…) 表达式创建的对象相同。</p>\n\n<h4 id=\"array\">Array 构造器</h4>\n\n<h5 id=\"\">参数不是一个</h5>\n\n<p>当且仅当以无参数或至少两个参数调用 Array 构造器时，适用这里的描述。</p>\n\n<p>新构造对象的 [[Prototype]] 内部属性要设定为原始的数组原型对象，他是 Array.prototype 的初始值。</p>\n\n<p>新构造对象的 [[Class]] 内部属性要设定为 \"Array\"。</p>\n\n<p>新构造对象的 [[Extensible]] 内部属性要设定为 true。</p>\n\n<p>新构造对象的 length 属性要设定为参数的个数。</p>\n\n<p>新构造对象的 0 属性要设定为 item0( 如果提供了 ); 新构造对象的 1 属性要设定为 item1( 如果提供了 ); 更多的参数可应用普遍规律，新构造对象的 k 属性要设定为第 k 个参数，这里的 k 是从 0 开始的。所有这些属性都有特性 {[[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}。</p>\n\n<h5 id=\"\">只有一个参数</h5>\n\n<p>新构造对象的 [[Prototype]] 内部属性要设定为原始的数组原型对象，他是 Array.prototype 的初始值。新构造对象的 [[Class]] 内部属性要设定为 \"Array\"。新构造对象的 [[Extensible]] 内部属性要设定为 true。</p>\n\n<p>如果参数 len 是个数字值并且 ToUint32(len) 等于 len，则新构造对象的 length 属性要设定为 ToUint32(len)。如果参数 len 是个数字值并且 ToUint32(len) 不等于 len，则抛出一个 RangeError 异常。</p>\n\n<p>如果参数 len 不是数字值，则新构造对象的 length 属性要设定为 1，并且新构造对象的 0 属性要设定为 len，设定它的特性为 {[[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}。</p>\n\n<h4 id=\"array\">Array 构造器的属性</h4>\n\n<p>Array 构造器的 [[Prototype]] 内部属性值是函数原型对象。</p>\n\n<p>Array 构造器除了有一些内部属性和 length 属性（其值是 1）之外，还有如下属性：</p>\n\n<h5 id=\"arrayprototype\">Array.prototype</h5>\n\n<p>Array.prototype 的初始值是数组原型对象。</p>\n\n<p>此属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}。</p>\n\n<h5 id=\"arrayisarrayarg\">Array.isArray ( arg )</h5>\n\n<p>根据 [[Class]] 内部属性值是 \"Array\" 来判断。</p>\n\n<h4 id=\"\">数组原型对象的属性</h4>\n\n<p>数组原型对象的 [[Prototype]] 内部属性值是标准内置 Object 原型对象。</p>\n\n<p>数组原型对象自身是个数组；它的 [[Class]] 是 \"Array\"，它拥有一个 length 属性（初始值是 +0）和特殊的 [[DefineOwnProperty]] 内部方法。</p>\n\n<p>在以下的对数组原型对象的属性函数的描述中，短语“this 对象”指的是调用这个函数时的 this 值对象。允许 this 是 [[Class]] 内部属性值不是 \"Array\" 的对象。</p>\n\n<h5 id=\"arrayprototypeconstructor\">Array.prototype.constructor</h5>\n\n<p>Array.prototype.constructor 的初始值是标准内置 Array 构造器。</p>\n\n<h5 id=\"arrayprototypetostring\">Array.prototype.toString ( )</h5>\n\n<p>当调用 toString 方法，采用如下步骤：</p>\n\n<ol>\n<li>令 array 为用 this 值调用 ToObject 的结果。  </li>\n<li>令 func 为以 \"join\" 作为参数调用 array 的 [[Get]] 内部方法的结果。  </li>\n<li>如果 IsCallable(func) 是 false, 则令 func 为标准内置方法 Object.prototype.toString。  </li>\n<li>提供 array 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法，返回结果。</li>\n</ol>\n\n<h5 id=\"arrayprototypetolocalestring\">Array.prototype.toLocaleString()</h5>\n\n<p>toLocaleString() 返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 \",\"）隔开。</p>\n\n<pre><code>var number = 1337;  \nvar date = new Date();  \nvar myArr = [number, date, \"foo\"];\n\nvar str = myArr.toLocaleString(); \n\nconsole.log(str);  \n// 输出 \"1337,2015/2/27 下午8:29:04,foo\" \n// 假定运行在中文（zh-CN）环境，北京时区\n</code></pre>\n\n<h5 id=\"arrayprototypeconcatitem1item2\">Array.prototype.concat([item1 [,item2 [,…]]] )</h5>\n\n<p>concat() 方法将传入的数组或非数组值与原数组合并，组成一个新的数组并返回。</p>\n\n<h5 id=\"arrayprototypejoinseparator\">Array.prototype.join(separator)</h5>\n\n<p>join() 方法将数组中的所有元素连接成一个字符串。separator 为连接符。</p>\n\n<blockquote>\n  <p>性能要比 \"+\" 要好。</p>\n</blockquote>\n\n<h5 id=\"arrayprototypepop\">Array.prototype.pop()</h5>\n\n<p>pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。</p>\n\n<h5 id=\"arrayprototypepushitem1item2\">Array.prototype.push([item1 [, item2[, … ]]])</h5>\n\n<p>push() 方法添加一个或多个元素到数组的末尾，并返回数组新的长度（length 属性值）。</p>\n\n<blockquote>\n  <p>push 遇到数组参数时，把整个数组参数作为一个元素；而 concat 则是拆开数组参数，一个元素一个元素地加进去。push 直接改变当前数组；concat 不改变当前数组。</p>\n</blockquote>\n\n<h5 id=\"arrayprototypereverse\">Array.prototype.reverse()</h5>\n\n<p>reverse() 方法颠倒数组中元素的位置。第一个元素会成为最后一个，最后一个会成为第一个。返回该数组的引用。</p>\n\n<h5 id=\"arrayprototypeshift\">Array.prototype.shift()</h5>\n\n<p>shift() 方法删除数组的第一个元素，并返回这个元素。该方法会改变数组的长度。</p>\n\n<h5 id=\"arrayprototypeslicestartend\">Array.prototype.slice(start, end)</h5>\n\n<p>slice() 方法会浅复制（shallow copy）数组的一部分到一个新的数组，并返回这个新数组。start 或 end 为负，表示倒数第几个，start 省略表示从0开始，end 省略表示到结尾。</p>\n\n<p>由于是浅复制，所以如果是引用类型，那么会相互影响，值类型则不会。</p>\n\n<p>最常用的用法就是把类数组对象转换为数组对象，例如 Arguments 对象。对于类数组对象，后面会专门写一篇来讲。</p>\n\n<h5 id=\"arrayprototypesplicestartdeletecountitem1item2\">Array.prototype.splice(start, deleteCount[, item1[, item2[, …]]])</h5>\n\n<p>splice() 方法用新元素替换旧元素，以此修改数组的内容。表示从第 start 开始删除 deleteCount 个元素，然后再插入第三个参数指定的内容，没有指定则只进行删除。</p>\n\n<h5 id=\"arrayprototypeunshiftitem1item2\">Array.prototype.unshift([item1[, item2[, …]]])</h5>\n\n<p>unshift() 方法在数组的开头添加一个或者多个元素，并返回数组新的 length 值。</p>\n\n<h5 id=\"arrayprototypeindexofsearchelementfromindex\">Array.prototype.indexOf(searchElement[, fromIndex])</h5>\n\n<p>indexOf()方法返回给定元素能找在数组中找到的第一个索引值，否则返回-1。fromIndex 开始查找的下标，默认为0。searchElement 表示查找的元素。</p>\n\n<blockquote>\n  <p>严格比较。</p>\n</blockquote>\n\n<h5 id=\"arrayprototypelastindexofsearchelementfromindex\">Array.prototype.lastIndexOf(searchElement[, fromIndex])</h5>\n\n<p>lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。</p>\n\n<blockquote>\n  <p>严格比较。</p>\n</blockquote>\n\n<h5 id=\"\">小结</h5>\n\n<p>因为下面都是高阶函数，所以现在这里小结一下。</p>\n\n<p>我们可以看到 Array.prototype 的所有方法都被设计成通用的，也就是可以应用在类数组对象之上。</p>\n\n<p>其次这里要划分一下，哪些方法是会改变元素组，哪些是返回新数组。改变原数组的方法有以下几个：push、pop、shift、unshift、reverse、splice；返回新数组的有：concat、slice；其余的几个是获取数组的一些信息的。</p>\n\n<h5 id=\"\">高阶函数</h5>\n\n<p>好，接下来继续讲高阶函数，因为 js 中函数是第一类对象，所以它既可以做参数、又可以当返回值。高阶函数就是以函数为参数的函数。es 引用了很多有用的高阶函数。</p>\n\n<h5 id=\"arrayprototypesortcomparefn\">Array.prototype.sort(comparefn)</h5>\n\n<p>sort() 方法对数组的元素做原地的排序，并返回这个数组。sort 排序可能是不稳定的。（稳定与否指的是相同的元素在排序前后的相对位置是否改变）默认按照字符串的Unicode码位点（code point）排序。</p>\n\n<ul>\n<li>如果指明了 comparefn ，那么数组会按照调用该函数的返回值排序。记 a 和 b 是两个将要被比较的元素：</li>\n<li>如果 comparefn(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</li>\n<li>如果 comparefn(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；</li>\n<li>如果 comparefn(a, b) 大于 0 ， b 会被排列到 a 之前。</li>\n<li>comparefn(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。</li>\n</ul>\n\n<p>在网上看到一个面试题：js实现：一个数组，把奇数放到右边，偶数放到左边，不许使用额外空间。</p>\n\n<p>用 sort 一句话搞定：</p>\n\n<pre><code>arr.sort((a,b) =&gt; { return a%2!=0 })  \n</code></pre>\n\n<h5 id=\"arrayprototypeeverycallbackfnthisarg\">Array.prototype.every(callbackfn[, thisArg])</h5>\n\n<p>every() 方法测试数组的所有元素是否都通过了指定函数的测试。</p>\n\n<p>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。</p>\n\n<p>callback 被调用时传入三个参数：元素值，元素的索引，原数组。</p>\n\n<p>如果为 every 提供一个 thisArg 参数，在该参数为调用 callback 时的 this 值。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。</p>\n\n<p>every 不会改变原数组。</p>\n\n<p>every 遍历的元素范围在第一次调用 callback 之前就已确定了。在调用 every 之后添加到数组中的元素不会被 callback 访问到。如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。</p>\n\n<h5 id=\"arrayprototypesomecallbackfnthisarg\">Array.prototype.some(callbackfn[, thisArg])</h5>\n\n<p>some 和 every类似，唯一的区别是 some 只要存在一个检测同过，返回的值就是 true。</p>\n\n<h5 id=\"arrayprototypeforeachcallbackfnthisarg\">Array.prototype.forEach(callbackfn[, thisArg])</h5>\n\n<p>forEach() 方法让数组的每一项都执行一次给定的函数。</p>\n\n<p>forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者从未赋值的项将被跳过（但不包括哪些值为 undefined 的项）。</p>\n\n<p>callback 函数会被依次传入三个参数：</p>\n\n<ul>\n<li>数组当前项的值</li>\n<li>数组当前项的索引</li>\n<li>数组对象本身</li>\n</ul>\n\n<p>如果给forEach传递了thisArg 参数，它将作为 callback 函数的执行上下文，类似执行如下函数callback.call(thisArg, element, index, array)。如果 thisArg 值为 undefined 或 null，函数的 this 值取决于当前执行环境是否为严格模式（严格模式下为 undefined，非严格模式下为全局对象）。</p>\n\n<p>forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。</p>\n\n<blockquote>\n  <p>在 node 下分别用 for 和 forEach 遍历长度不同长度的数组，发现小数组（万以内）forEach效率高，但是随着数组变大 forEach 下降特别厉害。因此我们平时的数据使用 forEach 较好。</p>\n</blockquote>\n\n<h5 id=\"arrayprototypemapcallbackfnthisarg\">Array.prototype.map(callbackfn[, thisArg])</h5>\n\n<p>map() 方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。</p>\n\n<p>参数及规则和 forEach 类似。</p>\n\n<h5 id=\"arrayprototypefiltercallbackfnthisarg\">Array.prototype.filter(callbackfn[, thisArg])</h5>\n\n<p>filter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。</p>\n\n<p>参数及规则和 forEach 类似。</p>\n\n<h5 id=\"arrayprototypereducecallbackfninitialvalue\">Array.prototype.reduce(callbackfn[, initialValue])</h5>\n\n<p>reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。</p>\n\n<p>reduce 的 callbackfn 和前面的几个有些不同。</p>\n\n<p>reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。</p>\n\n<p>回调函数第一次执行时，previousValue 和 currentValue 的取值有两种情况，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。</p>\n\n<p>如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。</p>\n\n<h5 id=\"arrayprototypereducerightcallbackfninitialvalue\">Array.prototype.reduceRight(callbackfn[, initialValue])</h5>\n\n<p>reduceRight() 方法接受一个函数作为累加器（accumulator），让每个值（从右到左，亦即从尾到头）缩减为一个值。（与 reduce() 的执行方向相反）。除了方向其余和 reduce 相同。</p>\n\n<p>最早的一篇文章讲到 redux 中的 compose 组合函数，那时候提到过 reduceRight。来温故一下那段代码吧！</p>\n\n<pre><code>export default function compose(...funcs) {  \n  // 没有要组合的函数，则返回一个原样范围参数的函数\n  if (funcs.length === 0) {\n    return arg =&gt; arg\n  }\n\n  // 只有一个函数，则直接返回该函数\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  // 取出最后一个函数\n  const last = funcs[funcs.length - 1]\n  // 取出其余的函数，转为数组\n  const rest = funcs.slice(0, -1)\n  // 以最后一个函数调用参数为初始值，进行reduce，每次都会把右边的一个函数执行的结果传入当前的函数执行，一直重复，达到函数组合的目的\n  return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))\n}\n</code></pre>\n\n<h5 id=\"\">小结</h5>\n\n<p>高阶函数同样也是通用设计，为类数组对象服务。</p>\n\n<p>其次在划分一下那些是会改动原数组的：sort。返回新数组：map、filter。forEach、every、some、reduce、reduceRight不会改动原数组，返回一个值。</p>\n\n<h4 id=\"array\">Array 实例的属性</h4>\n\n<p>Array 实例从数组原型对象继承属性，Array 实例的 [[Class]] 内部属性是 \"Array\"。Array 实例还有以下属性。</p>\n\n<h5 id=\"defineownpropertypdescthrow\"><a href=\"P, Desc, Throw\">[DefineOwnProperty]</a></h5>\n\n<p>略</p>\n\n<h5 id=\"length\">length</h5>\n\n<p>数组对象的 length 属性是个数据属性，其值总是在数值上大于任何属性名是数组索引的可删除属性的属性名。</p>\n\n<p>length 属性拥有的初始特性是 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }.</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1474959993304,"created_by":1,"updated_at":1475051042200,"updated_by":1,"published_at":1474975853318,"published_by":1},{"id":93,"uuid":"d3115c6e-4a91-4c40-a881-41fb838165c8","title":"js String对象","slug":"js-string-dui-xiang","markdown":"#### 作为函数调用 String 构造器\n\n当将 String 作为函数调用，而不是作为构造器，它执行一个类型转换。\n\n返回一个由 ToString(value) 计算出的字符串值（不是 String 对象）。如果没有提供 value，返回空字符串 \"\"。\n\n#### String 构造器\n\n当 String 作为一个 new 表达式的一部分被调用，它是个构造器：它初始化新创建的对象。\n\n新构造对象的 [[Prototype]] 内部属性设定为标准内置的字符串原型对象，它是 String.prototype 的初始值 (15.5.3.1)。\n\n新构造对象的 [[Class]] 内部属性设定为 \"String\"。\n\n新构造对象的 [[Extensible]] 内部属性设定为 true。\n\n新构造对象的 [[PrimitiveValue]] 内部属性设定为 ToString(value)，或如果没提供 value 则设定为空字符串。\n\n#### String 构造器的属性\n\nString 构造器的 [[Prototype]] 内部属性的值是标准内置的函数原型对象。\n\n除了内部属性和 length 属性（值为 1）之外，String 构造器还有以下属性：\n\n##### String.prototype\n\nString.prototype 的初始值是标准内置的字符串原型对象。\n\n这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n##### String.fromCharCode([char0[, char1[, …]]])\n\n返回一个字符串值，包含的字符数与参数数目相同。每个参数指定返回字符串中的一个字符，也就是说第一个参数第一个字符，以此类推（从左到右）。一个参数转换为一个字符，通过先应用 ToUint16 操作，再将返回的 16 位整数看作字符的代码单元值。如果没提供参数，返回空字符串。\n\nfromCharCode 函数的 length 属性是 1。\n\n> 因为 js 内部的字符使用2个字节的 UTF-16，准确说是 USC-2 表示的，因此要把码点 ToUint16 ，这也是唯一用到 ToUint16 的地方。\n\n#### 字符串原型对象的属性\n\n字符串原型对象本身是一个值为空字符串的 String 对象（它的 [[Class]] 是 \"String\"）。\n\n字符串原型对象的 [[Prototype]] 内部属性值是标准内置的 Object 原型对象。\n\n##### String.prototype.constructor\n\nString.prototype.constructor 的初始值是内置 String 构造器。\n\n##### String.prototype.toString()\n\n返回 this 字符串值。（注，对于一个 String 对象，toString 方法和 valueOf 方法返回相同值。）\n\ntoString 函数是非通用的 ; 如果它的 this 值不是一个字符串或字符串对象，则抛出一个 TypeError 异常。因此它不能作为方法转移到其他类型对象上。\n\n##### String.prototype.valueOf()\n\n返回 this 字符串值。\n\nvalueOf 函数是非通用的 ; 如果它的 this 值不是一个字符串或字符串对象，则抛出一个 TypeError 异常。因此它不能作为方法转移到其他类型对象上。\n\n##### String.prototype.charAt(pos)\n\ncharAt() 方法返回字符串中指定位置的字符。\n\n> 这个方法只支持2字节的字符，对于需要4个字节储存的字符，（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。es6 有了 codePointAt()方法来正确处理带 4 字节的字符。会在后面的 es6 系列文章进行介绍。\n\n##### String.prototype.charCodeAt(pos)\n\ncharCodeAt() 方法返回0到65535之间的整数，代表索引处字符的UTF-16编码单元。\n\n> 和上面的方法有同样的问题，就是无法处理非基本平面的Unicode编码单元如果你希望得到整点编码值，使用 es6 的 codePointAt()。\n\n##### String.prototype.concat([string1[, string2[, …]]])\n\nconcat() 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。\n\n但是 MDN 上看到强烈建议使用赋值操作符（+, +=）代替 concat 方法。参看 [性能测试（perfomance test）](https://jsperf.com/concat-vs-plus-vs-join)。\n\n##### String.prototype.indexOf(searchString, position)\n\nindexOf() 方法返回指定值在字符串对象中首次出现的位置。从 fromIndex 位置开始查找，如果不存在，则返回 -1。（区分大小写）\n\n##### String.prototype.lastIndexOf(searchString, position)\n\nlastIndexOf() 方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。从该字符串的后面向前查找，从 fromIndex 处开始。（区分大小写）\n\n##### String.prototype.localeCompare(that)\n\nlocaleCompare() 方法返回一个数字来表明调用该函数的字符串（reference string）的排列顺序是否在某个给定的字符串的前面或者后面，或者是一样的（编码中的位置）。\n\n> 这也目前看到的提一个与国际化相关的方法，国际化会专门写一篇的。\n\n##### String.prototype.match(regexp)\n\n见正则表达式一文。\n\n##### String.prototype.replace(searchValue, replaceValue)\n\n见正则表达式一文。\n\n##### String.prototype.search (regexp)\n\n见正则表达式一文。\n\n##### String.prototype.split(separator, limit)\n\n见正则表达式一文。\n\n##### String.prototype.slice (start, end)\n\nslice() 从一个字符串中提取字符串并返回新字符串。在一个字符串中的改变不会影响另一个字符串。也就是说，slice 不修改原字符串，只会返回一个包含了原字符串中部分字符的新字符串。\n\nslice() 提取新字符串但不包括 endSlice。str.slice(1, 4) 提起新字符串从第二个字符到第四个 (字符索引值为 1, 2, 和 3)。\n\n##### String.prototype.substring(start, end)\n\n和 slice 差不多，不过有几个区别，首先是对于负值会直接转化为0，start大于end会交换两个的值。这些涉及坐标的一般都是前闭后开的。\n\n##### String.prototype.toLowerCase()\n\ntoLowerCase 会将调用该方法的字符串值转为小写形式，并返回。toLowerCase 不会影响字符串本身的值。\n\n##### String.prototype.toLocaleLowerCase()\n\ntoLocaleLowerCase()方法返回调用该方法的字符串被转换成小写之后的值，转换规则根据任何本地化特定的大小写映射。toLocaleLowerCase()并不会影响字符串自身的值。在大多数情况下，该方法产生的结果和调用toLowerCase()的结果相同，但是在某些本地环境中，比如土耳其语，它的大小写映射并不遵循在Unicode中的默认的大小写映射，因此会有一个不同的结果。\n\n##### String.prototype.toUpperCase()\n\n类似 toLowerCase 方法。\n\n##### String.prototype.toLocaleUpperCase()\n\n类似 toLocaleLowerCase 方法。\n\n##### String.prototype.trim()\n\ntrim() 方法会删除一个字符串两端的空白字符。在这个字符串里的空格包括所有的空格字符 (space, tab, no-break space 等)以及所有的行结束符（如 LF，CR）。\n\n##### 小结\n\n上面的方法除了 valueOf、toString 都是被设计成通用的。\n\n另外还是要分一下：\n\n- 改变原字符串：toLowerCase、toUpperCase、toLocaleLowerCase、toLocaleUpperCase。\n- 产生新串：concat、slice、substring、trim。\n\n#### String 实例的属性\n\n\n字符串实例从字符串原型对象继承属性，字符串实例的 [[Class]] 内部属性值是 \"String\"。字符串实例还有 [[PrimitiveValue]] 内部属性，length 属性，和一组属性名是数组索引的可遍历属性。\n\n[[PrimitiveValue]] 内部属性是代表这个字符串对象的字符串值。以数组索引命名的属性对应字符串值里的单字符。一个特殊的 [[GetOwnProperty]] 内部方法用来为数组索引命名的属性指定数字，值，和特性。\n\n##### length\n\n在代表这个字符串对象的字符串值里的字符数。\n\n一旦创建了一个字符串对象，这个属性是不可变的。它有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n##### [[GetOwnProperty]] (P)\n\n略。\n\n\n","html":"<h4 id=\"string\">作为函数调用 String 构造器</h4>\n\n<p>当将 String 作为函数调用，而不是作为构造器，它执行一个类型转换。</p>\n\n<p>返回一个由 ToString(value) 计算出的字符串值（不是 String 对象）。如果没有提供 value，返回空字符串 \"\"。</p>\n\n<h4 id=\"string\">String 构造器</h4>\n\n<p>当 String 作为一个 new 表达式的一部分被调用，它是个构造器：它初始化新创建的对象。</p>\n\n<p>新构造对象的 [[Prototype]] 内部属性设定为标准内置的字符串原型对象，它是 String.prototype 的初始值 (15.5.3.1)。</p>\n\n<p>新构造对象的 [[Class]] 内部属性设定为 \"String\"。</p>\n\n<p>新构造对象的 [[Extensible]] 内部属性设定为 true。</p>\n\n<p>新构造对象的 [[PrimitiveValue]] 内部属性设定为 ToString(value)，或如果没提供 value 则设定为空字符串。</p>\n\n<h4 id=\"string\">String 构造器的属性</h4>\n\n<p>String 构造器的 [[Prototype]] 内部属性的值是标准内置的函数原型对象。</p>\n\n<p>除了内部属性和 length 属性（值为 1）之外，String 构造器还有以下属性：</p>\n\n<h5 id=\"stringprototype\">String.prototype</h5>\n\n<p>String.prototype 的初始值是标准内置的字符串原型对象。</p>\n\n<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h5 id=\"stringfromcharcodechar0char1\">String.fromCharCode([char0[, char1[, …]]])</h5>\n\n<p>返回一个字符串值，包含的字符数与参数数目相同。每个参数指定返回字符串中的一个字符，也就是说第一个参数第一个字符，以此类推（从左到右）。一个参数转换为一个字符，通过先应用 ToUint16 操作，再将返回的 16 位整数看作字符的代码单元值。如果没提供参数，返回空字符串。</p>\n\n<p>fromCharCode 函数的 length 属性是 1。</p>\n\n<blockquote>\n  <p>因为 js 内部的字符使用2个字节的 UTF-16，准确说是 USC-2 表示的，因此要把码点 ToUint16 ，这也是唯一用到 ToUint16 的地方。</p>\n</blockquote>\n\n<h4 id=\"\">字符串原型对象的属性</h4>\n\n<p>字符串原型对象本身是一个值为空字符串的 String 对象（它的 [[Class]] 是 \"String\"）。</p>\n\n<p>字符串原型对象的 [[Prototype]] 内部属性值是标准内置的 Object 原型对象。</p>\n\n<h5 id=\"stringprototypeconstructor\">String.prototype.constructor</h5>\n\n<p>String.prototype.constructor 的初始值是内置 String 构造器。</p>\n\n<h5 id=\"stringprototypetostring\">String.prototype.toString()</h5>\n\n<p>返回 this 字符串值。（注，对于一个 String 对象，toString 方法和 valueOf 方法返回相同值。）</p>\n\n<p>toString 函数是非通用的 ; 如果它的 this 值不是一个字符串或字符串对象，则抛出一个 TypeError 异常。因此它不能作为方法转移到其他类型对象上。</p>\n\n<h5 id=\"stringprototypevalueof\">String.prototype.valueOf()</h5>\n\n<p>返回 this 字符串值。</p>\n\n<p>valueOf 函数是非通用的 ; 如果它的 this 值不是一个字符串或字符串对象，则抛出一个 TypeError 异常。因此它不能作为方法转移到其他类型对象上。</p>\n\n<h5 id=\"stringprototypecharatpos\">String.prototype.charAt(pos)</h5>\n\n<p>charAt() 方法返回字符串中指定位置的字符。</p>\n\n<blockquote>\n  <p>这个方法只支持2字节的字符，对于需要4个字节储存的字符，（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。es6 有了 codePointAt()方法来正确处理带 4 字节的字符。会在后面的 es6 系列文章进行介绍。</p>\n</blockquote>\n\n<h5 id=\"stringprototypecharcodeatpos\">String.prototype.charCodeAt(pos)</h5>\n\n<p>charCodeAt() 方法返回0到65535之间的整数，代表索引处字符的UTF-16编码单元。</p>\n\n<blockquote>\n  <p>和上面的方法有同样的问题，就是无法处理非基本平面的Unicode编码单元如果你希望得到整点编码值，使用 es6 的 codePointAt()。</p>\n</blockquote>\n\n<h5 id=\"stringprototypeconcatstring1string2\">String.prototype.concat([string1[, string2[, …]]])</h5>\n\n<p>concat() 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。</p>\n\n<p>但是 MDN 上看到强烈建议使用赋值操作符（+, +=）代替 concat 方法。参看 <a href=\"https://jsperf.com/concat-vs-plus-vs-join\">性能测试（perfomance test）</a>。</p>\n\n<h5 id=\"stringprototypeindexofsearchstringposition\">String.prototype.indexOf(searchString, position)</h5>\n\n<p>indexOf() 方法返回指定值在字符串对象中首次出现的位置。从 fromIndex 位置开始查找，如果不存在，则返回 -1。（区分大小写）</p>\n\n<h5 id=\"stringprototypelastindexofsearchstringposition\">String.prototype.lastIndexOf(searchString, position)</h5>\n\n<p>lastIndexOf() 方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。从该字符串的后面向前查找，从 fromIndex 处开始。（区分大小写）</p>\n\n<h5 id=\"stringprototypelocalecomparethat\">String.prototype.localeCompare(that)</h5>\n\n<p>localeCompare() 方法返回一个数字来表明调用该函数的字符串（reference string）的排列顺序是否在某个给定的字符串的前面或者后面，或者是一样的（编码中的位置）。</p>\n\n<blockquote>\n  <p>这也目前看到的提一个与国际化相关的方法，国际化会专门写一篇的。</p>\n</blockquote>\n\n<h5 id=\"stringprototypematchregexp\">String.prototype.match(regexp)</h5>\n\n<p>见正则表达式一文。</p>\n\n<h5 id=\"stringprototypereplacesearchvaluereplacevalue\">String.prototype.replace(searchValue, replaceValue)</h5>\n\n<p>见正则表达式一文。</p>\n\n<h5 id=\"stringprototypesearchregexp\">String.prototype.search (regexp)</h5>\n\n<p>见正则表达式一文。</p>\n\n<h5 id=\"stringprototypesplitseparatorlimit\">String.prototype.split(separator, limit)</h5>\n\n<p>见正则表达式一文。</p>\n\n<h5 id=\"stringprototypeslicestartend\">String.prototype.slice (start, end)</h5>\n\n<p>slice() 从一个字符串中提取字符串并返回新字符串。在一个字符串中的改变不会影响另一个字符串。也就是说，slice 不修改原字符串，只会返回一个包含了原字符串中部分字符的新字符串。</p>\n\n<p>slice() 提取新字符串但不包括 endSlice。str.slice(1, 4) 提起新字符串从第二个字符到第四个 (字符索引值为 1, 2, 和 3)。</p>\n\n<h5 id=\"stringprototypesubstringstartend\">String.prototype.substring(start, end)</h5>\n\n<p>和 slice 差不多，不过有几个区别，首先是对于负值会直接转化为0，start大于end会交换两个的值。这些涉及坐标的一般都是前闭后开的。</p>\n\n<h5 id=\"stringprototypetolowercase\">String.prototype.toLowerCase()</h5>\n\n<p>toLowerCase 会将调用该方法的字符串值转为小写形式，并返回。toLowerCase 不会影响字符串本身的值。</p>\n\n<h5 id=\"stringprototypetolocalelowercase\">String.prototype.toLocaleLowerCase()</h5>\n\n<p>toLocaleLowerCase()方法返回调用该方法的字符串被转换成小写之后的值，转换规则根据任何本地化特定的大小写映射。toLocaleLowerCase()并不会影响字符串自身的值。在大多数情况下，该方法产生的结果和调用toLowerCase()的结果相同，但是在某些本地环境中，比如土耳其语，它的大小写映射并不遵循在Unicode中的默认的大小写映射，因此会有一个不同的结果。</p>\n\n<h5 id=\"stringprototypetouppercase\">String.prototype.toUpperCase()</h5>\n\n<p>类似 toLowerCase 方法。</p>\n\n<h5 id=\"stringprototypetolocaleuppercase\">String.prototype.toLocaleUpperCase()</h5>\n\n<p>类似 toLocaleLowerCase 方法。</p>\n\n<h5 id=\"stringprototypetrim\">String.prototype.trim()</h5>\n\n<p>trim() 方法会删除一个字符串两端的空白字符。在这个字符串里的空格包括所有的空格字符 (space, tab, no-break space 等)以及所有的行结束符（如 LF，CR）。</p>\n\n<h5 id=\"\">小结</h5>\n\n<p>上面的方法除了 valueOf、toString 都是被设计成通用的。</p>\n\n<p>另外还是要分一下：</p>\n\n<ul>\n<li>改变原字符串：toLowerCase、toUpperCase、toLocaleLowerCase、toLocaleUpperCase。</li>\n<li>产生新串：concat、slice、substring、trim。</li>\n</ul>\n\n<h4 id=\"string\">String 实例的属性</h4>\n\n<p>字符串实例从字符串原型对象继承属性，字符串实例的 [[Class]] 内部属性值是 \"String\"。字符串实例还有 [[PrimitiveValue]] 内部属性，length 属性，和一组属性名是数组索引的可遍历属性。</p>\n\n<p>[[PrimitiveValue]] 内部属性是代表这个字符串对象的字符串值。以数组索引命名的属性对应字符串值里的单字符。一个特殊的 [[GetOwnProperty]] 内部方法用来为数组索引命名的属性指定数字，值，和特性。</p>\n\n<h5 id=\"length\">length</h5>\n\n<p>在代表这个字符串对象的字符串值里的字符数。</p>\n\n<p>一旦创建了一个字符串对象，这个属性是不可变的。它有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h5 id=\"getownpropertyp\">[[GetOwnProperty]] (P)</h5>\n\n<p>略。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475022482997,"created_by":1,"updated_at":1475051031371,"updated_by":1,"published_at":1475028528386,"published_by":1},{"id":94,"uuid":"b9a2e842-683d-40d0-be83-96342cfb5420","title":"js Number 对象","slug":"js-number-dui-xiang","markdown":"布尔对象就跳过了，因为没有额外的属性，原型对象也没有额外的方法。值得注意的是 Boolean.prototype 是一个字面量为 false 布尔对象。为什么不是 true 不得而知了，不过关系也不大。\n\n#### 作为函数调用的 Number 构造器\n\n当把 Number 当作一个函数来调用，而不是作为构造器，它执行一个类型转换。\n\n如果提供了 value，返回 ToNumber(value) 计算出的数字值（非 Number 对象），否则返回 +0。\n\n#### Number 构造器\n\n当把 Number 作为 new 表达式的一部分来调用，它是构造器：它初始化新创建的对象。\n\n新构造对象的 [[Prototype]] 内部属性设定为原始数字原型对象，它是 Number.prototype 的初始值。\n\n新构造对象的 [[Class]] 内部属性设定为 \"Number\"。\n\n新构造对象的 [[PrimitiveValue]] 内部属性在提供了 value 时设定为 ToNumber(value)，否则设定为 +0。\n\n新构造对象的 [[Extensible]] 内部属性设定为 true。\n\n#### Number 构造器的属性\n\nNumber 构造器的 [[Prototype]] 内部属性值是函数原型对象。\n\n除了内部属性和 length 属性（值为 1）之外，Number 构造器还有以下属性：\n\n##### Number.prototype\n\nNumber.prototype 的初始值是数字原型对象。\n\n这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n##### Number.MAX_VALUE\n\nNumber.MAX_VALUE 的值是数字类型的最大正有限值，约为 1.7976931348623157 × 10^308。\n\n这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n##### Number.MIN_VALUE\n\nNumber.MIN_VALUE 的值是数字类型的最小正有限值，约为 5 × 10^-324。\n\n这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n##### Number.NaN\n\nNumber.NaN 的值是 NaN。\n\n这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n##### Number.NEGATIVE_INFINITY\n\nNumber.NEGATIVE_INFINITY 的值是−∞。\n\n这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n##### Number.POSITIVE_INFINITY\n\nNumber.POSITIVE_INFINITY 的值是 +∞。\n\n这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n#### 数字原型对象的属性\n\n数字原型对象其自身是 Number 对象（其 [[Class]] 是 \"Number\"），其值为 +0。\n\n数字原型对象的 [[Prototype]] 内部属性值是标准内置 Object 原型对象。\n\n除非另外明确声明，以下定义的数字原型对象的方法是非通用的，传递给它们的 this 值必须是数字值或 [[Class]] 内部属性值是 \"Number\" 的对象。\n\n在以下对作为数字原型对象属性的函数的描述中，短语“this Number 对象”是指函数调用中的 this 值，或如果 Type(this 值 ) 是 Number，“this Number 对象”指仿佛是用表达式 new Number(this value) 创建的对象，这里 Number 是标准内置构造器名。此外，短语“this 数字值”是指代表 this Number 对象的数字值，也就是 this Number 对象的 [[PrimitiveValue]] 内部属性值；或如果 this 是数字类型，“this 数字值”指 this 值。如果 this 值不是 [[Class]] 内部属性为 \"Number\" 的对象，也不是数字类型的值，则抛出一个 TypeError 异常。\n\n##### Number.prototype.constructor\n\nNumber.prototype.constructor 的初始值是内置 Number 构造器。\n\n##### Number.prototype.toString ( [ radix ] )\n\n可选参数 radix 应当是 2 到 36 闭区间上的整数。如果 radix 不存在或是 undefined，用数字 10 作为 radix 的值。如果 ToInteger(radix) 是数字 10，则将 this Number 对象作为一个参数传给 ToString 抽象操作；返回结果字符串值。\n\n如果 ToInteger(radix) 不是在 2 到 36 闭区间上的整数，则抛出一个 RangeError 异常。如果 ToInteger(radix) 是 2 到 36 的整数，担不是 10，则结果是 this 数字值使用指定基数表示法的字符串。字母 a-z 用来指值为 10 到 35 的数字。基数不为 10 时的精确算法是依赖于实现的，然而算法应当是 9.8.1 指定算法的推广形式。\n\n> toString 函数不是通用的；如果 this 值不是数字或 Number 对象，抛出一个 TypeError 异常。因此它不能当作方法转移到其他类型对象上。\n\n##### Number.prototype.toLocaleString()\n\n根据宿主环境的当前语言环境惯例来格式化 this 数字值，生成代表这个值的字符串。此函数是依赖于实现的，允许但不鼓励它的返回值与 toString 相同。\n\n##### Number.prototype.valueOf()\n\n返回 this 数字值。\n\nvalueOf 函数不是通用的；如果 this 值不是数字或 Number 对象，抛出一个 TypeError 异常。因此它不能当作方法转移到其他类型对象上。\n\n##### Number.prototype.toFixed(fractionDigits)\n\ntoFixed() 方法使用定点表示法来格式化一个数。\n\n小数点后数字的个数；介于 0 到 20 （包括）之间，实现环境可能支持更大范围。如果忽略该参数，则默认为 0。\n\n##### Number.prototype.toExponential(fractionDigits)\n\ntoExponential() 方法以指数表示法返回该数值字符串表示形式。\n\n返回值一个用幂的形式 (科学技术法) 来表示Number 对象的字符串。小数点后以fractionDigits 提供的值来四舍五入。如果 fractionDigits 参数被忽略了，小数点后的将尽可能用最多的位数来表示该数值。\n\n对数值字面量使用 toExponential() 方法，且该数值网游小数点和指数时，应该在该数值与该方法之间隔开一个空格，以避免点号被解释为一个小数点。也可以使用两个点号调用该方法。\n\n如果一个数值的小数位数多余 fractionDigits 参数所提供的，则该数值将会在 fractionDigits 指定的小数位数处四舍五入，同 toFixed()。\n\n##### Number.prototype.toPrecision(precision)\n\ntoPrecision() 方法以指定的精度返回该数值对象的字符串表示。\n\n返回值以定点表示法或指数表示法表示的一个数值对象的字符串表示，四舍五入到 precision 参数指定的显示数字位数。如果忽略 precision 参数，则该方法表现类似于 Number.prototype.toString()。如果该参数是一个非整数值，将会向下舍入到最接近的整数。\n\n#### 数字实例的属性\n\n数字实例从数字原型对象继承属性，数字实例的 [[Class]] 内部属性是 \"Number\"。数字实例还有一个 [[PrimitiveValue]] 内部属性。\n\n[[PrimitiveValue]] 内部属性是代表 this Number 对象的数字值。\n\n","html":"<p>布尔对象就跳过了，因为没有额外的属性，原型对象也没有额外的方法。值得注意的是 Boolean.prototype 是一个字面量为 false 布尔对象。为什么不是 true 不得而知了，不过关系也不大。</p>\n\n<h4 id=\"number\">作为函数调用的 Number 构造器</h4>\n\n<p>当把 Number 当作一个函数来调用，而不是作为构造器，它执行一个类型转换。</p>\n\n<p>如果提供了 value，返回 ToNumber(value) 计算出的数字值（非 Number 对象），否则返回 +0。</p>\n\n<h4 id=\"number\">Number 构造器</h4>\n\n<p>当把 Number 作为 new 表达式的一部分来调用，它是构造器：它初始化新创建的对象。</p>\n\n<p>新构造对象的 [[Prototype]] 内部属性设定为原始数字原型对象，它是 Number.prototype 的初始值。</p>\n\n<p>新构造对象的 [[Class]] 内部属性设定为 \"Number\"。</p>\n\n<p>新构造对象的 [[PrimitiveValue]] 内部属性在提供了 value 时设定为 ToNumber(value)，否则设定为 +0。</p>\n\n<p>新构造对象的 [[Extensible]] 内部属性设定为 true。</p>\n\n<h4 id=\"number\">Number 构造器的属性</h4>\n\n<p>Number 构造器的 [[Prototype]] 内部属性值是函数原型对象。</p>\n\n<p>除了内部属性和 length 属性（值为 1）之外，Number 构造器还有以下属性：</p>\n\n<h5 id=\"numberprototype\">Number.prototype</h5>\n\n<p>Number.prototype 的初始值是数字原型对象。</p>\n\n<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h5 id=\"numbermax_value\">Number.MAX_VALUE</h5>\n\n<p>Number.MAX_VALUE 的值是数字类型的最大正有限值，约为 1.7976931348623157 × 10^308。</p>\n\n<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h5 id=\"numbermin_value\">Number.MIN_VALUE</h5>\n\n<p>Number.MIN_VALUE 的值是数字类型的最小正有限值，约为 5 × 10^-324。</p>\n\n<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h5 id=\"numbernan\">Number.NaN</h5>\n\n<p>Number.NaN 的值是 NaN。</p>\n\n<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h5 id=\"numbernegative_infinity\">Number.NEGATIVE_INFINITY</h5>\n\n<p>Number.NEGATIVE_INFINITY 的值是−∞。</p>\n\n<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h5 id=\"numberpositive_infinity\">Number.POSITIVE_INFINITY</h5>\n\n<p>Number.POSITIVE_INFINITY 的值是 +∞。</p>\n\n<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h4 id=\"\">数字原型对象的属性</h4>\n\n<p>数字原型对象其自身是 Number 对象（其 [[Class]] 是 \"Number\"），其值为 +0。</p>\n\n<p>数字原型对象的 [[Prototype]] 内部属性值是标准内置 Object 原型对象。</p>\n\n<p>除非另外明确声明，以下定义的数字原型对象的方法是非通用的，传递给它们的 this 值必须是数字值或 [[Class]] 内部属性值是 \"Number\" 的对象。</p>\n\n<p>在以下对作为数字原型对象属性的函数的描述中，短语“this Number 对象”是指函数调用中的 this 值，或如果 Type(this 值 ) 是 Number，“this Number 对象”指仿佛是用表达式 new Number(this value) 创建的对象，这里 Number 是标准内置构造器名。此外，短语“this 数字值”是指代表 this Number 对象的数字值，也就是 this Number 对象的 [[PrimitiveValue]] 内部属性值；或如果 this 是数字类型，“this 数字值”指 this 值。如果 this 值不是 [[Class]] 内部属性为 \"Number\" 的对象，也不是数字类型的值，则抛出一个 TypeError 异常。</p>\n\n<h5 id=\"numberprototypeconstructor\">Number.prototype.constructor</h5>\n\n<p>Number.prototype.constructor 的初始值是内置 Number 构造器。</p>\n\n<h5 id=\"numberprototypetostringradix\">Number.prototype.toString ( [ radix ] )</h5>\n\n<p>可选参数 radix 应当是 2 到 36 闭区间上的整数。如果 radix 不存在或是 undefined，用数字 10 作为 radix 的值。如果 ToInteger(radix) 是数字 10，则将 this Number 对象作为一个参数传给 ToString 抽象操作；返回结果字符串值。</p>\n\n<p>如果 ToInteger(radix) 不是在 2 到 36 闭区间上的整数，则抛出一个 RangeError 异常。如果 ToInteger(radix) 是 2 到 36 的整数，担不是 10，则结果是 this 数字值使用指定基数表示法的字符串。字母 a-z 用来指值为 10 到 35 的数字。基数不为 10 时的精确算法是依赖于实现的，然而算法应当是 9.8.1 指定算法的推广形式。</p>\n\n<blockquote>\n  <p>toString 函数不是通用的；如果 this 值不是数字或 Number 对象，抛出一个 TypeError 异常。因此它不能当作方法转移到其他类型对象上。</p>\n</blockquote>\n\n<h5 id=\"numberprototypetolocalestring\">Number.prototype.toLocaleString()</h5>\n\n<p>根据宿主环境的当前语言环境惯例来格式化 this 数字值，生成代表这个值的字符串。此函数是依赖于实现的，允许但不鼓励它的返回值与 toString 相同。</p>\n\n<h5 id=\"numberprototypevalueof\">Number.prototype.valueOf()</h5>\n\n<p>返回 this 数字值。</p>\n\n<p>valueOf 函数不是通用的；如果 this 值不是数字或 Number 对象，抛出一个 TypeError 异常。因此它不能当作方法转移到其他类型对象上。</p>\n\n<h5 id=\"numberprototypetofixedfractiondigits\">Number.prototype.toFixed(fractionDigits)</h5>\n\n<p>toFixed() 方法使用定点表示法来格式化一个数。</p>\n\n<p>小数点后数字的个数；介于 0 到 20 （包括）之间，实现环境可能支持更大范围。如果忽略该参数，则默认为 0。</p>\n\n<h5 id=\"numberprototypetoexponentialfractiondigits\">Number.prototype.toExponential(fractionDigits)</h5>\n\n<p>toExponential() 方法以指数表示法返回该数值字符串表示形式。</p>\n\n<p>返回值一个用幂的形式 (科学技术法) 来表示Number 对象的字符串。小数点后以fractionDigits 提供的值来四舍五入。如果 fractionDigits 参数被忽略了，小数点后的将尽可能用最多的位数来表示该数值。</p>\n\n<p>对数值字面量使用 toExponential() 方法，且该数值网游小数点和指数时，应该在该数值与该方法之间隔开一个空格，以避免点号被解释为一个小数点。也可以使用两个点号调用该方法。</p>\n\n<p>如果一个数值的小数位数多余 fractionDigits 参数所提供的，则该数值将会在 fractionDigits 指定的小数位数处四舍五入，同 toFixed()。</p>\n\n<h5 id=\"numberprototypetoprecisionprecision\">Number.prototype.toPrecision(precision)</h5>\n\n<p>toPrecision() 方法以指定的精度返回该数值对象的字符串表示。</p>\n\n<p>返回值以定点表示法或指数表示法表示的一个数值对象的字符串表示，四舍五入到 precision 参数指定的显示数字位数。如果忽略 precision 参数，则该方法表现类似于 Number.prototype.toString()。如果该参数是一个非整数值，将会向下舍入到最接近的整数。</p>\n\n<h4 id=\"\">数字实例的属性</h4>\n\n<p>数字实例从数字原型对象继承属性，数字实例的 [[Class]] 内部属性是 \"Number\"。数字实例还有一个 [[PrimitiveValue]] 内部属性。</p>\n\n<p>[[PrimitiveValue]] 内部属性是代表 this Number 对象的数字值。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475028820109,"created_by":1,"updated_at":1475051016957,"updated_by":1,"published_at":1475031582090,"published_by":1},{"id":95,"uuid":"c029394f-8294-4708-9f20-403f221b11ae","title":"结束阅读es5.1文档系列","slug":"jie-shu-zhe-ge-es5-1wen-dang-xi-lie","markdown":"这几篇写得很无聊，大多都是些记记的东西，所以后面的 Date、JSON 就合在一起写一写了，Math、Error 跳过了。写完这个系列，接下来的计划是再过一遍阮老师的《es6入门》，js的国际化暂时不看吧，一是兼容性问题比较大，而是暂时没有这个需求。\n\n看完《es入门》以后就是 dom 和 bom，这部分之前了解过，但是不深，需要深入了解一下。结束 dom 和 bom，js 就算基本结束了，当然各个宿主对象还存在很多扩展，还有函数式编程的各中技巧、设计模式，这些相比于语言来说更加广，所以碰到了，或者想到了再学。\n\n对了还是要看看 underscore 或是 lodash 的源码！从中学一些更加实用的技巧。\n\n#### JSON（不是一个函数对象）\n\nJSON 对象包含了两个方法，一是解析 JavaScript Object Notation (JSON)，二是将值转换为 JSON。这个对象本身不能被调用或者作为构造函数，除了它的这两个方法属性外 JSON 对象本身并没有什么有用的功能。\n\n##### JavaScript Object Notation\n\nJSON 是一种用来序列化对象、数组、数值、字符串、布尔值和 null 的语法。它基于 JavaScript 语法，但是又有区别：一些 JavaScript 值不是 JSON，而某些 JSON 不是 JavaScript 值。\n\nJSON结构允许任何深度的嵌套，但是不能够循环引用。若value是或者包含了一个循环结构，则stringify函数必须抛出一个TypeError异常。以下是一个不能够被字符串化的值的例子：\n\n```\na = []; \na[0] = a; \nmy_text = JSON.stringify(a); // This must throw an TypeError.\n```\n\n- null值在JSON文本中表示为字符串null\n- undefined 值不出现\n- true值在JSON文本中表示为字符串true\n- false值在JSON文本中表示为字符串false\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f89a6z6d55j311a0kwwjv.jpg)\n\n> 为了兼容旧的浏览器 IE8 以前的，则需要加入一些垫片，[JSON2](https://github.com/douglascrockford/JSON-js) 或 [JSON3](http://bestiejs.github.com/json3)。\n\n#### Date\n\nDate 内容比较多，就留到最后了。中间有一部分很久以前的文章也有提到，但是这篇会更加详细地讲时间。\n\n规范定义了一堆抽象操作，比较烦，暂时不看了！\n\n##### 作为函数调用 Date 构造器\n\n当把 Date 作为函数来调用，而不作为构造器，它返回一个表示当前时间（UTC）的字符串。（测试了下返回的是 CST 时间）\n\n函数调用 Date(…) 的结果和用相同参数调用表达式 new Date(…) 创建的对象是不同的。\n\n> 格林尼治标准时（GMT）是格林尼治天文台通过天文学观测将每日太阳穿过本初子午线的瞬间定为正午时刻，并以此来制定时间,所以格林尼治标准时是“天文学时间”，随着科技的进步，人们发现该时间不够精确,因为地球自转的速度是不均衡的，而且自转速度也会越来越慢，所以不再使用.\n而协调世界时（UTC）是基于原子物理学的特性，将在海平面上实现的“原子时秒”定义为国际标准时的时间单位，而原子时秒是这样定义的：铯-133 原子基态的两个超精细能级间在零磁场下跃迁辐射9192631770周所持续的时间。所以，协调世界时属于“原子物理时间”，它更加精确，基本不会产生误差。\n\n###### Date([year[, month[, date[, hours[, minutes[, seconds[, ms]]]]]]])\n\n所有参数都是可选的；接受提供的任何参数，但被完全忽略。返回一个仿佛是用表达式 (new Date()).toString() 创建的字符串，这里的 Date 是标准内置构造器，toString 是标准内置方法 Date.prototype.toString。\n\n##### Date 构造器\n\n当把 Date 作为 new 表达式的一部分来调用，它是个构造器：它初始化新创建的对象。（测试了下得到的是 UTC 时间）\n\n###### new Date([year[, month[, date[, hours[, minutes[, seconds[, ms]]]]]]])\n\n当用二到七个参数调用 Date 构造器，它用 year, month, 还有 ( 可选的 ) date, hours, minutes, seconds, ms 来计算时间。\n\n新构造对象的 [[Prototype]] 内部属性设定为原始的时间原型对象，它是 Date.prototype 的初始值。\n\n新构造对象的 [[Class]] 内部属性设定为 \"Date\"。\n\n新构造对象的 [[Extensible]] 内部属性设定为 ture。\n\n> 下面两种调用的 [[PrimitiveValue]] 外的内部属性同上。\n\n###### new Date (value)\n\n新构造对象的 [[PrimitiveValue]] 内部属性按照以下步骤设定：\n\n1. 令 v 为 ToPrimitive(value)。\n2. 如果 Type(v) 是 String，则用与 parse 方法完全相同的方式将 v 解析为一个日期时间；令 V 为这个日期时间的时间值。\n3. 否则，令 V 为 ToNumber(v)。\n4. 设定新构造对象的 [[PrimitiveValue]] 内部属性为 TimeClip(V)，并返回这个值。\n\n###### new Date()\n\n新构造对象的 [[PrimitiveValue]] 内部属性设定为表示当前时间的时间值（协调世界时）。\n\n##### Date 构造器的属性\n\nDate 构造器的 [[Prototype]] 内部属性的值是函数原型对象。\n\n除了内部属性和 length 属性 ( 值为 7) 之外，Date 构造器还有以下属性：\n\n###### Date.prototype\n\nDate.prototype 的初始值是内置的 Date 原型对象。\n\n此属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。\n\n###### Date.parse\n\nDate.parse() 方法解析一个表示某个日期的字符串，并返回从1970-1-1 00:00:00 UTC 到该日期对象（该日期对象的UTC时间）的毫秒数，如果该字符串无法识别，或者一些情况下，包含了不合法的日期数值（如：2015-02-31），则返回值为NaN。\n\n不推荐在ES5之前使用Date.parse方法，因为字符串的解析完全取决于实现。直到至今，不同宿主在如何解析日期字符串上仍存在许多差异，因此最好还是手动解析日期字符串（在需要适应不同格式时库能起到很大帮助）。 \n\n###### Date.UTC(year, month[, date[, hours[, minutes[, seconds[, ms]]]]])\n\nDate.UTC() 方法接受的参数同日期构造函数接受最多参数时一样，返回从1970-1-1 00:00:00 UTC到指定日期的的毫秒数。\n\n你应该指定一个完整格式的年份，如 1998。如果年份被指定为 0 到 99 之间，则该方法会将年份转换为 20 世纪的一个年份（即 1990 + year），例如，指定为 95， 则年份为 1995。\n\nUTC 方法与 Date 有两点不同：\n\n- Date.UTC 方法使用协调世界时代替本地时间。\n- Date.UTC 方法返回一个时间数值，而不是一个日期对象。\n\n如果有一个指定的参数超出其合理范围，则 UTC 方法会通过更新其他参数直到该参数在合理范围内。例如，为月份指定 15，则年份将会加 1，然后月份将会使用 3。\n\n###### Date.now()\n\nnow 函数返回一个数字值，它表示调用 now 时的 UTC 日期时间的时间值。\n\n##### Date 原型对象的属性\n\nDate 原型对象自身是一个 Date 对象（其 [[Class]] 是 \"Date\"），其 [[PrimitiveValue]] 是 NaN。\n\nDate 原型对象的 [[Prototype]] 内部属性的值是标准内置 Object 原型对象。\n\n在以下对 Date 原型对象的函数属性的描述中，短语“this Date 对象”指调用函数时的 this 值对象。除非另外说明，这些函数不是通用的；如果 this 值不是 [[Class]] 内部属性为 \"Date\" 的对象，则抛出一个 TypeError 异常。短语“this 时间值”指代表 this Date 对象的时间值的数字值，它是 this Date 对象的 [[PrimitiveValue]] 内部属性的值。\n\n###### Date.prototype.constructor\n\nDate.prototype.constructor 的初始值是内置 Date 构造器。\n\n###### Date.prototype.toString()\n\n此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种方便，人类可读的形式表示当前时区的时间。\n\n```\nnew Date().toString() //'Wed Sep 28 2016 16:18:15 GMT+0800 (CST)'\n```\n\n###### Date.prototype.toDateString()\n\n此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种方便，人类可读的形式表示当前时区时间的“日期”部分。\n\n```\nnew Date().toDateString() //'Wed Sep 28 2016'\n```\n\n###### Date.prototype.toTimeString()\n\n此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种方便，人类可读的形式表示当前时区时间的“时间”部分。\n\n```\nnew Date().toTimeString() //'16:19:13 GMT+0800 (CST)'\n```\n\n###### Date.prototype.toLocaleString()\n\n此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种 -- 对应宿主环境的当前语言环境设定的 -- 方便，人类可读的形式表示当前时区的时间。\n\n```\nnew Date().toLocaleString() //'2016-09-28 15:52:50'\n```\n\n> 这个方法目前支持国际化，可以提供 locates 和 options 来指定语言环境。具体会在国际化的文章讨论。\n\n###### Date.prototype.toLocaleDateString()\n\n此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种 -- 对应宿主环境的当前语言环境设定的 -- 方便，人类可读的形式表示当前时区时间的“日期”部分。\n\n```\nnew Date().toLocaleDateString() //'2016-09-28'\n```\n\n> 这个方法目前支持国际化，可以提供 locates 和 options 来指定语言环境。具体会在国际化的文章讨论。\n\n###### Date.prototype.toLocaleTimeString()\n\n此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种 -- 对应宿主环境的当前语言环境设定的 -- 方便，人类可读的形式表示当前时区时间的“时间”部分。\n\n```\nnew Date().toLocaleTimeString() //'15:52:50'\n```\n\n> 这个方法目前支持国际化，可以提供 locates 和 options 来指定语言环境。具体会在国际化的文章讨论。\n\n###### Date.prototype.valueOf()\n\nvalueOf 函数返回一个数字值，它是 this 时间值。\n\n###### Date.prototype.getTime()\n\n返回 this 时间值。\n\n###### 一系列get set\n\n可以看到每一个get、set 都有针对 UTC 的实现。分别处理本地时间和 UTC 时间。\n\n###### Date.prototype.toUTCString()\n\n此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种方便，人类可读的形式表示 UTC 时间。\n\n```\nnew Date().toUTCString() //'Wed, 28 Sep 2016 08:03:33 GMT'\n```\n\n###### Date.prototype.toISOString()\n\n此函数返回一个代表 --this Date 对象表示的时间的实例 -- 的字符串。字符串的格式是 15.9.1.15 定义的日期时间字符串格式。字符串中包含所有的字段。字符串表示的时区总是 UTC，用后缀 Z 标记。如果 this 对象的时间值不是有限的数字值，抛出一个 RangeError 异常。\n\n```\nnew Date().toISOString() //'2016-09-28T08:04:40.791Z'\n```\n\n##### Date 实例的属性\n\nDate 实例从 Date 原型对象继承属性，Date 实例的 [[Class]] 内部属性值是 \"Date\"。Date 实例还有一个 [[PrimitiveValue]] 内部属性。\n\n[[PrimitiveValue]] 内部属性是代表 this Date 对象的时间值。\n\n##### 小结\n\n我们得到和处理的都是本地时间，Date 也为我们提供了对 UTC 时间的访问和处理。\n\n转换字符串的方法都是依赖于实现的，正则来处理日期的展示更加好。\n\n#### 结束了\n\n最后几篇原生对象有点敷衍了，不过确实也没有什么特别好写的。好了，休息下，把 es6 过一遍，前面看过几遍不是特别仔细。\n","html":"<p>这几篇写得很无聊，大多都是些记记的东西，所以后面的 Date、JSON 就合在一起写一写了，Math、Error 跳过了。写完这个系列，接下来的计划是再过一遍阮老师的《es6入门》，js的国际化暂时不看吧，一是兼容性问题比较大，而是暂时没有这个需求。</p>\n\n<p>看完《es入门》以后就是 dom 和 bom，这部分之前了解过，但是不深，需要深入了解一下。结束 dom 和 bom，js 就算基本结束了，当然各个宿主对象还存在很多扩展，还有函数式编程的各中技巧、设计模式，这些相比于语言来说更加广，所以碰到了，或者想到了再学。</p>\n\n<p>对了还是要看看 underscore 或是 lodash 的源码！从中学一些更加实用的技巧。</p>\n\n<h4 id=\"json\">JSON（不是一个函数对象）</h4>\n\n<p>JSON 对象包含了两个方法，一是解析 JavaScript Object Notation (JSON)，二是将值转换为 JSON。这个对象本身不能被调用或者作为构造函数，除了它的这两个方法属性外 JSON 对象本身并没有什么有用的功能。</p>\n\n<h5 id=\"javascriptobjectnotation\">JavaScript Object Notation</h5>\n\n<p>JSON 是一种用来序列化对象、数组、数值、字符串、布尔值和 null 的语法。它基于 JavaScript 语法，但是又有区别：一些 JavaScript 值不是 JSON，而某些 JSON 不是 JavaScript 值。</p>\n\n<p>JSON结构允许任何深度的嵌套，但是不能够循环引用。若value是或者包含了一个循环结构，则stringify函数必须抛出一个TypeError异常。以下是一个不能够被字符串化的值的例子：</p>\n\n<pre><code>a = [];  \na[0] = a;  \nmy_text = JSON.stringify(a); // This must throw an TypeError.  \n</code></pre>\n\n<ul>\n<li>null值在JSON文本中表示为字符串null</li>\n<li>undefined 值不出现</li>\n<li>true值在JSON文本中表示为字符串true</li>\n<li>false值在JSON文本中表示为字符串false</li>\n</ul>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f89a6z6d55j311a0kwwjv.jpg\" alt=\"\" /></p>\n\n<blockquote>\n  <p>为了兼容旧的浏览器 IE8 以前的，则需要加入一些垫片，<a href=\"https://github.com/douglascrockford/JSON-js\">JSON2</a> 或 <a href=\"http://bestiejs.github.com/json3\">JSON3</a>。</p>\n</blockquote>\n\n<h4 id=\"date\">Date</h4>\n\n<p>Date 内容比较多，就留到最后了。中间有一部分很久以前的文章也有提到，但是这篇会更加详细地讲时间。</p>\n\n<p>规范定义了一堆抽象操作，比较烦，暂时不看了！</p>\n\n<h5 id=\"date\">作为函数调用 Date 构造器</h5>\n\n<p>当把 Date 作为函数来调用，而不作为构造器，它返回一个表示当前时间（UTC）的字符串。（测试了下返回的是 CST 时间）</p>\n\n<p>函数调用 Date(…) 的结果和用相同参数调用表达式 new Date(…) 创建的对象是不同的。</p>\n\n<blockquote>\n  <p>格林尼治标准时（GMT）是格林尼治天文台通过天文学观测将每日太阳穿过本初子午线的瞬间定为正午时刻，并以此来制定时间,所以格林尼治标准时是“天文学时间”，随着科技的进步，人们发现该时间不够精确,因为地球自转的速度是不均衡的，而且自转速度也会越来越慢，所以不再使用.\n  而协调世界时（UTC）是基于原子物理学的特性，将在海平面上实现的“原子时秒”定义为国际标准时的时间单位，而原子时秒是这样定义的：铯-133 原子基态的两个超精细能级间在零磁场下跃迁辐射9192631770周所持续的时间。所以，协调世界时属于“原子物理时间”，它更加精确，基本不会产生误差。</p>\n</blockquote>\n\n<h6 id=\"dateyearmonthdatehoursminutessecondsms\">Date([year[, month[, date[, hours[, minutes[, seconds[, ms]]]]]]])</h6>\n\n<p>所有参数都是可选的；接受提供的任何参数，但被完全忽略。返回一个仿佛是用表达式 (new Date()).toString() 创建的字符串，这里的 Date 是标准内置构造器，toString 是标准内置方法 Date.prototype.toString。</p>\n\n<h5 id=\"date\">Date 构造器</h5>\n\n<p>当把 Date 作为 new 表达式的一部分来调用，它是个构造器：它初始化新创建的对象。（测试了下得到的是 UTC 时间）</p>\n\n<h6 id=\"newdateyearmonthdatehoursminutessecondsms\">new Date([year[, month[, date[, hours[, minutes[, seconds[, ms]]]]]]])</h6>\n\n<p>当用二到七个参数调用 Date 构造器，它用 year, month, 还有 ( 可选的 ) date, hours, minutes, seconds, ms 来计算时间。</p>\n\n<p>新构造对象的 [[Prototype]] 内部属性设定为原始的时间原型对象，它是 Date.prototype 的初始值。</p>\n\n<p>新构造对象的 [[Class]] 内部属性设定为 \"Date\"。</p>\n\n<p>新构造对象的 [[Extensible]] 内部属性设定为 ture。</p>\n\n<blockquote>\n  <p>下面两种调用的 [[PrimitiveValue]] 外的内部属性同上。</p>\n</blockquote>\n\n<h6 id=\"newdatevalue\">new Date (value)</h6>\n\n<p>新构造对象的 [[PrimitiveValue]] 内部属性按照以下步骤设定：</p>\n\n<ol>\n<li>令 v 为 ToPrimitive(value)。  </li>\n<li>如果 Type(v) 是 String，则用与 parse 方法完全相同的方式将 v 解析为一个日期时间；令 V 为这个日期时间的时间值。  </li>\n<li>否则，令 V 为 ToNumber(v)。  </li>\n<li>设定新构造对象的 [[PrimitiveValue]] 内部属性为 TimeClip(V)，并返回这个值。</li>\n</ol>\n\n<h6 id=\"newdate\">new Date()</h6>\n\n<p>新构造对象的 [[PrimitiveValue]] 内部属性设定为表示当前时间的时间值（协调世界时）。</p>\n\n<h5 id=\"date\">Date 构造器的属性</h5>\n\n<p>Date 构造器的 [[Prototype]] 内部属性的值是函数原型对象。</p>\n\n<p>除了内部属性和 length 属性 ( 值为 7) 之外，Date 构造器还有以下属性：</p>\n\n<h6 id=\"dateprototype\">Date.prototype</h6>\n\n<p>Date.prototype 的初始值是内置的 Date 原型对象。</p>\n\n<p>此属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>\n\n<h6 id=\"dateparse\">Date.parse</h6>\n\n<p>Date.parse() 方法解析一个表示某个日期的字符串，并返回从1970-1-1 00:00:00 UTC 到该日期对象（该日期对象的UTC时间）的毫秒数，如果该字符串无法识别，或者一些情况下，包含了不合法的日期数值（如：2015-02-31），则返回值为NaN。</p>\n\n<p>不推荐在ES5之前使用Date.parse方法，因为字符串的解析完全取决于实现。直到至今，不同宿主在如何解析日期字符串上仍存在许多差异，因此最好还是手动解析日期字符串（在需要适应不同格式时库能起到很大帮助）。 </p>\n\n<h6 id=\"dateutcyearmonthdatehoursminutessecondsms\">Date.UTC(year, month[, date[, hours[, minutes[, seconds[, ms]]]]])</h6>\n\n<p>Date.UTC() 方法接受的参数同日期构造函数接受最多参数时一样，返回从1970-1-1 00:00:00 UTC到指定日期的的毫秒数。</p>\n\n<p>你应该指定一个完整格式的年份，如 1998。如果年份被指定为 0 到 99 之间，则该方法会将年份转换为 20 世纪的一个年份（即 1990 + year），例如，指定为 95， 则年份为 1995。</p>\n\n<p>UTC 方法与 Date 有两点不同：</p>\n\n<ul>\n<li>Date.UTC 方法使用协调世界时代替本地时间。</li>\n<li>Date.UTC 方法返回一个时间数值，而不是一个日期对象。</li>\n</ul>\n\n<p>如果有一个指定的参数超出其合理范围，则 UTC 方法会通过更新其他参数直到该参数在合理范围内。例如，为月份指定 15，则年份将会加 1，然后月份将会使用 3。</p>\n\n<h6 id=\"datenow\">Date.now()</h6>\n\n<p>now 函数返回一个数字值，它表示调用 now 时的 UTC 日期时间的时间值。</p>\n\n<h5 id=\"date\">Date 原型对象的属性</h5>\n\n<p>Date 原型对象自身是一个 Date 对象（其 [[Class]] 是 \"Date\"），其 [[PrimitiveValue]] 是 NaN。</p>\n\n<p>Date 原型对象的 [[Prototype]] 内部属性的值是标准内置 Object 原型对象。</p>\n\n<p>在以下对 Date 原型对象的函数属性的描述中，短语“this Date 对象”指调用函数时的 this 值对象。除非另外说明，这些函数不是通用的；如果 this 值不是 [[Class]] 内部属性为 \"Date\" 的对象，则抛出一个 TypeError 异常。短语“this 时间值”指代表 this Date 对象的时间值的数字值，它是 this Date 对象的 [[PrimitiveValue]] 内部属性的值。</p>\n\n<h6 id=\"dateprototypeconstructor\">Date.prototype.constructor</h6>\n\n<p>Date.prototype.constructor 的初始值是内置 Date 构造器。</p>\n\n<h6 id=\"dateprototypetostring\">Date.prototype.toString()</h6>\n\n<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种方便，人类可读的形式表示当前时区的时间。</p>\n\n<pre><code>new Date().toString() //'Wed Sep 28 2016 16:18:15 GMT+0800 (CST)'  \n</code></pre>\n\n<h6 id=\"dateprototypetodatestring\">Date.prototype.toDateString()</h6>\n\n<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种方便，人类可读的形式表示当前时区时间的“日期”部分。</p>\n\n<pre><code>new Date().toDateString() //'Wed Sep 28 2016'  \n</code></pre>\n\n<h6 id=\"dateprototypetotimestring\">Date.prototype.toTimeString()</h6>\n\n<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种方便，人类可读的形式表示当前时区时间的“时间”部分。</p>\n\n<pre><code>new Date().toTimeString() //'16:19:13 GMT+0800 (CST)'  \n</code></pre>\n\n<h6 id=\"dateprototypetolocalestring\">Date.prototype.toLocaleString()</h6>\n\n<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种 -- 对应宿主环境的当前语言环境设定的 -- 方便，人类可读的形式表示当前时区的时间。</p>\n\n<pre><code>new Date().toLocaleString() //'2016-09-28 15:52:50'  \n</code></pre>\n\n<blockquote>\n  <p>这个方法目前支持国际化，可以提供 locates 和 options 来指定语言环境。具体会在国际化的文章讨论。</p>\n</blockquote>\n\n<h6 id=\"dateprototypetolocaledatestring\">Date.prototype.toLocaleDateString()</h6>\n\n<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种 -- 对应宿主环境的当前语言环境设定的 -- 方便，人类可读的形式表示当前时区时间的“日期”部分。</p>\n\n<pre><code>new Date().toLocaleDateString() //'2016-09-28'  \n</code></pre>\n\n<blockquote>\n  <p>这个方法目前支持国际化，可以提供 locates 和 options 来指定语言环境。具体会在国际化的文章讨论。</p>\n</blockquote>\n\n<h6 id=\"dateprototypetolocaletimestring\">Date.prototype.toLocaleTimeString()</h6>\n\n<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种 -- 对应宿主环境的当前语言环境设定的 -- 方便，人类可读的形式表示当前时区时间的“时间”部分。</p>\n\n<pre><code>new Date().toLocaleTimeString() //'15:52:50'  \n</code></pre>\n\n<blockquote>\n  <p>这个方法目前支持国际化，可以提供 locates 和 options 来指定语言环境。具体会在国际化的文章讨论。</p>\n</blockquote>\n\n<h6 id=\"dateprototypevalueof\">Date.prototype.valueOf()</h6>\n\n<p>valueOf 函数返回一个数字值，它是 this 时间值。</p>\n\n<h6 id=\"dateprototypegettime\">Date.prototype.getTime()</h6>\n\n<p>返回 this 时间值。</p>\n\n<h6 id=\"getset\">一系列get set</h6>\n\n<p>可以看到每一个get、set 都有针对 UTC 的实现。分别处理本地时间和 UTC 时间。</p>\n\n<h6 id=\"dateprototypetoutcstring\">Date.prototype.toUTCString()</h6>\n\n<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种方便，人类可读的形式表示 UTC 时间。</p>\n\n<pre><code>new Date().toUTCString() //'Wed, 28 Sep 2016 08:03:33 GMT'  \n</code></pre>\n\n<h6 id=\"dateprototypetoisostring\">Date.prototype.toISOString()</h6>\n\n<p>此函数返回一个代表 --this Date 对象表示的时间的实例 -- 的字符串。字符串的格式是 15.9.1.15 定义的日期时间字符串格式。字符串中包含所有的字段。字符串表示的时区总是 UTC，用后缀 Z 标记。如果 this 对象的时间值不是有限的数字值，抛出一个 RangeError 异常。</p>\n\n<pre><code>new Date().toISOString() //'2016-09-28T08:04:40.791Z'  \n</code></pre>\n\n<h5 id=\"date\">Date 实例的属性</h5>\n\n<p>Date 实例从 Date 原型对象继承属性，Date 实例的 [[Class]] 内部属性值是 \"Date\"。Date 实例还有一个 [[PrimitiveValue]] 内部属性。</p>\n\n<p>[[PrimitiveValue]] 内部属性是代表 this Date 对象的时间值。</p>\n\n<h5 id=\"\">小结</h5>\n\n<p>我们得到和处理的都是本地时间，Date 也为我们提供了对 UTC 时间的访问和处理。</p>\n\n<p>转换字符串的方法都是依赖于实现的，正则来处理日期的展示更加好。</p>\n\n<h4 id=\"\">结束了</h4>\n\n<p>最后几篇原生对象有点敷衍了，不过确实也没有什么特别好写的。好了，休息下，把 es6 过一遍，前面看过几遍不是特别仔细。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475031882625,"created_by":1,"updated_at":1475051001924,"updated_by":1,"published_at":1475050929845,"published_by":1},{"id":96,"uuid":"dbef79b5-9a18-4424-83f6-4b615bff8974","title":"es6 启航 —— babel","slug":"es6-qi-hang-babel","markdown":"虽然阮老师的《es6入门》已经断断续续地读了好几遍了，但是对于一些问题的理解还不够深刻，所以在看完了 es5.1 标准文档后，准备把《es6入门》再拿出来看一遍，针对一些内容进行更深入地尝试和研究。\n\n要吸取 es5.1 最后阶段文章质量下降的经验，这个系列将把重点放在阅读过程中一些重点，而不会像之前那样把所有方法写一遍。有了《es6入门》我没有必要再复制一份，而是需要做深入的思考和尝试。\n\n### 关于 es 草案\n\n关于[ es 草案](https://m2mbob.cn/2016/06/25/guan-yu-es-cao-an/)的制定相关的问题，前面专门有一篇文章写过了，这里不讲了。\n\n### 部署进度\n\n各大浏览器的最新版本，对ES6的支持可以查看[传送门](kangax.github.io/es5-compat-table/es6/)。\n\n就我目前使用的 node 6.6 和 chrome 53 来说（其实就是 V8 引擎），支持程度都达到了 90%，和上面传送门写的不太一致。但是我测试了一下 import、export 确实没有支持，另外尾递归、以及数组原型的几个方法没有支持。不过刚更新的 Safari 10 已经 100% 支持了。\n\n> es6 固然好，但是很多特性现有的支持可能并不好，性能比较差，比如 V8 原生的 Promise 比起 BlueBird 的实现性能差很多。因此在使用前最好对某个特性有比较深的了解。\n\n### 主角 babel\n\n考虑到低版本的浏览器，尤其是 IE，在实际生产环境中无法直接使用 es6（有时甚至是 es5 部分特性也需要加垫片来支持）。因此通常的做法是将 es6 的代码转换编译成 es5 的代码，而 babel 正是为了帮助我们做这件事出现的。（Traceur转码器没见到有人用，就不提了）\n\n现在的 babel 已经不光光是为我们转义 es6 了，它已经支持 es2016、es2017 甚至 react 的转义了。通过配置插件，我们就能够体验各种各样未来的、简洁的语法了。\n\n> 插件化的设计使得每个人都有了扩展 babel 的能力，也是得 babel 生态相比于 Traceur 活跃得多。个人认为，插件化是 babel 能够成功的很重要的一个因素。\n\n#### Packages \n\n> 在介绍如何使用 babel 前，觉得有必要对于 babel 的整体架构有一个认识。本段既是翻译自 babel 的 readme.md 的 Packages 一小节。\n\nbabel 的仓库作为 monorepo（单个仓库）被管理，它由很多个 npm 包组成。[使用单个仓库的原因](https://github.com/babel/babel/blob/master/doc/design/monorepo.md)\n\n###### Core Packages（核心）\n\n核心包包括四个：[`babel-core`](https://github.com/babel/babel/blob/master/packages/babel-core)、[`babylon`](https://github.com/babel/babylon)、[`babel-traverse`](https://github.com/babel/babel/blob/master/packages/babel-traverse)、[`babel-generator`](https://github.com/babel/babel/blob/master/packages/babel-generator)。\n\n[`babel-core`](https://github.com/babel/babel/blob/master/packages/babel-core) 是 babel 的编译器本体。他暴露了 `babel.transform` 这个方法，用来编译使用了新语法的 es 代码。\n\nbabel 编译器能够被分解成三个部分：\n\n- 解释器: [`babylon`](https://github.com/babel/babylon) (被转移到分离的仓库，并且独立版本)\n- 转换器: 所有的 plugins/presets\n - 它们都使用 [`babel-traverse`](https://github.com/babel/babel/blob/master/packages/babel-traverse) 来遍历 AST（抽象语法树）\n- 生成器: [`babel-generator`](https://github.com/babel/babel/blob/master/packages/babel-generator)\n\n过程就像下面一样：\n\n输入的代码 -> `babylon` 解析器 -> `AST` -> 转换器 -> `AST` -> `babel-generator` -> 输出编译后的代码\n\n###### 其它包\n\n- [`babel-cli`](https://github.com/babel/babel/blob/master/packages/babel-cli) 是运行 `babel-core` 的命令行工具并且帮助输出编译结果到目录、字符串、标准输出流以及更多（也包括 `babel-node`）[了解更多]\n- [`babel-polyfill`](https://github.com/babel/babel/blob/master/packages/babel-polyfill) 是对 [`core-js`](https://github.com/zloirock/core-js) 和 [regenerator-runtime](https://github.com/facebook/regenerator/tree/master/packages/regenerator-runtime) （用来支持 generators 和 async functions）两个库的包装。[了解更多](https://babeljs.io/docs/usage/polyfill/).\n- [`babel-runtime`](https://github.com/babel/babel/blob/master/packages/babel-runtime) 类似于 polyfill，不过它不会修改全局作用域而是和 [`babel-plugin-transform-runtime`](https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime) 一起使用，把运行时需要的 helper 加入。[了解更多](https://babeljs.io/docs/plugins/transform-runtime/)\n- [`babel-register`](https://github.com/babel/babel/blob/master/packages/babel-register) 会使用 babel 自动编译 node require 的文件。[了解更多](http://babeljs.io/docs/usage/require/)\n- 省略了与使用无关的包\n\n> `babel-browser`已经被移除，官方建议使用 browserify/webpack 这类打包工具或者直接使用 `babel-core`。\n\n##### Presets（预定义的插件组）\n\n在 babel 6以后，默认的转换器被移除了；如果你不定义任何 plugins/presets ，它将会返回原始输入的代码。\n\n在 babel 中插件都是独立的，举例来说：[es2015-arrow-functions](https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-es2015-arrow-functions) 仅仅转换箭头函数为普通的函数。Presets 只是简单地将一系列的插件组合，方便我们转换，比如 es6 的所有特性插件就被定义成一个 Presets，引入这个 Presets 我们就可以方便地使用 es6 的各种语法了。\n\n> 如果仅仅是使用确定的几个特性，也可以使用插件配置。\n\n官方维护了一下一些 persets：\n\n- [babel-preset-es2015](https://github.com/babel/babel/blob/master/packages/babel-preset-es2015)\n- [babel-preset-es2016](https://github.com/babel/babel/blob/master/packages/babel-preset-es2016)\n- [babel-preset-es2017](https://github.com/babel/babel/blob/master/packages/babel-preset-es2017)\n- [babel-preset-stage-0](https://github.com/babel/babel/blob/master/packages/babel-preset-stage-0)\n- [babel-preset-stage-1](https://github.com/babel/babel/blob/master/packages/babel-preset-stage-1)\n- [babel-preset-stage-2](https://github.com/babel/babel/blob/master/packages/babel-preset-stage-2)\n- [babel-preset-stage-3](https://github.com/babel/babel/blob/master/packages/babel-preset-stage-3)\n- [babel-preset-react](https://github.com/babel/babel/blob/master/packages/babel-preset-react)\n\n> 我们也可以在 npm 上找到社区维护的 persets。\n\n###### Plugins\n\n插件时 babel 的心脏，它使得 babel 能够工作。\n\n- Transform Plugins：它包括了很多种插件，es6 转 es5、转换es3、 minification, JSX, flow, 实验室特性还有更多。\n- Syntax Plugins：它们仅仅启用了转换器来启用具体特性的解析。（转换插件被包含在语法插件，所以你不用两个都加入）\n\n插件很多，就不一一介绍了。\n\n###### Helpers\n\n主要在插件内部使用，不具体介绍了。\n\n#### 使用 babel\n\n看了上面的介绍，对于 babel 的整个体系应该有了一个初步的认识。那么接下来介绍如何使用。内容主要参考[babel用户手册](https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md#toc-babel-register) 和 [官网](http://babeljs.io/)。\n\nbabel 针对各种框架、工具都提供了集成，从 Gulp 到 Browserify，从 Ember 到 Meteor，不管你的环境设置如何，Babel 都有正式的集成支持。\n\n但是无论如何，集成的内部都离不开 babel 本身，因此有必要熟悉 babel 本身的使用，然后再学习集成，甚至插件编写。\n\n##### 安装 babel\n\n###### `babel-core`\n\n`babel-core` 是下面写到的几个库真正的爸爸了，因为没有它，下面几个库什么都干不了，提供的继承本质也是在内部调用它暴露的方法。前面提到它暴露了 `babel.transform(code, options);`，为我们提供了编程式地使用 babel 的途径。\n\n首先安装 `babel-core`。（使用 `babel-cli` 的话不需要，因为已经依赖了）\n\n```\n$ npm install babel-core\n```\n```\nvar babel = require(\"babel-core\");\n```\n\n看最新的文档，实际上暴露的是如下四个方法：\n\n字符串形式的 JavaScript 代码可以直接使用 `babel.transform` 来编译。\n\n```\nbabel.transform(\"code();\", options);\n// => { code, map, ast }\n```\n\n如果是文件的话，可以使用异步 api：\n\n```\nbabel.transformFile(\"filename.js\", options, function(err, result) {\n  result; // => { code, map, ast }\n});\n```\n\n或者是同步 api：\n\n```\nbabel.transformFileSync(\"filename.js\", options);\n// => { code, map, ast }\n```\n\n要是已经有一个 Babel AST（抽象语法树）了就可以直接从 AST 进行转换。\n\n```\nbabel.transformFromAst(ast, code, options);\n// => { code, map, ast }\n```\n\n> [options](http://babeljs.io/docs/usage/options/)常见的一些最好要知道。\n\n###### `babel-cli`\n\nbabel 的 cli 是一种在命令行下使用 babel 编译文件的简单方法。\n\n全局安装：\n\n```\n$ npm install --global babel-cli\n```\n\n编译单个文件，结果直接输出至终端：\n\n```\n$ babel my-file.js\n```\n\n使用 --out-file 或着 -o 可以将结果写入到指定的文件：\n\n```\n$ babel example.js --out-file compiled.js\n# 或\n$ babel example.js -o compiled.js\n```\n\n如果我们想要把一个目录整个编译成一个新的目录，可以使用 --out-dir 或者 -d。\n\n```\n$ babel src --out-dir lib\n# 或\n$ babel src -d lib\n```\n\n但是 babel 官方并不建议全局安装，有两个主要的原因：\n\n1. 在同一台机器上的不同项目或许会依赖不同版本的 babel 并允许你有选择的更新。\n2. 这意味着你对工作环境没有隐式依赖，这让你的项目有很好的可移植性并且易于安装。\n\n本地安装 babel-cli：\n\n```\nnpm install --save-dev babel-cli\n```\n\n> 注意：因为全局运行 babel 通常不是什么好习惯所以如果你想要卸载全局安装的 babel 的话，可以运行：`$ npm uninstall --global babel-cli`\n\n安装完以后，我们不直接从命令行运行 babel 了，取而代之我们将把运行命令写在 npm scripts 里，这样可以使用 babel 的本地版本。\n\n```\n  {\n    // ...\n    \"scripts\": {\n      \"build\": \"babel src -d lib\"\n    },\n    // ...\n  }\n```\n\n现在可以在终端里运行：\n\n```\nnpm run build\n```\n\n这将以与之前同样的方式运行 babel，但这一次我们使用的是本地副本。\n\ncli 基本的使用就是如此。不过还有很多参数可以配置，我已经把所有参数看了一遍，大致记了一下，但不贴在这里了，因为 ghost 的表格支持不太友好。[传送门](http://babeljs.io/docs/usage/options/)\n\n> 补充知识：全局安装的包会安装在 /usr/local/lib/node_modules 中，并且在 /usr/local/bin 下创建相应的软链，因此能够在命令行中使用。而本地安装的模块，在 node_modeuls 下会生成 .bin 目录，scripts 中会调用这里的命令，而不能够直接在命令行中调用。这样的设计想想还算合理。如果真的想要在命令行调用本地模块的命令，可以将其加入到 PATH 不过这是不推荐的做法。\n\n###### `babel-node`\n\n如果你要用 `node CLI` 来运行代码，那么整合 babel 最简单的方式就是使用 `babel-node CLI`，它是 `node CLI` 的替代品。它会在代码运行前进行编译。使用前需要安装 `babel-cli`，因为这个命令是被包含在 `babel-cli` 中的。\n\n目前 node 对于 es6 的支持已经超过了 90%，没有使用 `babel-node CLI` 的必要了。除非一定要使用一些更加新的语法。\n\n参数不多，[传送门](http://babeljs.io/docs/usage/cli/)\n\n> 注意：这种方法并不适合正式产品环境使用。 直接部署用此方式编译的代码不是好的做法。 在部署之前预先编译会更好。 不过用在构建脚本或是其他本地运行的脚本中是非常合适的。\n\n###### `babel-register`\n\n这是一个 node's `require` 的钩子（hook）。\n\n```\nrequire(\"babel-register\");\n```\n\n引入了 `babel-register`，那么之后 require 的以 `.es6`, `.es`, `.jsx` 和 `.js`为后缀的文件都会被自动的被 babel 编译。（后缀是可配置的，见下文）\n\n另外 babel-register 默认会忽略从 node_modules `require` 的内容。不过这是可配置的：\n\n```\nrequire(\"babel-register\")({\n  ignore: false\n});\n```\n\n其余 babel.transform 支持的 options 都可以进行配置，不过优先级会低于 .babelrc 文件的配置。\n\n> 注意：这种方法并不适合正式产品环境使用。 直接部署用此方式编译的代码不是好的做法。 在部署之前预先编译会更好。 不过用在构建脚本或是其他本地运行的脚本中是非常合适的。\n\n> 注意：你不能在你要编译的文件内同时注册 Babel，因为 node 会在 Babel 编译它之前就将它执行了。\n\n##### 配置 babel\n\n> 前面也讲到了，babel 6 以后默认的转换器被移除了，因此不进行配置，babel 是不会对代码进行转换的。所有进行精确地配置是十分必要的。\n\n到目前我们讲到的配置参数都是通过命令行传入或者在调用 transform 相关方法时传入（无论何种配置方式，本质都是会在调用 transform 相关方法时传入）。\n\n在这一章，我们要讲一种更加常见的配置方式，利用 `.babelrc` 文件。举个最简单的例子，启用对 es6 的配置：\n\n首先安装 \"es2015\" babel 预设：\n\n```\n$ npm install --save-dev babel-preset-es2015\n```\n\n我们修改 .babelrc 来包含这个预设：\n\n```\n  {\n    \"presets\": [\n      \"es2015\"\n    ]\n  }\n```\n\n这样的话，当你再次用上面一章提到的方法来编译代码时，就可以正常地处理 es6 的代码了。上面提到的 options 包含的内容在此都是可配置的。\n\n除了 `.babelrc` 还可以在 package.json 中添加配置：\n\n```\n{\n  //...\n  \"babel\": {\n    // my babel config here\n  }\n}\n```\n\n最后要了解一下各种配置的查找行为，用过 eslint 肯定能够理解。babel 的差早和 eslint 查找配置文件类似，先是在当前目录找，如果没有找到则会逐级向上层目录查找 `.babelrc` 或 `package.json` 的 `babel` 字段。\n\n> 技巧补充：`env` 配置项允许我们为 babel 进行不同环境下的配置。默认从 `process.env.BABEL_ENV` 中读取，如果没有则为 development。\n\n##### 执行 babel 生成的代码\n\n即便你已经用 babel 编译了你的代码，但这还不算完。因为 babel 仅仅是帮我们把 es6 的语法进行了编译，对于 es6 新的 API 如 `Array.from` 它是不会进行编译的。但是它为我们提供了 `babel-polyfill` 和 `babel-runtime`。\n\n###### `babel-polyfill`\n\n`babel-polyfill` 本质上是对 core-js 和 regenerator 这两个库的包装。前者提供了 es6 的 API，后者提供了对 generator 和 async function 的支持。\n\n要使用它，首先用 npm 安装它：\n\n```\n$ npm install --save babel-polyfill\n```\n\n然后只需要在文件顶部导入 polyfill 就可以了：\n\n```\nrequire(\"babel-polyfill\")\n或\nimport \"babel-polyfill\";\n```\n\n###### `babel-runtime`\n\n与 `babel-polyfill` 一样，`babel-runtime` 的作用也是模拟 ES2015 环境。只不过，`babel-polyfill` 是针对全局环境的，引入它，我们的浏览器就好像具备了规范里定义的完整的特性 – 虽然原生并未实现。\n\n`babel-runtime` 更像是分散的 polyfill 模块，我们可以在自己的模块里单独引入，比如 `require(‘babel-runtime/core-js/promise’)` ，它们不会在全局环境添加未实现的方法，只是这样手动引用每个 polyfill 会非常低效。因此通常和[`babel-plugin-transform-runtime`](https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime)一起使用。\n\n通过安装 `babel-plugin-transform-runtime` 和 `babel-runtime` 来开始。\n\n```\n$ npm install --save-dev babel-plugin-transform-runtime\n$ npm install --save babel-runtime\n```\n\n> In most cases, you should install babel-plugin-transform-runtime as a development dependency (with --save-dev) and babel-runtime as a production dependency (with --save).\n\n> The transformation plugin is typically used only in development, but the runtime itself will be depended on by your deployed/published code.\n\n然后更新 `.babelrc`：\n\n```\n{\n    \"plugins\": [\n        \"transform-runtime\"    \n    ]\n}\n```\n\n这样 babel 在编译时就会帮助我们自动加入需要的 API。\n\n> `babel-plugin-transform-runtime` 不会帮我们引入实例的方案，如 `\"foobar\".includes(\"foo\")`，这种情况下往往需要我们自己从 `core-js` 中引入。直接引入 `babel-polyfill` 有点浪费了。\n\n##### 高级\n\n用户指南最后还有一章介绍了一些高级技巧如：自定义插件、环境设置、制作预设。前两个两面已经提过了，这里讲一下如何做自己的 presets。\n\n首先，创建一个 `package.json`，包括针对预设所必要的 dependencies。\n\n```\n{\n  \"name\": \"babel-preset-my-awesome-preset\",\n  \"version\": \"1.0.0\",\n  \"author\": \"James Kyle <me@thejameskyle.com>\",\n  \"dependencies\": {\n    \"babel-preset-es2015\": \"^6.3.13\",\n    \"babel-preset-react\": \"^6.3.13\",\n    \"babel-plugin-transform-flow-strip-types\": \"^6.3.15\"\n  }\n}\n```\n\n然后创建 `index.js` 文件用于导出 `.babelrc` 的内容，使用对应的 `require` 调用来替换 plugins／presets 字符串。\n\n```\nmodule.exports = {\n  presets: [\n    require(\"babel-preset-es2015\"),\n    require(\"babel-preset-react\")\n  ],\n  plugins: [\n    require(\"babel-plugin-transform-flow-strip-types\")\n  ]\n};\n```\n\n然后只需要发布到 npm 于是你就可以像其它预设一样来使用你的预设了。\n\n##### loose 模式\n\nbabel 的 preset-es2015 在 6.13 以后提供了 loose 模式，这个模式为了兼容一些 es5 都没有完全支持的浏览器（没错就是IE）做出了一些改动。主要针对的是一下几个插件：'transform-es2015-template-literals'、'transform-es2015-classes'、'transform-es2015-computed-properties'、'transform-es2015-for-of'、'transform-es2015-spread'、'transform-es2015-destructuring'、'transform-es2015-modules-commonjs/amd/systemjs/umd'。（这个具体再开一篇介绍了，估计内容比较多）\n\n### 小结\n\n到这里 babel 的基本使用已经都呈现在这里了，但是真正运用到项目中还需要更多的实践。下篇就会详细介绍一个成功的集成案例，可能是 react-native 吧，还说不准！","html":"<p>虽然阮老师的《es6入门》已经断断续续地读了好几遍了，但是对于一些问题的理解还不够深刻，所以在看完了 es5.1 标准文档后，准备把《es6入门》再拿出来看一遍，针对一些内容进行更深入地尝试和研究。</p>\n\n<p>要吸取 es5.1 最后阶段文章质量下降的经验，这个系列将把重点放在阅读过程中一些重点，而不会像之前那样把所有方法写一遍。有了《es6入门》我没有必要再复制一份，而是需要做深入的思考和尝试。</p>\n\n<h3 id=\"es\">关于 es 草案</h3>\n\n<p>关于<a href=\"https://m2mbob.cn/2016/06/25/guan-yu-es-cao-an/\"> es 草案</a>的制定相关的问题，前面专门有一篇文章写过了，这里不讲了。</p>\n\n<h3 id=\"\">部署进度</h3>\n\n<p>各大浏览器的最新版本，对ES6的支持可以查看<a href=\"kangax.github.io/es5-compat-table/es6/\">传送门</a>。</p>\n\n<p>就我目前使用的 node 6.6 和 chrome 53 来说（其实就是 V8 引擎），支持程度都达到了 90%，和上面传送门写的不太一致。但是我测试了一下 import、export 确实没有支持，另外尾递归、以及数组原型的几个方法没有支持。不过刚更新的 Safari 10 已经 100% 支持了。</p>\n\n<blockquote>\n  <p>es6 固然好，但是很多特性现有的支持可能并不好，性能比较差，比如 V8 原生的 Promise 比起 BlueBird 的实现性能差很多。因此在使用前最好对某个特性有比较深的了解。</p>\n</blockquote>\n\n<h3 id=\"babel\">主角 babel</h3>\n\n<p>考虑到低版本的浏览器，尤其是 IE，在实际生产环境中无法直接使用 es6（有时甚至是 es5 部分特性也需要加垫片来支持）。因此通常的做法是将 es6 的代码转换编译成 es5 的代码，而 babel 正是为了帮助我们做这件事出现的。（Traceur转码器没见到有人用，就不提了）</p>\n\n<p>现在的 babel 已经不光光是为我们转义 es6 了，它已经支持 es2016、es2017 甚至 react 的转义了。通过配置插件，我们就能够体验各种各样未来的、简洁的语法了。</p>\n\n<blockquote>\n  <p>插件化的设计使得每个人都有了扩展 babel 的能力，也是得 babel 生态相比于 Traceur 活跃得多。个人认为，插件化是 babel 能够成功的很重要的一个因素。</p>\n</blockquote>\n\n<h4 id=\"packages\">Packages</h4>\n\n<blockquote>\n  <p>在介绍如何使用 babel 前，觉得有必要对于 babel 的整体架构有一个认识。本段既是翻译自 babel 的 readme.md 的 Packages 一小节。</p>\n</blockquote>\n\n<p>babel 的仓库作为 monorepo（单个仓库）被管理，它由很多个 npm 包组成。<a href=\"https://github.com/babel/babel/blob/master/doc/design/monorepo.md\">使用单个仓库的原因</a></p>\n\n<h6 id=\"corepackages\">Core Packages（核心）</h6>\n\n<p>核心包包括四个：<a href=\"https://github.com/babel/babel/blob/master/packages/babel-core\"><code>babel-core</code></a>、<a href=\"https://github.com/babel/babylon\"><code>babylon</code></a>、<a href=\"https://github.com/babel/babel/blob/master/packages/babel-traverse\"><code>babel-traverse</code></a>、<a href=\"https://github.com/babel/babel/blob/master/packages/babel-generator\"><code>babel-generator</code></a>。</p>\n\n<p><a href=\"https://github.com/babel/babel/blob/master/packages/babel-core\"><code>babel-core</code></a> 是 babel 的编译器本体。他暴露了 <code>babel.transform</code> 这个方法，用来编译使用了新语法的 es 代码。</p>\n\n<p>babel 编译器能够被分解成三个部分：</p>\n\n<ul>\n<li>解释器: <a href=\"https://github.com/babel/babylon\"><code>babylon</code></a> (被转移到分离的仓库，并且独立版本)</li>\n<li>转换器: 所有的 plugins/presets\n<ul><li>它们都使用 <a href=\"https://github.com/babel/babel/blob/master/packages/babel-traverse\"><code>babel-traverse</code></a> 来遍历 AST（抽象语法树）</li></ul></li>\n<li>生成器: <a href=\"https://github.com/babel/babel/blob/master/packages/babel-generator\"><code>babel-generator</code></a></li>\n</ul>\n\n<p>过程就像下面一样：</p>\n\n<p>输入的代码 -> <code>babylon</code> 解析器 -> <code>AST</code> -> 转换器 -> <code>AST</code> -> <code>babel-generator</code> -> 输出编译后的代码</p>\n\n<h6 id=\"\">其它包</h6>\n\n<ul>\n<li><a href=\"https://github.com/babel/babel/blob/master/packages/babel-cli\"><code>babel-cli</code></a> 是运行 <code>babel-core</code> 的命令行工具并且帮助输出编译结果到目录、字符串、标准输出流以及更多（也包括 <code>babel-node</code>）[了解更多]</li>\n<li><a href=\"https://github.com/babel/babel/blob/master/packages/babel-polyfill\"><code>babel-polyfill</code></a> 是对 <a href=\"https://github.com/zloirock/core-js\"><code>core-js</code></a> 和 <a href=\"https://github.com/facebook/regenerator/tree/master/packages/regenerator-runtime\">regenerator-runtime</a> （用来支持 generators 和 async functions）两个库的包装。<a href=\"https://babeljs.io/docs/usage/polyfill/\">了解更多</a>.</li>\n<li><a href=\"https://github.com/babel/babel/blob/master/packages/babel-runtime\"><code>babel-runtime</code></a> 类似于 polyfill，不过它不会修改全局作用域而是和 <a href=\"https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime\"><code>babel-plugin-transform-runtime</code></a> 一起使用，把运行时需要的 helper 加入。<a href=\"https://babeljs.io/docs/plugins/transform-runtime/\">了解更多</a></li>\n<li><a href=\"https://github.com/babel/babel/blob/master/packages/babel-register\"><code>babel-register</code></a> 会使用 babel 自动编译 node require 的文件。<a href=\"http://babeljs.io/docs/usage/require/\">了解更多</a></li>\n<li>省略了与使用无关的包</li>\n</ul>\n\n<blockquote>\n  <p><code>babel-browser</code>已经被移除，官方建议使用 browserify/webpack 这类打包工具或者直接使用 <code>babel-core</code>。</p>\n</blockquote>\n\n<h5 id=\"presets\">Presets（预定义的插件组）</h5>\n\n<p>在 babel 6以后，默认的转换器被移除了；如果你不定义任何 plugins/presets ，它将会返回原始输入的代码。</p>\n\n<p>在 babel 中插件都是独立的，举例来说：<a href=\"https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-es2015-arrow-functions\">es2015-arrow-functions</a> 仅仅转换箭头函数为普通的函数。Presets 只是简单地将一系列的插件组合，方便我们转换，比如 es6 的所有特性插件就被定义成一个 Presets，引入这个 Presets 我们就可以方便地使用 es6 的各种语法了。</p>\n\n<blockquote>\n  <p>如果仅仅是使用确定的几个特性，也可以使用插件配置。</p>\n</blockquote>\n\n<p>官方维护了一下一些 persets：</p>\n\n<ul>\n<li><a href=\"https://github.com/babel/babel/blob/master/packages/babel-preset-es2015\">babel-preset-es2015</a></li>\n<li><a href=\"https://github.com/babel/babel/blob/master/packages/babel-preset-es2016\">babel-preset-es2016</a></li>\n<li><a href=\"https://github.com/babel/babel/blob/master/packages/babel-preset-es2017\">babel-preset-es2017</a></li>\n<li><a href=\"https://github.com/babel/babel/blob/master/packages/babel-preset-stage-0\">babel-preset-stage-0</a></li>\n<li><a href=\"https://github.com/babel/babel/blob/master/packages/babel-preset-stage-1\">babel-preset-stage-1</a></li>\n<li><a href=\"https://github.com/babel/babel/blob/master/packages/babel-preset-stage-2\">babel-preset-stage-2</a></li>\n<li><a href=\"https://github.com/babel/babel/blob/master/packages/babel-preset-stage-3\">babel-preset-stage-3</a></li>\n<li><a href=\"https://github.com/babel/babel/blob/master/packages/babel-preset-react\">babel-preset-react</a></li>\n</ul>\n\n<blockquote>\n  <p>我们也可以在 npm 上找到社区维护的 persets。</p>\n</blockquote>\n\n<h6 id=\"plugins\">Plugins</h6>\n\n<p>插件时 babel 的心脏，它使得 babel 能够工作。</p>\n\n<ul>\n<li>Transform Plugins：它包括了很多种插件，es6 转 es5、转换es3、 minification, JSX, flow, 实验室特性还有更多。</li>\n<li>Syntax Plugins：它们仅仅启用了转换器来启用具体特性的解析。（转换插件被包含在语法插件，所以你不用两个都加入）</li>\n</ul>\n\n<p>插件很多，就不一一介绍了。</p>\n\n<h6 id=\"helpers\">Helpers</h6>\n\n<p>主要在插件内部使用，不具体介绍了。</p>\n\n<h4 id=\"babel\">使用 babel</h4>\n\n<p>看了上面的介绍，对于 babel 的整个体系应该有了一个初步的认识。那么接下来介绍如何使用。内容主要参考<a href=\"https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md#toc-babel-register\">babel用户手册</a> 和 <a href=\"http://babeljs.io/\">官网</a>。</p>\n\n<p>babel 针对各种框架、工具都提供了集成，从 Gulp 到 Browserify，从 Ember 到 Meteor，不管你的环境设置如何，Babel 都有正式的集成支持。</p>\n\n<p>但是无论如何，集成的内部都离不开 babel 本身，因此有必要熟悉 babel 本身的使用，然后再学习集成，甚至插件编写。</p>\n\n<h5 id=\"babel\">安装 babel</h5>\n\n<h6 id=\"babelcore\"><code>babel-core</code></h6>\n\n<p><code>babel-core</code> 是下面写到的几个库真正的爸爸了，因为没有它，下面几个库什么都干不了，提供的继承本质也是在内部调用它暴露的方法。前面提到它暴露了 <code>babel.transform(code, options);</code>，为我们提供了编程式地使用 babel 的途径。</p>\n\n<p>首先安装 <code>babel-core</code>。（使用 <code>babel-cli</code> 的话不需要，因为已经依赖了）</p>\n\n<pre><code>$ npm install babel-core\n</code></pre>\n\n<pre><code>var babel = require(\"babel-core\");  \n</code></pre>\n\n<p>看最新的文档，实际上暴露的是如下四个方法：</p>\n\n<p>字符串形式的 JavaScript 代码可以直接使用 <code>babel.transform</code> 来编译。</p>\n\n<pre><code>babel.transform(\"code();\", options);  \n// =&gt; { code, map, ast }\n</code></pre>\n\n<p>如果是文件的话，可以使用异步 api：</p>\n\n<pre><code>babel.transformFile(\"filename.js\", options, function(err, result) {  \n  result; // =&gt; { code, map, ast }\n});\n</code></pre>\n\n<p>或者是同步 api：</p>\n\n<pre><code>babel.transformFileSync(\"filename.js\", options);  \n// =&gt; { code, map, ast }\n</code></pre>\n\n<p>要是已经有一个 Babel AST（抽象语法树）了就可以直接从 AST 进行转换。</p>\n\n<pre><code>babel.transformFromAst(ast, code, options);  \n// =&gt; { code, map, ast }\n</code></pre>\n\n<blockquote>\n  <p><a href=\"http://babeljs.io/docs/usage/options/\">options</a>常见的一些最好要知道。</p>\n</blockquote>\n\n<h6 id=\"babelcli\"><code>babel-cli</code></h6>\n\n<p>babel 的 cli 是一种在命令行下使用 babel 编译文件的简单方法。</p>\n\n<p>全局安装：</p>\n\n<pre><code>$ npm install --global babel-cli\n</code></pre>\n\n<p>编译单个文件，结果直接输出至终端：</p>\n\n<pre><code>$ babel my-file.js\n</code></pre>\n\n<p>使用 --out-file 或着 -o 可以将结果写入到指定的文件：</p>\n\n<pre><code>$ babel example.js --out-file compiled.js\n# 或\n$ babel example.js -o compiled.js\n</code></pre>\n\n<p>如果我们想要把一个目录整个编译成一个新的目录，可以使用 --out-dir 或者 -d。</p>\n\n<pre><code>$ babel src --out-dir lib\n# 或\n$ babel src -d lib\n</code></pre>\n\n<p>但是 babel 官方并不建议全局安装，有两个主要的原因：</p>\n\n<ol>\n<li>在同一台机器上的不同项目或许会依赖不同版本的 babel 并允许你有选择的更新。  </li>\n<li>这意味着你对工作环境没有隐式依赖，这让你的项目有很好的可移植性并且易于安装。</li>\n</ol>\n\n<p>本地安装 babel-cli：</p>\n\n<pre><code>npm install --save-dev babel-cli  \n</code></pre>\n\n<blockquote>\n  <p>注意：因为全局运行 babel 通常不是什么好习惯所以如果你想要卸载全局安装的 babel 的话，可以运行：<code>$ npm uninstall --global babel-cli</code></p>\n</blockquote>\n\n<p>安装完以后，我们不直接从命令行运行 babel 了，取而代之我们将把运行命令写在 npm scripts 里，这样可以使用 babel 的本地版本。</p>\n\n<pre><code>  {\n    // ...\n    \"scripts\": {\n      \"build\": \"babel src -d lib\"\n    },\n    // ...\n  }\n</code></pre>\n\n<p>现在可以在终端里运行：</p>\n\n<pre><code>npm run build  \n</code></pre>\n\n<p>这将以与之前同样的方式运行 babel，但这一次我们使用的是本地副本。</p>\n\n<p>cli 基本的使用就是如此。不过还有很多参数可以配置，我已经把所有参数看了一遍，大致记了一下，但不贴在这里了，因为 ghost 的表格支持不太友好。<a href=\"http://babeljs.io/docs/usage/options/\">传送门</a></p>\n\n<blockquote>\n  <p>补充知识：全局安装的包会安装在 /usr/local/lib/node<em>modules 中，并且在 /usr/local/bin 下创建相应的软链，因此能够在命令行中使用。而本地安装的模块，在 node</em>modeuls 下会生成 .bin 目录，scripts 中会调用这里的命令，而不能够直接在命令行中调用。这样的设计想想还算合理。如果真的想要在命令行调用本地模块的命令，可以将其加入到 PATH 不过这是不推荐的做法。</p>\n</blockquote>\n\n<h6 id=\"babelnode\"><code>babel-node</code></h6>\n\n<p>如果你要用 <code>node CLI</code> 来运行代码，那么整合 babel 最简单的方式就是使用 <code>babel-node CLI</code>，它是 <code>node CLI</code> 的替代品。它会在代码运行前进行编译。使用前需要安装 <code>babel-cli</code>，因为这个命令是被包含在 <code>babel-cli</code> 中的。</p>\n\n<p>目前 node 对于 es6 的支持已经超过了 90%，没有使用 <code>babel-node CLI</code> 的必要了。除非一定要使用一些更加新的语法。</p>\n\n<p>参数不多，<a href=\"http://babeljs.io/docs/usage/cli/\">传送门</a></p>\n\n<blockquote>\n  <p>注意：这种方法并不适合正式产品环境使用。 直接部署用此方式编译的代码不是好的做法。 在部署之前预先编译会更好。 不过用在构建脚本或是其他本地运行的脚本中是非常合适的。</p>\n</blockquote>\n\n<h6 id=\"babelregister\"><code>babel-register</code></h6>\n\n<p>这是一个 node's <code>require</code> 的钩子（hook）。</p>\n\n<pre><code>require(\"babel-register\");  \n</code></pre>\n\n<p>引入了 <code>babel-register</code>，那么之后 require 的以 <code>.es6</code>, <code>.es</code>, <code>.jsx</code> 和 <code>.js</code>为后缀的文件都会被自动的被 babel 编译。（后缀是可配置的，见下文）</p>\n\n<p>另外 babel-register 默认会忽略从 node_modules <code>require</code> 的内容。不过这是可配置的：</p>\n\n<pre><code>require(\"babel-register\")({  \n  ignore: false\n});\n</code></pre>\n\n<p>其余 babel.transform 支持的 options 都可以进行配置，不过优先级会低于 .babelrc 文件的配置。</p>\n\n<blockquote>\n  <p>注意：这种方法并不适合正式产品环境使用。 直接部署用此方式编译的代码不是好的做法。 在部署之前预先编译会更好。 不过用在构建脚本或是其他本地运行的脚本中是非常合适的。</p>\n  \n  <p>注意：你不能在你要编译的文件内同时注册 Babel，因为 node 会在 Babel 编译它之前就将它执行了。</p>\n</blockquote>\n\n<h5 id=\"babel\">配置 babel</h5>\n\n<blockquote>\n  <p>前面也讲到了，babel 6 以后默认的转换器被移除了，因此不进行配置，babel 是不会对代码进行转换的。所有进行精确地配置是十分必要的。</p>\n</blockquote>\n\n<p>到目前我们讲到的配置参数都是通过命令行传入或者在调用 transform 相关方法时传入（无论何种配置方式，本质都是会在调用 transform 相关方法时传入）。</p>\n\n<p>在这一章，我们要讲一种更加常见的配置方式，利用 <code>.babelrc</code> 文件。举个最简单的例子，启用对 es6 的配置：</p>\n\n<p>首先安装 \"es2015\" babel 预设：</p>\n\n<pre><code>$ npm install --save-dev babel-preset-es2015\n</code></pre>\n\n<p>我们修改 .babelrc 来包含这个预设：</p>\n\n<pre><code>  {\n    \"presets\": [\n      \"es2015\"\n    ]\n  }\n</code></pre>\n\n<p>这样的话，当你再次用上面一章提到的方法来编译代码时，就可以正常地处理 es6 的代码了。上面提到的 options 包含的内容在此都是可配置的。</p>\n\n<p>除了 <code>.babelrc</code> 还可以在 package.json 中添加配置：</p>\n\n<pre><code>{\n  //...\n  \"babel\": {\n    // my babel config here\n  }\n}\n</code></pre>\n\n<p>最后要了解一下各种配置的查找行为，用过 eslint 肯定能够理解。babel 的差早和 eslint 查找配置文件类似，先是在当前目录找，如果没有找到则会逐级向上层目录查找 <code>.babelrc</code> 或 <code>package.json</code> 的 <code>babel</code> 字段。</p>\n\n<blockquote>\n  <p>技巧补充：<code>env</code> 配置项允许我们为 babel 进行不同环境下的配置。默认从 <code>process.env.BABEL_ENV</code> 中读取，如果没有则为 development。</p>\n</blockquote>\n\n<h5 id=\"babel\">执行 babel 生成的代码</h5>\n\n<p>即便你已经用 babel 编译了你的代码，但这还不算完。因为 babel 仅仅是帮我们把 es6 的语法进行了编译，对于 es6 新的 API 如 <code>Array.from</code> 它是不会进行编译的。但是它为我们提供了 <code>babel-polyfill</code> 和 <code>babel-runtime</code>。</p>\n\n<h6 id=\"babelpolyfill\"><code>babel-polyfill</code></h6>\n\n<p><code>babel-polyfill</code> 本质上是对 core-js 和 regenerator 这两个库的包装。前者提供了 es6 的 API，后者提供了对 generator 和 async function 的支持。</p>\n\n<p>要使用它，首先用 npm 安装它：</p>\n\n<pre><code>$ npm install --save babel-polyfill\n</code></pre>\n\n<p>然后只需要在文件顶部导入 polyfill 就可以了：</p>\n\n<pre><code>require(\"babel-polyfill\")  \n或\nimport \"babel-polyfill\";  \n</code></pre>\n\n<h6 id=\"babelruntime\"><code>babel-runtime</code></h6>\n\n<p>与 <code>babel-polyfill</code> 一样，<code>babel-runtime</code> 的作用也是模拟 ES2015 环境。只不过，<code>babel-polyfill</code> 是针对全局环境的，引入它，我们的浏览器就好像具备了规范里定义的完整的特性 – 虽然原生并未实现。</p>\n\n<p><code>babel-runtime</code> 更像是分散的 polyfill 模块，我们可以在自己的模块里单独引入，比如 <code>require(‘babel-runtime/core-js/promise’)</code> ，它们不会在全局环境添加未实现的方法，只是这样手动引用每个 polyfill 会非常低效。因此通常和<a href=\"https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime\"><code>babel-plugin-transform-runtime</code></a>一起使用。</p>\n\n<p>通过安装 <code>babel-plugin-transform-runtime</code> 和 <code>babel-runtime</code> 来开始。</p>\n\n<pre><code>$ npm install --save-dev babel-plugin-transform-runtime\n$ npm install --save babel-runtime\n</code></pre>\n\n<blockquote>\n  <p>In most cases, you should install babel-plugin-transform-runtime as a development dependency (with --save-dev) and babel-runtime as a production dependency (with --save).</p>\n  \n  <p>The transformation plugin is typically used only in development, but the runtime itself will be depended on by your deployed/published code.</p>\n</blockquote>\n\n<p>然后更新 <code>.babelrc</code>：</p>\n\n<pre><code>{\n    \"plugins\": [\n        \"transform-runtime\"    \n    ]\n}\n</code></pre>\n\n<p>这样 babel 在编译时就会帮助我们自动加入需要的 API。</p>\n\n<blockquote>\n  <p><code>babel-plugin-transform-runtime</code> 不会帮我们引入实例的方案，如 <code>\"foobar\".includes(\"foo\")</code>，这种情况下往往需要我们自己从 <code>core-js</code> 中引入。直接引入 <code>babel-polyfill</code> 有点浪费了。</p>\n</blockquote>\n\n<h5 id=\"\">高级</h5>\n\n<p>用户指南最后还有一章介绍了一些高级技巧如：自定义插件、环境设置、制作预设。前两个两面已经提过了，这里讲一下如何做自己的 presets。</p>\n\n<p>首先，创建一个 <code>package.json</code>，包括针对预设所必要的 dependencies。</p>\n\n<pre><code>{\n  \"name\": \"babel-preset-my-awesome-preset\",\n  \"version\": \"1.0.0\",\n  \"author\": \"James Kyle &lt;me@thejameskyle.com&gt;\",\n  \"dependencies\": {\n    \"babel-preset-es2015\": \"^6.3.13\",\n    \"babel-preset-react\": \"^6.3.13\",\n    \"babel-plugin-transform-flow-strip-types\": \"^6.3.15\"\n  }\n}\n</code></pre>\n\n<p>然后创建 <code>index.js</code> 文件用于导出 <code>.babelrc</code> 的内容，使用对应的 <code>require</code> 调用来替换 plugins／presets 字符串。</p>\n\n<pre><code>module.exports = {  \n  presets: [\n    require(\"babel-preset-es2015\"),\n    require(\"babel-preset-react\")\n  ],\n  plugins: [\n    require(\"babel-plugin-transform-flow-strip-types\")\n  ]\n};\n</code></pre>\n\n<p>然后只需要发布到 npm 于是你就可以像其它预设一样来使用你的预设了。</p>\n\n<h5 id=\"loose\">loose 模式</h5>\n\n<p>babel 的 preset-es2015 在 6.13 以后提供了 loose 模式，这个模式为了兼容一些 es5 都没有完全支持的浏览器（没错就是IE）做出了一些改动。主要针对的是一下几个插件：'transform-es2015-template-literals'、'transform-es2015-classes'、'transform-es2015-computed-properties'、'transform-es2015-for-of'、'transform-es2015-spread'、'transform-es2015-destructuring'、'transform-es2015-modules-commonjs/amd/systemjs/umd'。（这个具体再开一篇介绍了，估计内容比较多）</p>\n\n<h3 id=\"\">小结</h3>\n\n<p>到这里 babel 的基本使用已经都呈现在这里了，但是真正运用到项目中还需要更多的实践。下篇就会详细介绍一个成功的集成案例，可能是 react-native 吧，还说不准！</p>","image":"/content/images/2016/09/5d5e6ceac1f8a2b4522209e75761caa2.png","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475057413171,"created_by":1,"updated_at":1475372820404,"updated_by":1,"published_at":1475059911731,"published_by":1},{"id":97,"uuid":"c423a13d-1725-401a-b65e-75dbac310f41","title":"随笔","slug":"sui-bi-4","markdown":"<audio autoplay=\"autoplay\">\n  <source src=\"http://ws.stream.qqmusic.qq.com/C200002TuPpZ3hx1Vt.m4a?vkey=0CD03FE62351F5C40C9BDF357AE475E4E215762325E96D3E95839E266336484867E07939562CB061884B6F5D1E5C0265ED695C58AFCD5F32&guid=4415146451&fromtag=30\" />\n</audio>\n\n前两天看了两部电影《街角洋果子店》和《花牌情缘》。\n\n《街角洋果子店》，去看小优的，可是大晚上看着这些蛋糕，一下子饿了。有人说：每当心情低落困顿，或是渐渐失去生活的热情，因倦怠而随波逐流的时候，美食或者美食电影，往往是治愈脾胃与心灵的最好良药。放屁嘞，明明只是会更饿！\n\n开玩笑的！看的时候想的是好想和这样一群人工作啊，有个傲娇的、有个大家都信服的、有个有才气谦逊的，并且大家都心知肚明自己爱的就是这里，不会轻易地离开。这就是我所想的工作环境，也是电影最吸引我的地方。\n\n励志嘛，因为看得多了，也就没有太强烈的共鸣！不对，导演呈现的不够，仅仅只有几个片段。导演更多地把戏份放到了，情感和剧情推动上了，所以感觉少了点什么。\n\n《花牌情缘》，好像是漫改的，充满了热血和激情的片子。（没看过漫画）\n\n无法理解里面的一些设定，绫濑千早仅仅因为小时新的一句世界第一就维持了对于歌留多这项竞技这么多年的热情。也许是因为我们大多数人没有一件能够让我们持续热爱的东西吧，所以无法理解。真是伤感，想起放在寝室的吉他，三个月了，弹得越来越少。\n\n军哥哥说我是三分钟热度，也许是吧，因为没有绫濑千早那样的信念让我去坚持那份枯燥。不对，现在每天待在图书馆的我不正是在坚持着一份枯燥吗？甚至对我来说已经不是枯燥的东西了！但又是什么东西在背后推动着我呢！是想要把未来不确定性降低的信念。\n\n心境一般，写出来的东西都有点那个了！算了就到这吧！对了昨天室友说有个不错的工作，美国的，待遇还行，问我要不要去。我说今天回复他，其实心里早就有了答案。我必须继续这样的生活，直到能够给四年的大学生活以及未来的我一个交代时，才会去找工作，或者自己干也说不定。\n\n而我理想中的未来，也就是上面两部电影描述的那样，有几个有趣且合得来的队友，自己也对于生活对于工作充满热血！这就是理想中的样子！这就是理想中的样子！这就是理想中的样子！重要的事说三遍！","html":"<audio autoplay=\"autoplay\">  \n  <source src=\"http://ws.stream.qqmusic.qq.com/C200002TuPpZ3hx1Vt.m4a?vkey=0CD03FE62351F5C40C9BDF357AE475E4E215762325E96D3E95839E266336484867E07939562CB061884B6F5D1E5C0265ED695C58AFCD5F32&guid=4415146451&fromtag=30\" />\n</audio>\n\n<p>前两天看了两部电影《街角洋果子店》和《花牌情缘》。</p>\n\n<p>《街角洋果子店》，去看小优的，可是大晚上看着这些蛋糕，一下子饿了。有人说：每当心情低落困顿，或是渐渐失去生活的热情，因倦怠而随波逐流的时候，美食或者美食电影，往往是治愈脾胃与心灵的最好良药。放屁嘞，明明只是会更饿！</p>\n\n<p>开玩笑的！看的时候想的是好想和这样一群人工作啊，有个傲娇的、有个大家都信服的、有个有才气谦逊的，并且大家都心知肚明自己爱的就是这里，不会轻易地离开。这就是我所想的工作环境，也是电影最吸引我的地方。</p>\n\n<p>励志嘛，因为看得多了，也就没有太强烈的共鸣！不对，导演呈现的不够，仅仅只有几个片段。导演更多地把戏份放到了，情感和剧情推动上了，所以感觉少了点什么。</p>\n\n<p>《花牌情缘》，好像是漫改的，充满了热血和激情的片子。（没看过漫画）</p>\n\n<p>无法理解里面的一些设定，绫濑千早仅仅因为小时新的一句世界第一就维持了对于歌留多这项竞技这么多年的热情。也许是因为我们大多数人没有一件能够让我们持续热爱的东西吧，所以无法理解。真是伤感，想起放在寝室的吉他，三个月了，弹得越来越少。</p>\n\n<p>军哥哥说我是三分钟热度，也许是吧，因为没有绫濑千早那样的信念让我去坚持那份枯燥。不对，现在每天待在图书馆的我不正是在坚持着一份枯燥吗？甚至对我来说已经不是枯燥的东西了！但又是什么东西在背后推动着我呢！是想要把未来不确定性降低的信念。</p>\n\n<p>心境一般，写出来的东西都有点那个了！算了就到这吧！对了昨天室友说有个不错的工作，美国的，待遇还行，问我要不要去。我说今天回复他，其实心里早就有了答案。我必须继续这样的生活，直到能够给四年的大学生活以及未来的我一个交代时，才会去找工作，或者自己干也说不定。</p>\n\n<p>而我理想中的未来，也就是上面两部电影描述的那样，有几个有趣且合得来的队友，自己也对于生活对于工作充满热血！这就是理想中的样子！这就是理想中的样子！这就是理想中的样子！重要的事说三遍！</p>","image":"/content/images/2016/09/p2268020767.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475107953152,"created_by":1,"updated_at":1475111528742,"updated_by":1,"published_at":1475110475668,"published_by":1},{"id":98,"uuid":"20506711-713d-44c6-80f8-fba89df15df0","title":"babel loose 模式","slug":"babel-loose-mo-shi","markdown":"babel 的 loose 模式在上一篇已经提过了，本篇是对这个话题的展开，会针对最新的 preset-es2015 中支持 loose 模式的每个插件进行相关的介绍。最后也顺其自然地探究了一下兼容 IE 8 的最佳实践。（6.13前需要使用别的 preset 来支持 loose 模式，github 上自行查找）\n\n#### es2015-template-literals\n\n模板字符串插件包括了以下两个参数：\n\n- loose：在 loose 模式下，带标签的模板字符串对象将不是 frozen 的。\n- spec：默认 false，是不符合标准的，但是为了性能做了权衡。true 的话表现将与标准保持一致。祥见 [babel/babel#1065](https://github.com/babel/babel/issues/1065)\n\n有下面一段代码：（未开启 transform-runtime）\n\n```\nvar a = 5;\n\nfunction tag(strings, ...values) {\n  console.log(strings[0]); // \"Hello \"\n  console.log(strings[1]); // \" world \"\n  console.log(values[0]);  // 15\n\n  return \"Bazinga!\";\n}\n\nconsole.log(tag`Hello ${ a } world`);\n// \"Bazinga!\"\n```\n\nnormal 下编译的结果：\n\n```\n\"use strict\";\n\nvar _templateObject = _taggedTemplateLiteral([\"Hello \", \" world\"], [\"Hello \", \" world\"]);\n\nfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nvar a = 5;\n\nfunction tag(strings) {\n  console.log(strings[0]); // \"Hello \"\n  console.log(strings[1]); // \" world \"\n  console.log(arguments.length <= 1 ? undefined : arguments[1]); // 15\n\n  return \"Bazinga!\";\n}\n\nconsole.log(tag(_templateObject, a));\n// \"Bazinga!\"\n```\n\nloose 模式下：\n\n```\n\"use strict\";\n\nvar _templateObject = _taggedTemplateLiteralLoose([\"Hello \", \" world\"], [\"Hello \", \" world\"]);\n\nfunction _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }\n\nvar a = 5;\n\nfunction tag(strings) {\n  console.log(strings[0]); // \"Hello \"\n  console.log(strings[1]); // \" world \"\n  console.log(arguments.length <= 1 ? undefined : arguments[1]); // 15\n\n  return \"Bazinga!\";\n}\n\nconsole.log(tag(_templateObject, a));\n// \"Bazinga!\"\n```\n\n可以看到 loose 下是直接使用属性赋值，这是非标准的，但是在 IE8 下是正常的。对于 normal 我们可以看到它使用了 `Object.freeze` 和 `Object.defineProperties` 这两个 IE 9 才开始支持的方法。\n\n`Object.freeze` 的好处在于带标签的模板字符串对象是冻结的，不会被修改和删除，更加安全。\n\n#### es2015-classes\n\nes6 classes 只包含如下一个选项：\n\n- loose\n - 方法是可枚举的，这是不符合标准的。\n - 方法通过赋值的方式，因此类似下面的例子将不起作用。（虽然在生产环境很少会写出这样的代码）\n\n```\nclass Foo {\n  set bar() {\n    throw new Error(\"foo!\");\n  }\n}\n\nclass Bar extends Foo {\n  bar() {\n    // will throw an error when this method is defined\n  }\n}\n```\n\nnormal 模式下，会通过 `Object.defineProperty` 来进行方法的设置。而 loose 下则是直接赋值。到这里可以猜测下面的几个也是出于同样目的吧！\n\n#### es2015-computed-properties\n\n- loose\n - 就像 loose 模式下在 classes 中方法是通过赋值的一样。在 loose 模式下，计算属性也是通过赋值的方式，而不是 define 的方式。原因一样是为了避免使用 es5 的 `Object.defineProperty` 方法。\n\n#### es2015-for-of\n\n- loose\n - 突然完成：在 loose 模式下，因为抛出异常而导致迭代突然完成时，不会调用迭代器的 return 方法。[github issue 838](https://github.com/babel/babel/issues/838)\n - 数组： loose 模式下 forOf 转换器会输出更详细的迭代代码。这可以带来快速通道、性能显著提升。所有其它的迭代器将继续正常工作，除了数组会有显著地提升。\n\nnormal 模式下，编译的代码时带两个 try catch，这会影响 V8 内部的性能优化，而为了权衡性能，loose 下去掉了这两个 try catch。[github issue 1176](https://github.com/babel/babel/issues/1176)\n\n#### es2015-spread\n\n- loose\n - 所有可迭代对象会被假定为数组。\n\n以下代码：\n\n```\nlet a = new Set([1,2,3]);\nconsole.log('union', [...a]);\n```\n\n在 normal 模式下：\n\n```\n'use strict';\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar a = new Set([1, 2, 3]);\nconsole.log('union', [].concat(_toConsumableArray(a)));\n```\n\nloose 模式下：\n\n```\n'use strict';\n\nvar a = new Set([1, 2, 3]);\nconsole.log('union', [].concat(a));\n```\n\nnormal 模式下用到了 IE 9 才支持的 `Array.isArray` 以及 es6 的 `Array.from`。\n\n#### es2015-destructuring\n\n结构赋值的 loose 模式官网没有提到，试了几个例子才找到：\n\n```\nfunction add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]); // 3\n```\n\n这段代码在 normal 模式下：\n\n```\n\"use strict\";\n\nvar _slicedToArray = function () { \n\tfunction sliceIterator(arr, i) { \n\t\tvar _arr = []; \n\t\tvar _n = true; \n\t\tvar _d = false; \n\t\tvar _e = undefined; \n\t\ttry { \n\t\t\tfor (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { \n\t\t\t\t_arr.push(_s.value); \n\t\t\t\tif (i && _arr.length === i) break; \n\t\t\t} \n\t\t} catch (err) { _\n\t\t\td = true; _e = err; \n\t\t} finally { \n\t\t\ttry { \n\t\t\t\tif (!_n && _i[\"return\"]) _i[\"return\"](); \n\t\t\t} finally { \n\t\t\t\tif (_d) throw _e; \n\t\t\t} \n\t\t} \n\t\treturn _arr; \n\t} \n\treturn function (arr, i) { \n\t\tif (Array.isArray(arr)) { \n\t\t\treturn arr; \n\t\t} else if (Symbol.iterator in Object(arr)) { \n\t\t\treturn sliceIterator(arr, i); \n\t\t} else { \n\t\t\tthrow new TypeError(\"Invalid attempt to destructure non-iterable instance\"); \n\t\t} \n\t}; \n}();\n\nfunction add(_ref) {\n  var _ref2 = _slicedToArray(_ref, 2);\n\n  var x = _ref2[0];\n  var y = _ref2[1];\n\n  return x + y;\n}\n\nadd([1, 2]); // 3\n```\n\n而 loose 下简单地多：\n\n```\n\"use strict\";\n\nfunction add(_ref) {\n  var x = _ref[0];\n  var y = _ref[1];\n\n  return x + y;\n}\n\nadd([1, 2]); // 3\n```\n\n显然 normal 模式下的代码更加安全，但是兼容性及性能略差。\n\n#### Modules\n\n6.13 preset-2015 在引入 loose 配置项的同时引入了 modules 配置项，用来将 es6 module 语法转换为其它的 module 语法，默认为 commonjs，另外还支持[\"amd\", \"umd\", \"systemjs\", \"commonjs\"]。配置为 false 则不进行转换。\n\n对应四种 module 规范有四个插件，都支持 loose 模式。\n\n- loose\n - 在规范中，规定 import 和 export 只能出现在模块顶层，而不能出现在语句块中。在 loose 模式下，则没有这种限制\n - 当 module 存在 default export 的时候，babel 会同时 export 一个不可枚举的属性 `__esModule`。在 loose 模式下，这个属性是使用赋值来做的，而正常情况下是使用 `Object.defineProperty` 来做的。\n\n从上面的分析可以看到，loose 模式摒弃了一些 IE9 一下不支持的 es5 特性，从而来兼容 IE 9 一下的浏览器。loose 模式下也有对一些性能问题的妥协，如去掉 try block，数组 forOf 降级为 for 来实现，以提高性能。\n\n#### 兼容 IE8 的最佳实践（待测试）\n\n网上对于 loose 模式的介绍通常是与 IE 8 的兼容进行挂钩的。所以在对 loose 有了比较全面的认识之后，就来探究一下兼容 IE 8 的最佳实践吧！\n\n1. `babel-plugin-transform-runtime`\n2. `core.js`\n\n上一篇讲到 `babel-plugin-transform-runtime`。这个插件做了如下三件事：\n\n- 当你使用 generators/async functions 自动帮你引入 babel-runtime/regenerator。\n- 当你帮我们引入静态方法和一些内建模块，如 Object.assign Promise 等。实例方法是不会引入的，建议的方式是直接从 core.js 中手动引入。\n- 把行内的 helper 用 babel-runtime/helpers 代替。\n\n它支持四个参数 helpers、polyfill、regenerator、moduleName，下面一个个介绍。\n\nhelpers 是 6.12.0 增加的，默认开启，开启后就会用 babel-runtime/helpers 代替行内的 helper。增加这个是因为开启 helpers 后打包后的体积变大了不少，还不如不开启。\n\npolyfill 默认开启，开启时会自动引入静态方法和内置对象。但要注意的是开启 polyfill 后，会与 `export * from 'xx'` 有冲突。因此要注意开启 polyfill 后避免使用 `export * from 'xx'`。github上虽然已经有了一些变通的方案，但是避免使用 `export * from 'xx'` 或者关闭 polyfill，然后手动导入 core.js 是比较推荐的。[传送门](https://github.com/babel/babel/issues/2877#issuecomment-245402025)\n\nregenerator 是默认开启，用来支持 generators/async functions。\n\nmoduleName 默认值是 \"babel-runtime\"，6.15.0 引入这了个配置项。主要针对非本地项目安装 `babel-runtime` 时出现的路径问题。有需求的看[传送门](https://github.com/facebookincubator/create-react-app/issues/255?spm=5176.100239.blogcont60724.21.NPmW0P)\n\n既然这个插件能够自动引入 `Object.defineProperty` 等静态方法了，那么貌似 `loose` 都不用开启了。\n\n最后的配置如下：\n\n```\n{\n  plugins: [\n    [\"transform-runtime\", {\n      \"helpers\": false,\n      \"polyfill\": true,  // 默认，可不配置\n      \"regenerator\": true  // 默认，可不配置\n    }],\n    'add-module-exports',// 解决 babel6 export default的问题，自行github  \n    'transform-es3-member-expression-literals',// 解决保留字作为取值表达式，自行 github\n    'transform-es3-property-literals', // 解决保留字作为键，自行 github\n  ],\n  \"presets\": [\n    'es2015',\n    // 根据需求增加\n  ],\n}\n```\n\nes5-shim/es5-sham 是否还有必要待测试，网上看到的说法是都加的，mac 下没法测试 windows ，真是尴尬。这部分的内容会用在之后用 react 重写博客的时候进行验证的，届时找台 windows 测试一下。\n\n参考资料：\n\n1. [官网](babeljs.io)\n2. [github](https://github.com/babel/babel)\n3. [ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍(上)](https://yq.aliyun.com/articles/59107?spm=5176.100239.blogcont60724.33.NPmW0P)\n4. [ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍(下)](https://yq.aliyun.com/articles/60724?spm=5176.100239.blogcont59107.15.0msnB1)","html":"<p>babel 的 loose 模式在上一篇已经提过了，本篇是对这个话题的展开，会针对最新的 preset-es2015 中支持 loose 模式的每个插件进行相关的介绍。最后也顺其自然地探究了一下兼容 IE 8 的最佳实践。（6.13前需要使用别的 preset 来支持 loose 模式，github 上自行查找）</p>\n\n<h4 id=\"es2015templateliterals\">es2015-template-literals</h4>\n\n<p>模板字符串插件包括了以下两个参数：</p>\n\n<ul>\n<li>loose：在 loose 模式下，带标签的模板字符串对象将不是 frozen 的。</li>\n<li>spec：默认 false，是不符合标准的，但是为了性能做了权衡。true 的话表现将与标准保持一致。祥见 <a href=\"https://github.com/babel/babel/issues/1065\">babel/babel#1065</a></li>\n</ul>\n\n<p>有下面一段代码：（未开启 transform-runtime）</p>\n\n<pre><code>var a = 5;\n\nfunction tag(strings, ...values) {  \n  console.log(strings[0]); // \"Hello \"\n  console.log(strings[1]); // \" world \"\n  console.log(values[0]);  // 15\n\n  return \"Bazinga!\";\n}\n\nconsole.log(tag`Hello ${ a } world`);  \n// \"Bazinga!\"\n</code></pre>\n\n<p>normal 下编译的结果：</p>\n\n<pre><code>\"use strict\";\n\nvar _templateObject = _taggedTemplateLiteral([\"Hello \", \" world\"], [\"Hello \", \" world\"]);\n\nfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nvar a = 5;\n\nfunction tag(strings) {  \n  console.log(strings[0]); // \"Hello \"\n  console.log(strings[1]); // \" world \"\n  console.log(arguments.length &lt;= 1 ? undefined : arguments[1]); // 15\n\n  return \"Bazinga!\";\n}\n\nconsole.log(tag(_templateObject, a));  \n// \"Bazinga!\"\n</code></pre>\n\n<p>loose 模式下：</p>\n\n<pre><code>\"use strict\";\n\nvar _templateObject = _taggedTemplateLiteralLoose([\"Hello \", \" world\"], [\"Hello \", \" world\"]);\n\nfunction _taggedTemplateLiteralLoose(strings, raw) { strings.raw = raw; return strings; }\n\nvar a = 5;\n\nfunction tag(strings) {  \n  console.log(strings[0]); // \"Hello \"\n  console.log(strings[1]); // \" world \"\n  console.log(arguments.length &lt;= 1 ? undefined : arguments[1]); // 15\n\n  return \"Bazinga!\";\n}\n\nconsole.log(tag(_templateObject, a));  \n// \"Bazinga!\"\n</code></pre>\n\n<p>可以看到 loose 下是直接使用属性赋值，这是非标准的，但是在 IE8 下是正常的。对于 normal 我们可以看到它使用了 <code>Object.freeze</code> 和 <code>Object.defineProperties</code> 这两个 IE 9 才开始支持的方法。</p>\n\n<p><code>Object.freeze</code> 的好处在于带标签的模板字符串对象是冻结的，不会被修改和删除，更加安全。</p>\n\n<h4 id=\"es2015classes\">es2015-classes</h4>\n\n<p>es6 classes 只包含如下一个选项：</p>\n\n<ul>\n<li>loose\n<ul><li>方法是可枚举的，这是不符合标准的。</li>\n<li>方法通过赋值的方式，因此类似下面的例子将不起作用。（虽然在生产环境很少会写出这样的代码）</li></ul></li>\n</ul>\n\n<pre><code>class Foo {  \n  set bar() {\n    throw new Error(\"foo!\");\n  }\n}\n\nclass Bar extends Foo {  \n  bar() {\n    // will throw an error when this method is defined\n  }\n}\n</code></pre>\n\n<p>normal 模式下，会通过 <code>Object.defineProperty</code> 来进行方法的设置。而 loose 下则是直接赋值。到这里可以猜测下面的几个也是出于同样目的吧！</p>\n\n<h4 id=\"es2015computedproperties\">es2015-computed-properties</h4>\n\n<ul>\n<li>loose\n<ul><li>就像 loose 模式下在 classes 中方法是通过赋值的一样。在 loose 模式下，计算属性也是通过赋值的方式，而不是 define 的方式。原因一样是为了避免使用 es5 的 <code>Object.defineProperty</code> 方法。</li></ul></li>\n</ul>\n\n<h4 id=\"es2015forof\">es2015-for-of</h4>\n\n<ul>\n<li>loose\n<ul><li>突然完成：在 loose 模式下，因为抛出异常而导致迭代突然完成时，不会调用迭代器的 return 方法。<a href=\"https://github.com/babel/babel/issues/838\">github issue 838</a></li>\n<li>数组： loose 模式下 forOf 转换器会输出更详细的迭代代码。这可以带来快速通道、性能显著提升。所有其它的迭代器将继续正常工作，除了数组会有显著地提升。</li></ul></li>\n</ul>\n\n<p>normal 模式下，编译的代码时带两个 try catch，这会影响 V8 内部的性能优化，而为了权衡性能，loose 下去掉了这两个 try catch。<a href=\"https://github.com/babel/babel/issues/1176\">github issue 1176</a></p>\n\n<h4 id=\"es2015spread\">es2015-spread</h4>\n\n<ul>\n<li>loose\n<ul><li>所有可迭代对象会被假定为数组。</li></ul></li>\n</ul>\n\n<p>以下代码：</p>\n\n<pre><code>let a = new Set([1,2,3]);  \nconsole.log('union', [...a]);  \n</code></pre>\n\n<p>在 normal 模式下：</p>\n\n<pre><code>'use strict';\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i &lt; arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar a = new Set([1, 2, 3]);  \nconsole.log('union', [].concat(_toConsumableArray(a)));  \n</code></pre>\n\n<p>loose 模式下：</p>\n\n<pre><code>'use strict';\n\nvar a = new Set([1, 2, 3]);  \nconsole.log('union', [].concat(a));  \n</code></pre>\n\n<p>normal 模式下用到了 IE 9 才支持的 <code>Array.isArray</code> 以及 es6 的 <code>Array.from</code>。</p>\n\n<h4 id=\"es2015destructuring\">es2015-destructuring</h4>\n\n<p>结构赋值的 loose 模式官网没有提到，试了几个例子才找到：</p>\n\n<pre><code>function add([x, y]){  \n  return x + y;\n}\n\nadd([1, 2]); // 3  \n</code></pre>\n\n<p>这段代码在 normal 模式下：</p>\n\n<pre><code>\"use strict\";\n\nvar _slicedToArray = function () {  \n    function sliceIterator(arr, i) { \n        var _arr = []; \n        var _n = true; \n        var _d = false; \n        var _e = undefined; \n        try { \n            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { \n                _arr.push(_s.value); \n                if (i &amp;&amp; _arr.length === i) break; \n            } \n        } catch (err) { _\n            d = true; _e = err; \n        } finally { \n            try { \n                if (!_n &amp;&amp; _i[\"return\"]) _i[\"return\"](); \n            } finally { \n                if (_d) throw _e; \n            } \n        } \n        return _arr; \n    } \n    return function (arr, i) { \n        if (Array.isArray(arr)) { \n            return arr; \n        } else if (Symbol.iterator in Object(arr)) { \n            return sliceIterator(arr, i); \n        } else { \n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); \n        } \n    }; \n}();\n\nfunction add(_ref) {  \n  var _ref2 = _slicedToArray(_ref, 2);\n\n  var x = _ref2[0];\n  var y = _ref2[1];\n\n  return x + y;\n}\n\nadd([1, 2]); // 3  \n</code></pre>\n\n<p>而 loose 下简单地多：</p>\n\n<pre><code>\"use strict\";\n\nfunction add(_ref) {  \n  var x = _ref[0];\n  var y = _ref[1];\n\n  return x + y;\n}\n\nadd([1, 2]); // 3  \n</code></pre>\n\n<p>显然 normal 模式下的代码更加安全，但是兼容性及性能略差。</p>\n\n<h4 id=\"modules\">Modules</h4>\n\n<p>6.13 preset-2015 在引入 loose 配置项的同时引入了 modules 配置项，用来将 es6 module 语法转换为其它的 module 语法，默认为 commonjs，另外还支持[\"amd\", \"umd\", \"systemjs\", \"commonjs\"]。配置为 false 则不进行转换。</p>\n\n<p>对应四种 module 规范有四个插件，都支持 loose 模式。</p>\n\n<ul>\n<li>loose\n<ul><li>在规范中，规定 import 和 export 只能出现在模块顶层，而不能出现在语句块中。在 loose 模式下，则没有这种限制</li>\n<li>当 module 存在 default export 的时候，babel 会同时 export 一个不可枚举的属性 <code>__esModule</code>。在 loose 模式下，这个属性是使用赋值来做的，而正常情况下是使用 <code>Object.defineProperty</code> 来做的。</li></ul></li>\n</ul>\n\n<p>从上面的分析可以看到，loose 模式摒弃了一些 IE9 一下不支持的 es5 特性，从而来兼容 IE 9 一下的浏览器。loose 模式下也有对一些性能问题的妥协，如去掉 try block，数组 forOf 降级为 for 来实现，以提高性能。</p>\n\n<h4 id=\"ie8\">兼容 IE8 的最佳实践（待测试）</h4>\n\n<p>网上对于 loose 模式的介绍通常是与 IE 8 的兼容进行挂钩的。所以在对 loose 有了比较全面的认识之后，就来探究一下兼容 IE 8 的最佳实践吧！</p>\n\n<ol>\n<li><code>babel-plugin-transform-runtime</code>  </li>\n<li><code>core.js</code></li>\n</ol>\n\n<p>上一篇讲到 <code>babel-plugin-transform-runtime</code>。这个插件做了如下三件事：</p>\n\n<ul>\n<li>当你使用 generators/async functions 自动帮你引入 babel-runtime/regenerator。</li>\n<li>当你帮我们引入静态方法和一些内建模块，如 Object.assign Promise 等。实例方法是不会引入的，建议的方式是直接从 core.js 中手动引入。</li>\n<li>把行内的 helper 用 babel-runtime/helpers 代替。</li>\n</ul>\n\n<p>它支持四个参数 helpers、polyfill、regenerator、moduleName，下面一个个介绍。</p>\n\n<p>helpers 是 6.12.0 增加的，默认开启，开启后就会用 babel-runtime/helpers 代替行内的 helper。增加这个是因为开启 helpers 后打包后的体积变大了不少，还不如不开启。</p>\n\n<p>polyfill 默认开启，开启时会自动引入静态方法和内置对象。但要注意的是开启 polyfill 后，会与 <code>export * from 'xx'</code> 有冲突。因此要注意开启 polyfill 后避免使用 <code>export * from 'xx'</code>。github上虽然已经有了一些变通的方案，但是避免使用 <code>export * from 'xx'</code> 或者关闭 polyfill，然后手动导入 core.js 是比较推荐的。<a href=\"https://github.com/babel/babel/issues/2877#issuecomment-245402025\">传送门</a></p>\n\n<p>regenerator 是默认开启，用来支持 generators/async functions。</p>\n\n<p>moduleName 默认值是 \"babel-runtime\"，6.15.0 引入这了个配置项。主要针对非本地项目安装 <code>babel-runtime</code> 时出现的路径问题。有需求的看<a href=\"https://github.com/facebookincubator/create-react-app/issues/255?spm=5176.100239.blogcont60724.21.NPmW0P\">传送门</a></p>\n\n<p>既然这个插件能够自动引入 <code>Object.defineProperty</code> 等静态方法了，那么貌似 <code>loose</code> 都不用开启了。</p>\n\n<p>最后的配置如下：</p>\n\n<pre><code>{\n  plugins: [\n    [\"transform-runtime\", {\n      \"helpers\": false,\n      \"polyfill\": true,  // 默认，可不配置\n      \"regenerator\": true  // 默认，可不配置\n    }],\n    'add-module-exports',// 解决 babel6 export default的问题，自行github  \n    'transform-es3-member-expression-literals',// 解决保留字作为取值表达式，自行 github\n    'transform-es3-property-literals', // 解决保留字作为键，自行 github\n  ],\n  \"presets\": [\n    'es2015',\n    // 根据需求增加\n  ],\n}\n</code></pre>\n\n<p>es5-shim/es5-sham 是否还有必要待测试，网上看到的说法是都加的，mac 下没法测试 windows ，真是尴尬。这部分的内容会用在之后用 react 重写博客的时候进行验证的，届时找台 windows 测试一下。</p>\n\n<p>参考资料：</p>\n\n<ol>\n<li><a href=\"babeljs.io\">官网</a>  </li>\n<li><a href=\"https://github.com/babel/babel\">github</a>  </li>\n<li><a href=\"https://yq.aliyun.com/articles/59107?spm=5176.100239.blogcont60724.33.NPmW0P\">ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍(上)</a>  </li>\n<li><a href=\"https://yq.aliyun.com/articles/60724?spm=5176.100239.blogcont59107.15.0msnB1\">ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍(下)</a></li>\n</ol>","image":"/content/images/2016/09/---2.png","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475148042179,"created_by":1,"updated_at":1475372808167,"updated_by":1,"published_at":1475151003217,"published_by":1},{"id":99,"uuid":"2f37d7bc-7499-4441-83fc-2144e5c73429","title":"babel 集成——babel loader","slug":"babel-loader","markdown":"之前讲到要写一个 babel 集成的例子，本来打算写 react native 集成 babel 的方案，但考虑到之后重构博客要集成 webpack，所以还是选了 babel loader。所以这篇除了写到 babel 集成外，还会涉及 webpack 的 loader 编写，想想都有点激动吧！因为之前对 webpack 的理解不深，所以会从最基础开始，前面的铺垫就略长。\n\n#### loaders 基础\n\n> 以下内容本人翻译自官网\n\nwebpack 的 loaders 允许我们在 `require` 或加载文件时，预处理这些文件。loaders 有点类似其它构建工具中的 “tasks”，并提供了强大的方式来处理前端构建流程。loaders 能够将文件从一种语言转换成另一种，例如 CoffeeScript 到 Javascript，也可以把 images 转换成 data URLs 的形式。它甚至允许你在 Javascript 中 `require` css 文件。\n\n为了告诉 webpack 用某个 loader 来进行处理，你需要在 webpack 的配置文件中进行配置（推荐的方式）或在请求某个模块时指定，例如在 `require` 中：\n\n```\nvar moduleWithOneLoader = require(\"my-loader!./my-awesome-module\");\n```\n\n注意到 `!` 语法将 loader 从模块路径分割了吗？loaders 也可以使用相对路径的方式来代替 loader 名：\n\n```\nrequire(\"./loaders/my-loader!./my-awesome-module\");\n```\n\nloaders 也可以通过 `!` 分隔进行组合链式地调用。这是十分有用的，当一个文件需要多重转换的时候。\n\n```\nrequire(\"style-loader!css-loader!less-loader!./my-styles.less\");\n```\n\n链式调用是从右到左进行的，就上面的例子来看 `my-styles.less` 首先会被 `less-loader` 处理成 css，然后传递给 `css-loader` 处理，最后交给 `style-loader` 将其转换到一个 `<style>` 标签内。\n\n###### 参数\n\nloaders 能够接收 query 参数：\n\n```\nrequire(\"loader?with=parameter!./file\");\n```\n\nquery 字符串的格式应当由每个 loader 来负责，所以使用前需要检查 loaders 文档找出关于 loader 接收参数的内容，但是通常大多数 loaders 是支持传统 query 字符串格式化。\n\n###### 配置 loaders\n\n在每个某块请求中指定 loaders 是缺乏弹性、重复性高的。webpack 提供在配置文件中为每类文件指定 loaders 的方式。这种方式也是更加推荐的，因为构建的代码不会侵入到我们的代码中，从而提高了复用性。\n\n```\n{\n    module: {\n        loaders: [\n            { test: /\\.coffee$/, loader: \"coffee-loader\" }\n        ],\n        preLoaders: [\n            { test: /\\.coffee$/, loader: \"coffee-hint-loader\" }\n        ]\n    }\n};\n```\n\n###### loader 顺序\n\n在文件从文件系统读取之后，loaders 按以下的顺序执行：\n\n1. 配置文件中的 `preloaders`。\n2. 配置文件中的 `loaders`。\n3. loaders specified in the request (e.g. require('raw!./file.js'))\n4. 配置文件中的 `postLoaders`。\n\n你也可以在 模块请求中覆盖配置的 loader 顺序来适应一些特殊的情况。\n\n- adding ! to a request will disable configured preLoaders\nrequire(\"!raw!./script.coffee\")\n- adding !! to a request will disable all loaders specified in the configuration\nrequire(\"!!raw!./script.coffee\")\n- adding -! to a request will disable configured preLoaders and loaders but not the postLoaders\nrequire(\"-!raw!./script.coffee\")\n\n###### 推荐做法\n\n> 这部分没有很好理解，放到后面写 webpack 的时候。\n\n推荐在第二步处理之后结果为 Javascript。\n\n推荐非 Javascript 向 Javascript 的转换放在第一步。（当它们不全局应用的时候也可以第二步）\n\n建议preloader 和 postloader 的过程中，使用相同的语言。\n\n想要覆盖非 Javascript 到 Javascript 转换的源代码，加入 `!` 前缀。\n\n使用 `!!` 和 `-!` 前缀来禁用 loaders 是不推荐的。\n\n以下是几个使用的例子\n\n- preloader：图片压缩。\n- loader （配置文件）：coffee-script转换成js。\n- loader （请求）：bundle loader。\n- postloader：代码覆盖率测试等。\n\n#### 写一个 loader\n\n写一个 loader 是相当简单的。一个 loader 仅仅是导出一个函数的文件。编译器会调用这个函数并将结果传递给前面的 loader 或者导入源文件给它。这个函数的 `this` 上下文是由编译器传递进来的的，它包含了很多有用的方法，能够让我们做一些如异步、获取参数的事。源文件的内容传递给第一个 loader。然后编译器期望从最后一个 loader 得到一个结果。结果可以使字符串也可以是 Buffer，代表了这个模块的 Javascript 源代码。一个可选的 SourceMap （JSON object）结果也许也会被传递。\n\n在同步模式，一个单一的结果可以直接被返回。想要返回多个结果，必须调用 `this.callback` 方法。在异步模式下，`this.async()` 必须被调用。如果 `this.async()` 被允许，那么会返回 `this.callback` 。然后这个 loader 必须返回 `undefined` 并调用 callback。\n\n错误能够在同步模式下被抛出，或 `this.callback` 调用时带 error。\n\nwebpack 允许在任何地方使用异步模式。\n\n`enhanced-require` allows async mode only with `require.ensure` or AMD `require`。\n\n更详细的说明和指南，check out [How to write a loader](http://webpack.github.io/docs/how-to-write-a-loader.html)。\n\n##### 例子\n\n###### sync loader\n\n```\nmodule.exports = function(content) {\n    return someSyncOperation(content);\n};\n```\n\n###### async loader\n\n```\nmodule.exports = function(content) {\n    var callback = this.async();\n    if(!callback) return someSyncOperation(content);\n    someAsyncOperation(content, function(err, result) {\n        if(err) return callback(err);\n        callback(null, result);\n    });\n};\n```\n\n###### raw loader\n\n默认情况下源文件被以 utf-8 字符串对待，并传递字符串给 loader。通过设置 raw 为 true 来传递 raw Buffer。\n\n每一个 loader 允许接受 String 或 Buffer 结果。编译器会在两个 loaders 之间转换它们。\n\n```\nmodule.exports = function(content) {\n    assert(content instanceof Buffer);\n    return someSyncOperation(content);\n    // return value can be a Buffer too\n    // This is also allowed if loader is not \"raw\"\n};\nmodule.exports.raw = true;\n```\n\n###### pitching loader\n\nloaders 默认是从右向左调用。但是在一些情况下 loaders 不在乎前一个 loader 的结果或者 源文件。它们只关注 metadata。在 loaders 调用之前，loaders 上的 pitch 方法被从左向右调用。如果一个loader用pitch方法提供了结果，程序就会回转并跳过剩下的loaders，继续调用更多的左边的loaders。数据可以在 pitch和普通调用间传递。（[不是很理解到底有什么用，这里有个讨论](https://github.com/webpack/webpack/issues/360)，因为和 babel loader 关系不大，暂时跳过）\n\n```\nmodule.exports = function(content) {\n    return someSyncOperation(content, this.data.value);\n};\nmodule.exports.pitch = function(remainingRequest, precedingRequest, data) {\n    if(someCondition()) {\n        // fast exit\n        return \"module.exports = require(\" + JSON.stringify(\"-!\" + remainingRequest) + \");\";\n    }\n    data.value = 42;\n};\n```\n\n##### this 上下文\n\n这里内容太多，只在 babel loader 里面具体介绍所用到的方法了。\n\n#### babel loader\n\n到目前为止，我们大致把 webpack loader 相关的所有知识都过了一遍，差不多可以开始读 babel-loader 的源码了！\n\n```\n'use strict';\n\nvar assign = require('object-assign');          // 用来合并不同的配置项\nvar babel = require('babel-core');              // 提供 transform 方法\nvar loaderUtils = require('loader-utils');      // loader 工具库\nvar cache = require('./lib/fs-cache.js');       // 提供文件缓存\nvar exists = require('./lib/helpers/exists')(); // 判断文件是否存在于缓存或文件系统\nvar read = require('./lib/helpers/read')();     // 从缓存或文件系统读取文件\nvar resolveRc = require('./lib/resolve-rc.js'); // 查找 .babelrc 配置文件\nvar pkg = require('./package.json');            \nvar path = require('path');\n\n/**\n * 自定义符合 webpack 输出规则的 Error \n */\nfunction BabelLoaderError(name, message, codeFrame, hideStack, error) {\n  Error.call(this);\n  Error.captureStackTrace(this, BabelLoaderError);\n\n  this.name = 'BabelLoaderError';\n  this.message = formatMessage(name, message, codeFrame);\n  this.hideStack = hideStack;\n  this.error = error;\n}\n\nBabelLoaderError.prototype = Object.create(Error.prototype);\nBabelLoaderError.prototype.constructor = BabelLoaderError;\n\nvar STRIP_FILENAME_RE = /^[^:]+: /;    // 除去文件名的正则\n\nvar formatMessage = function(name, message, codeFrame) {\n  return (name ? name + ': ' : '') + message + '\\n\\n' + codeFrame + '\\n';\n};\n\n// 调用 babel.transform 转换代码\nvar transpile = function(source, options) {\n  var result;\n  try {\n    result = babel.transform(source, options);\n  } catch (error) {\n    if (error.message && error.codeFrame) {\n      var message = error.message;\n      var name;\n      var hideStack;\n      if (error instanceof SyntaxError) {\n        message = message.replace(STRIP_FILENAME_RE, '');\n        name = 'SyntaxError';\n        hideStack = true;\n      } else if (error instanceof TypeError) {\n        message = message.replace(STRIP_FILENAME_RE, '');\n        hideStack = true;\n      }\n      throw new BabelLoaderError(\n        name, message, error.codeFrame, hideStack, error);\n    } else {\n      throw error;\n    }\n  }\n  var code = result.code;     // 编译得到的代码\n  var map = result.map;       // 编译得到的sourceMap\n\n  if (map && (!map.sourcesContent || !map.sourcesContent.length)) {\n    map.sourcesContent = [source];\n  }\n\n  return {\n    code: code,\n    map: map,\n  };\n};\n\n\nmodule.exports = function(source, inputSourceMap) {\n  var result = {};\n\n  // Handle filenames (#106)\n  var webpackRemainingChain = loaderUtils.getRemainingRequest(this).split('!');\n  var filename = webpackRemainingChain[webpackRemainingChain.length - 1];\n\n  // 把用户的配置、默认的配置以及来自 .babelrc 的配置组合\n  var globalOptions = this.options.babel || {};\n  var loaderOptions = loaderUtils.parseQuery(this.query);\n  var userOptions = assign({}, globalOptions, loaderOptions);\n  var defaultOptions = {\n    inputSourceMap: inputSourceMap,\n    sourceRoot: process.cwd(),\n    filename: filename,\n    cacheIdentifier: JSON.stringify({\n      'babel-loader': pkg.version,\n      'babel-core': babel.version,\n      babelrc: exists(userOptions.babelrc) ?\n          read(userOptions.babelrc) :\n          resolveRc(path.dirname(filename)),\n      env: process.env.BABEL_ENV || process.env.NODE_ENV,\n    }),\n  };\n\n  var options = assign({}, defaultOptions, userOptions);\n\n  if (userOptions.sourceMap === undefined) {\n    options.sourceMap = this.sourceMap;\n  }\n\n  if (options.sourceFileName === undefined) {\n    options.sourceFileName = path.relative(\n        options.sourceRoot,\n        options.filename\n    );\n  }\n\n  // 获取缓存参数缓存\n  var cacheDirectory = options.cacheDirectory;\n  var cacheIdentifier = options.cacheIdentifier;\n\n  delete options.cacheDirectory;    // options 要传递给 transform 所以要把没用的参数删掉，不删掉貌似会有问题\n  delete options.cacheIdentifier;    // options 要传递给 transform 所以要把没用的参数删掉，不删掉貌似会有问题\n\n  this.cacheable(); // 开启缓存的要求是输入相同的情况下输出一定相同\n\n  // 如果提供了缓存目录，那么下面就是异步的\n  // cache 函数会先从缓存中返回内容，如果缓存变了，那么会重新编译存入缓存\n  if (cacheDirectory) {\n    var callback = this.async();\n    return cache({\n      directory: cacheDirectory,\n      identifier: cacheIdentifier,\n      source: source,\n      options: options,\n      transform: transpile,\n    }, function(err, result) {\n      if (err) { return callback(err); }\n      return callback(null, result.code, result.map);\n    });\n  }\n\n  // 没有缓存的话直接进行转换，并调用 this.callback\n  result = transpile(source, options);\n  this.callback(null, result.code, result.map);\n};\n```\n\n大致看下来，没有太多问题，就是简单地利用 `babel-core` 进行编译，而后进行缓存。中间外加了配置信息的组合和异常的处理。\n\n到这里我还有一个小疑问，就是 `this.cacheable` 到底干了什么，因为实际的缓存工作都是 babel-loader 自己干的。目前未知！！！\n\n#### babel 集成小结\n\nbabel 和各大框架、工具的继承其实都是在内部调用 `babel-core` 的 `transform` 方法，然后把结果进行处理或者直接输出到指定的文件。`react-native` 是这么做的，`babel-cli` 其实也是这么做的。有点头重脚轻了，哈哈，毕竟 babel 本身还是很简单的。\n\nbabel 暂时就到这里，没想到拖了这么久，但是收获还是很大的。后面将正式开启 es6 的深入。另外 webpack 也有必要在后面深入研究一下，因为这篇文章中还有一些没解决的关于 webpack 的问题。\n","html":"<p>之前讲到要写一个 babel 集成的例子，本来打算写 react native 集成 babel 的方案，但考虑到之后重构博客要集成 webpack，所以还是选了 babel loader。所以这篇除了写到 babel 集成外，还会涉及 webpack 的 loader 编写，想想都有点激动吧！因为之前对 webpack 的理解不深，所以会从最基础开始，前面的铺垫就略长。</p>\n\n<h4 id=\"loaders\">loaders 基础</h4>\n\n<blockquote>\n  <p>以下内容本人翻译自官网</p>\n</blockquote>\n\n<p>webpack 的 loaders 允许我们在 <code>require</code> 或加载文件时，预处理这些文件。loaders 有点类似其它构建工具中的 “tasks”，并提供了强大的方式来处理前端构建流程。loaders 能够将文件从一种语言转换成另一种，例如 CoffeeScript 到 Javascript，也可以把 images 转换成 data URLs 的形式。它甚至允许你在 Javascript 中 <code>require</code> css 文件。</p>\n\n<p>为了告诉 webpack 用某个 loader 来进行处理，你需要在 webpack 的配置文件中进行配置（推荐的方式）或在请求某个模块时指定，例如在 <code>require</code> 中：</p>\n\n<pre><code>var moduleWithOneLoader = require(\"my-loader!./my-awesome-module\");  \n</code></pre>\n\n<p>注意到 <code>!</code> 语法将 loader 从模块路径分割了吗？loaders 也可以使用相对路径的方式来代替 loader 名：</p>\n\n<pre><code>require(\"./loaders/my-loader!./my-awesome-module\");  \n</code></pre>\n\n<p>loaders 也可以通过 <code>!</code> 分隔进行组合链式地调用。这是十分有用的，当一个文件需要多重转换的时候。</p>\n\n<pre><code>require(\"style-loader!css-loader!less-loader!./my-styles.less\");  \n</code></pre>\n\n<p>链式调用是从右到左进行的，就上面的例子来看 <code>my-styles.less</code> 首先会被 <code>less-loader</code> 处理成 css，然后传递给 <code>css-loader</code> 处理，最后交给 <code>style-loader</code> 将其转换到一个 <code>&lt;style&gt;</code> 标签内。</p>\n\n<h6 id=\"\">参数</h6>\n\n<p>loaders 能够接收 query 参数：</p>\n\n<pre><code>require(\"loader?with=parameter!./file\");  \n</code></pre>\n\n<p>query 字符串的格式应当由每个 loader 来负责，所以使用前需要检查 loaders 文档找出关于 loader 接收参数的内容，但是通常大多数 loaders 是支持传统 query 字符串格式化。</p>\n\n<h6 id=\"loaders\">配置 loaders</h6>\n\n<p>在每个某块请求中指定 loaders 是缺乏弹性、重复性高的。webpack 提供在配置文件中为每类文件指定 loaders 的方式。这种方式也是更加推荐的，因为构建的代码不会侵入到我们的代码中，从而提高了复用性。</p>\n\n<pre><code>{\n    module: {\n        loaders: [\n            { test: /\\.coffee$/, loader: \"coffee-loader\" }\n        ],\n        preLoaders: [\n            { test: /\\.coffee$/, loader: \"coffee-hint-loader\" }\n        ]\n    }\n};\n</code></pre>\n\n<h6 id=\"loader\">loader 顺序</h6>\n\n<p>在文件从文件系统读取之后，loaders 按以下的顺序执行：</p>\n\n<ol>\n<li>配置文件中的 <code>preloaders</code>。  </li>\n<li>配置文件中的 <code>loaders</code>。  </li>\n<li>loaders specified in the request (e.g. require('raw!./file.js'))  </li>\n<li>配置文件中的 <code>postLoaders</code>。</li>\n</ol>\n\n<p>你也可以在 模块请求中覆盖配置的 loader 顺序来适应一些特殊的情况。</p>\n\n<ul>\n<li>adding ! to a request will disable configured preLoaders\nrequire(\"!raw!./script.coffee\")  </li>\n<li>adding !! to a request will disable all loaders specified in the configuration\nrequire(\"!!raw!./script.coffee\")  </li>\n<li>adding -! to a request will disable configured preLoaders and loaders but not the postLoaders\nrequire(\"-!raw!./script.coffee\")</li>\n</ul>\n\n<h6 id=\"\">推荐做法</h6>\n\n<blockquote>\n  <p>这部分没有很好理解，放到后面写 webpack 的时候。</p>\n</blockquote>\n\n<p>推荐在第二步处理之后结果为 Javascript。</p>\n\n<p>推荐非 Javascript 向 Javascript 的转换放在第一步。（当它们不全局应用的时候也可以第二步）</p>\n\n<p>建议preloader 和 postloader 的过程中，使用相同的语言。</p>\n\n<p>想要覆盖非 Javascript 到 Javascript 转换的源代码，加入 <code>!</code> 前缀。</p>\n\n<p>使用 <code>!!</code> 和 <code>-!</code> 前缀来禁用 loaders 是不推荐的。</p>\n\n<p>以下是几个使用的例子</p>\n\n<ul>\n<li>preloader：图片压缩。</li>\n<li>loader （配置文件）：coffee-script转换成js。</li>\n<li>loader （请求）：bundle loader。</li>\n<li>postloader：代码覆盖率测试等。</li>\n</ul>\n\n<h4 id=\"loader\">写一个 loader</h4>\n\n<p>写一个 loader 是相当简单的。一个 loader 仅仅是导出一个函数的文件。编译器会调用这个函数并将结果传递给前面的 loader 或者导入源文件给它。这个函数的 <code>this</code> 上下文是由编译器传递进来的的，它包含了很多有用的方法，能够让我们做一些如异步、获取参数的事。源文件的内容传递给第一个 loader。然后编译器期望从最后一个 loader 得到一个结果。结果可以使字符串也可以是 Buffer，代表了这个模块的 Javascript 源代码。一个可选的 SourceMap （JSON object）结果也许也会被传递。</p>\n\n<p>在同步模式，一个单一的结果可以直接被返回。想要返回多个结果，必须调用 <code>this.callback</code> 方法。在异步模式下，<code>this.async()</code> 必须被调用。如果 <code>this.async()</code> 被允许，那么会返回 <code>this.callback</code> 。然后这个 loader 必须返回 <code>undefined</code> 并调用 callback。</p>\n\n<p>错误能够在同步模式下被抛出，或 <code>this.callback</code> 调用时带 error。</p>\n\n<p>webpack 允许在任何地方使用异步模式。</p>\n\n<p><code>enhanced-require</code> allows async mode only with <code>require.ensure</code> or AMD <code>require</code>。</p>\n\n<p>更详细的说明和指南，check out <a href=\"http://webpack.github.io/docs/how-to-write-a-loader.html\">How to write a loader</a>。</p>\n\n<h5 id=\"\">例子</h5>\n\n<h6 id=\"syncloader\">sync loader</h6>\n\n<pre><code>module.exports = function(content) {  \n    return someSyncOperation(content);\n};\n</code></pre>\n\n<h6 id=\"asyncloader\">async loader</h6>\n\n<pre><code>module.exports = function(content) {  \n    var callback = this.async();\n    if(!callback) return someSyncOperation(content);\n    someAsyncOperation(content, function(err, result) {\n        if(err) return callback(err);\n        callback(null, result);\n    });\n};\n</code></pre>\n\n<h6 id=\"rawloader\">raw loader</h6>\n\n<p>默认情况下源文件被以 utf-8 字符串对待，并传递字符串给 loader。通过设置 raw 为 true 来传递 raw Buffer。</p>\n\n<p>每一个 loader 允许接受 String 或 Buffer 结果。编译器会在两个 loaders 之间转换它们。</p>\n\n<pre><code>module.exports = function(content) {  \n    assert(content instanceof Buffer);\n    return someSyncOperation(content);\n    // return value can be a Buffer too\n    // This is also allowed if loader is not \"raw\"\n};\nmodule.exports.raw = true;  \n</code></pre>\n\n<h6 id=\"pitchingloader\">pitching loader</h6>\n\n<p>loaders 默认是从右向左调用。但是在一些情况下 loaders 不在乎前一个 loader 的结果或者 源文件。它们只关注 metadata。在 loaders 调用之前，loaders 上的 pitch 方法被从左向右调用。如果一个loader用pitch方法提供了结果，程序就会回转并跳过剩下的loaders，继续调用更多的左边的loaders。数据可以在 pitch和普通调用间传递。（<a href=\"https://github.com/webpack/webpack/issues/360\">不是很理解到底有什么用，这里有个讨论</a>，因为和 babel loader 关系不大，暂时跳过）</p>\n\n<pre><code>module.exports = function(content) {  \n    return someSyncOperation(content, this.data.value);\n};\nmodule.exports.pitch = function(remainingRequest, precedingRequest, data) {  \n    if(someCondition()) {\n        // fast exit\n        return \"module.exports = require(\" + JSON.stringify(\"-!\" + remainingRequest) + \");\";\n    }\n    data.value = 42;\n};\n</code></pre>\n\n<h5 id=\"this\">this 上下文</h5>\n\n<p>这里内容太多，只在 babel loader 里面具体介绍所用到的方法了。</p>\n\n<h4 id=\"babelloader\">babel loader</h4>\n\n<p>到目前为止，我们大致把 webpack loader 相关的所有知识都过了一遍，差不多可以开始读 babel-loader 的源码了！</p>\n\n<pre><code>'use strict';\n\nvar assign = require('object-assign');          // 用来合并不同的配置项  \nvar babel = require('babel-core');              // 提供 transform 方法  \nvar loaderUtils = require('loader-utils');      // loader 工具库  \nvar cache = require('./lib/fs-cache.js');       // 提供文件缓存  \nvar exists = require('./lib/helpers/exists')(); // 判断文件是否存在于缓存或文件系统  \nvar read = require('./lib/helpers/read')();     // 从缓存或文件系统读取文件  \nvar resolveRc = require('./lib/resolve-rc.js'); // 查找 .babelrc 配置文件  \nvar pkg = require('./package.json');  \nvar path = require('path');\n\n/**\n * 自定义符合 webpack 输出规则的 Error \n */\nfunction BabelLoaderError(name, message, codeFrame, hideStack, error) {  \n  Error.call(this);\n  Error.captureStackTrace(this, BabelLoaderError);\n\n  this.name = 'BabelLoaderError';\n  this.message = formatMessage(name, message, codeFrame);\n  this.hideStack = hideStack;\n  this.error = error;\n}\n\nBabelLoaderError.prototype = Object.create(Error.prototype);  \nBabelLoaderError.prototype.constructor = BabelLoaderError;\n\nvar STRIP_FILENAME_RE = /^[^:]+: /;    // 除去文件名的正则\n\nvar formatMessage = function(name, message, codeFrame) {  \n  return (name ? name + ': ' : '') + message + '\\n\\n' + codeFrame + '\\n';\n};\n\n// 调用 babel.transform 转换代码\nvar transpile = function(source, options) {  \n  var result;\n  try {\n    result = babel.transform(source, options);\n  } catch (error) {\n    if (error.message &amp;&amp; error.codeFrame) {\n      var message = error.message;\n      var name;\n      var hideStack;\n      if (error instanceof SyntaxError) {\n        message = message.replace(STRIP_FILENAME_RE, '');\n        name = 'SyntaxError';\n        hideStack = true;\n      } else if (error instanceof TypeError) {\n        message = message.replace(STRIP_FILENAME_RE, '');\n        hideStack = true;\n      }\n      throw new BabelLoaderError(\n        name, message, error.codeFrame, hideStack, error);\n    } else {\n      throw error;\n    }\n  }\n  var code = result.code;     // 编译得到的代码\n  var map = result.map;       // 编译得到的sourceMap\n\n  if (map &amp;&amp; (!map.sourcesContent || !map.sourcesContent.length)) {\n    map.sourcesContent = [source];\n  }\n\n  return {\n    code: code,\n    map: map,\n  };\n};\n\n\nmodule.exports = function(source, inputSourceMap) {  \n  var result = {};\n\n  // Handle filenames (#106)\n  var webpackRemainingChain = loaderUtils.getRemainingRequest(this).split('!');\n  var filename = webpackRemainingChain[webpackRemainingChain.length - 1];\n\n  // 把用户的配置、默认的配置以及来自 .babelrc 的配置组合\n  var globalOptions = this.options.babel || {};\n  var loaderOptions = loaderUtils.parseQuery(this.query);\n  var userOptions = assign({}, globalOptions, loaderOptions);\n  var defaultOptions = {\n    inputSourceMap: inputSourceMap,\n    sourceRoot: process.cwd(),\n    filename: filename,\n    cacheIdentifier: JSON.stringify({\n      'babel-loader': pkg.version,\n      'babel-core': babel.version,\n      babelrc: exists(userOptions.babelrc) ?\n          read(userOptions.babelrc) :\n          resolveRc(path.dirname(filename)),\n      env: process.env.BABEL_ENV || process.env.NODE_ENV,\n    }),\n  };\n\n  var options = assign({}, defaultOptions, userOptions);\n\n  if (userOptions.sourceMap === undefined) {\n    options.sourceMap = this.sourceMap;\n  }\n\n  if (options.sourceFileName === undefined) {\n    options.sourceFileName = path.relative(\n        options.sourceRoot,\n        options.filename\n    );\n  }\n\n  // 获取缓存参数缓存\n  var cacheDirectory = options.cacheDirectory;\n  var cacheIdentifier = options.cacheIdentifier;\n\n  delete options.cacheDirectory;    // options 要传递给 transform 所以要把没用的参数删掉，不删掉貌似会有问题\n  delete options.cacheIdentifier;    // options 要传递给 transform 所以要把没用的参数删掉，不删掉貌似会有问题\n\n  this.cacheable(); // 开启缓存的要求是输入相同的情况下输出一定相同\n\n  // 如果提供了缓存目录，那么下面就是异步的\n  // cache 函数会先从缓存中返回内容，如果缓存变了，那么会重新编译存入缓存\n  if (cacheDirectory) {\n    var callback = this.async();\n    return cache({\n      directory: cacheDirectory,\n      identifier: cacheIdentifier,\n      source: source,\n      options: options,\n      transform: transpile,\n    }, function(err, result) {\n      if (err) { return callback(err); }\n      return callback(null, result.code, result.map);\n    });\n  }\n\n  // 没有缓存的话直接进行转换，并调用 this.callback\n  result = transpile(source, options);\n  this.callback(null, result.code, result.map);\n};\n</code></pre>\n\n<p>大致看下来，没有太多问题，就是简单地利用 <code>babel-core</code> 进行编译，而后进行缓存。中间外加了配置信息的组合和异常的处理。</p>\n\n<p>到这里我还有一个小疑问，就是 <code>this.cacheable</code> 到底干了什么，因为实际的缓存工作都是 babel-loader 自己干的。目前未知！！！</p>\n\n<h4 id=\"babel\">babel 集成小结</h4>\n\n<p>babel 和各大框架、工具的继承其实都是在内部调用 <code>babel-core</code> 的 <code>transform</code> 方法，然后把结果进行处理或者直接输出到指定的文件。<code>react-native</code> 是这么做的，<code>babel-cli</code> 其实也是这么做的。有点头重脚轻了，哈哈，毕竟 babel 本身还是很简单的。</p>\n\n<p>babel 暂时就到这里，没想到拖了这么久，但是收获还是很大的。后面将正式开启 es6 的深入。另外 webpack 也有必要在后面深入研究一下，因为这篇文章中还有一些没解决的关于 webpack 的问题。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475321910675,"created_by":1,"updated_at":1475396924270,"updated_by":1,"published_at":1475371500000,"published_by":1},{"id":100,"uuid":"f000dea8-d8f1-49e9-aede-e60b3c379cec","title":"Re：从零开始的异世界生活","slug":"re-cong-ling-kai-shi-de-yi-shi-jie-sheng-huo","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=430053935&auto=1&height=66\"></iframe>\n\n最近看的一部动漫，说最近其实也过去有一周了。\n\n给人的感觉还是挺不错的，尤其是前几集，完全被它的设定所吸引了。\n\n男主，在经过一次史上最随便的穿越来到了异世界。来到这个世界它的技能是死亡以后可以回到死亡前的某个时刻重新来过。很像游戏的设定对吧，但是游戏加以一个真实的人物身上，反而有一种不错的效果。\n\n就这样，男主一直在死，然后重来。死过几次以后，一般能够把故事改写。这让我想到了《求婚大作战》里的山p，虽然其实两个故事相差挺大的。\n\n故事到了后半部分，开始有人吐槽男主智商下线等等，其实我觉得没必要，因为经历过这么多次死亡的人，确实会存在某些的不正常。虽然男主能够读档，但是他的死以及当时的恐惧是真真切切的。至于是何种的不正常，没人知道，但是肯定和现在豆瓣上那种大多数人不理解的不正常是同一属性的。\n\n最后我在思考的是这部番真正吸引我们的是什么，毕竟能够横扫四月番、播放量破亿是件很了不起的事。\n\n两个字：蕾姆！蕾姆！蕾姆！\n\n四个字：艾米莉亚！艾米莉亚！艾米莉亚！\n\n开玩笑的！当然蕾姆、艾米莉亚都算。最重要的可能还是设定吧，设定眼前一亮，在一开始就抓住了很多吃瓜观众的心！\n\n不对，又想到一点，废柴的死宅男主，其实就像是视频前的很多人吧！他让这些人看到即使是死宅、废柴，在死一般地一次次挣扎过后，还是能够改变点什么的吧！算了，这口鸡汤只能自己喝了。\n\n好了，睡觉，源码还没看完！！！","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=430053935&auto=1&height=66\"></iframe>\n\n<p>最近看的一部动漫，说最近其实也过去有一周了。</p>\n\n<p>给人的感觉还是挺不错的，尤其是前几集，完全被它的设定所吸引了。</p>\n\n<p>男主，在经过一次史上最随便的穿越来到了异世界。来到这个世界它的技能是死亡以后可以回到死亡前的某个时刻重新来过。很像游戏的设定对吧，但是游戏加以一个真实的人物身上，反而有一种不错的效果。</p>\n\n<p>就这样，男主一直在死，然后重来。死过几次以后，一般能够把故事改写。这让我想到了《求婚大作战》里的山p，虽然其实两个故事相差挺大的。</p>\n\n<p>故事到了后半部分，开始有人吐槽男主智商下线等等，其实我觉得没必要，因为经历过这么多次死亡的人，确实会存在某些的不正常。虽然男主能够读档，但是他的死以及当时的恐惧是真真切切的。至于是何种的不正常，没人知道，但是肯定和现在豆瓣上那种大多数人不理解的不正常是同一属性的。</p>\n\n<p>最后我在思考的是这部番真正吸引我们的是什么，毕竟能够横扫四月番、播放量破亿是件很了不起的事。</p>\n\n<p>两个字：蕾姆！蕾姆！蕾姆！</p>\n\n<p>四个字：艾米莉亚！艾米莉亚！艾米莉亚！</p>\n\n<p>开玩笑的！当然蕾姆、艾米莉亚都算。最重要的可能还是设定吧，设定眼前一亮，在一开始就抓住了很多吃瓜观众的心！</p>\n\n<p>不对，又想到一点，废柴的死宅男主，其实就像是视频前的很多人吧！他让这些人看到即使是死宅、废柴，在死一般地一次次挣扎过后，还是能够改变点什么的吧！算了，这口鸡汤只能自己喝了。</p>\n\n<p>好了，睡觉，源码还没看完！！！</p>","image":"/content/images/2016/10/6073b956f2912ded8a8c57fea66c7624.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475459357742,"created_by":1,"updated_at":1475849236784,"updated_by":1,"published_at":1475848157917,"published_by":1},{"id":101,"uuid":"f252ecec-d40c-44da-9895-6a560985e7b5","title":"es6 温故第一天小结","slug":"es6-di-yi-tian-xiao-jie","markdown":"今天家里客人比较多，看得效率很低，但还是有一些收获的。\n\n#### let&const\n\n没有深入研究块状作用域和 let&const 的实现机制，因为一研究可能就是好几天。不过大致看了一下文档。下面是本来已知的一些特性：\n\n1. 存在块级作用域\n2. 没有变量提升，存在暂时性死区（指的是定义前到块级作用域顶部无法进行访问和其它声明）\n3. 不允许重复声明\n4. 两者区别在于是否可以修改，对于 const 定义的对象来说只要引用不变，修改属性是允许的\n\n> 注意事项：es6 前，只允许在全局作用域或函数作用域声明函数，es6 允许在块级作用域声明函数。但是考虑到浏览器环境，因此 es6 特地规定浏览器可以不遵循这条规定。因此尽量不要在块级作用域使用函数声明，用函数表达式代替。\n\n上面的原来就知晓的知识，本次阅读 es6 规范，注意到了一些别的知识。\n\n> 全局对象的属性赋值与全局变量的赋值，是同一件事。（对于Node来说，这一条只对REPL环境适用，模块环境之中，全局变量必须显式声明成global对象的属性。）\n\n而值得注意的是，我们使用 let、const、class 声明的全局变量将不会是全局对象的属性。这个问题之前在用 chrome 的控制台时就有了，但是一直没有注意，今天看到这个就恍然大悟。\n\n而打开 es6 规范文档，里面这么讲道：\n\n> var 定义的变量将被绑定在变量环境上，而 let&const 将被绑定在词法环境上。就是靠这个实现的吧，至于词法环境和变量环境到底有什么本质的区别，还不是特别的明朗。\n\n#### 解构赋值\n\n##### 数组\n\n1. 如果解构不成功，变量的值就等于undefined。\n2. 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。\n3. 只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。\n4. 解构赋值允许指定默认值。\n\n##### 对象\n\n1. 解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。\n2. 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。\n3. 对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。\n\n##### 用途\n\n1. 交换变量的值\n2. 从函数返回多个值\n3. 函数参数的定义\n4. 提取JSON数据\n5. 函数参数的默认值\n6. 遍历Map结构\n7. 输入模块的指定方法\n\n> 注意点：模式和变量\n\n```\nvar { foo: baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // \"aaa\" 变量\nfoo // error: foo is not defined 模式\n```\n\n> 赋值语句的非模式部分，可以使用圆括号。来避免 {} 的歧义。\n\n#### 字符串扩展\n\n##### unicode 扩展\n\n1. `String.fromCodePoint` 对应 `String.fromCharCode`\n2. `String.prototype.codePointAt` 对应 `String.prototype.charCodeAt`\n3. `String.prototype.at` 对应 `String.prototype.charAt`（只是提案）\n4. ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。\n\n##### 其他扩展方法\n\n1. includes(), startsWith(), endsWith() 这三个方法都支持第二个参数，表示开始搜索的位置。\n2. repeat方法返回一个新字符串，表示将原字符串重复n次。\n3. ES7 推出了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart用于头部补全，padEnd用于尾部补全。（已通过，明年会加入 es 2017）\n\n##### 模板字符串\n\n1. 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。\n2. 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。\n3. 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。\n4. 大括号中是一个对象，将默认调用对象的toString方法。\n5. 模板字符串甚至还能嵌套。\n\n###### 标签模板及 `String.raw`\n\n标签模板是解析模板字符串，并将结果提供给一个自定义 tag 函数进行处理。\n\ntag 函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。\n\n举例来看：\n\n```\nvar a = 5;\nvar b = 10;\ntag`Hello ${ a + b } world ${ a * b }`;\n// 等同于\ntag(['Hello ', ' world ', ''], 15, 50);\n```\n\n而 `String.raw` 是默认的 tag 函数，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。\n\n```\nString.raw`Hi\\n${2+3}!`; // \"Hi\\\\n5!\"\nString.raw`Hi\\u000A!`;   // 'Hi\\\\u000A!'\n```\n\n因此，tag 函数的第一个参数strings，有一个 raw 属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[\"First line\\nSecond line\"]，那么strings.raw数组就是[\"First line\\\\nSecond line\"]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw数组会将\\n视为\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。\n\n#### 小结\n\n第一天就复习了这些，现在看相较于前几次来说清楚很多，因为看完 es5.1 标准对整个内部机制有了更多了解。不过想要知道这些新语法的实现，尤其是块级作用域，建议还是看标准文档。\n\n\n\n\n\n","html":"<p>今天家里客人比较多，看得效率很低，但还是有一些收获的。</p>\n\n<h4 id=\"letconst\">let&amp;const</h4>\n\n<p>没有深入研究块状作用域和 let&amp;const 的实现机制，因为一研究可能就是好几天。不过大致看了一下文档。下面是本来已知的一些特性：</p>\n\n<ol>\n<li>存在块级作用域  </li>\n<li>没有变量提升，存在暂时性死区（指的是定义前到块级作用域顶部无法进行访问和其它声明）  </li>\n<li>不允许重复声明  </li>\n<li>两者区别在于是否可以修改，对于 const 定义的对象来说只要引用不变，修改属性是允许的</li>\n</ol>\n\n<blockquote>\n  <p>注意事项：es6 前，只允许在全局作用域或函数作用域声明函数，es6 允许在块级作用域声明函数。但是考虑到浏览器环境，因此 es6 特地规定浏览器可以不遵循这条规定。因此尽量不要在块级作用域使用函数声明，用函数表达式代替。</p>\n</blockquote>\n\n<p>上面的原来就知晓的知识，本次阅读 es6 规范，注意到了一些别的知识。</p>\n\n<blockquote>\n  <p>全局对象的属性赋值与全局变量的赋值，是同一件事。（对于Node来说，这一条只对REPL环境适用，模块环境之中，全局变量必须显式声明成global对象的属性。）</p>\n</blockquote>\n\n<p>而值得注意的是，我们使用 let、const、class 声明的全局变量将不会是全局对象的属性。这个问题之前在用 chrome 的控制台时就有了，但是一直没有注意，今天看到这个就恍然大悟。</p>\n\n<p>而打开 es6 规范文档，里面这么讲道：</p>\n\n<blockquote>\n  <p>var 定义的变量将被绑定在变量环境上，而 let&amp;const 将被绑定在词法环境上。就是靠这个实现的吧，至于词法环境和变量环境到底有什么本质的区别，还不是特别的明朗。</p>\n</blockquote>\n\n<h4 id=\"\">解构赋值</h4>\n\n<h5 id=\"\">数组</h5>\n\n<ol>\n<li>如果解构不成功，变量的值就等于undefined。  </li>\n<li>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。  </li>\n<li>只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。  </li>\n<li>解构赋值允许指定默认值。</li>\n</ol>\n\n<h5 id=\"\">对象</h5>\n\n<ol>\n<li>解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。  </li>\n<li>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。  </li>\n<li>对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。</li>\n</ol>\n\n<h5 id=\"\">用途</h5>\n\n<ol>\n<li>交换变量的值  </li>\n<li>从函数返回多个值  </li>\n<li>函数参数的定义  </li>\n<li>提取JSON数据  </li>\n<li>函数参数的默认值  </li>\n<li>遍历Map结构  </li>\n<li>输入模块的指定方法</li>\n</ol>\n\n<blockquote>\n  <p>注意点：模式和变量</p>\n</blockquote>\n\n<pre><code>var { foo: baz } = { foo: \"aaa\", bar: \"bbb\" };  \nbaz // \"aaa\" 变量  \nfoo // error: foo is not defined 模式  \n</code></pre>\n\n<blockquote>\n  <p>赋值语句的非模式部分，可以使用圆括号。来避免 {} 的歧义。</p>\n</blockquote>\n\n<h4 id=\"\">字符串扩展</h4>\n\n<h5 id=\"unicode\">unicode 扩展</h5>\n\n<ol>\n<li><code>String.fromCodePoint</code> 对应 <code>String.fromCharCode</code>  </li>\n<li><code>String.prototype.codePointAt</code> 对应 <code>String.prototype.charCodeAt</code>  </li>\n<li><code>String.prototype.at</code> 对应 <code>String.prototype.charAt</code>（只是提案）  </li>\n<li>ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</li>\n</ol>\n\n<h5 id=\"\">其他扩展方法</h5>\n\n<ol>\n<li>includes(), startsWith(), endsWith() 这三个方法都支持第二个参数，表示开始搜索的位置。  </li>\n<li>repeat方法返回一个新字符串，表示将原字符串重复n次。  </li>\n<li>ES7 推出了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart用于头部补全，padEnd用于尾部补全。（已通过，明年会加入 es 2017）</li>\n</ol>\n\n<h5 id=\"\">模板字符串</h5>\n\n<ol>\n<li>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。  </li>\n<li>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。  </li>\n<li>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。  </li>\n<li>大括号中是一个对象，将默认调用对象的toString方法。  </li>\n<li>模板字符串甚至还能嵌套。</li>\n</ol>\n\n<h6 id=\"stringraw\">标签模板及 <code>String.raw</code></h6>\n\n<p>标签模板是解析模板字符串，并将结果提供给一个自定义 tag 函数进行处理。</p>\n\n<p>tag 函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>\n\n<p>举例来看：</p>\n\n<pre><code>var a = 5;  \nvar b = 10;  \ntag`Hello ${ a + b } world ${ a * b }`;  \n// 等同于\ntag(['Hello ', ' world ', ''], 15, 50);  \n</code></pre>\n\n<p>而 <code>String.raw</code> 是默认的 tag 函数，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>\n\n<pre><code>String.raw`Hi\\n${2+3}!`; // \"Hi\\\\n5!\"  \nString.raw`Hi\\u000A!`;   // 'Hi\\\\u000A!'  \n</code></pre>\n\n<p>因此，tag 函数的第一个参数strings，有一个 raw 属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[\"First line\\nSecond line\"]，那么strings.raw数组就是[\"First line\\nSecond line\"]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw数组会将\\n视为\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p>\n\n<h4 id=\"\">小结</h4>\n\n<p>第一天就复习了这些，现在看相较于前几次来说清楚很多，因为看完 es5.1 标准对整个内部机制有了更多了解。不过想要知道这些新语法的实现，尤其是块级作用域，建议还是看标准文档。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475502365206,"created_by":1,"updated_at":1475505070026,"updated_by":1,"published_at":1475505070028,"published_by":1},{"id":102,"uuid":"98f62ce8-eba9-4fb7-a3c8-137375808a43","title":"关于希望你不要成为薛之谦那样的人","slug":"xi-wang-ni-bu-yao-cheng-wei-xie-zhi-qian-na-yang-de-ren","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=169185&auto=1&height=66\"></iframe>\n\n早上听电台，听到一篇文章《希望你不要成为薛之谦那样的人》。这篇文章一开头就讲到：\n\n> 记得《火星情报局》收官的时候薛之谦说了一句话，“我想像你一样的哭一场，可我做不到了。”“我的心太老了，在感情方面已经很难被别人感动，我很想遇见一个女孩，能够激起我心中的波澜，所以这一刻我特别羡慕沈梦辰能够这样哭一场。”\n\n然后便去看了这一期的《火星情报局》，大致是节目收官，现场的每个人都可以讲出自己的一个愿望。于是沈梦辰的愿望是听薛之谦唱《认真的雪》，这首歌在她的记忆中有重要的位置。也于是薛之谦唱起了《认真的雪》\n\n爱得那么认真 爱得那么认真\n\n可还是听见了你说不可能\n\n已经十几年没下雪的上海 突然飘雪\n\n就在你说了分手的瞬间\n\n雪下得那么深 下得那么认真\n\n倒映出我躺在雪中的伤痕\n\n我并不在乎自己究竟多伤痕累累\n\n可我在乎今后你有谁陪\n\n沈梦辰当场大哭了起来，是那种我没有见过的哭。看到这一幕的我十分地震惊。唱完之后，薛之谦说：“我想像你一样的哭一场，可我做不到了。我的心太老了。”\n\n这一刻其实我渐渐明白为什么这么多人喜欢他了，因为外表像个神经病，而内心已经伤痕累累，这其实是我们大多数人的样子。看到他就像看到了我们自己，这就是前面我提到的共有吧。共有的事物拉近了我们的距离，也就慢慢地喜欢上了。\n\n至于是否要成为薛之谦那样的人，其实这不是我们能够控制的。如果我们在经历了像他一样的岁月，仍能够想他这样，也算是不错了，因为大多数人熬不过去，中途放弃。\n\n也正是这点，他让我们看到了我们坚持下去的样子，虽然伤痕累累，但是坚强、深情。使我们也有一丝继续下去的勇气，十年后，我们也可以咬着后槽牙抹着泪水说，“我坚持了十年。”\n\n好了，睡了，明天回学校解决一些事！\n\n","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=169185&auto=1&height=66\"></iframe>\n\n<p>早上听电台，听到一篇文章《希望你不要成为薛之谦那样的人》。这篇文章一开头就讲到：</p>\n\n<blockquote>\n  <p>记得《火星情报局》收官的时候薛之谦说了一句话，“我想像你一样的哭一场，可我做不到了。”“我的心太老了，在感情方面已经很难被别人感动，我很想遇见一个女孩，能够激起我心中的波澜，所以这一刻我特别羡慕沈梦辰能够这样哭一场。”</p>\n</blockquote>\n\n<p>然后便去看了这一期的《火星情报局》，大致是节目收官，现场的每个人都可以讲出自己的一个愿望。于是沈梦辰的愿望是听薛之谦唱《认真的雪》，这首歌在她的记忆中有重要的位置。也于是薛之谦唱起了《认真的雪》</p>\n\n<p>爱得那么认真 爱得那么认真</p>\n\n<p>可还是听见了你说不可能</p>\n\n<p>已经十几年没下雪的上海 突然飘雪</p>\n\n<p>就在你说了分手的瞬间</p>\n\n<p>雪下得那么深 下得那么认真</p>\n\n<p>倒映出我躺在雪中的伤痕</p>\n\n<p>我并不在乎自己究竟多伤痕累累</p>\n\n<p>可我在乎今后你有谁陪</p>\n\n<p>沈梦辰当场大哭了起来，是那种我没有见过的哭。看到这一幕的我十分地震惊。唱完之后，薛之谦说：“我想像你一样的哭一场，可我做不到了。我的心太老了。”</p>\n\n<p>这一刻其实我渐渐明白为什么这么多人喜欢他了，因为外表像个神经病，而内心已经伤痕累累，这其实是我们大多数人的样子。看到他就像看到了我们自己，这就是前面我提到的共有吧。共有的事物拉近了我们的距离，也就慢慢地喜欢上了。</p>\n\n<p>至于是否要成为薛之谦那样的人，其实这不是我们能够控制的。如果我们在经历了像他一样的岁月，仍能够想他这样，也算是不错了，因为大多数人熬不过去，中途放弃。</p>\n\n<p>也正是这点，他让我们看到了我们坚持下去的样子，虽然伤痕累累，但是坚强、深情。使我们也有一丝继续下去的勇气，十年后，我们也可以咬着后槽牙抹着泪水说，“我坚持了十年。”</p>\n\n<p>好了，睡了，明天回学校解决一些事！</p>","image":"/content/images/2016/10/cb03593d0285e5f79c6bd359a4d10235.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475505391504,"created_by":1,"updated_at":1475508029201,"updated_by":1,"published_at":1475507188953,"published_by":1},{"id":103,"uuid":"bfbb5fa4-fb2e-401a-b502-2d6e4ccdb8f5","title":"js 模块化演进","slug":"js-mo-kuai-hua-yan-jin","markdown":"#### 小背景\n\n个人猜测 js 之父 Brendan Eich 设计 js 之初，应该没有意料到 js 会面对现在这样的如此复杂的应用场景，所以也就没有考虑为 js 设计相应的模块化方案。\n\n以至于当应用越来越复杂，很多大牛开始编写一些工具，并制定出一套模块化规范（服务端有 commonjs、浏览器端有 amd 和 cmd，为了两端通用还有 umd）。不光是规范，各种工具也是层出不穷，给人一种眼花缭乱，不知所措的感觉。\n\n而跟随着 es6 的大潮而来的 es6 module 也许能够帮助我们从上面的困境中走出来。es6 module 静态化的设计，使得其拥有更高的性能。不过，由于兼容性的问题，使得使用它还需要一些工具来对代码进行一些转换。\n\n好了接下来拿出瓜子和小板凳，开始正文了！\n\n在快写完这篇文章时看到了这个[干货](http://huangxuan.me/js-module-7day/#/)，感觉组织的比我好，所以拿出来分享了。\n\n#### 模块与模块化\n\n百度百科：\n\n> 模块，又称构件，是能够单独命名并独立地完成一定功能的程序语句的集合（即程序代码和数据结构的集合体）。\n\n两个基本的特征：\n\n- 外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能；（依赖与被依赖）\n- 内部特征是指模块的内部环境具有的特点。（内部独立、完整）\n\n而模块化要做的主要就是下面三件事：\n\n1. 规定如何定义模块；\n2. 规定如何依赖一个模块；\n3. 规定如何对其他模块的引入支持。\n\n用现有的 commonjs 规范来简单解释就是：`module` 则用来定义一个模块。`require` 和 `exports` 用来描述模块与外部环境交互。`require` 规定了如何依赖一个模块，`exports`规定了模块如何暴露内部方法来支持其它模块的引入。模块内部的局部数据代码用来描述模块的内部特征。\n\n#### 模块化的意义\n\n###### 全局变量与命名冲突！\n\n想想我大一写 js 代码的时候，总写下面这种代码。现在看来当时还是挺年轻的，第一这样的写法会污染全局环境，第二可能会与其他同学或者第三方库产生一些命名冲突。\n\n```\nfunction m1(){\n　　//...\n}\nfunction m2(){\n　　//...\n}\n```\n\n为了解决这个问题，后来通常的做法就是 IIFE，将内容包在函数作用域内，然后返回。\n\n```\nvar module1 = (function(){\n　　var _count = 0;\n　　var m1 = function(){\n　　　　//...\n　　};\n　　var m2 = function(){\n　　　　//...\n　　};\n　　return {\n　　　　m1 : m1,\n　　　　m2 : m2\n　　};\n})();\n```\n\n当然还有另一种方案，就是 YUI 当时使用的命名空间方案（命名空间相对于 IIEF 方案来说，不能够有内部私有变量，所有状态都可以被外部改写，并且有些较长的命名空间记起来比较繁琐，造成了额外的负担）：\n\n```\nvar app = {};\napp.module1 = {};\napp.module1.m1 = function () {\n  // ...\n};\napp.module1.m2 = function () {\n  // ...\n};\n```\n\n所以从上面看下来，IIEF 是用来实现纯 js 系统，模块化方案的不错工具。\n\n###### 依赖关系的维护！\n\n光是 IIEF，我认为只能称得上模块，但是称不上模块化，因为它是独立的，不存在外部特征和模块依赖的管理。而通常情况下，我们的前端工程的各个模块之间往往是存在依赖关系的。如以下例子：\n\n```\n<script src=\"util.js\"></script>\n<script src=\"dialog.js\"></script>\n<script>\n  org.CoolSite.Dialog.init({ /* 传入配置 */ });\n</script>\n```\n\ndialog.js 是依赖于 util.js，那么我们每次使用 dialog.js 时都要手动地去引入 util.js，这是件很低效的事。另外当依赖关系越来越复杂时，手工操作也会变得十分地头疼（处理依赖及其版本、依赖加载的顺序、甚至可能存在的循环依赖）。\n\n文件的依赖，目前在绝大部分类库框架里，比如国外的 YUI3 框架、国内的 KISSY 等类库，目前是通过配置的方式来解决。\n\n```\nYUI.add('my-module', function (Y) {\n  // ...\n}, '0.0.1', {\n    requires: ['node', 'event']\n});\n```\n\n上面的代码，通过 requires 等方式来指定当前模块的依赖。这很大程度上可以解决依赖问题，但不够优雅。当模块很多，依赖很复杂时，烦琐的配置会带来不少隐患。\n\n#### 模块化演进\n\n###### nodejs 与 commonjs\n\njs 真正从模块走向模块化，应该是在 2009年，nodejs 的横空出世。（之前那些应该只能算是模块，YUI 的可以算模块化，但是太久远了，那时候才小学可能）如果说浏览器端的 js 即便没有模块化也可以忍的话，那服务端是万万不能的。大牛云集的 CommonJs 社区（原来叫 ServerJs）发力，制定了 [Modules/1.0](http://wiki.commonjs.org/wiki/Modules/1.0) 规范，首次定义了一个模块应该长啥样，以及依赖如何管理。具体来说， Modules/1.0 规范包含以下内容：\n\n1. 模块的标识应遵循的规则。\n2. 定义全局函数 `require`，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的 API。\n3. 如果被 `require` 函数引入的模块中也包含依赖，那么依次加载这些依赖\n4. 如果引入模块失败，那么 `require` 函数应该报一个异常\n5. 模块通过变量 `exports` 来向往暴漏 API，`exports` 只能是一个对象，暴漏的 API 须作为此对象的属性。\n\n此规范一出，立刻产生了良好的效果，由于其简单而直接，在 nodejs 中，这种模块化方案立刻被推广开了。\n\n###### 向浏览器进发\n\n09年下半年 CommonJs 社区想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：\n\n- Modules/1.x 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 [Modules/Transport](http://wiki.commonjs.org/wiki/Modules/Transport) 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。browserify 做的就是类似的事情，它会将 commonjs 规范的代码打包成浏览器端可以执行的代码。 这样的好处就是可以共享 npm 上成千上万的库。\n\n- Modules/Async 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。因为浏览器的加载特点和 node 不同，node 同步的加载方式在浏览器端会造成比较大的问题，因此这个流派认为模块的加载应当通过异步下载-回调这样的过程来进行。代表有 AMD。\n\n- Modules/2.0 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。[这里有个故事](https://github.com/seajs/seajs/issues/588)\n\n这场争论最后胜出的应当还是 Modules/Async 流派，随后 AMD 的实现 RequireJs 也迅速崛起。但是 AMD 规范一直没有被 CommonJS 社区认同，核心争议点如下：\n\n执行时机：\n\nModules/1.0:\n\n```\nvar a = require(\"./a\") // 执行到此处时，a.js 才同步下载并执行\n```\n\nAMD:\n\n```\ndefine([\"require\"], function(require) {\n  // 在这里，模块 a 已经下载并执行好\n  // ...\n  var a = require(\"./a\") // 此处仅仅是取模块 a 的 exports\n\n})\n```\n\n模块书写风格有争议\n\nAMD 风格下，通过参数传入依赖模块，破坏了 就近声明 原则。比如：\n\n```\ndefine([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) {\n\n    // 等于在最前面申明并初始化了要用到的所有模块\n\n   if (false) {\n       // 即便压根儿没用到某个模块 b，但 b 还是提前执行了\n       b.foo()\n   }\n\n})\n```\n\n还有就是 AMD 下 `require` 的用法，以及增加了全局变量 `define` 等细节，当时在社区被很多人不认可。\n\n最后，AMD 从 CommonJS 社区独立了出去，单独成为了 AMD 社区。有阵子，CommonJS 社区还要求 RequireJS 的文档里，不能再打 CommonJS 的旗帜。\n\n正是存在这些争议，淘宝前端布道者玉伯兼容并包，实现了 SeaJs，并推出了 CMD 规范。它吸取了 RequireJS，以及 Modules/Wrappings 规范的优点。\n\n再到后来还有 umd，用来同时支持 AMD 和 commonjs，UMD的实现很简单，先判断是否支持 node 模块格式（`exports`是否存在），存在则使用 node 模块格式。再判断是否支持 AMD（`define`是否存在），存在则使用AMD方式加载模块。前两个都不存在，则将模块公开的全局（window或global）。\n\n再往后应该就是 es6 module 了，es6 与上面讲到的模块化规范有着本质的不同。上面的都是纯 js 环境的下的模块系统。对于纯 js 环境（所谓纯 js 系统，就是不依赖其他机制如预处理之类的系统）下的模块系统，其中的模块都是一个个对象。客户代码导入模块所导出的定义，实际上是查找 module 对象上的属性。\n\n```\nvar { stat, exists, readFile } = require('fs')\n```\n\nes6 模块系统则相反，模块不是对象，而是声明式的代码集合。从模块导入定义也是声明式的。\n\n```\nimport { stat, exists, readFile } from 'fs'\n```\n\n两种差别的主要原因在于，那些大牛们没有办法从语言层面作出修改，因此只能退而求其次，走渐进的、改良式的道路。而从语言层面进行改进，正是 tc39 能做的。（虽然 node 的作者表示了相反的意见，但是这已经是一个既成的事实了）\n\n#### 模块化的实现\n\n##### node\n\nnode 端的情况相对来说不那么复杂，它的模块实现主要在[这里](https://github.com/nodejs/node/blob/master/lib/module.js)。下面从定义模块、加载模块、导出模块三个点的实现来介绍\n\n定义模块：\n\nnode 定义了一个构造函数 Module，所有的模块都是 Module 的实例。可以看到，当前模块（module.js）也是 Module 的一个实例。\n\n```\nfunction Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  if (parent && parent.children) {\n    parent.children.push(this);\n  }\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n```\n\n加载模块：\n\n加载模块是通过 `require` 方法。`require` 不是全局属性，看下去就能明白。\n\n```\nModule.prototype.require = function(path) {\n  // path 是加载模块路径\n  // this 表示当前加载模块\n  return Module._load(path, this, /* isMain */ false);\n};\n```\n\n`require` 方法实际调用的是 `Module._load` 方法。主要进行了路径的处理以及缓存的处理。\n\n```\nModule._load = function(request, parent, isMain) {\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s', request, parent.id);\n  }\n\n  // 这里实际上是获取模块的绝对路径\n  var filename = Module._resolveFilename(request, parent, isMain);\n\n  // 检查是否存在缓存，如果存在缓存就从缓存中返回\n  var cachedModule = Module._cache[filename];\n  if (cachedModule) {\n    return cachedModule.exports;\n  }\n\n  // 检查是否为内置模块\n  if (NativeModule.nonInternalExists(filename)) {\n    debug('load native module %s', request);\n    return NativeModule.require(filename);\n  }\n\n  // 新建模块，存入缓存\n  var module = new Module(filename, parent);\n\n  if (isMain) {\n    process.mainModule = module;\n    module.id = '.';\n  }\n\n  Module._cache[filename] = module;\n  \n  // 尝试加载模块\n  tryModuleLoad(module, filename);\n\n  return module.exports;\n};\n\nfunction tryModuleLoad(module, filename) {\n  var threw = true;\n  try {\n    // 加载模块\n    module.load(filename);\n    threw = false;\n  } finally {\n    // 加载失败，则从缓存中删除\n    if (threw) {\n      delete Module._cache[filename];\n    }\n  }\n}\n```\n\n从上面看到真实调用的是 `module.load(filename);`，那就来看看这里干了什么。主要是根据不同的后缀调用不同的处理函数。\n\n```\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j', filename, this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  var extension = path.extname(filename) || '.js';\n  if (!Module._extensions[extension]) extension = '.js';\n  Module._extensions[extension](this, filename);\n  this.loaded = true;\n};\n```\n\n无论哪一种后缀，都会以 utf-8 编码读取模块文件，对 js 文件，在剃去 bom 头以后调用 `module._compile` 方法啊，json 文件则直接用 `JSON.parse` 进行解析。\n\n```\nModule._extensions['.js'] = function(module, filename) {\n  var content = fs.readFileSync(filename, 'utf8');\n  module._compile(internalModule.stripBOM(content), filename);\n};\n\n// Native extension for .json\nModule._extensions['.json'] = function(module, filename) {\n  var content = fs.readFileSync(filename, 'utf8');\n  try {\n    module.exports = JSON.parse(internalModule.stripBOM(content));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n```\n\n最后看一下 `module._compile` 方法，简化了一下：\n\n```\nModule.prototype._compile = function(content, filename) {\n  var self = this;\n  var args = [self.exports, require, self, filename, dirname];\n  return compiledWrapper.apply(self.exports, args);\n};\n```\n\n`module._compile` 类似于下面这样。所以每个模块下都能够访问这五个变量，这五个变量不是全局变量。\n\n```\n(function (exports, require, module, __filename, __dirname) {\n  // 模块源码\n});\n```\n\n这基本就是 node 加载模块的整个过程。导出比较简单，就不讲了。\n\n##### 浏览器\n\n浏览器端的情况就比较复杂，几年前主要 RequireJs、SeaJs 还是比较流行的，但是随着 es6 module 以及 webpack 这类工具的出现 RequireJs、SeaJs 已经慢慢地成为了历史。[感觉一直追赶的SeaJs已死](https://github.com/seajs/seajs/issues/1605)。下面就对于这些模式进行一些分析。\n\n###### loader 模式\n\nloader 模式简单来说就通过入口模块，依次异步加载和执行各个依赖模块。[实现原理](https://www.zhihu.com/question/21157540)及[seajs源码分析](http://git.oschina.net/m2mbob/seajs-annotation)。\n\n> 彼时流行的模块加载器都有几个共同的问题：\n\n> - 项目稍微大一点之后，加载的前端模块就变得特别多，上线时需要用配套工具做合并、打包。\n- 没有或者自建有一套模块管理方案，比如 SeaJs 自己搞的 spm。\n- 彼此打架，SeaJs 不兼容 RequireJs 的，反之亦然。\n- 无法像 npm 那样嵌套依赖，也不能直接支持多版本并存。\n\n这里要讲的 SystemJs，这应该是现在还没过时的模块加载器，因为 ng2 就是用它来加载模块的。（不过据说现在已经换成 webpack2 了）。\n\n它相对于 SeaJs、RequireJs 最大的优势是支持多种模块规范、多种环境，另外配合 jspm，可以解决上面大部分存在的问题。\n\n不过也有反对的意见，认为把预加载放在浏览器端是件不妥的事。\n\n###### 预编译打包模式\n\n预编译打包是指在服务端就将模块进行分析、加载和打包。主要代表是 browserify、webpack 及 rollup 等打包工具。\n\nbrowserify 简单，但是没有 webpack 那么强大，一般够用。\n\nwebpack 强大地一逼，建议使用。\n\nrollup 下一代的打包工具，vue 目前就用它来打包，引入 tree-shaking 技术。（webpack2 也引入了）\n\n因为只是简单地使用，没深入用过，只能瞎逼逼这些。就目前的形势来看，webpack 是标配，无论是搭配 react 还是 vue。结束 es6 系列会拿来深入学习一下。\n","html":"<h4 id=\"\">小背景</h4>\n\n<p>个人猜测 js 之父 Brendan Eich 设计 js 之初，应该没有意料到 js 会面对现在这样的如此复杂的应用场景，所以也就没有考虑为 js 设计相应的模块化方案。</p>\n\n<p>以至于当应用越来越复杂，很多大牛开始编写一些工具，并制定出一套模块化规范（服务端有 commonjs、浏览器端有 amd 和 cmd，为了两端通用还有 umd）。不光是规范，各种工具也是层出不穷，给人一种眼花缭乱，不知所措的感觉。</p>\n\n<p>而跟随着 es6 的大潮而来的 es6 module 也许能够帮助我们从上面的困境中走出来。es6 module 静态化的设计，使得其拥有更高的性能。不过，由于兼容性的问题，使得使用它还需要一些工具来对代码进行一些转换。</p>\n\n<p>好了接下来拿出瓜子和小板凳，开始正文了！</p>\n\n<p>在快写完这篇文章时看到了这个<a href=\"http://huangxuan.me/js-module-7day/#/\">干货</a>，感觉组织的比我好，所以拿出来分享了。</p>\n\n<h4 id=\"\">模块与模块化</h4>\n\n<p>百度百科：</p>\n\n<blockquote>\n  <p>模块，又称构件，是能够单独命名并独立地完成一定功能的程序语句的集合（即程序代码和数据结构的集合体）。</p>\n</blockquote>\n\n<p>两个基本的特征：</p>\n\n<ul>\n<li>外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能；（依赖与被依赖）</li>\n<li>内部特征是指模块的内部环境具有的特点。（内部独立、完整）</li>\n</ul>\n\n<p>而模块化要做的主要就是下面三件事：</p>\n\n<ol>\n<li>规定如何定义模块；  </li>\n<li>规定如何依赖一个模块；  </li>\n<li>规定如何对其他模块的引入支持。</li>\n</ol>\n\n<p>用现有的 commonjs 规范来简单解释就是：<code>module</code> 则用来定义一个模块。<code>require</code> 和 <code>exports</code> 用来描述模块与外部环境交互。<code>require</code> 规定了如何依赖一个模块，<code>exports</code>规定了模块如何暴露内部方法来支持其它模块的引入。模块内部的局部数据代码用来描述模块的内部特征。</p>\n\n<h4 id=\"\">模块化的意义</h4>\n\n<h6 id=\"\">全局变量与命名冲突！</h6>\n\n<p>想想我大一写 js 代码的时候，总写下面这种代码。现在看来当时还是挺年轻的，第一这样的写法会污染全局环境，第二可能会与其他同学或者第三方库产生一些命名冲突。</p>\n\n<pre><code>function m1(){  \n　　//...\n}\nfunction m2(){  \n　　//...\n}\n</code></pre>\n\n<p>为了解决这个问题，后来通常的做法就是 IIFE，将内容包在函数作用域内，然后返回。</p>\n\n<pre><code>var module1 = (function(){  \n　　var _count = 0;\n　　var m1 = function(){\n　　　　//...\n　　};\n　　var m2 = function(){\n　　　　//...\n　　};\n　　return {\n　　　　m1 : m1,\n　　　　m2 : m2\n　　};\n})();\n</code></pre>\n\n<p>当然还有另一种方案，就是 YUI 当时使用的命名空间方案（命名空间相对于 IIEF 方案来说，不能够有内部私有变量，所有状态都可以被外部改写，并且有些较长的命名空间记起来比较繁琐，造成了额外的负担）：</p>\n\n<pre><code>var app = {};  \napp.module1 = {};  \napp.module1.m1 = function () {  \n  // ...\n};\napp.module1.m2 = function () {  \n  // ...\n};\n</code></pre>\n\n<p>所以从上面看下来，IIEF 是用来实现纯 js 系统，模块化方案的不错工具。</p>\n\n<h6 id=\"\">依赖关系的维护！</h6>\n\n<p>光是 IIEF，我认为只能称得上模块，但是称不上模块化，因为它是独立的，不存在外部特征和模块依赖的管理。而通常情况下，我们的前端工程的各个模块之间往往是存在依赖关系的。如以下例子：</p>\n\n<pre><code>&lt;script src=\"util.js\"&gt;&lt;/script&gt;  \n&lt;script src=\"dialog.js\"&gt;&lt;/script&gt;  \n&lt;script&gt;  \n  org.CoolSite.Dialog.init({ /* 传入配置 */ });\n&lt;/script&gt;  \n</code></pre>\n\n<p>dialog.js 是依赖于 util.js，那么我们每次使用 dialog.js 时都要手动地去引入 util.js，这是件很低效的事。另外当依赖关系越来越复杂时，手工操作也会变得十分地头疼（处理依赖及其版本、依赖加载的顺序、甚至可能存在的循环依赖）。</p>\n\n<p>文件的依赖，目前在绝大部分类库框架里，比如国外的 YUI3 框架、国内的 KISSY 等类库，目前是通过配置的方式来解决。</p>\n\n<pre><code>YUI.add('my-module', function (Y) {  \n  // ...\n}, '0.0.1', {\n    requires: ['node', 'event']\n});\n</code></pre>\n\n<p>上面的代码，通过 requires 等方式来指定当前模块的依赖。这很大程度上可以解决依赖问题，但不够优雅。当模块很多，依赖很复杂时，烦琐的配置会带来不少隐患。</p>\n\n<h4 id=\"\">模块化演进</h4>\n\n<h6 id=\"nodejscommonjs\">nodejs 与 commonjs</h6>\n\n<p>js 真正从模块走向模块化，应该是在 2009年，nodejs 的横空出世。（之前那些应该只能算是模块，YUI 的可以算模块化，但是太久远了，那时候才小学可能）如果说浏览器端的 js 即便没有模块化也可以忍的话，那服务端是万万不能的。大牛云集的 CommonJs 社区（原来叫 ServerJs）发力，制定了 <a href=\"http://wiki.commonjs.org/wiki/Modules/1.0\">Modules/1.0</a> 规范，首次定义了一个模块应该长啥样，以及依赖如何管理。具体来说， Modules/1.0 规范包含以下内容：</p>\n\n<ol>\n<li>模块的标识应遵循的规则。  </li>\n<li>定义全局函数 <code>require</code>，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的 API。  </li>\n<li>如果被 <code>require</code> 函数引入的模块中也包含依赖，那么依次加载这些依赖  </li>\n<li>如果引入模块失败，那么 <code>require</code> 函数应该报一个异常  </li>\n<li>模块通过变量 <code>exports</code> 来向往暴漏 API，<code>exports</code> 只能是一个对象，暴漏的 API 须作为此对象的属性。</li>\n</ol>\n\n<p>此规范一出，立刻产生了良好的效果，由于其简单而直接，在 nodejs 中，这种模块化方案立刻被推广开了。</p>\n\n<h6 id=\"\">向浏览器进发</h6>\n\n<p>09年下半年 CommonJs 社区想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：</p>\n\n<ul>\n<li><p>Modules/1.x 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href=\"http://wiki.commonjs.org/wiki/Modules/Transport\">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。browserify 做的就是类似的事情，它会将 commonjs 规范的代码打包成浏览器端可以执行的代码。 这样的好处就是可以共享 npm 上成千上万的库。</p></li>\n<li><p>Modules/Async 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。因为浏览器的加载特点和 node 不同，node 同步的加载方式在浏览器端会造成比较大的问题，因此这个流派认为模块的加载应当通过异步下载-回调这样的过程来进行。代表有 AMD。</p></li>\n<li><p>Modules/2.0 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。<a href=\"https://github.com/seajs/seajs/issues/588\">这里有个故事</a></p></li>\n</ul>\n\n<p>这场争论最后胜出的应当还是 Modules/Async 流派，随后 AMD 的实现 RequireJs 也迅速崛起。但是 AMD 规范一直没有被 CommonJS 社区认同，核心争议点如下：</p>\n\n<p>执行时机：</p>\n\n<p>Modules/1.0:</p>\n\n<pre><code>var a = require(\"./a\") // 执行到此处时，a.js 才同步下载并执行  \n</code></pre>\n\n<p>AMD:</p>\n\n<pre><code>define([\"require\"], function(require) {  \n  // 在这里，模块 a 已经下载并执行好\n  // ...\n  var a = require(\"./a\") // 此处仅仅是取模块 a 的 exports\n\n})\n</code></pre>\n\n<p>模块书写风格有争议</p>\n\n<p>AMD 风格下，通过参数传入依赖模块，破坏了 就近声明 原则。比如：</p>\n\n<pre><code>define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) {\n\n    // 等于在最前面申明并初始化了要用到的所有模块\n\n   if (false) {\n       // 即便压根儿没用到某个模块 b，但 b 还是提前执行了\n       b.foo()\n   }\n\n})\n</code></pre>\n\n<p>还有就是 AMD 下 <code>require</code> 的用法，以及增加了全局变量 <code>define</code> 等细节，当时在社区被很多人不认可。</p>\n\n<p>最后，AMD 从 CommonJS 社区独立了出去，单独成为了 AMD 社区。有阵子，CommonJS 社区还要求 RequireJS 的文档里，不能再打 CommonJS 的旗帜。</p>\n\n<p>正是存在这些争议，淘宝前端布道者玉伯兼容并包，实现了 SeaJs，并推出了 CMD 规范。它吸取了 RequireJS，以及 Modules/Wrappings 规范的优点。</p>\n\n<p>再到后来还有 umd，用来同时支持 AMD 和 commonjs，UMD的实现很简单，先判断是否支持 node 模块格式（<code>exports</code>是否存在），存在则使用 node 模块格式。再判断是否支持 AMD（<code>define</code>是否存在），存在则使用AMD方式加载模块。前两个都不存在，则将模块公开的全局（window或global）。</p>\n\n<p>再往后应该就是 es6 module 了，es6 与上面讲到的模块化规范有着本质的不同。上面的都是纯 js 环境的下的模块系统。对于纯 js 环境（所谓纯 js 系统，就是不依赖其他机制如预处理之类的系统）下的模块系统，其中的模块都是一个个对象。客户代码导入模块所导出的定义，实际上是查找 module 对象上的属性。</p>\n\n<pre><code>var { stat, exists, readFile } = require('fs')  \n</code></pre>\n\n<p>es6 模块系统则相反，模块不是对象，而是声明式的代码集合。从模块导入定义也是声明式的。</p>\n\n<pre><code>import { stat, exists, readFile } from 'fs'  \n</code></pre>\n\n<p>两种差别的主要原因在于，那些大牛们没有办法从语言层面作出修改，因此只能退而求其次，走渐进的、改良式的道路。而从语言层面进行改进，正是 tc39 能做的。（虽然 node 的作者表示了相反的意见，但是这已经是一个既成的事实了）</p>\n\n<h4 id=\"\">模块化的实现</h4>\n\n<h5 id=\"node\">node</h5>\n\n<p>node 端的情况相对来说不那么复杂，它的模块实现主要在<a href=\"https://github.com/nodejs/node/blob/master/lib/module.js\">这里</a>。下面从定义模块、加载模块、导出模块三个点的实现来介绍</p>\n\n<p>定义模块：</p>\n\n<p>node 定义了一个构造函数 Module，所有的模块都是 Module 的实例。可以看到，当前模块（module.js）也是 Module 的一个实例。</p>\n\n<pre><code>function Module(id, parent) {  \n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  if (parent &amp;&amp; parent.children) {\n    parent.children.push(this);\n  }\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n</code></pre>\n\n<p>加载模块：</p>\n\n<p>加载模块是通过 <code>require</code> 方法。<code>require</code> 不是全局属性，看下去就能明白。</p>\n\n<pre><code>Module.prototype.require = function(path) {  \n  // path 是加载模块路径\n  // this 表示当前加载模块\n  return Module._load(path, this, /* isMain */ false);\n};\n</code></pre>\n\n<p><code>require</code> 方法实际调用的是 <code>Module._load</code> 方法。主要进行了路径的处理以及缓存的处理。</p>\n\n<pre><code>Module._load = function(request, parent, isMain) {  \n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s', request, parent.id);\n  }\n\n  // 这里实际上是获取模块的绝对路径\n  var filename = Module._resolveFilename(request, parent, isMain);\n\n  // 检查是否存在缓存，如果存在缓存就从缓存中返回\n  var cachedModule = Module._cache[filename];\n  if (cachedModule) {\n    return cachedModule.exports;\n  }\n\n  // 检查是否为内置模块\n  if (NativeModule.nonInternalExists(filename)) {\n    debug('load native module %s', request);\n    return NativeModule.require(filename);\n  }\n\n  // 新建模块，存入缓存\n  var module = new Module(filename, parent);\n\n  if (isMain) {\n    process.mainModule = module;\n    module.id = '.';\n  }\n\n  Module._cache[filename] = module;\n\n  // 尝试加载模块\n  tryModuleLoad(module, filename);\n\n  return module.exports;\n};\n\nfunction tryModuleLoad(module, filename) {  \n  var threw = true;\n  try {\n    // 加载模块\n    module.load(filename);\n    threw = false;\n  } finally {\n    // 加载失败，则从缓存中删除\n    if (threw) {\n      delete Module._cache[filename];\n    }\n  }\n}\n</code></pre>\n\n<p>从上面看到真实调用的是 <code>module.load(filename);</code>，那就来看看这里干了什么。主要是根据不同的后缀调用不同的处理函数。</p>\n\n<pre><code>Module.prototype.load = function(filename) {  \n  debug('load %j for module %j', filename, this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  var extension = path.extname(filename) || '.js';\n  if (!Module._extensions[extension]) extension = '.js';\n  Module._extensions[extension](this, filename);\n  this.loaded = true;\n};\n</code></pre>\n\n<p>无论哪一种后缀，都会以 utf-8 编码读取模块文件，对 js 文件，在剃去 bom 头以后调用 <code>module._compile</code> 方法啊，json 文件则直接用 <code>JSON.parse</code> 进行解析。</p>\n\n<pre><code>Module._extensions['.js'] = function(module, filename) {  \n  var content = fs.readFileSync(filename, 'utf8');\n  module._compile(internalModule.stripBOM(content), filename);\n};\n\n// Native extension for .json\nModule._extensions['.json'] = function(module, filename) {  \n  var content = fs.readFileSync(filename, 'utf8');\n  try {\n    module.exports = JSON.parse(internalModule.stripBOM(content));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n</code></pre>\n\n<p>最后看一下 <code>module._compile</code> 方法，简化了一下：</p>\n\n<pre><code>Module.prototype._compile = function(content, filename) {  \n  var self = this;\n  var args = [self.exports, require, self, filename, dirname];\n  return compiledWrapper.apply(self.exports, args);\n};\n</code></pre>\n\n<p><code>module._compile</code> 类似于下面这样。所以每个模块下都能够访问这五个变量，这五个变量不是全局变量。</p>\n\n<pre><code>(function (exports, require, module, __filename, __dirname) {\n  // 模块源码\n});\n</code></pre>\n\n<p>这基本就是 node 加载模块的整个过程。导出比较简单，就不讲了。</p>\n\n<h5 id=\"\">浏览器</h5>\n\n<p>浏览器端的情况就比较复杂，几年前主要 RequireJs、SeaJs 还是比较流行的，但是随着 es6 module 以及 webpack 这类工具的出现 RequireJs、SeaJs 已经慢慢地成为了历史。<a href=\"https://github.com/seajs/seajs/issues/1605\">感觉一直追赶的SeaJs已死</a>。下面就对于这些模式进行一些分析。</p>\n\n<h6 id=\"loader\">loader 模式</h6>\n\n<p>loader 模式简单来说就通过入口模块，依次异步加载和执行各个依赖模块。<a href=\"https://www.zhihu.com/question/21157540\">实现原理</a>及<a href=\"http://git.oschina.net/m2mbob/seajs-annotation\">seajs源码分析</a>。</p>\n\n<blockquote>\n  <p>彼时流行的模块加载器都有几个共同的问题：</p>\n  \n  <ul>\n  <li>项目稍微大一点之后，加载的前端模块就变得特别多，上线时需要用配套工具做合并、打包。</li>\n  <li>没有或者自建有一套模块管理方案，比如 SeaJs 自己搞的 spm。</li>\n  <li>彼此打架，SeaJs 不兼容 RequireJs 的，反之亦然。</li>\n  <li>无法像 npm 那样嵌套依赖，也不能直接支持多版本并存。</li>\n  </ul>\n</blockquote>\n\n<p>这里要讲的 SystemJs，这应该是现在还没过时的模块加载器，因为 ng2 就是用它来加载模块的。（不过据说现在已经换成 webpack2 了）。</p>\n\n<p>它相对于 SeaJs、RequireJs 最大的优势是支持多种模块规范、多种环境，另外配合 jspm，可以解决上面大部分存在的问题。</p>\n\n<p>不过也有反对的意见，认为把预加载放在浏览器端是件不妥的事。</p>\n\n<h6 id=\"\">预编译打包模式</h6>\n\n<p>预编译打包是指在服务端就将模块进行分析、加载和打包。主要代表是 browserify、webpack 及 rollup 等打包工具。</p>\n\n<p>browserify 简单，但是没有 webpack 那么强大，一般够用。</p>\n\n<p>webpack 强大地一逼，建议使用。</p>\n\n<p>rollup 下一代的打包工具，vue 目前就用它来打包，引入 tree-shaking 技术。（webpack2 也引入了）</p>\n\n<p>因为只是简单地使用，没深入用过，只能瞎逼逼这些。就目前的形势来看，webpack 是标配，无论是搭配 react 还是 vue。结束 es6 系列会拿来深入学习一下。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475629017140,"created_by":1,"updated_at":1476009418512,"updated_by":1,"published_at":1475672569385,"published_by":1},{"id":104,"uuid":"4246a3b5-127a-4664-b8e1-48cfd4e466de","title":"es6 温故第二天小结","slug":"es6-di-er-tian-xiao-jie","markdown":"模块化看了很久，被各种非标准的模块规范以及各种模块加载器、打包工具弄得头大，所以进展不大，先看其他的部分压压惊！\n\n#### 正则的扩展\n\n###### 构造函数\n\n构造函数支持第一个参数为正则，第二个为修饰符的写法。\n\n###### 字符串的正则方法\n\nES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。\n\n- `String.prototype.match` 调用 `RegExp.prototype[Symbol.match]`\n- `String.prototype.replace` 调用 `RegExp.prototype[Symbol.replace]`\n- `String.prototype.search` 调用 `RegExp.prototype[Symbol.search]`\n- `String.prototype.split` 调用 `RegExp.prototype[Symbol.split]`\n\n###### 增加实例属性\n\n1. flags属性，得到正则实例的修饰符。\n2. sticky属性，返回是否存在 y 修饰符。\n\n###### unicode扩展\n\n增加了 u 修饰符，用来支持码点大于 FFFF 的 unicode 字符。\n\n- . 字符在 u 模式下，可以正确匹配码点大于 FFFF 的 unicode 字符。\n- 大括号表示的 unicode 字符在 u 模式下才能识别。\n- 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。\n- u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。\n- 有些Unicode字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。下面代码中，不加u修饰符，就无法识别非规范的K字符。\n\n```\n/[a-z]/i.test('\\u212A') // false\n/[a-z]/iu.test('\\u212A') // true\n```\n\n###### y 修饰符\n\n区别于g，y要求下一次匹配必须从剩下的第一个开始。\n\n###### es7及最新提案\n\n- `RegExp.escape()` 字符串必须转移之后才能够作为正则的模式。\n- 后行断言，js 原来只支持前瞻，现在有提案要加入后顾，并且 V8 已经实现了。`/(?<=y)x/` 和 `/(?<!y)x/`。\n- unicode 属性类，目前有一个提案，引入了一种新的类的写法 `\\p{...}` 和 `\\P{...}`，允许正则表达式匹配符合 unicode 某种属性的所有字符。\n\n```\nconst regexGreekSymbol = /\\p{Script=Greek}/u;\nregexGreekSymbol.test('π') // u\n```\n\n#### 数值扩展\n\n###### 二进制和八进制\n\nES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。继在 es5 严格模式中指出不能以 0 开头表示八进制字面量后，es6 更加明确地定义了八进制字面量的写法。\n\n###### 转移全局对象的方法\n\n这些方法都被从全局对象上转移到了 Number 对象上，但是考虑到兼容性的问题，全局对象上也保留了这些方法：\n\n- `Number.isFinite()`\n- `Number.isNaN()`\n- `Number.parseInt()`\n- `Number.parseFloat()`\n\nNumber 对象上除了这些方法，还增加了下面两个方法：\n\n- `Number.isInteger()`，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。\n- `Number.isSafeInteger()`，JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。\n\n###### 增加了几个常量\n\n- `Number.MAX_SAFE_INTEGER` 等于 `Math.pow(2, 53) - 1`\n- `Number.MIN_SAFE_INTEGER` 等于 `- Number.MIN_SAFE_INTEGER`\n- `Number.EPSILON` 等于 2.220446049250313e-16（前面讲个双精度浮点数的精度，这个常量就是用来表示一个可以接受的精度范围）\n\n#### Math 的扩展\n\nES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。\n\n###### 普通方法\n\n- `Math.trunc` 方法用于去除一个数的小数部分，返回整数部分。\n- `Math.sign` 方法用来判断一个数到底是正数、负数、还是零。它会返回五种值。\n - 参数为正数，返回+1；\n - 参数为负数，返回-1；\n - 参数为0，返回0；\n - 参数为-0，返回-0;\n - 其他值，返回NaN。\n- `Math.cbrt` 方法用于计算一个数的立方根。\n- `Math.clz32` 方法返回一个数的32位无符号整数形式有多少个前导0。\n- `Math.imul` 方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。\n- `Math.fround` 方法返回一个数的单精度浮点数形式。\n- `Math.hypot` 方法返回所有参数的平方和的平方根。\n\n###### 对数方法\n\n- `Math.expm1(x)` 返回 ex - 1，即 `Math.exp(x) - 1`。\n- `Math.log1p(x)` 方法返回 1 + x 的自然对数，即 `Math.log(1 + x)`。如果 `x` 小于-1，返回 `NaN`。\n- `Math.log10(x)` 返回以10为底的 `x` 的对数。如果 `x` 小于0，则返回 `NaN`。\n- `Math.log2(x)` 返回以2为底的 `x` 的对数。如果 `x` 小于0，则返回 `NaN`。\n\n###### 三角函数方法\nES6新增了6个三角函数方法。\n\n- `Math.sinh(x)` 返回x的双曲正弦（hyperbolic sine）\n- `Math.cosh(x)` 返回x的双曲余弦（hyperbolic cosine）\n- `Math.tanh(x)` 返回x的双曲正切（hyperbolic tangent）\n- `Math.asinh(x)` 返回x的反双曲正弦（inverse hyperbolic sine）\n- `Math.acosh(x)` 返回x的反双曲余弦（inverse hyperbolic cosine）\n- `Math.atanh(x)` 返回x的反双曲正切（inverse hyperbolic tangent）\n\n###### es7\n\nES7 新增的两个特性中，包括了一个指数运算符（**），目前最新的 V8 已经支持。\n\n```\n2 ** 2 // 4\n// 或 **=\nlet a = 2;\na **= 2;\n// 等同于 a = a * a;\n```\n","html":"<p>模块化看了很久，被各种非标准的模块规范以及各种模块加载器、打包工具弄得头大，所以进展不大，先看其他的部分压压惊！</p>\n\n<h4 id=\"\">正则的扩展</h4>\n\n<h6 id=\"\">构造函数</h6>\n\n<p>构造函数支持第一个参数为正则，第二个为修饰符的写法。</p>\n\n<h6 id=\"\">字符串的正则方法</h6>\n\n<p>ES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p>\n\n<ul>\n<li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li>\n<li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li>\n<li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li>\n<li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li>\n</ul>\n\n<h6 id=\"\">增加实例属性</h6>\n\n<ol>\n<li>flags属性，得到正则实例的修饰符。  </li>\n<li>sticky属性，返回是否存在 y 修饰符。</li>\n</ol>\n\n<h6 id=\"unicode\">unicode扩展</h6>\n\n<p>增加了 u 修饰符，用来支持码点大于 FFFF 的 unicode 字符。</p>\n\n<ul>\n<li>. 字符在 u 模式下，可以正确匹配码点大于 FFFF 的 unicode 字符。</li>\n<li>大括号表示的 unicode 字符在 u 模式下才能识别。</li>\n<li>使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。</li>\n<li>u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。</li>\n<li>有些Unicode字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。下面代码中，不加u修饰符，就无法识别非规范的K字符。</li>\n</ul>\n\n<pre><code>/[a-z]/i.test('\\u212A') // false\n/[a-z]/iu.test('\\u212A') // true\n</code></pre>\n\n<h6 id=\"y\">y 修饰符</h6>\n\n<p>区别于g，y要求下一次匹配必须从剩下的第一个开始。</p>\n\n<h6 id=\"es7\">es7及最新提案</h6>\n\n<ul>\n<li><code>RegExp.escape()</code> 字符串必须转移之后才能够作为正则的模式。</li>\n<li>后行断言，js 原来只支持前瞻，现在有提案要加入后顾，并且 V8 已经实现了。<code>/(?&lt;=y)x/</code> 和 <code>/(?&lt;!y)x/</code>。</li>\n<li>unicode 属性类，目前有一个提案，引入了一种新的类的写法 <code>\\p{...}</code> 和 <code>\\P{...}</code>，允许正则表达式匹配符合 unicode 某种属性的所有字符。</li>\n</ul>\n\n<pre><code>const regexGreekSymbol = /\\p{Script=Greek}/u;  \nregexGreekSymbol.test('π') // u  \n</code></pre>\n\n<h4 id=\"\">数值扩展</h4>\n\n<h6 id=\"\">二进制和八进制</h6>\n\n<p>ES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。继在 es5 严格模式中指出不能以 0 开头表示八进制字面量后，es6 更加明确地定义了八进制字面量的写法。</p>\n\n<h6 id=\"\">转移全局对象的方法</h6>\n\n<p>这些方法都被从全局对象上转移到了 Number 对象上，但是考虑到兼容性的问题，全局对象上也保留了这些方法：</p>\n\n<ul>\n<li><code>Number.isFinite()</code></li>\n<li><code>Number.isNaN()</code></li>\n<li><code>Number.parseInt()</code></li>\n<li><code>Number.parseFloat()</code></li>\n</ul>\n\n<p>Number 对象上除了这些方法，还增加了下面两个方法：</p>\n\n<ul>\n<li><code>Number.isInteger()</code>，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</li>\n<li><code>Number.isSafeInteger()</code>，JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。</li>\n</ul>\n\n<h6 id=\"\">增加了几个常量</h6>\n\n<ul>\n<li><code>Number.MAX_SAFE_INTEGER</code> 等于 <code>Math.pow(2, 53) - 1</code></li>\n<li><code>Number.MIN_SAFE_INTEGER</code> 等于 <code>- Number.MIN_SAFE_INTEGER</code></li>\n<li><code>Number.EPSILON</code> 等于 2.220446049250313e-16（前面讲个双精度浮点数的精度，这个常量就是用来表示一个可以接受的精度范围）</li>\n</ul>\n\n<h4 id=\"math\">Math 的扩展</h4>\n\n<p>ES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。</p>\n\n<h6 id=\"\">普通方法</h6>\n\n<ul>\n<li><code>Math.trunc</code> 方法用于去除一个数的小数部分，返回整数部分。</li>\n<li><code>Math.sign</code> 方法用来判断一个数到底是正数、负数、还是零。它会返回五种值。\n<ul><li>参数为正数，返回+1；</li>\n<li>参数为负数，返回-1；</li>\n<li>参数为0，返回0；</li>\n<li>参数为-0，返回-0;</li>\n<li>其他值，返回NaN。</li></ul></li>\n<li><code>Math.cbrt</code> 方法用于计算一个数的立方根。</li>\n<li><code>Math.clz32</code> 方法返回一个数的32位无符号整数形式有多少个前导0。</li>\n<li><code>Math.imul</code> 方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。</li>\n<li><code>Math.fround</code> 方法返回一个数的单精度浮点数形式。</li>\n<li><code>Math.hypot</code> 方法返回所有参数的平方和的平方根。</li>\n</ul>\n\n<h6 id=\"\">对数方法</h6>\n\n<ul>\n<li><code>Math.expm1(x)</code> 返回 ex - 1，即 <code>Math.exp(x) - 1</code>。</li>\n<li><code>Math.log1p(x)</code> 方法返回 1 + x 的自然对数，即 <code>Math.log(1 + x)</code>。如果 <code>x</code> 小于-1，返回 <code>NaN</code>。</li>\n<li><code>Math.log10(x)</code> 返回以10为底的 <code>x</code> 的对数。如果 <code>x</code> 小于0，则返回 <code>NaN</code>。</li>\n<li><code>Math.log2(x)</code> 返回以2为底的 <code>x</code> 的对数。如果 <code>x</code> 小于0，则返回 <code>NaN</code>。</li>\n</ul>\n\n<h6 id=\"\">三角函数方法</h6>\n\n<p>ES6新增了6个三角函数方法。</p>\n\n<ul>\n<li><code>Math.sinh(x)</code> 返回x的双曲正弦（hyperbolic sine）</li>\n<li><code>Math.cosh(x)</code> 返回x的双曲余弦（hyperbolic cosine）</li>\n<li><code>Math.tanh(x)</code> 返回x的双曲正切（hyperbolic tangent）</li>\n<li><code>Math.asinh(x)</code> 返回x的反双曲正弦（inverse hyperbolic sine）</li>\n<li><code>Math.acosh(x)</code> 返回x的反双曲余弦（inverse hyperbolic cosine）</li>\n<li><code>Math.atanh(x)</code> 返回x的反双曲正切（inverse hyperbolic tangent）</li>\n</ul>\n\n<h6 id=\"es7\">es7</h6>\n\n<p>ES7 新增的两个特性中，包括了一个指数运算符（**），目前最新的 V8 已经支持。</p>\n\n<pre><code>2 ** 2 // 4  \n// 或 **=\nlet a = 2;  \na **= 2;  \n// 等同于 a = a * a;\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475648473893,"created_by":1,"updated_at":1475655173278,"updated_by":1,"published_at":1475655032976,"published_by":1},{"id":105,"uuid":"6119cb4f-a6a3-4bfd-8171-df9639facb82","title":"js 同步异步加载小结","slug":"js-tong-bu-yi-bu-jia-zai-xiao-jie","markdown":"在 amd 和 cmd 中都涉及了 js 的异步加载，所以顺便把这块知识回顾了一下。并且从 seajs 源码出发，介绍了异步加载、延迟执行在模块化中的实现原理。 \n\n#### 同步加载\n\n```\n<script src=\"http://yourdomain.com/script.js\"></script> \n```\n\n1. 阻塞后续的文件加载（如图像）、渲染、代码执行。\n2. 加载完同步执行，同样会阻塞。\n3. 一般建议是把 `<script>` 放在页面末尾 `</body>` 之前，这样尽可能减少这种阻塞行为，而先让页面展示出来。\n4. 很多高级浏览器会并发这些请求。\n\n#### 异步加载\n\n##### 常规异步加载\n\n```\n(function() {\n     var s = document.createElement('script');\n     s.type = 'text/javascript';\n     // s.async = true; 可选\n     s.src = 'http://yourdomain.com/script.js';\n     var x = document.getElementsByTagName('script')[0];\n     x.parentNode.insertBefore(s, x);\n })();\n```\n\n1. 异步加载 js 文件，同步执行。\n2. 出于安全性的要求，异步加载的 js 文件内不能进行 `document.write` 操作。在页面 loaded 之后进行这个操作，会自动调用 `document.open()` 从而清空页面。\n3. 这种加载方式在加载执行完之前会阻塞 onload 事件的触发，而现在很多页面的代码都在 onload 时还要执行额外的渲染工作等，所以还是会阻塞部分页面的初始化处理。因此有需要的话可以在 onload 事件之后进行异步加载。\n\n> 小贴士：`DOMContentLoaded`事件：页面(document)已经解析完成，页面中的 dom 元素已经可用。但是页面中引用的图片、subframe可能还没有加载完。\n`onload`事件：页面的所有资源都加载完毕（包括图片）。浏览器的载入进度在这时才停止。上面第二点将的 loaded 之后指的是 `DOMContentLoaded` 而不是 `onload` 事件之后。\n\n##### 其他异步加载\n\n###### async 和 defer 属性\n\n- defer：在IE 4.0中就实现了，Firefox 从 3.5 开始支持defer属性 ，其他高级浏览器不支持。其行为是异步加载，在 `DOMContentLoaded` 事件之后按顺序同步执行。\n- async：是HTML5新增的。作用和 defer 类似，但是它将在下载后尽快执行，不能保证脚本会按顺序执行。它们将在 onload 事件之前完成。\nFirefox 3.6、Opera 10.5、IE 9 和 最新的Chrome 和 Safari 都支持 async 属性。\n- 可以两个一起使用，达到兼容低版本的 IE 并实现异步加载的目的，但是对于各个 js 存在依赖的情况下，async 是存在问题的，因为执行顺序不被保证。\n\n###### XHR Eval\n\n通过 ajax 获取js的内容，然后 eval 执行。需要解决跨域的问题。\n\n```\nvar xhrObj = getXHRObject(); \n xhrObj.onreadystatechange =  \n   function() {  \n     if ( xhrObj.readyState != 4 ) return; \n     eval(xhrObj.responseText); \n   }; \n xhrObj.open('GET', 'A.js', true); \n xhrObj.send('');\n```\n\n###### Script in Iframe\n\n创建并插入一个iframe元素，让其异步加载执行 js。原理和常规的差不多。\n\n```\nvar iframe = document.createElement('iframe'); \ndocument.body.appendChild(iframe); \nvar doc = iframe.contentWindow.document; \ndoc.open().write('<body onload=\"insertJS()\">'); \ndoc.close();\n```\n\n#### 延迟执行\n\n不管是同步加载还是异步加载，其执行都是同步的。而这个阶段也是会造成阻塞的，而事实上有一部分脚本我们是不需要立即执行的（比如只是在展示某个界面或执行某个操作时才需要）。这些 script 可以延迟执行，先异步下载缓存起来，但不立即执行，而是在第一次需要的时候执行一次。\n利用特殊的技巧可以做到下载与执行的分离。比如将 js 的内容作为 Image或 object 对象加载缓存起来，所以就不会立即执行了，然后在第一次需要的时候再执行。\n\n#### cmd 的 异步加载和延迟执行\n\n对于模块化的前端组织来说，单纯的异步加载是不能够满足需求的，而要考虑模块之间的依赖关系。并且配合延迟执行，可以比较好地提升页面加载阶段的性能。这一节就将针对 seajs 的实现进行一些分析。（虽然 seajs 作者也承认已死，但是作为 js 模块化历史上一个重要的过渡角色，还是可以研究一下的。）\n\n看了两天终于可以来填坑了。首先看 seajs 异步加载的方案。\n\n```\nvar head = doc.head || doc.getElementsByTagName(\"head\")[0] || doc.documentElement\nvar baseElement = head.getElementsByTagName(\"base\")[0]\n\nvar currentlyAddingScript\nvar interactiveScript\n\n// 创建 script 标签发出异步请求\nfunction request(url, callback, charset) {\n  var node = doc.createElement(\"script\")\n  \n  // 设置编码，默认为 utf-8\n  if (charset) {\n    var cs = isFunction(charset) ? charset(url) : charset\n    if (cs) {\n      node.charset = cs\n    }\n  }\n\n  // 为 script node 添加 onload 事件\n  addOnload(node, callback, url)\n\n  node.async = true\n  node.src = url\n\n  // For some cache cases in IE 6-8, the script executes IMMEDIATELY after\n  // the end of the insert execution, so use `currentlyAddingScript` to\n  // hold current node, for deriving url in `define` call\n  currentlyAddingScript = node\n\n  // 后加载的 js 被插在了 head 的最前边，这样会导致 X-UA-Compatible 失效\n  // 所以不存在 base 时使用 appendChild\n  // ref: #185 & http://dev.jquery.com/ticket/2709\n  baseElement ?\n      head.insertBefore(node, baseElement) :\n      head.appendChild(node)\n\n  currentlyAddingScript = null\n}\n\n// 检测是否支持 onload\n// 不支持使用 onreadystatechange 代替\nfunction addOnload(node, callback, url) {\n  var supportOnload = \"onload\" in node\n\n  if (supportOnload) {\n    node.onload = onload\n    node.onerror = function() {\n      emit(\"error\", { uri: url, node: node })\n      onload()\n    }\n  }\n  else {\n    node.onreadystatechange = function() {\n      if (/loaded|complete/.test(node.readyState)) {\n        onload()\n      }\n    }\n  }\n\n  function onload() {\n    // 确保只执行一次，处理 IE 的内存泄漏\n    node.onload = node.onerror = node.onreadystatechange = null\n\n    // 移除 script 减少内存泄露，因为模块以及被缓存在变量中，所以为了不立即执行代码，会在 onload 时就把 node 移除掉。\n    if (!data.debug) {\n      head.removeChild(node)\n    }\n\n    // 删除 node 引用\n    node = null\n    \n    callback()\n  }\n}\n```\n\n上面是每次 seajs 模块加载依赖的时候都会进行调用的函数，做法和我们上面提到的一样，是创建 `<script>`。不过为了管理依赖，它内部创建 `<script>` 会根据依赖的关系按次序进行，执行回调也会考虑到依赖是否被加载。另外值得注意的是，它在 onload 之后便把 node 移除了，因为这个模块已经被缓存起来了。针对没有 onload 事件的 IE6-8，它使用了 `onreadystatechange` 事件来进行兼容。\n \n那么延迟执行是怎么做的呢！其实 node 在 onload 之前已经执行了，只不过执行的是模块的 `define` 方法，而方法的回调会在入口模块加载完毕的 `onload` 方法或者是执行过程中的 `require` 中被调用。因此保证了执行是在真正用到的时候。这就是 seajs 的延迟执行。\n\n```\n// Use function is equal to load a anonymous module\n// 加载一个匿名模块\nModule.use = function (ids, callback, uri) {\n  // 从缓存取中或新建加入缓存\n  var mod = Module.get(uri, isArray(ids) ? ids : [ids])\n\n  // 这个 callback 会在 Module.onload 中调用\n  mod.callback = function() {\n    var exports = []\n    var uris = mod.resolve()\n\n    for (var i = 0, len = uris.length; i < len; i++) {\n      // 将依赖的模块执行\n      exports[i] = cachedMods[uris[i]].exec()\n    }\n\n    if (callback) {\n      callback.apply(global, exports)\n    }\n\n    delete mod.callback\n  }\n\n  // 无需物理抓取直接加载这个模块\n  mod.load()\n}\n```\n\n完整的源码注释可以看[seajs 源码注释](http://git.oschina.net/m2mbob/seajs-annotation)\n\n#### 最佳实践\n\n1. 对于需要在脚本内进行 `document.write` 的 js，放在 `</body>` 前同步加载（尽量少用 `document.write` ）；\n2. 其它的，如果 js 没有依赖关系，可以使用 async + defer 的方式，比较简单；\n3. 简单系统的依赖关系，可以手动按顺序放在 `</body>` 前同步加载；\n4. 复杂系统存在模块间复杂的依赖关系，则需要 requirejs、seajs、webpack 等工具来进行模块加载。","html":"<p>在 amd 和 cmd 中都涉及了 js 的异步加载，所以顺便把这块知识回顾了一下。并且从 seajs 源码出发，介绍了异步加载、延迟执行在模块化中的实现原理。 </p>\n\n<h4 id=\"\">同步加载</h4>\n\n<pre><code>&lt;script src=\"http://yourdomain.com/script.js\"&gt;&lt;/script&gt;  \n</code></pre>\n\n<ol>\n<li>阻塞后续的文件加载（如图像）、渲染、代码执行。  </li>\n<li>加载完同步执行，同样会阻塞。  </li>\n<li>一般建议是把 <code>&lt;script&gt;</code> 放在页面末尾 <code>&lt;/body&gt;</code> 之前，这样尽可能减少这种阻塞行为，而先让页面展示出来。  </li>\n<li>很多高级浏览器会并发这些请求。</li>\n</ol>\n\n<h4 id=\"\">异步加载</h4>\n\n<h5 id=\"\">常规异步加载</h5>\n\n<pre><code>(function() {\n     var s = document.createElement('script');\n     s.type = 'text/javascript';\n     // s.async = true; 可选\n     s.src = 'http://yourdomain.com/script.js';\n     var x = document.getElementsByTagName('script')[0];\n     x.parentNode.insertBefore(s, x);\n })();\n</code></pre>\n\n<ol>\n<li>异步加载 js 文件，同步执行。  </li>\n<li>出于安全性的要求，异步加载的 js 文件内不能进行 <code>document.write</code> 操作。在页面 loaded 之后进行这个操作，会自动调用 <code>document.open()</code> 从而清空页面。  </li>\n<li>这种加载方式在加载执行完之前会阻塞 onload 事件的触发，而现在很多页面的代码都在 onload 时还要执行额外的渲染工作等，所以还是会阻塞部分页面的初始化处理。因此有需要的话可以在 onload 事件之后进行异步加载。</li>\n</ol>\n\n<blockquote>\n  <p>小贴士：<code>DOMContentLoaded</code>事件：页面(document)已经解析完成，页面中的 dom 元素已经可用。但是页面中引用的图片、subframe可能还没有加载完。\n  <code>onload</code>事件：页面的所有资源都加载完毕（包括图片）。浏览器的载入进度在这时才停止。上面第二点将的 loaded 之后指的是 <code>DOMContentLoaded</code> 而不是 <code>onload</code> 事件之后。</p>\n</blockquote>\n\n<h5 id=\"\">其他异步加载</h5>\n\n<h6 id=\"asyncdefer\">async 和 defer 属性</h6>\n\n<ul>\n<li>defer：在IE 4.0中就实现了，Firefox 从 3.5 开始支持defer属性 ，其他高级浏览器不支持。其行为是异步加载，在 <code>DOMContentLoaded</code> 事件之后按顺序同步执行。</li>\n<li>async：是HTML5新增的。作用和 defer 类似，但是它将在下载后尽快执行，不能保证脚本会按顺序执行。它们将在 onload 事件之前完成。\nFirefox 3.6、Opera 10.5、IE 9 和 最新的Chrome 和 Safari 都支持 async 属性。  </li>\n<li>可以两个一起使用，达到兼容低版本的 IE 并实现异步加载的目的，但是对于各个 js 存在依赖的情况下，async 是存在问题的，因为执行顺序不被保证。</li>\n</ul>\n\n<h6 id=\"xhreval\">XHR Eval</h6>\n\n<p>通过 ajax 获取js的内容，然后 eval 执行。需要解决跨域的问题。</p>\n\n<pre><code>var xhrObj = getXHRObject();  \n xhrObj.onreadystatechange =  \n   function() {  \n     if ( xhrObj.readyState != 4 ) return; \n     eval(xhrObj.responseText); \n   }; \n xhrObj.open('GET', 'A.js', true); \n xhrObj.send('');\n</code></pre>\n\n<h6 id=\"scriptiniframe\">Script in Iframe</h6>\n\n<p>创建并插入一个iframe元素，让其异步加载执行 js。原理和常规的差不多。</p>\n\n<pre><code>var iframe = document.createElement('iframe');  \ndocument.body.appendChild(iframe);  \nvar doc = iframe.contentWindow.document;  \ndoc.open().write('&lt;body onload=\"insertJS()\"&gt;');  \ndoc.close();  \n</code></pre>\n\n<h4 id=\"\">延迟执行</h4>\n\n<p>不管是同步加载还是异步加载，其执行都是同步的。而这个阶段也是会造成阻塞的，而事实上有一部分脚本我们是不需要立即执行的（比如只是在展示某个界面或执行某个操作时才需要）。这些 script 可以延迟执行，先异步下载缓存起来，但不立即执行，而是在第一次需要的时候执行一次。\n利用特殊的技巧可以做到下载与执行的分离。比如将 js 的内容作为 Image或 object 对象加载缓存起来，所以就不会立即执行了，然后在第一次需要的时候再执行。</p>\n\n<h4 id=\"cmd\">cmd 的 异步加载和延迟执行</h4>\n\n<p>对于模块化的前端组织来说，单纯的异步加载是不能够满足需求的，而要考虑模块之间的依赖关系。并且配合延迟执行，可以比较好地提升页面加载阶段的性能。这一节就将针对 seajs 的实现进行一些分析。（虽然 seajs 作者也承认已死，但是作为 js 模块化历史上一个重要的过渡角色，还是可以研究一下的。）</p>\n\n<p>看了两天终于可以来填坑了。首先看 seajs 异步加载的方案。</p>\n\n<pre><code>var head = doc.head || doc.getElementsByTagName(\"head\")[0] || doc.documentElement  \nvar baseElement = head.getElementsByTagName(\"base\")[0]\n\nvar currentlyAddingScript  \nvar interactiveScript\n\n// 创建 script 标签发出异步请求\nfunction request(url, callback, charset) {  \n  var node = doc.createElement(\"script\")\n\n  // 设置编码，默认为 utf-8\n  if (charset) {\n    var cs = isFunction(charset) ? charset(url) : charset\n    if (cs) {\n      node.charset = cs\n    }\n  }\n\n  // 为 script node 添加 onload 事件\n  addOnload(node, callback, url)\n\n  node.async = true\n  node.src = url\n\n  // For some cache cases in IE 6-8, the script executes IMMEDIATELY after\n  // the end of the insert execution, so use `currentlyAddingScript` to\n  // hold current node, for deriving url in `define` call\n  currentlyAddingScript = node\n\n  // 后加载的 js 被插在了 head 的最前边，这样会导致 X-UA-Compatible 失效\n  // 所以不存在 base 时使用 appendChild\n  // ref: #185 &amp; http://dev.jquery.com/ticket/2709\n  baseElement ?\n      head.insertBefore(node, baseElement) :\n      head.appendChild(node)\n\n  currentlyAddingScript = null\n}\n\n// 检测是否支持 onload\n// 不支持使用 onreadystatechange 代替\nfunction addOnload(node, callback, url) {  \n  var supportOnload = \"onload\" in node\n\n  if (supportOnload) {\n    node.onload = onload\n    node.onerror = function() {\n      emit(\"error\", { uri: url, node: node })\n      onload()\n    }\n  }\n  else {\n    node.onreadystatechange = function() {\n      if (/loaded|complete/.test(node.readyState)) {\n        onload()\n      }\n    }\n  }\n\n  function onload() {\n    // 确保只执行一次，处理 IE 的内存泄漏\n    node.onload = node.onerror = node.onreadystatechange = null\n\n    // 移除 script 减少内存泄露，因为模块以及被缓存在变量中，所以为了不立即执行代码，会在 onload 时就把 node 移除掉。\n    if (!data.debug) {\n      head.removeChild(node)\n    }\n\n    // 删除 node 引用\n    node = null\n\n    callback()\n  }\n}\n</code></pre>\n\n<p>上面是每次 seajs 模块加载依赖的时候都会进行调用的函数，做法和我们上面提到的一样，是创建 <code>&lt;script&gt;</code>。不过为了管理依赖，它内部创建 <code>&lt;script&gt;</code> 会根据依赖的关系按次序进行，执行回调也会考虑到依赖是否被加载。另外值得注意的是，它在 onload 之后便把 node 移除了，因为这个模块已经被缓存起来了。针对没有 onload 事件的 IE6-8，它使用了 <code>onreadystatechange</code> 事件来进行兼容。</p>\n\n<p>那么延迟执行是怎么做的呢！其实 node 在 onload 之前已经执行了，只不过执行的是模块的 <code>define</code> 方法，而方法的回调会在入口模块加载完毕的 <code>onload</code> 方法或者是执行过程中的 <code>require</code> 中被调用。因此保证了执行是在真正用到的时候。这就是 seajs 的延迟执行。</p>\n\n<pre><code>// Use function is equal to load a anonymous module\n// 加载一个匿名模块\nModule.use = function (ids, callback, uri) {  \n  // 从缓存取中或新建加入缓存\n  var mod = Module.get(uri, isArray(ids) ? ids : [ids])\n\n  // 这个 callback 会在 Module.onload 中调用\n  mod.callback = function() {\n    var exports = []\n    var uris = mod.resolve()\n\n    for (var i = 0, len = uris.length; i &lt; len; i++) {\n      // 将依赖的模块执行\n      exports[i] = cachedMods[uris[i]].exec()\n    }\n\n    if (callback) {\n      callback.apply(global, exports)\n    }\n\n    delete mod.callback\n  }\n\n  // 无需物理抓取直接加载这个模块\n  mod.load()\n}\n</code></pre>\n\n<p>完整的源码注释可以看<a href=\"http://git.oschina.net/m2mbob/seajs-annotation\">seajs 源码注释</a></p>\n\n<h4 id=\"\">最佳实践</h4>\n\n<ol>\n<li>对于需要在脚本内进行 <code>document.write</code> 的 js，放在 <code>&lt;/body&gt;</code> 前同步加载（尽量少用 <code>document.write</code> ）；  </li>\n<li>其它的，如果 js 没有依赖关系，可以使用 async + defer 的方式，比较简单；  </li>\n<li>简单系统的依赖关系，可以手动按顺序放在 <code>&lt;/body&gt;</code> 前同步加载；  </li>\n<li>复杂系统存在模块间复杂的依赖关系，则需要 requirejs、seajs、webpack 等工具来进行模块加载。</li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475724877792,"created_by":1,"updated_at":1475987539630,"updated_by":1,"published_at":1475737401657,"published_by":1},{"id":106,"uuid":"d6f1a7ed-9f5f-4792-9344-22e930f4a9c1","title":"es6 温故第三天小结","slug":"es6-wen-gu-di-san-tian-xiao-jie","markdown":"源码看得头疼，虽然有些进展，但还是先缓一缓，看两章 《es6入门》 放松一下。\n\n#### 数组扩展\n\n##### 静态方法\n\n###### `Array.from`\n\n第一个参数：\n\n- 类似数组的对象（array-like object）。\n- 可遍历（iterable）的对象（包括ES6新增的数据结构 `Set` 和 `Map`）。\n- 数组原样返回。\n\n类数组对象：（下面是 underscore 1.8.3 中判断类数组对象的源码）\n\n```\n// Math.pow(2, 53) - 1 是 JavaScript 中能精确表示的最大数字\n// 但是数组索引明确规定是 32 位整数，underscore 这里的实现有待商榷\nvar MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n// getLength 函数\n// 该函数传入一个参数，返回参数的 length 属性值\n// 用来获取 array 以及 arrayLike 元素的 length 属性值\nvar getLength = property('length');\n\n// 判断是否是 ArrayLike Object\n// 类数组，即拥有 length 属性并且 length 属性值为 Number 类型的元素\n// 包括数组、arguments、HTML Collection 以及 NodeList 等等\n// 包括类似 {length: 10} 这样的对象\n// 包括字符串、函数等\nvar isArrayLike = function(collection) {\n  // 返回参数 collection 的 length 属性值\n  var length = getLength(collection);\n  return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n};\n```\n\n通过的注释，对于类数组对象应该比较清楚了。\n\n可遍历（iterable）的对象，就是部署了 Iterator 接口 的对象。在介绍 Iterator 时会详细写。现在只要知道 `Set`、`Map`、`Generator` 等都是就可以了。\n\n> 扩展运算符（...）：也可以将某些数据结构转为数组。扩展运算符背后调用的是遍历器接口（`Symbol.iterator`），如果一个对象没有部署这个接口，就无法转换。\n\n第二个参数：\n\n`Array.from` 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\n\n```\nArray.from(arrayLike, x => x * x);\n// 等同于\nArray.from(arrayLike).map(x => x * x);\n\nArray.from([1, 2, 3], (x) => x * x)\n// [1, 4, 9]\n```\n\n第三个参数：\n\n绑定 `this`。\n\n应用：\n\n- `Array.from()` 可以将各种值转为真正的数组，并且还提供 map 功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。\n- `Array.from()` 的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 unicode 字符，可以避免 js 将大于 \\uFFFF 的 unicode 字符，算作两个字符的 bug。\n\n###### `Array.of`\n\n前面 [js Array 对象](https://m2mbob.cn/2016/09/27/js-array-dui-xiang/) 一文讲到 Array 构造器在处理一个参数和多个参数时采用了不同的策略。\n\n`Array.of` 便是用来弥补数组构造函数 `Array()` 的这种不足。行为非常统一。\n\n`Array.of` 方法可以用下面的代码模拟实现。\n\n```\nfunction ArrayOf(){\n  return [].slice.call(arguments);\n}\n```\n\n##### 实例方法\n\n- `copyWithin(target, start, end)`\n - target（必需）：从该位置开始替换数据。\n - start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。\n - end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。\n- `find(cb(value,index,arr),this)`：它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。\n- `findIndex(cb(value,index,arr),this)`：与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。\n- `fill(value,start,end)`：使用给定值，填充一个数组。\n- `entries()`、`keys()`、`values()`：用于遍历数组。\n- `includes()`：该方法属于ES7。返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。\n\n> 补充：`find()` 和 `findIndex()` 都可以发现 `NaN` ，弥补了数组的 `IndexOf` 方法的不足。\n\n```\n[NaN].indexOf(NaN)\n// -1\n\n[NaN].findIndex(y => Object.is(NaN, y))\n// 0\n```\n\n##### 数组空位\n\n空位不是 `undefined`：\n\n```\n0 in [undefined, undefined, undefined] // true\n0 in [, , ,] // false\n```\n\nes5 对空位的处理，很不一致，大多数情况下会忽略空位。\n\n- `forEach()`, `filter()`, `every()` 和 `some()` 都会跳过空位。\n- `map()` 会跳过空位，但会保留这个值\n- `join()` 和 `toString()` 会将空位视为 `undefined`，而`undefined` 和 `null` 会被处理成空字符串。\n\nes6 明确将空位转为 `undefined`。上面提到的扩展方法都会以 `undefined` 处理空位。\n\n但是考虑到 es5 的不一致情况，尽量少出现空位。\n\n#### 对象的扩展\n\n##### 属性简写\n\n- es6 允许在对象之中，只写属性名，不写属性值。这时，属性值等于属性名所代表的变量。\n- 除了属性简写，方法也可以简写。\n- 用于函数返回和模块导出十分方便。\n- 简洁写法的属性名总是字符串，`'class'` 这种在解析时也不会报错，但是不推荐。\n- generator 函数，前面需要加上星号。\n\n> 属性名表达式与简洁表示法，不能同时使用，会报错。\n\n```\n// 报错\nvar foo = 'bar';\nvar bar = 'abc';\nvar baz = { [foo] };\n\n// 正确\nvar foo = 'bar';\nvar baz = { [foo]: 'abc'};\n```\n\n##### 方法的 name 属性\n\n这应该不算是 es6 的内容，但是既然书上写到了，也就记一下：\n\n- 方法的name属性返回函数名（即方法名）。\n- 如果使用了取值函数，则会在方法名前加上get。\n- 如果是存值函数，方法名的前面会加上set。\n- bind方法创造的函数，name属性返回“bound”加上原函数的名字。\n- Function构造函数创造的函数，name属性返回“anonymous”。\n- 如果对象的方法是一个Symbol值，那么name属性返回的是这个Symbol值的描述。\n\n##### 静态方法\n\n###### `Object.is()`\n\nJavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。`===` 在处理 `NaN` 和正负零时存在问题。`Object.is()`的算法修复了这两个问题。\n\n- `Object.is(NaN,NaN) === true`\n- `Object.is(+0,-0) === false`\n\n###### `Object.assign()`\n\n`Object.assign` 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。注意点：\n\n- 只拷贝自身可枚举属性。\n- 同名属性后面的覆盖前面的。\n- 参数会被转成对象，首参数无法转成对象会报错，后面的源参数无法转成对象会忽略。\n- 布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性 `[[PrimitiveValue]]` 上面，这个属性是不会被 `Object.assign` 拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。\n- 浅拷贝，得到的是对象的引用。\n- 可以用来处理数组，但是会把数组视为对象。\n\n> 有一些函数库提供 `Object.assign` 的定制版本（比如 Lodash 的 `_.defaultsDeep` 方法），可以解决浅拷贝的问题，得到深拷贝的合并。\n\n###### `Object.setPrototypeOf` 和 `Object.getPrototypeOf`\n\n设置和获取原型。因为直接操作 `__proto__` 这个内部属性不是一个明智的选择。\n\n> `__proto__` 在 IE 10 以后才支持，其他现代浏览器都部署了这个属性。该属性没有写入 es6 的正文，而是写入了附录，原因是 `__proto__` 前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的API，只是由于浏览器广泛支持，才被加入了 es6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的`Object.setPrototypeOf()`（写操作）、`Object.getPrototypeOf()`（读操作）、`Object.create()`（生成操作）代替。\n\n###### `Object.values()`，`Object.entries()`\n\n不是 es6 的，目前还只是一个提案。主要是配套 `Object.keys`。\n\n###### `Object.getOwnPropertyDescriptors` \n\n同样是一个提案，提出了 `Object.getOwnPropertyDescriptors` 方法，返回指定对象所有自身属性（非继承属性）的描述对象。\n\n该方法的提出目的，主要是为了解决 `Object.assign()` 无法正确拷贝 `get` 属性和 `set` 属性的问题。\n\n##### 可枚举属性\n\n看过前面文章的同学应该都知道属性表述符，不管是命名数据属性还是命名的访问器属性都有 `[[Enumerable]]` 特性，用来描述属性是否可以被枚举。\n\nes5 有三个操作会忽略 `[[Enumerable]]` 为 false 的属性：\n\n- `for...in`循环：只遍历对象自身的和继承的可枚举的属性\n- `Object.keys()`：返回对象自身的所有可枚举的属性的键名\n- `JSON.stringify()`：只串行化对象自身的可枚举的属性\n\n上面讲的 `Object.assign()` 是一个新的会忽略 `[[Enumerable]]` 为 false 的操作。另外 es6 规定，所有 Class 的原型的方法都是不可枚举的。\n\n##### 属性的遍历\n\n- `for...in`：包含自身和继承的可枚举非 Symbol 属性。\n- `Object.keys()`：包含自身非继承的可枚举非 Symbol 属性。\n- `Object.getOwnPropertyNames()`：包含自身所有非 Symbol 属性。\n- `Object.getOwnPropertySymbols()`：包含自身所有 Symbol 属性。\n- `Reflect.ownKeys(obj)`：包含自身所有属性。\n\n##### 对象的扩展运算符\n\n目前，es7 有一个提案，将 rest运算符（解构赋值）/扩展运算符（...）引入对象。\n\n###### 结构赋值\n\n对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。\n\n```\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nx // 1\ny // 2\nz // { a: 3, b: 4 }\n```\n\n###### 扩展运算符\n\n可 `Object.assign()` 的表现和作用基本相同，但是看起来更简洁。`babel` 转码扩展运算符时使用的就是 `Object.assign()`，因此也不能很好地解决 `get` 和 `set` 的问题。\n","html":"<p>源码看得头疼，虽然有些进展，但还是先缓一缓，看两章 《es6入门》 放松一下。</p>\n\n<h4 id=\"\">数组扩展</h4>\n\n<h5 id=\"\">静态方法</h5>\n\n<h6 id=\"arrayfrom\"><code>Array.from</code></h6>\n\n<p>第一个参数：</p>\n\n<ul>\n<li>类似数组的对象（array-like object）。</li>\n<li>可遍历（iterable）的对象（包括ES6新增的数据结构 <code>Set</code> 和 <code>Map</code>）。</li>\n<li>数组原样返回。</li>\n</ul>\n\n<p>类数组对象：（下面是 underscore 1.8.3 中判断类数组对象的源码）</p>\n\n<pre><code>// Math.pow(2, 53) - 1 是 JavaScript 中能精确表示的最大数字\n// 但是数组索引明确规定是 32 位整数，underscore 这里的实现有待商榷\nvar MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n// getLength 函数\n// 该函数传入一个参数，返回参数的 length 属性值\n// 用来获取 array 以及 arrayLike 元素的 length 属性值\nvar getLength = property('length');\n\n// 判断是否是 ArrayLike Object\n// 类数组，即拥有 length 属性并且 length 属性值为 Number 类型的元素\n// 包括数组、arguments、HTML Collection 以及 NodeList 等等\n// 包括类似 {length: 10} 这样的对象\n// 包括字符串、函数等\nvar isArrayLike = function(collection) {  \n  // 返回参数 collection 的 length 属性值\n  var length = getLength(collection);\n  return typeof length == 'number' &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;\n};\n</code></pre>\n\n<p>通过的注释，对于类数组对象应该比较清楚了。</p>\n\n<p>可遍历（iterable）的对象，就是部署了 Iterator 接口 的对象。在介绍 Iterator 时会详细写。现在只要知道 <code>Set</code>、<code>Map</code>、<code>Generator</code> 等都是就可以了。</p>\n\n<blockquote>\n  <p>扩展运算符（...）：也可以将某些数据结构转为数组。扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。</p>\n</blockquote>\n\n<p>第二个参数：</p>\n\n<p><code>Array.from</code> 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>\n\n<pre><code>Array.from(arrayLike, x =&gt; x * x);  \n// 等同于\nArray.from(arrayLike).map(x =&gt; x * x);\n\nArray.from([1, 2, 3], (x) =&gt; x * x)  \n// [1, 4, 9]\n</code></pre>\n\n<p>第三个参数：</p>\n\n<p>绑定 <code>this</code>。</p>\n\n<p>应用：</p>\n\n<ul>\n<li><code>Array.from()</code> 可以将各种值转为真正的数组，并且还提供 map 功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</li>\n<li><code>Array.from()</code> 的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 unicode 字符，可以避免 js 将大于 \\uFFFF 的 unicode 字符，算作两个字符的 bug。</li>\n</ul>\n\n<h6 id=\"arrayof\"><code>Array.of</code></h6>\n\n<p>前面 <a href=\"https://m2mbob.cn/2016/09/27/js-array-dui-xiang/\">js Array 对象</a> 一文讲到 Array 构造器在处理一个参数和多个参数时采用了不同的策略。</p>\n\n<p><code>Array.of</code> 便是用来弥补数组构造函数 <code>Array()</code> 的这种不足。行为非常统一。</p>\n\n<p><code>Array.of</code> 方法可以用下面的代码模拟实现。</p>\n\n<pre><code>function ArrayOf(){  \n  return [].slice.call(arguments);\n}\n</code></pre>\n\n<h5 id=\"\">实例方法</h5>\n\n<ul>\n<li><code>copyWithin(target, start, end)</code>\n<ul><li>target（必需）：从该位置开始替换数据。</li>\n<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>\n<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li></ul></li>\n<li><code>find(cb(value,index,arr),this)</code>：它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</li>\n<li><code>findIndex(cb(value,index,arr),this)</code>：与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</li>\n<li><code>fill(value,start,end)</code>：使用给定值，填充一个数组。</li>\n<li><code>entries()</code>、<code>keys()</code>、<code>values()</code>：用于遍历数组。</li>\n<li><code>includes()</code>：该方法属于ES7。返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</li>\n</ul>\n\n<blockquote>\n  <p>补充：<code>find()</code> 和 <code>findIndex()</code> 都可以发现 <code>NaN</code> ，弥补了数组的 <code>IndexOf</code> 方法的不足。</p>\n</blockquote>\n\n<pre><code>[NaN].indexOf(NaN)\n// -1\n\n[NaN].findIndex(y =&gt; Object.is(NaN, y))\n// 0\n</code></pre>\n\n<h5 id=\"\">数组空位</h5>\n\n<p>空位不是 <code>undefined</code>：</p>\n\n<pre><code>0 in [undefined, undefined, undefined] // true  \n0 in [, , ,] // false  \n</code></pre>\n\n<p>es5 对空位的处理，很不一致，大多数情况下会忽略空位。</p>\n\n<ul>\n<li><code>forEach()</code>, <code>filter()</code>, <code>every()</code> 和 <code>some()</code> 都会跳过空位。</li>\n<li><code>map()</code> 会跳过空位，但会保留这个值</li>\n<li><code>join()</code> 和 <code>toString()</code> 会将空位视为 <code>undefined</code>，而<code>undefined</code> 和 <code>null</code> 会被处理成空字符串。</li>\n</ul>\n\n<p>es6 明确将空位转为 <code>undefined</code>。上面提到的扩展方法都会以 <code>undefined</code> 处理空位。</p>\n\n<p>但是考虑到 es5 的不一致情况，尽量少出现空位。</p>\n\n<h4 id=\"\">对象的扩展</h4>\n\n<h5 id=\"\">属性简写</h5>\n\n<ul>\n<li>es6 允许在对象之中，只写属性名，不写属性值。这时，属性值等于属性名所代表的变量。</li>\n<li>除了属性简写，方法也可以简写。</li>\n<li>用于函数返回和模块导出十分方便。</li>\n<li>简洁写法的属性名总是字符串，<code>'class'</code> 这种在解析时也不会报错，但是不推荐。</li>\n<li>generator 函数，前面需要加上星号。</li>\n</ul>\n\n<blockquote>\n  <p>属性名表达式与简洁表示法，不能同时使用，会报错。</p>\n</blockquote>\n\n<pre><code>// 报错\nvar foo = 'bar';  \nvar bar = 'abc';  \nvar baz = { [foo] };\n\n// 正确\nvar foo = 'bar';  \nvar baz = { [foo]: 'abc'};  \n</code></pre>\n\n<h5 id=\"name\">方法的 name 属性</h5>\n\n<p>这应该不算是 es6 的内容，但是既然书上写到了，也就记一下：</p>\n\n<ul>\n<li>方法的name属性返回函数名（即方法名）。</li>\n<li>如果使用了取值函数，则会在方法名前加上get。</li>\n<li>如果是存值函数，方法名的前面会加上set。</li>\n<li>bind方法创造的函数，name属性返回“bound”加上原函数的名字。</li>\n<li>Function构造函数创造的函数，name属性返回“anonymous”。</li>\n<li>如果对象的方法是一个Symbol值，那么name属性返回的是这个Symbol值的描述。</li>\n</ul>\n\n<h5 id=\"\">静态方法</h5>\n\n<h6 id=\"objectis\"><code>Object.is()</code></h6>\n\n<p>JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。<code>===</code> 在处理 <code>NaN</code> 和正负零时存在问题。<code>Object.is()</code>的算法修复了这两个问题。</p>\n\n<ul>\n<li><code>Object.is(NaN,NaN) === true</code></li>\n<li><code>Object.is(+0,-0) === false</code></li>\n</ul>\n\n<h6 id=\"objectassign\"><code>Object.assign()</code></h6>\n\n<p><code>Object.assign</code> 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。注意点：</p>\n\n<ul>\n<li>只拷贝自身可枚举属性。</li>\n<li>同名属性后面的覆盖前面的。</li>\n<li>参数会被转成对象，首参数无法转成对象会报错，后面的源参数无法转成对象会忽略。</li>\n<li>布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性 <code>[[PrimitiveValue]]</code> 上面，这个属性是不会被 <code>Object.assign</code> 拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</li>\n<li>浅拷贝，得到的是对象的引用。</li>\n<li>可以用来处理数组，但是会把数组视为对象。</li>\n</ul>\n\n<blockquote>\n  <p>有一些函数库提供 <code>Object.assign</code> 的定制版本（比如 Lodash 的 <code>_.defaultsDeep</code> 方法），可以解决浅拷贝的问题，得到深拷贝的合并。</p>\n</blockquote>\n\n<h6 id=\"objectsetprototypeofobjectgetprototypeof\"><code>Object.setPrototypeOf</code> 和 <code>Object.getPrototypeOf</code></h6>\n\n<p>设置和获取原型。因为直接操作 <code>__proto__</code> 这个内部属性不是一个明智的选择。</p>\n\n<blockquote>\n  <p><code>__proto__</code> 在 IE 10 以后才支持，其他现代浏览器都部署了这个属性。该属性没有写入 es6 的正文，而是写入了附录，原因是 <code>__proto__</code> 前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的API，只是由于浏览器广泛支持，才被加入了 es6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>\n</blockquote>\n\n<h6 id=\"objectvaluesobjectentries\"><code>Object.values()</code>，<code>Object.entries()</code></h6>\n\n<p>不是 es6 的，目前还只是一个提案。主要是配套 <code>Object.keys</code>。</p>\n\n<h6 id=\"objectgetownpropertydescriptors\"><code>Object.getOwnPropertyDescriptors</code></h6>\n\n<p>同样是一个提案，提出了 <code>Object.getOwnPropertyDescriptors</code> 方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>\n\n<p>该方法的提出目的，主要是为了解决 <code>Object.assign()</code> 无法正确拷贝 <code>get</code> 属性和 <code>set</code> 属性的问题。</p>\n\n<h5 id=\"\">可枚举属性</h5>\n\n<p>看过前面文章的同学应该都知道属性表述符，不管是命名数据属性还是命名的访问器属性都有 <code>[[Enumerable]]</code> 特性，用来描述属性是否可以被枚举。</p>\n\n<p>es5 有三个操作会忽略 <code>[[Enumerable]]</code> 为 false 的属性：</p>\n\n<ul>\n<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性</li>\n<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名</li>\n<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性</li>\n</ul>\n\n<p>上面讲的 <code>Object.assign()</code> 是一个新的会忽略 <code>[[Enumerable]]</code> 为 false 的操作。另外 es6 规定，所有 Class 的原型的方法都是不可枚举的。</p>\n\n<h5 id=\"\">属性的遍历</h5>\n\n<ul>\n<li><code>for...in</code>：包含自身和继承的可枚举非 Symbol 属性。</li>\n<li><code>Object.keys()</code>：包含自身非继承的可枚举非 Symbol 属性。</li>\n<li><code>Object.getOwnPropertyNames()</code>：包含自身所有非 Symbol 属性。</li>\n<li><code>Object.getOwnPropertySymbols()</code>：包含自身所有 Symbol 属性。</li>\n<li><code>Reflect.ownKeys(obj)</code>：包含自身所有属性。</li>\n</ul>\n\n<h5 id=\"\">对象的扩展运算符</h5>\n\n<p>目前，es7 有一个提案，将 rest运算符（解构赋值）/扩展运算符（...）引入对象。</p>\n\n<h6 id=\"\">结构赋值</h6>\n\n<p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>\n\n<pre><code>let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };  \nx // 1  \ny // 2  \nz // { a: 3, b: 4 }  \n</code></pre>\n\n<h6 id=\"\">扩展运算符</h6>\n\n<p>可 <code>Object.assign()</code> 的表现和作用基本相同，但是看起来更简洁。<code>babel</code> 转码扩展运算符时使用的就是 <code>Object.assign()</code>，因此也不能很好地解决 <code>get</code> 和 <code>set</code> 的问题。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475805222652,"created_by":1,"updated_at":1475822884884,"updated_by":1,"published_at":1475809526540,"published_by":1},{"id":107,"uuid":"bfa9d3b5-de03-4f45-9bcd-b19fc106ac9d","title":"React Native 0.32 以下版本 Xcode8 报错解决办法","slug":"sheng-ji-xcode8-hou-rn-xiang-mu-bao-cuo-jie-jue-fang-an","markdown":"今天中午吃饭收到消息说之前的 rn 项目要改，晚上抽了个空看看，发现跑不起来了。显然是 Xcode8 的问题，于是去中文社区找到了解决方案，在此记一下。[原文](http://bbs.reactnative.cn/topic/2595/react-native-0-32%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%ACxcode8%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95)\n\n###### RCTSRWEBSOCKET.M报错\n\n> Ignoring return value of function declared with warn_unused_result attribute\n\n这个报错在此文件中有两处，代码：\n\n```\nSecRandomCopyBytes(kSecRandomDefault, sizeof(uint32_t), (uint8_t *)mask_key);\n```\n\n修改为\n\n```\n(void)SecRandomCopyBytes(kSecRandomDefault, sizeof(uint32_t), (uint8_t *)mask_key);\n```\n\n前面加上(void)。\n\n###### RCTSCROLLVIEW.M 报错\n\n> Use of undeclared identifier '_refreshControl'; did you mean 'refreshControl'?\n\n```\n@implementation RCTCustomScrollView\n{\n  __weak UIView *_dockedHeaderView;\n  RCTRefreshControl *_refreshControl;  // 加入此行\n}\n```\n\n","html":"<p>今天中午吃饭收到消息说之前的 rn 项目要改，晚上抽了个空看看，发现跑不起来了。显然是 Xcode8 的问题，于是去中文社区找到了解决方案，在此记一下。<a href=\"http://bbs.reactnative.cn/topic/2595/react-native-0-32%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%ACxcode8%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\">原文</a></p>\n\n<h6 id=\"rctsrwebsocketm\">RCTSRWEBSOCKET.M报错</h6>\n\n<blockquote>\n  <p>Ignoring return value of function declared with warn<em>unused</em>result attribute</p>\n</blockquote>\n\n<p>这个报错在此文件中有两处，代码：</p>\n\n<pre><code>SecRandomCopyBytes(kSecRandomDefault, sizeof(uint32_t), (uint8_t *)mask_key);  \n</code></pre>\n\n<p>修改为</p>\n\n<pre><code>(void)SecRandomCopyBytes(kSecRandomDefault, sizeof(uint32_t), (uint8_t *)mask_key);\n</code></pre>\n\n<p>前面加上(void)。</p>\n\n<h6 id=\"rctscrollviewm\">RCTSCROLLVIEW.M 报错</h6>\n\n<blockquote>\n  <p>Use of undeclared identifier '_refreshControl'; did you mean 'refreshControl'?</p>\n</blockquote>\n\n<pre><code>@implementation RCTCustomScrollView\n{\n  __weak UIView *_dockedHeaderView;\n  RCTRefreshControl *_refreshControl;  // 加入此行\n}\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475927695238,"created_by":1,"updated_at":1475928134833,"updated_by":1,"published_at":1475928051510,"published_by":1},{"id":108,"uuid":"b051cfbf-bb51-43bc-a287-92cab2a5787e","title":"欢迎来到阴阳屋","slug":"huan-ying-lai-dao-yin-yang-wu","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=28147624&auto=1&height=66\"></iframe>\n\n最近好像手游《阴阳师》很火，看室友和同学都在玩，还整天抱怨“垃圾游戏，毁我青春，耗我钱财”什么的。\n\n前几天找剧便想到了 66 好像演过一部和阴阳师有关的剧，于是查了一下，就是这部《欢迎来到阴阳屋》，就是每天看一两集看完了。一开始感觉和 66 的《武士老师》有些像，不过后面感觉更有一种《深夜食堂》的感觉。\n\n阴阳师是什么？这部剧给出了新的定义，或者说在这个世代的定义。在这个世代的阴阳师是破除人心中的鬼祟，让人回归幸福的职业。主要的技能就是洞察人心，其余的仪式其实只能算作是一种幌子。\n\n说实话我更喜欢这种形式的阴阳师。剧也是完全按这个套路来的，每一集都会让阴阳师来解决一个个更像是家事的问题，有点像老娘舅。只不过编剧所塑造的阴阳师，太会洞察人心，当然周围人的单纯也衬托地很好。每个故事也能能够以一种无比温暖的方式解决。\n\n解决之后，一群人坐在居酒屋，聊聊商店街的八卦，真是让人羡慕。整部剧也是以这样的氛围，让人看完了。\n\n虽说有些故事，如弹幕所说是日剧的尿性，但是也不妨碍这是部值得一看的好剧。为了突出阴阳师，对于其余人的刻画也有些那个，但是每个人都是有血有肉，不对应该是有情的。\n\n是的有情，人情味。我想这是给我的最大的惊喜吧！本以为要看到的是妖魔鬼怪，而实际看到的是浓浓的人情味！\n\n突然想起来室友之前的游戏昵称就叫“人情味000”！是不是他也想表达什么！\n\n不过对于人情味也没什么好抱怨的，毕竟我们自己本身付出的就不够，还有很多能够做的。这是个相互的东西。\n\n最后就是剧照了哈哈：\n\n想吃小双😳\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f8lu2ijojrj30g40923yy.jpg)\n\n笑死了😂\n\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f8lu2lgb7sj30zk0k045z.jpg)\n\n终于看到三井同学了，果然很美😍\n\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f8lu2lg2sij30zk0k07cs.jpg)\n\n自带集数的小哥😅\n\n![](https://ws1.sinaimg.cn/large/006bH5BKgw1f8lu64yu5dj30c60itgmd.jpg)\n\n\n","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=28147624&auto=1&height=66\"></iframe>\n\n<p>最近好像手游《阴阳师》很火，看室友和同学都在玩，还整天抱怨“垃圾游戏，毁我青春，耗我钱财”什么的。</p>\n\n<p>前几天找剧便想到了 66 好像演过一部和阴阳师有关的剧，于是查了一下，就是这部《欢迎来到阴阳屋》，就是每天看一两集看完了。一开始感觉和 66 的《武士老师》有些像，不过后面感觉更有一种《深夜食堂》的感觉。</p>\n\n<p>阴阳师是什么？这部剧给出了新的定义，或者说在这个世代的定义。在这个世代的阴阳师是破除人心中的鬼祟，让人回归幸福的职业。主要的技能就是洞察人心，其余的仪式其实只能算作是一种幌子。</p>\n\n<p>说实话我更喜欢这种形式的阴阳师。剧也是完全按这个套路来的，每一集都会让阴阳师来解决一个个更像是家事的问题，有点像老娘舅。只不过编剧所塑造的阴阳师，太会洞察人心，当然周围人的单纯也衬托地很好。每个故事也能能够以一种无比温暖的方式解决。</p>\n\n<p>解决之后，一群人坐在居酒屋，聊聊商店街的八卦，真是让人羡慕。整部剧也是以这样的氛围，让人看完了。</p>\n\n<p>虽说有些故事，如弹幕所说是日剧的尿性，但是也不妨碍这是部值得一看的好剧。为了突出阴阳师，对于其余人的刻画也有些那个，但是每个人都是有血有肉，不对应该是有情的。</p>\n\n<p>是的有情，人情味。我想这是给我的最大的惊喜吧！本以为要看到的是妖魔鬼怪，而实际看到的是浓浓的人情味！</p>\n\n<p>突然想起来室友之前的游戏昵称就叫“人情味000”！是不是他也想表达什么！</p>\n\n<p>不过对于人情味也没什么好抱怨的，毕竟我们自己本身付出的就不够，还有很多能够做的。这是个相互的东西。</p>\n\n<p>最后就是剧照了哈哈：</p>\n\n<p>想吃小双😳</p>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f8lu2ijojrj30g40923yy.jpg\" alt=\"\" /></p>\n\n<p>笑死了😂</p>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f8lu2lgb7sj30zk0k045z.jpg\" alt=\"\" /></p>\n\n<p>终于看到三井同学了，果然很美😍</p>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f8lu2lg2sij30zk0k07cs.jpg\" alt=\"\" /></p>\n\n<p>自带集数的小哥😅</p>\n\n<p><img src=\"https://ws1.sinaimg.cn/large/006bH5BKgw1f8lu64yu5dj30c60itgmd.jpg\" alt=\"\" /></p>","image":"/content/images/2016/10/2082785-1475851669.png","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475971824131,"created_by":1,"updated_at":1475987427016,"updated_by":1,"published_at":1475982270350,"published_by":1},{"id":109,"uuid":"c3c6b9d2-3f0b-4dae-a790-75ef0b532d7b","title":"es6 温故第四天小结","slug":"es6-wen-gu-di-si-tian-xiao-jie","markdown":"#### 函数扩展\n\n###### 默认参数\n\n- 代替 `x || default value` 的写法。\n- 不能用 `let` 和 `const` 再次声明。\n- 与结构赋值默认值一起使用，不过容易两个容易混淆，建议不用。\n- 默认参数必须是尾参数，否则无法只省略该参数，必须显式地传入 `undefined`。\n- 默认的参数不会计入函数的 `length` 中。如果设置了默认值的参数不是尾参数，那么 `length` 属性也不再计入后面的参数了。所以最佳的策略就是把默认参数写在尾部。\n- 默认值可以是变量，但是这个变量必须在作用域链上能够找到。\n- 默认值是函数，作用域是其声明时所在的作用域。当前函数作用域还没有形成，所以和当前函数的外部作用域是同一个。这与 es5.1 是冲突的，需要看看 es6 标准。\n\n> 猜测默认参数和 `let`、`const` 一样是定义在词法环境上的，而不是变量环境。而普通参数是定义在变量环境上的。待检验。\n\n应用：\n\n利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。\n\n```\nfunction throwIfMissing() {\n  throw new Error('Missing parameter');\n}\n\nfunction foo(mustBeProvided = throwIfMissing()) {\n  return mustBeProvided;\n}\n\nfoo()\n// Error: Missing parameter\n// 这表明参数的默认值不是在定义时执行，而是在运行时执行（即如果参数已经赋值，默认值中的函数就不会运行）\n```\n\n另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。\n\n```\nfunction foo(optional = undefined) { ··· }\n```\n\n###### rest 参数\n\n把剩余的参数放入一个数组，可以用来代替 `arguments` 对象：\n\n```\n// arguments变量的写法\nfunction sortNumbers() {\n  return Array.prototype.slice.call(arguments).sort();\n}\n\n// rest参数的写法\nconst sortNumbers = (...numbers) => numbers.sort();\n```\n\n> 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。`length` 也不会包括 rest 参数。\n\n###### 扩展运算符\n\n这与之前讲的对象扩展运算符类似，但是这是已经进入 es6 标准了的。它的作用好比 rest 运算符的逆运算。它会把数组展开成一个个元素。\n\n```\nfunction add(x, y) {\n  return x + y;\n}\n\nvar numbers = [4, 38];\nadd(...numbers) // 42\n```\n\n应用：\n\n- 替代 `apply`，因为部分方法只接受参数列表不接受数组作为参数，因此需要使用 `apply` 来支持数组形式的参数。`...` 能够展开数组成参数列表，因此可以替代，写法简洁。\n- 合并数组，`[...arr1,...arr2]`。\n- 解构赋值，`[first, ...rest] = [1, 2, 3, 4, 5]`。\n- 字符串转数组，支持 unicode。\n- 任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。\n\n###### 箭头函数\n\n这应该是平时用得比较多的了。主要看一下注意点：\n\n- 函数体内的 `this` 对象，就是定义时所在的对象，而不是使用时所在的对象。\n- 不可以当作构造函数，也就是说，不可以使用 `new` 命令，否则会抛出一个错误。\n- 不可以使用 `arguments` 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n- 不可以使用 `yield` 命令，因此箭头函数不能用作 generator 函数。\n\n主要要讲一下 `this`，下面是 babel 的转码：\n\n```\n// ES6\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\n// ES5\nfunction foo() {\n  var _this = this;\n\n  setTimeout(function () {\n    console.log('id:', _this.id);\n  }, 100);\n}\n```\n\n可以看到箭头函数转码后并不会使用自身的 `this`，而使用定义时所在的固定了的外部作用域。\n\n###### 函数绑定\n\n`::` 目前还是提案，提供了如下的一种语法糖。\n\n```\nfoo::bar;\n// 等同于\nbar.bind(foo);\n\nfoo::bar(...arguments);\n// 等同于\nbar.apply(foo, arguments);\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return obj::hasOwnProperty(key);\n}\n```\n\n###### 尾调用优化\n\n尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\n\n之所以称为优化在于尾调用无需保留外部函数的调用栈，这种优化对于递归来说十分的重要。\n\nes6 的尾调用优化只在严格模式下开启，正常模式是无效的。这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。\n\n```\narguments：返回调用时函数的参数。\nfunc.caller：返回调用当前函数的那个函数。\n```\n\n尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。\n\n[具体还是看阮老师的文章吧，已经很详细了](http://www.ruanyifeng.com/blog/2015/04/tail-call.html)\n\n###### 函数参数的尾逗号\n\nECMAScript 2017将允许函数的最后一个参数有尾逗号（trailing comma）。主要是为了后面加参数时方便，版本管理时也不会显示多余的差异。这一点对于大部分公司来说应该无所谓吧，除非有强迫症！\n","html":"<h4 id=\"\">函数扩展</h4>\n\n<h6 id=\"\">默认参数</h6>\n\n<ul>\n<li>代替 <code>x || default value</code> 的写法。</li>\n<li>不能用 <code>let</code> 和 <code>const</code> 再次声明。</li>\n<li>与结构赋值默认值一起使用，不过容易两个容易混淆，建议不用。</li>\n<li>默认参数必须是尾参数，否则无法只省略该参数，必须显式地传入 <code>undefined</code>。</li>\n<li>默认的参数不会计入函数的 <code>length</code> 中。如果设置了默认值的参数不是尾参数，那么 <code>length</code> 属性也不再计入后面的参数了。所以最佳的策略就是把默认参数写在尾部。</li>\n<li>默认值可以是变量，但是这个变量必须在作用域链上能够找到。</li>\n<li>默认值是函数，作用域是其声明时所在的作用域。当前函数作用域还没有形成，所以和当前函数的外部作用域是同一个。这与 es5.1 是冲突的，需要看看 es6 标准。</li>\n</ul>\n\n<blockquote>\n  <p>猜测默认参数和 <code>let</code>、<code>const</code> 一样是定义在词法环境上的，而不是变量环境。而普通参数是定义在变量环境上的。待检验。</p>\n</blockquote>\n\n<p>应用：</p>\n\n<p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>\n\n<pre><code>function throwIfMissing() {  \n  throw new Error('Missing parameter');\n}\n\nfunction foo(mustBeProvided = throwIfMissing()) {  \n  return mustBeProvided;\n}\n\nfoo()  \n// Error: Missing parameter\n// 这表明参数的默认值不是在定义时执行，而是在运行时执行（即如果参数已经赋值，默认值中的函数就不会运行）\n</code></pre>\n\n<p>另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。</p>\n\n<pre><code>function foo(optional = undefined) { ··· }  \n</code></pre>\n\n<h6 id=\"rest\">rest 参数</h6>\n\n<p>把剩余的参数放入一个数组，可以用来代替 <code>arguments</code> 对象：</p>\n\n<pre><code>// arguments变量的写法\nfunction sortNumbers() {  \n  return Array.prototype.slice.call(arguments).sort();\n}\n\n// rest参数的写法\nconst sortNumbers = (...numbers) =&gt; numbers.sort();  \n</code></pre>\n\n<blockquote>\n  <p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。<code>length</code> 也不会包括 rest 参数。</p>\n</blockquote>\n\n<h6 id=\"\">扩展运算符</h6>\n\n<p>这与之前讲的对象扩展运算符类似，但是这是已经进入 es6 标准了的。它的作用好比 rest 运算符的逆运算。它会把数组展开成一个个元素。</p>\n\n<pre><code>function add(x, y) {  \n  return x + y;\n}\n\nvar numbers = [4, 38];  \nadd(...numbers) // 42  \n</code></pre>\n\n<p>应用：</p>\n\n<ul>\n<li>替代 <code>apply</code>，因为部分方法只接受参数列表不接受数组作为参数，因此需要使用 <code>apply</code> 来支持数组形式的参数。<code>...</code> 能够展开数组成参数列表，因此可以替代，写法简洁。</li>\n<li>合并数组，<code>[...arr1,...arr2]</code>。</li>\n<li>解构赋值，<code>[first, ...rest] = [1, 2, 3, 4, 5]</code>。</li>\n<li>字符串转数组，支持 unicode。</li>\n<li>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。</li>\n</ul>\n\n<h6 id=\"\">箭头函数</h6>\n\n<p>这应该是平时用得比较多的了。主要看一下注意点：</p>\n\n<ul>\n<li>函数体内的 <code>this</code> 对象，就是定义时所在的对象，而不是使用时所在的对象。</li>\n<li>不可以当作构造函数，也就是说，不可以使用 <code>new</code> 命令，否则会抛出一个错误。</li>\n<li>不可以使用 <code>arguments</code> 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>\n<li>不可以使用 <code>yield</code> 命令，因此箭头函数不能用作 generator 函数。</li>\n</ul>\n\n<p>主要要讲一下 <code>this</code>，下面是 babel 的转码：</p>\n\n<pre><code>// ES6\nfunction foo() {  \n  setTimeout(() =&gt; {\n    console.log('id:', this.id);\n  }, 100);\n}\n\n// ES5\nfunction foo() {  \n  var _this = this;\n\n  setTimeout(function () {\n    console.log('id:', _this.id);\n  }, 100);\n}\n</code></pre>\n\n<p>可以看到箭头函数转码后并不会使用自身的 <code>this</code>，而使用定义时所在的固定了的外部作用域。</p>\n\n<h6 id=\"\">函数绑定</h6>\n\n<p><code>::</code> 目前还是提案，提供了如下的一种语法糖。</p>\n\n<pre><code>foo::bar;  \n// 等同于\nbar.bind(foo);\n\nfoo::bar(...arguments);  \n// 等同于\nbar.apply(foo, arguments);\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;  \nfunction hasOwn(obj, key) {  \n  return obj::hasOwnProperty(key);\n}\n</code></pre>\n\n<h6 id=\"\">尾调用优化</h6>\n\n<p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>\n\n<p>之所以称为优化在于尾调用无需保留外部函数的调用栈，这种优化对于递归来说十分的重要。</p>\n\n<p>es6 的尾调用优化只在严格模式下开启，正常模式是无效的。这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>\n\n<pre><code>arguments：返回调用时函数的参数。  \nfunc.caller：返回调用当前函数的那个函数。  \n</code></pre>\n\n<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>\n\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/04/tail-call.html\">具体还是看阮老师的文章吧，已经很详细了</a></p>\n\n<h6 id=\"\">函数参数的尾逗号</h6>\n\n<p>ECMAScript 2017将允许函数的最后一个参数有尾逗号（trailing comma）。主要是为了后面加参数时方便，版本管理时也不会显示多余的差异。这一点对于大部分公司来说应该无所谓吧，除非有强迫症！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1475971888148,"created_by":1,"updated_at":1475980283083,"updated_by":1,"published_at":1475980189862,"published_by":1},{"id":110,"uuid":"332c4df4-540b-41db-bde2-3474ddc32a4d","title":"es6 modules","slug":"es6-module","markdown":"虽然早就发布了，今天才完成了前面[《js 模块化演进》](https://m2mbob.cn/2016/10/05/js-mo-kuai-hua-yan-jin/)一文。介绍了什么是模块、模块化？为什么需要模块化？模块化的历史以及模块化的实现。更多地总结需要更多的经验来填补。其中对于 es6 module 仅仅是简要地进行了介绍，没有深入，所以新开了一篇专门写 es6 module。先看语法再讲原理吧！\n\n### 语法和使用\n\n#### export 语法\n\n- 导出接口。你可以在 `function`、`class`、`var`、`let` 或 `const` 前添加 `export`。\n- as 关键字设置别名，可以重复导出。\n- `export 1;` 和 `var m = 1;export m;` 这两种写法导出的都是值而不是接口。会报错。\n- `export` 命令可以出现在模块的任何位置，只要处于模块顶层就可以。为了做静态化。\n- `export {v} from 'mod';` 支持从 'mod' 模块导出 v，这种写法合并了 `import` 和 `export`，一开始会不好理解，写多了还是很方便的。现有新提案，支持 `export v from 'mod';` 等价于前面那种写法。\n- `export default` 默认导出。`import` 时无需加大括号。\n\n> `export default a` 的含义是将变量 a 的值赋给变量 default。因此上面第三点对于 `export default` 命令是不成立的。相反 `export default var a = 1;` 这种写法是会报错的。\n\n#### import 语法\n\n- 导入，默认导出无需加大括号，非默认导出需要与导出接口同名。\n- `import` 也支持 as 设置别名。\n- `import` 命令具有提升效果，会提升到整个模块的头部，首先执行。\n- `import` 支持整体加载一个模块。写法类似这样 `import * as mod from 'mod';`。\n\n#### 模块继承\n\n继承某个模块的本质就是导入这个模块，然后导出或者部分导出。\n\n全部继承：\n\n```\nexport * from 'mod';\n```\n\n部分继承：\n\nexport { a,b } from 'mod';\n\n#### 严格模式\n\nes module 默认开启严格模式\n\n#### es6 module 转码\n\n因为目前大部分的环境包括最新的 V8 还没有支持 es6 module，因此现在大多数情况下使用 es6 module 还是需要转码的。下面是几种工具：\n\n1. `babel`，前面讲过 `babel` 默认会将 es6 module 转成 commonjs 模块。`babel` 官方同时还支持 AMD、UMD、Systemjs。\n2. `es6 module transpiler` 是 square 公司开源的一个转码器，可以将 es6 模块转为 commonjs 模块或 AMD 模块的写法，从而在浏览器中使用。\n3. `Systemjs`，在前面的文章也提到过，可以在浏览器内加载 es6 模块、 AMD 模块和 commonjs 模块，将其转为 es5 格式。它在后台调用的是 Google 的 Traceur 转码器。\n\n至于何时能够真正用上 es6 module，还是等各大引擎支持吧。毕竟这个特性是在语言层面加的，转码器只能转成别的模块格式。\n\n### 本质与原理\n\n光是看 es6 Modules，问题很大，因为 es6 标准引入了很多新的内容，如 `Realm` 等，所以看到一半放弃了，等有空回头看或者建个翻译的仓库。\n\n所以还是找了[《es6-in-depth-modules》](https://hacks.mozilla.org/2015/08/es6-in-depth-modules/)这篇文章加上[《es6 入门》模块部分](http://es6.ruanyifeng.com/#docs/module)来写吧！\n\nES6 将模块的加载细节[完全交给了实现](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hostresolveimportedmodule)，其余的[执行部分](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toplevelmoduleevaluationjob)则规定得非常详细。\n\n大致来说，当 js 引擎运行一个模块的时候，它的行为大致可归纳为以下四步：（这是来自《es6-in-depth-modules》一文，看了下标准，描述上可能存在差异，但是大致意思是差不多的。）\n\n1. 解析：引擎实现会阅读模块的源码，并且检查是否有语法错误。\n2. 加载：引擎实现会（递归地）加载所有被引入的模块。这部分还没标准化。\n3. 链接：引擎实现会为每个新加载的模块创建一个作用域，并且将模块中的声明绑定填入其中，包括从其他模块中引入的。\n4. 执行：终于，js 引擎开始执行刚加载进来的模块中的代码。\n\n可以看到，对于 es6 模块来说加载在代码执行前就已经完成了，《es6 入门》中将其称作“编译时加载”或者“静态加载”。\n\n我们再来看看现有纯 js 系统实现的模块系统是如何加载的吧！拿 SeaJs 来举例，因为看过源码比较熟。SeaJs 是在运行时，以 `seajs.use` 为入口加载单个或多个入口模块，然后在保存到缓存后会调用这些模块的 `load()` 方法，去加载依赖模块。所有依赖加载完成之后，会调用入口模块的回调函数执行入口模块的代码。这一切都是在运行时完成的，也叫作“运行时加载”。对于非标准制定者来说，只能够实现“运行时加载”的模块系统。\n\n#### 那么为什么 es6 选择静态加载呢？\n\n[Static module resolution](http://calculist.org/blog/2012/06/29/static-module-resolution/) 这是 es6 模块作者的一篇文章，虽然有点旧了。\n\n静态加载，使得我们只要看一下源码中的 `import` 声明就可以在运行前搞清楚模块的依赖，某些 es6 的实现甚至可以通过预处理就完成所有的工作，然后将模块全部打包成一个文件，最后通过网络分发。像 webpack 这样的工具就是做这个事情的。\n\n这非常的了不起，因为通过网络加载资源是非常耗时的。假设你请求一个资源，接着发现里面有 import 声明，然后你又得请求更多的资源，这又会耗费更多的时间。（这是目前 AMD、CMD 的做法，发现依赖然后进行异步加载）一个 naive 的 loader 实现可能会发起许多次网络请求。但有了 webpack，你不仅可以在今天就开始使用 es6，还可以得到一切模块化的好处并且不向运行时性能妥协。\n\n对了目前针对没有规范化的加载机制，有人在制定相应的规范[Loader](https://whatwg.github.io/loader/)。这个规范定义了 `System.import` 在运行时动态加载 es6 模块。感觉是在走 AMD 和 CMD 的老路，但是多个选择也许也不算坏。\n\n另外，目前 rollup 以及 webpack2 引入了一种叫做 Tree-shaking 的技术，Tree-shaking 是无用代码移除（DCE, dead code elimination）的一个方法，但和传统的方法不太一样。Tree-shaking 找到需要的代码，灌入最终的结果；传统 DCE 找到执行不到的代码，从 AST 里清除。这就是得益于 es6 模块的静态特性。\n\n除了静态加载带来的各种好处，es6 模块还有以下好处。\n\n- 不再需要 UMD 模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。\n- 将来浏览器的新 API 就能用模块格式提供，不再必要做成全局变量或者 `navigator` 对象的属性。\n- 不再需要对象作为命名空间（比如 `Math` 对象），未来这些功能可以通过模块提供。\n\n#### 模块加载的实质\n \nes6 模块的运行机制与 commonjs 不一样，它遇到模块加载命令 `import` 时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，es6 的输入有点像 Unix 系统的“符号连接”，原始值变了，`import` 输入的值也会跟着变。因此，es6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n另外，多个模块 `import` 同一个模块得到的是同一个，且不可变。\n\n#### 循环加载\n\n虽然写得还不够深入，但是对于 es6 模块的理解算是提高了不少。最后还有一块循环加载的知识。\n\n首先看 commonjs 的循环加载的处理：\n\n> 对于 commonjs，脚本代码在 `require` 的时候，就会全部执行。\n\n```\n//a.js\nexports.done = false;\nvar b = require('./b.js');\nconsole.log('在 a.js 之中，b.done = %j', b.done);\nexports.done = true;\nconsole.log('a.js 执行完毕');\n\n// b.js\nexports.done = false;\nvar a = require('./a.js');\nconsole.log('在 b.js 之中，a.done = %j', a.done);\nexports.done = true;\nconsole.log('b.js 执行完毕');\n```\n\n执行 `a.js`，到 `require` 就会去执行 `b.js`，此时执行到 `require('a.js')`，发生了循环加载。commonjs 此处的处理是直接返回此时的 `module.exports`，而不是执行结束后的。因此 `b.js` 得到的是 `{done: false}`。然后 `b.js` 继续执行到结束，再回到 `a.js` 执行。\n\n然后来看看 es6 模块是如何处理：\n\n```\n// a.js如下\nimport {bar} from './b.js';\nconsole.log('a.js');\nconsole.log(bar);\nexport let foo = 'foo';\n\n// b.js\nimport {foo} from './a.js';\nconsole.log('b.js');\nconsole.log(foo);\nexport let bar = 'bar';\n```\n\n`a.js` 执行到 `import` 去执行 `b.js`，此时又执行到 `import`，但是 `a.js` 已经开始执行，不会重复执行，所以 `b.js` 继续执行，输出了 `undefined`。直到执行结束才把执行权交还给 `a.js`。\n\n还有一些复杂的情况，可以移步[《es6 入门》](http://es6.ruanyifeng.com/#docs/module#ES6模块的循环加载)。\n\n### 小结\n\n模块部分脱了很久终于结束了，但是还是需要很多实践来进行巩固和验证，得出最佳实践。\n\n\n\n","html":"<p>虽然早就发布了，今天才完成了前面<a href=\"https://m2mbob.cn/2016/10/05/js-mo-kuai-hua-yan-jin/\">《js 模块化演进》</a>一文。介绍了什么是模块、模块化？为什么需要模块化？模块化的历史以及模块化的实现。更多地总结需要更多的经验来填补。其中对于 es6 module 仅仅是简要地进行了介绍，没有深入，所以新开了一篇专门写 es6 module。先看语法再讲原理吧！</p>\n\n<h3 id=\"\">语法和使用</h3>\n\n<h4 id=\"export\">export 语法</h4>\n\n<ul>\n<li>导出接口。你可以在 <code>function</code>、<code>class</code>、<code>var</code>、<code>let</code> 或 <code>const</code> 前添加 <code>export</code>。</li>\n<li>as 关键字设置别名，可以重复导出。</li>\n<li><code>export 1;</code> 和 <code>var m = 1;export m;</code> 这两种写法导出的都是值而不是接口。会报错。</li>\n<li><code>export</code> 命令可以出现在模块的任何位置，只要处于模块顶层就可以。为了做静态化。</li>\n<li><code>export {v} from 'mod';</code> 支持从 'mod' 模块导出 v，这种写法合并了 <code>import</code> 和 <code>export</code>，一开始会不好理解，写多了还是很方便的。现有新提案，支持 <code>export v from 'mod';</code> 等价于前面那种写法。</li>\n<li><code>export default</code> 默认导出。<code>import</code> 时无需加大括号。</li>\n</ul>\n\n<blockquote>\n  <p><code>export default a</code> 的含义是将变量 a 的值赋给变量 default。因此上面第三点对于 <code>export default</code> 命令是不成立的。相反 <code>export default var a = 1;</code> 这种写法是会报错的。</p>\n</blockquote>\n\n<h4 id=\"import\">import 语法</h4>\n\n<ul>\n<li>导入，默认导出无需加大括号，非默认导出需要与导出接口同名。</li>\n<li><code>import</code> 也支持 as 设置别名。</li>\n<li><code>import</code> 命令具有提升效果，会提升到整个模块的头部，首先执行。</li>\n<li><code>import</code> 支持整体加载一个模块。写法类似这样 <code>import * as mod from 'mod';</code>。</li>\n</ul>\n\n<h4 id=\"\">模块继承</h4>\n\n<p>继承某个模块的本质就是导入这个模块，然后导出或者部分导出。</p>\n\n<p>全部继承：</p>\n\n<pre><code>export * from 'mod';  \n</code></pre>\n\n<p>部分继承：</p>\n\n<p>export { a,b } from 'mod';</p>\n\n<h4 id=\"\">严格模式</h4>\n\n<p>es module 默认开启严格模式</p>\n\n<h4 id=\"es6module\">es6 module 转码</h4>\n\n<p>因为目前大部分的环境包括最新的 V8 还没有支持 es6 module，因此现在大多数情况下使用 es6 module 还是需要转码的。下面是几种工具：</p>\n\n<ol>\n<li><code>babel</code>，前面讲过 <code>babel</code> 默认会将 es6 module 转成 commonjs 模块。<code>babel</code> 官方同时还支持 AMD、UMD、Systemjs。  </li>\n<li><code>es6 module transpiler</code> 是 square 公司开源的一个转码器，可以将 es6 模块转为 commonjs 模块或 AMD 模块的写法，从而在浏览器中使用。  </li>\n<li><code>Systemjs</code>，在前面的文章也提到过，可以在浏览器内加载 es6 模块、 AMD 模块和 commonjs 模块，将其转为 es5 格式。它在后台调用的是 Google 的 Traceur 转码器。</li>\n</ol>\n\n<p>至于何时能够真正用上 es6 module，还是等各大引擎支持吧。毕竟这个特性是在语言层面加的，转码器只能转成别的模块格式。</p>\n\n<h3 id=\"\">本质与原理</h3>\n\n<p>光是看 es6 Modules，问题很大，因为 es6 标准引入了很多新的内容，如 <code>Realm</code> 等，所以看到一半放弃了，等有空回头看或者建个翻译的仓库。</p>\n\n<p>所以还是找了<a href=\"https://hacks.mozilla.org/2015/08/es6-in-depth-modules/\">《es6-in-depth-modules》</a>这篇文章加上<a href=\"http://es6.ruanyifeng.com/#docs/module\">《es6 入门》模块部分</a>来写吧！</p>\n\n<p>ES6 将模块的加载细节<a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hostresolveimportedmodule\">完全交给了实现</a>，其余的<a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toplevelmoduleevaluationjob\">执行部分</a>则规定得非常详细。</p>\n\n<p>大致来说，当 js 引擎运行一个模块的时候，它的行为大致可归纳为以下四步：（这是来自《es6-in-depth-modules》一文，看了下标准，描述上可能存在差异，但是大致意思是差不多的。）</p>\n\n<ol>\n<li>解析：引擎实现会阅读模块的源码，并且检查是否有语法错误。  </li>\n<li>加载：引擎实现会（递归地）加载所有被引入的模块。这部分还没标准化。  </li>\n<li>链接：引擎实现会为每个新加载的模块创建一个作用域，并且将模块中的声明绑定填入其中，包括从其他模块中引入的。  </li>\n<li>执行：终于，js 引擎开始执行刚加载进来的模块中的代码。</li>\n</ol>\n\n<p>可以看到，对于 es6 模块来说加载在代码执行前就已经完成了，《es6 入门》中将其称作“编译时加载”或者“静态加载”。</p>\n\n<p>我们再来看看现有纯 js 系统实现的模块系统是如何加载的吧！拿 SeaJs 来举例，因为看过源码比较熟。SeaJs 是在运行时，以 <code>seajs.use</code> 为入口加载单个或多个入口模块，然后在保存到缓存后会调用这些模块的 <code>load()</code> 方法，去加载依赖模块。所有依赖加载完成之后，会调用入口模块的回调函数执行入口模块的代码。这一切都是在运行时完成的，也叫作“运行时加载”。对于非标准制定者来说，只能够实现“运行时加载”的模块系统。</p>\n\n<h4 id=\"es6\">那么为什么 es6 选择静态加载呢？</h4>\n\n<p><a href=\"http://calculist.org/blog/2012/06/29/static-module-resolution/\">Static module resolution</a> 这是 es6 模块作者的一篇文章，虽然有点旧了。</p>\n\n<p>静态加载，使得我们只要看一下源码中的 <code>import</code> 声明就可以在运行前搞清楚模块的依赖，某些 es6 的实现甚至可以通过预处理就完成所有的工作，然后将模块全部打包成一个文件，最后通过网络分发。像 webpack 这样的工具就是做这个事情的。</p>\n\n<p>这非常的了不起，因为通过网络加载资源是非常耗时的。假设你请求一个资源，接着发现里面有 import 声明，然后你又得请求更多的资源，这又会耗费更多的时间。（这是目前 AMD、CMD 的做法，发现依赖然后进行异步加载）一个 naive 的 loader 实现可能会发起许多次网络请求。但有了 webpack，你不仅可以在今天就开始使用 es6，还可以得到一切模块化的好处并且不向运行时性能妥协。</p>\n\n<p>对了目前针对没有规范化的加载机制，有人在制定相应的规范<a href=\"https://whatwg.github.io/loader/\">Loader</a>。这个规范定义了 <code>System.import</code> 在运行时动态加载 es6 模块。感觉是在走 AMD 和 CMD 的老路，但是多个选择也许也不算坏。</p>\n\n<p>另外，目前 rollup 以及 webpack2 引入了一种叫做 Tree-shaking 的技术，Tree-shaking 是无用代码移除（DCE, dead code elimination）的一个方法，但和传统的方法不太一样。Tree-shaking 找到需要的代码，灌入最终的结果；传统 DCE 找到执行不到的代码，从 AST 里清除。这就是得益于 es6 模块的静态特性。</p>\n\n<p>除了静态加载带来的各种好处，es6 模块还有以下好处。</p>\n\n<ul>\n<li>不再需要 UMD 模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>\n<li>将来浏览器的新 API 就能用模块格式提供，不再必要做成全局变量或者 <code>navigator</code> 对象的属性。</li>\n<li>不再需要对象作为命名空间（比如 <code>Math</code> 对象），未来这些功能可以通过模块提供。</li>\n</ul>\n\n<h4 id=\"\">模块加载的实质</h4>\n\n<p>es6 模块的运行机制与 commonjs 不一样，它遇到模块加载命令 <code>import</code> 时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，es6 的输入有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code> 输入的值也会跟着变。因此，es6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>\n\n<p>另外，多个模块 <code>import</code> 同一个模块得到的是同一个，且不可变。</p>\n\n<h4 id=\"\">循环加载</h4>\n\n<p>虽然写得还不够深入，但是对于 es6 模块的理解算是提高了不少。最后还有一块循环加载的知识。</p>\n\n<p>首先看 commonjs 的循环加载的处理：</p>\n\n<blockquote>\n  <p>对于 commonjs，脚本代码在 <code>require</code> 的时候，就会全部执行。</p>\n</blockquote>\n\n<pre><code>//a.js\nexports.done = false;  \nvar b = require('./b.js');  \nconsole.log('在 a.js 之中，b.done = %j', b.done);  \nexports.done = true;  \nconsole.log('a.js 执行完毕');\n\n// b.js\nexports.done = false;  \nvar a = require('./a.js');  \nconsole.log('在 b.js 之中，a.done = %j', a.done);  \nexports.done = true;  \nconsole.log('b.js 执行完毕');  \n</code></pre>\n\n<p>执行 <code>a.js</code>，到 <code>require</code> 就会去执行 <code>b.js</code>，此时执行到 <code>require('a.js')</code>，发生了循环加载。commonjs 此处的处理是直接返回此时的 <code>module.exports</code>，而不是执行结束后的。因此 <code>b.js</code> 得到的是 <code>{done: false}</code>。然后 <code>b.js</code> 继续执行到结束，再回到 <code>a.js</code> 执行。</p>\n\n<p>然后来看看 es6 模块是如何处理：</p>\n\n<pre><code>// a.js如下\nimport {bar} from './b.js';  \nconsole.log('a.js');  \nconsole.log(bar);  \nexport let foo = 'foo';\n\n// b.js\nimport {foo} from './a.js';  \nconsole.log('b.js');  \nconsole.log(foo);  \nexport let bar = 'bar';  \n</code></pre>\n\n<p><code>a.js</code> 执行到 <code>import</code> 去执行 <code>b.js</code>，此时又执行到 <code>import</code>，但是 <code>a.js</code> 已经开始执行，不会重复执行，所以 <code>b.js</code> 继续执行，输出了 <code>undefined</code>。直到执行结束才把执行权交还给 <code>a.js</code>。</p>\n\n<p>还有一些复杂的情况，可以移步<a href=\"http://es6.ruanyifeng.com/#docs/module#ES6模块的循环加载\">《es6 入门》</a>。</p>\n\n<h3 id=\"\">小结</h3>\n\n<p>模块部分脱了很久终于结束了，但是还是需要很多实践来进行巩固和验证，得出最佳实践。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476009709962,"created_by":1,"updated_at":1476152936453,"updated_by":1,"published_at":1476014774957,"published_by":1},{"id":111,"uuid":"8a7ef8c9-be7e-4399-8fa3-024700174a07","title":"随笔","slug":"sui-bi-5","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=426027645&auto=1&height=66\"></iframe>\n\n回寝室前写点什么。今天差不多除了上课的时间都在改之前的一个项目。虽然离职了，但是这个项目一直是我负责的，也快上线了，所以不打算就扔掉。不过还是觉得挺那个的，这种主业务上的需求可以一变再变。\n\n八点不到的时候差不多把流程改完了，还剩充值和 app 内一个打开支付宝的问题明天解决了。（不过还是很奇怪微信是能够正常打开的，可能是支付宝做了安全上的处理）改完后看了下 es6 标准文档的 Modules 部分，有点多，而且很多不理解，有点想放弃直接读一些别的文章。看明天的心情吧！\n\n对了昨天看火影 698，应该和漫画一样 700 集收尾吧，还剩两集。背景音乐就来自火影的 ED，感觉听着挺不错的。\n\n好了差不多回去了，二周目看《对不起青春》。\n\n","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=426027645&auto=1&height=66\"></iframe>\n\n<p>回寝室前写点什么。今天差不多除了上课的时间都在改之前的一个项目。虽然离职了，但是这个项目一直是我负责的，也快上线了，所以不打算就扔掉。不过还是觉得挺那个的，这种主业务上的需求可以一变再变。</p>\n\n<p>八点不到的时候差不多把流程改完了，还剩充值和 app 内一个打开支付宝的问题明天解决了。（不过还是很奇怪微信是能够正常打开的，可能是支付宝做了安全上的处理）改完后看了下 es6 标准文档的 Modules 部分，有点多，而且很多不理解，有点想放弃直接读一些别的文章。看明天的心情吧！</p>\n\n<p>对了昨天看火影 698，应该和漫画一样 700 集收尾吧，还剩两集。背景音乐就来自火影的 ED，感觉听着挺不错的。</p>\n\n<p>好了差不多回去了，二周目看《对不起青春》。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476103697289,"created_by":1,"updated_at":1476104334581,"updated_by":1,"published_at":1476104334581,"published_by":1},{"id":112,"uuid":"085b5fe5-0011-4d72-b490-8bed5f91e5f4","title":"es6 温故第五天小结","slug":"es6-wen-gu-di-wu-tian-xiao-jie","markdown":"前面单独写的模块、异步编程以及类写完以后 es6 的内容剩下的起始就不多了，或者说剩下的不是那么重要了，所以分两篇写完。第五天小结内容是 `Set`、`Map` 和 `Iterator`、`for...of`；第六天小结内容是 `Symbol`、`Proxy` 和 `Reflect`。然后就开始 DOM 和 BOM 的深入学习。\n\n#### `Symbol`\n\n第七种原始数据类型，表示独一无二的值，为了解决属性名冲突而出现。\n\n`Symbol` 值通过 `Symbol` 函数创建：\n\n```\nlet s1 = Symbol()\nlet s2 = Symbol()\n\ntypeof s1 // symbol\ns1 === s2 // false\n\nlet s3 = Symbol('foo')\nlet s4 = Symbol('foo')\ns3 === s4 // false\n```\n\n##### 类型转换\n\n- `Symbol` 不能参与运算，也就是不会隐式转换。\n- 可以显示转换为 `String` 和 `Boolean` 类型，但是不能转换为 `Number`。\n\n##### 作为属性名\n\n`Symbol` 不支持点运算符，只能用中括号或者 `Object.defineProperty`。\n\n另外遍历 `Symbol` 属性需要使用 `Object.getOwnPropertySymbols` 或 `Reflect.ownKeys` 方法，其他的 `for...in`、`Object.keys`、`Object.getOwnPropertyNames` 都不会获取 `Sysmol` 属性。\n\n##### `Symbol.for` 和 `Symbol.keyFor`\n\n`Symbol.for` 和 `Symbol` 的区别在于，前者的 key 会被登记在全局环境，第二次调用时，如果 key 已经被登记那么返回的就是同一个 `Symbol` 值。`Symbol.keyFor` 的作用就是根据 `Symbol` 值来得到原始的 key。\n\n##### 内置的 `Symbol`\n\nes6 提供了11个内置的 `Symbol` 值，指向了内部使用的方法，如前面讲过的 `toPrimitive` 转换为原始值方法还有字符串的正则方法。通常不回去覆盖内部的方法，所以用得不多，不费时间写一遍了。\n\n#### `Proxy`\n\n`Proxy` 用于拦截某些操作的默认行为，等同于在语言层面作出修改，属于“元编程”。下面是支持拦截的操作（不详述）：\n\n- `get(target, propKey, receiver)`\n- `set(target, propKey, receiver)`\n- `has(target, propKey)`\n- `deleteProperty(target, propKey)`\n- `enumerate(target)`\n- `hasOwn(target, propKey)`\n- `ownKeys(target)`\n- `getOwnPropertyDescriptor(target, propKey)`\n- `defineProperty(target, propKey, propDesc)`\n- `preventExtensions(target)`\n- `getPrototypeOf(target)`\n- `isExtensible(target)`\n- `setPrototypeOf(target, proto)`\n- `apply(target, object, args)`\n- `construct(target, args, proxy)`\n\n对于可以设置但没有设置的拦截，会按目标对象默认的方式产生结果。\n\n##### `Proxy.revocable()`\n\n```\nlet target = {}\nlet handler = {}\n\nlet { proxy, revoke } = Proxy.revocable(target, handler)\n\nproxy.foo = 123\nproxy.foo\t\t// 123\n\nrevoke()\n\nproxy.foo\t\t// TypeError\n```\n\n#### `Reflect`\n\n与 `Proxy` 一样为 es6 操作对象提供新的 API，以下是设计目的：\n\n- 将属于语言层面的方法放到 `Reflect` 上，现在会同时在 `Object` 上，为了会只部署在 `Reflect` 上。\n- 修改 `Object` 原有方法返回结果的不合理，如 `Object.defineProperty` 在无法定义时会抛出错误，而 `Reflect.defineProperty` 则返回 `false`。\n- 将一些命令式的操作变成函数行为，如 `in` 对应 `Reflect.has`，`delete` 对应 `Reflect.deleteProperty`。\n- 与 `Proxy` 的支持的操作一一对应。\n\n一句话概括就是把原来属于 `Object` 的语言层面的方法都放到了 `Reflect`，并做了扩展和修复，然后提供给为操作对象以及 `Proxy`。","html":"<p>前面单独写的模块、异步编程以及类写完以后 es6 的内容剩下的起始就不多了，或者说剩下的不是那么重要了，所以分两篇写完。第五天小结内容是 <code>Set</code>、<code>Map</code> 和 <code>Iterator</code>、<code>for...of</code>；第六天小结内容是 <code>Symbol</code>、<code>Proxy</code> 和 <code>Reflect</code>。然后就开始 DOM 和 BOM 的深入学习。</p>\n\n<h4 id=\"symbol\"><code>Symbol</code></h4>\n\n<p>第七种原始数据类型，表示独一无二的值，为了解决属性名冲突而出现。</p>\n\n<p><code>Symbol</code> 值通过 <code>Symbol</code> 函数创建：</p>\n\n<pre><code>let s1 = Symbol()  \nlet s2 = Symbol()\n\ntypeof s1 // symbol  \ns1 === s2 // false\n\nlet s3 = Symbol('foo')  \nlet s4 = Symbol('foo')  \ns3 === s4 // false  \n</code></pre>\n\n<h5 id=\"\">类型转换</h5>\n\n<ul>\n<li><code>Symbol</code> 不能参与运算，也就是不会隐式转换。</li>\n<li>可以显示转换为 <code>String</code> 和 <code>Boolean</code> 类型，但是不能转换为 <code>Number</code>。</li>\n</ul>\n\n<h5 id=\"\">作为属性名</h5>\n\n<p><code>Symbol</code> 不支持点运算符，只能用中括号或者 <code>Object.defineProperty</code>。</p>\n\n<p>另外遍历 <code>Symbol</code> 属性需要使用 <code>Object.getOwnPropertySymbols</code> 或 <code>Reflect.ownKeys</code> 方法，其他的 <code>for...in</code>、<code>Object.keys</code>、<code>Object.getOwnPropertyNames</code> 都不会获取 <code>Sysmol</code> 属性。</p>\n\n<h5 id=\"symbolforsymbolkeyfor\"><code>Symbol.for</code> 和 <code>Symbol.keyFor</code></h5>\n\n<p><code>Symbol.for</code> 和 <code>Symbol</code> 的区别在于，前者的 key 会被登记在全局环境，第二次调用时，如果 key 已经被登记那么返回的就是同一个 <code>Symbol</code> 值。<code>Symbol.keyFor</code> 的作用就是根据 <code>Symbol</code> 值来得到原始的 key。</p>\n\n<h5 id=\"symbol\">内置的 <code>Symbol</code></h5>\n\n<p>es6 提供了11个内置的 <code>Symbol</code> 值，指向了内部使用的方法，如前面讲过的 <code>toPrimitive</code> 转换为原始值方法还有字符串的正则方法。通常不回去覆盖内部的方法，所以用得不多，不费时间写一遍了。</p>\n\n<h4 id=\"proxy\"><code>Proxy</code></h4>\n\n<p><code>Proxy</code> 用于拦截某些操作的默认行为，等同于在语言层面作出修改，属于“元编程”。下面是支持拦截的操作（不详述）：</p>\n\n<ul>\n<li><code>get(target, propKey, receiver)</code></li>\n<li><code>set(target, propKey, receiver)</code></li>\n<li><code>has(target, propKey)</code></li>\n<li><code>deleteProperty(target, propKey)</code></li>\n<li><code>enumerate(target)</code></li>\n<li><code>hasOwn(target, propKey)</code></li>\n<li><code>ownKeys(target)</code></li>\n<li><code>getOwnPropertyDescriptor(target, propKey)</code></li>\n<li><code>defineProperty(target, propKey, propDesc)</code></li>\n<li><code>preventExtensions(target)</code></li>\n<li><code>getPrototypeOf(target)</code></li>\n<li><code>isExtensible(target)</code></li>\n<li><code>setPrototypeOf(target, proto)</code></li>\n<li><code>apply(target, object, args)</code></li>\n<li><code>construct(target, args, proxy)</code></li>\n</ul>\n\n<p>对于可以设置但没有设置的拦截，会按目标对象默认的方式产生结果。</p>\n\n<h5 id=\"proxyrevocable\"><code>Proxy.revocable()</code></h5>\n\n<pre><code>let target = {}  \nlet handler = {}\n\nlet { proxy, revoke } = Proxy.revocable(target, handler)\n\nproxy.foo = 123  \nproxy.foo        // 123\n\nrevoke()\n\nproxy.foo        // TypeError  \n</code></pre>\n\n<h4 id=\"reflect\"><code>Reflect</code></h4>\n\n<p>与 <code>Proxy</code> 一样为 es6 操作对象提供新的 API，以下是设计目的：</p>\n\n<ul>\n<li>将属于语言层面的方法放到 <code>Reflect</code> 上，现在会同时在 <code>Object</code> 上，为了会只部署在 <code>Reflect</code> 上。</li>\n<li>修改 <code>Object</code> 原有方法返回结果的不合理，如 <code>Object.defineProperty</code> 在无法定义时会抛出错误，而 <code>Reflect.defineProperty</code> 则返回 <code>false</code>。</li>\n<li>将一些命令式的操作变成函数行为，如 <code>in</code> 对应 <code>Reflect.has</code>，<code>delete</code> 对应 <code>Reflect.deleteProperty</code>。</li>\n<li>与 <code>Proxy</code> 的支持的操作一一对应。</li>\n</ul>\n\n<p>一句话概括就是把原来属于 <code>Object</code> 的语言层面的方法都放到了 <code>Reflect</code>，并做了扩展和修复，然后提供给为操作对象以及 <code>Proxy</code>。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476184267461,"created_by":1,"updated_at":1476859249721,"updated_by":1,"published_at":1476859249724,"published_by":1},{"id":113,"uuid":"8730c307-33e4-4cd4-9990-8cfa617bd908","title":"js 异步编程之 Promise","slug":"js-yi-bu-bian-cheng-zhi-promise","markdown":"#### 异步编程是什么？\n\n异步编程和之前讲过的异步 I/O，是两个东西。个人认为真正的异步函数（封装了异步任务）都是由 js 环境所提供的，主要分为 I/O 函数和计时函数（DOM 事件算什么？）。这些异步函数在 js 环境中都会有特殊的机制来实现，也就是上一篇所讲的异步 I/O。\n\n当然还有一类异步函数，它们是建立在上面所说的两类异步函数之上，也能够达到异步的效果。\n\n而异步编程是什么玩意，回到 js 环境提供的这些异步函数，它们在语法层面使用的基本都是回调函数或者是事件+回调。而回调函数在编写异步代码过程中主要的问题有两个：一是回调金字塔，写起来读起来都不爽；第二是异常捕获，Node 处理异常是在回调函数中加一个错误的参数，这种做法也很不优雅。\n\n正是由于回调函数的种种问题，才有了 Promise、Generator + co、async/await 等方案，来改进异步的写法，甚至是以同步地写法写异步代码。js 环境对于这些语法的实现，会在内部有一些类似异步函数的处理，至于 Babel 这类转码器来说，本质上还是会利用 js 环境的异步函数如 `setTimeout` 或 `process.nextTick` 等来达到类似的效果。\n\n弄明白上面的区别，我们再来看这些新的异步编程的写法。\n\n#### Promise\n\n##### Promise 的历史\n\nPromise 是一个古老的概念（最初提出于 1976 年），通常与 future 结合在一起。Future 指的是未来的值，通常在 Promise 里被作为参数和返回值传来传去。\n\nPromise 只是一个概念，很多常见语言的标准库都有 Promise 关联的特性（比如 C++ 11 的 `std::promise` 和 `std::future`、Java 8 的 `java.util.concurrent.Future`、Python 3.2+ 的 `concurrent.futures` 等）。即使标准库里没有，大部分语言里也有第三方实现的 Promise（比如 Ruby 的 Promise gem）。\n\n在 js 的世界里，最早得到广泛使用的 Promise 是 jQuery 的 Ajax 模块中出现的 `jQuery.Deferred()`。[Promise/A+](https://promisesaplus.com/#point-11) 标准规定了一系列 API，并配有大量的测试用例，es6 直接整合了这个标准。\n\nPromise/A+ 提供的 API 非常有限，很多 Promise 库（Q、bluebird 等）在兼容 Promise/A+ 的基础上添加了一些其他的扩展。jQuery 3.0 也已经将 `Deferred` 迁移成了与 Promise/A+ 兼容。\n\n##### Promise/A+\n\n虽然目前有很多 Promise 规范，Promises/A、Promises/B、Promises/Kiss等等，但是比较流行，被 es6 所采纳的还是 Promises/A 上发展起来的 Promise/A+ 规范。\n\n[Promise/A+ 规范翻译](https://m2mbob.cn/2016/10/15/promise-a-gui-fan-fan-yi/)\n\n从 Promise/A+ 的翻译来看，Promise/A+ 仅仅规定了 `then` 方法以及 `resolve` 的行为，而对于 promise 对象的创建、如何 fulfill、reject 它是交给具体实现了做的。\n\n对于 Promise/A+，我特别要强调的一点就是 `onFulfilled` 和 `onRejected` 直到执行上下文栈只包含平台代码才能够执行这一点。这一点的意思实际上就是 `onFulfilled` 和 `onRejected` 是在事件循环阶段来执行的，也就是异步执行的。第三方的实现一般是用如 `setTimeout` 或 `process.nextTick` 等来达到类似的效果。\n\n那为什么是这样的呢？就来看看 Promise/A+ 大多数实现代码的整体执行过程吧。\n\n1. `let promise = new Promise(fn(resolve, reject))`，这个 `fn` 一般是一个包含异步函数的函数，在 `new` 的时候实际上就会调用这个函数。\n2. `promise.then(onFulfilled,onRejected)`，`then` 可以调用多次，但是 `onFulfilled` 和 `onRejected` 只会调用一次。`then` 会在执行时形成一条 `promise` 链，前一个 `promise` 保存了后一个 `promise` 以及相关的 `onFulfilled` 和 `onRejected`，当前一个 `promise` 被 `resolve` 就会调用保存的 `onFulfilled` 或 `onRejected`。\n3. `promise.then(onFulfilled,onRejected)` 返回一个新的 `promise` 对象，为了链式调用。这个新的对象的行为根据规范来说，与上一个 `promise` 注册的 `onFulfilled`、`onRejected` 有关。如果 `onFulfilled`、`onRejected` 不是函数那么就会直接以前一个 `pormise` 的值进行相同的操作。如果出现异常，则以异常 `reject` 新的 `promise`。如果是函数，那么以返回值执行 `resolve`。也就是说进行链式调用时，后一个 `promise` 的值取决于前一个 `promise` 的 `onFulfilled`、`onRejected`。\n4. 对于返回 `onFulfilled` 返回 thenable 对象的时候，情况比较特殊，它会执行 thenable 的 `then` 方法，传入两个回调，回调会来调用外部的 `promise` 对象的 `resolve` 或 `reject`，达到链式向下传递的目的。\n\n[简化版的 Promise/A+ 实现](https://github.com/xxn520/PromiseA-CN/blob/master/ccPromise.js)这个是我参考[lie](https://github.com/calvinmetcalf/lie)实现的一个。\n\n##### es6 Promise\n\n看完了规范和执行过程，最后来看看 es6 Promise，目前来看各个环境原生的 Promise 的性能比起 Bluebird 这类原生库来说还差不少。但是随着原生 Promise 之后性能的改进，使用它还是大势所趋吧！\n\n###### `Promise.prototype.then`\n\n`then` 的行为在上面已经讲得差不多了。\n\n###### `Promise.prototype.catch`\n\n等价于 `then(null, onRejected)`，因此 `catch` 返回的还是个 `promise` 对象，并不是链的终点。错误在 `promise` 内部会被捕获，而不会抛到全局环境，如果需要抛出错误到全局环境：\n\n```\n//...\n.catch(function (reason) {\n     setTimeout(() => { throw reason }, 0);\n});\n```\n\n一些使用的注意点看前面[另一篇文章](https://m2mbob.cn/2016/08/12/liu-lan-qi-xia-zai-google-playde-apk/)\n\n###### `Promise.resolve(value)`\n\n- `value` 是 `promise` 对象，则直接返回。\n- `value` 是 `thenable`，执行 `then` 方法，新建一个空 `promise`，然后当 `then` 方法返回时，去修改新建的 `promise` 的状态，然后返回。\n- `value` 是其它的或者没有，那么会直接返回一个 `resolve(value)` 的空 `promise`\n\n这个方法可以快速创建一个 fulfilled 状态的 `promise` 对象，只不过 `resolve` 是在本轮事件循环结束调用的。\n\n###### `Promise.reject(value)`\n\n和 `Promise.resolve(value)` 类似。\n\n###### `Promise.all()`\n\n用于将多个 Promise 实例，包装成一个新的 Promise 实例。只有这多个 Promise 实例状态都为 fulfilled 或 rejected 时，才会调用所包装新 Promise 实例的 `resolve` 方法。\n\n参数不一定是数组，但必须有 `Iterator` 接口。另外如果传入的不是 `promise` 对象，会使用上面的 `Promise.resolve` 来转化成 `promise` 对象。\n\n###### `Promise.race()`\n\n和上面的 `Promise.all` 类似，但是这个方法只要有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。\n\n###### 扩展\n\n大多数 Promise 的实现都会扩展很多有用的方法，下面介绍两个比较有用的：\n\n`done()`\n\nPromise 对象的回调链，不管以 `then` 方法或 `catch` 方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个 `done` 方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。\n\n```\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  this.then(onFulfilled, onRejected)\n    .catch(function (reason) {\n      // 抛出一个全局错误\n      setTimeout(() => { throw reason }, 0);\n    });\n};\n```\n\n`finally`\n\n`finally` 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。它与 `done` 方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。\n\n```\nPromise.prototype.finally = function (callback) {\n  let P = this.constructor;\n  return this.then(\n    value  => P.resolve(callback()).then(() => value),\n    reason => P.resolve(callback()).then(() => { throw reason })\n  );\n};\n```","html":"<h4 id=\"\">异步编程是什么？</h4>\n\n<p>异步编程和之前讲过的异步 I/O，是两个东西。个人认为真正的异步函数（封装了异步任务）都是由 js 环境所提供的，主要分为 I/O 函数和计时函数（DOM 事件算什么？）。这些异步函数在 js 环境中都会有特殊的机制来实现，也就是上一篇所讲的异步 I/O。</p>\n\n<p>当然还有一类异步函数，它们是建立在上面所说的两类异步函数之上，也能够达到异步的效果。</p>\n\n<p>而异步编程是什么玩意，回到 js 环境提供的这些异步函数，它们在语法层面使用的基本都是回调函数或者是事件+回调。而回调函数在编写异步代码过程中主要的问题有两个：一是回调金字塔，写起来读起来都不爽；第二是异常捕获，Node 处理异常是在回调函数中加一个错误的参数，这种做法也很不优雅。</p>\n\n<p>正是由于回调函数的种种问题，才有了 Promise、Generator + co、async/await 等方案，来改进异步的写法，甚至是以同步地写法写异步代码。js 环境对于这些语法的实现，会在内部有一些类似异步函数的处理，至于 Babel 这类转码器来说，本质上还是会利用 js 环境的异步函数如 <code>setTimeout</code> 或 <code>process.nextTick</code> 等来达到类似的效果。</p>\n\n<p>弄明白上面的区别，我们再来看这些新的异步编程的写法。</p>\n\n<h4 id=\"promise\">Promise</h4>\n\n<h5 id=\"promise\">Promise 的历史</h5>\n\n<p>Promise 是一个古老的概念（最初提出于 1976 年），通常与 future 结合在一起。Future 指的是未来的值，通常在 Promise 里被作为参数和返回值传来传去。</p>\n\n<p>Promise 只是一个概念，很多常见语言的标准库都有 Promise 关联的特性（比如 C++ 11 的 <code>std::promise</code> 和 <code>std::future</code>、Java 8 的 <code>java.util.concurrent.Future</code>、Python 3.2+ 的 <code>concurrent.futures</code> 等）。即使标准库里没有，大部分语言里也有第三方实现的 Promise（比如 Ruby 的 Promise gem）。</p>\n\n<p>在 js 的世界里，最早得到广泛使用的 Promise 是 jQuery 的 Ajax 模块中出现的 <code>jQuery.Deferred()</code>。<a href=\"https://promisesaplus.com/#point-11\">Promise/A+</a> 标准规定了一系列 API，并配有大量的测试用例，es6 直接整合了这个标准。</p>\n\n<p>Promise/A+ 提供的 API 非常有限，很多 Promise 库（Q、bluebird 等）在兼容 Promise/A+ 的基础上添加了一些其他的扩展。jQuery 3.0 也已经将 <code>Deferred</code> 迁移成了与 Promise/A+ 兼容。</p>\n\n<h5 id=\"promisea\">Promise/A+</h5>\n\n<p>虽然目前有很多 Promise 规范，Promises/A、Promises/B、Promises/Kiss等等，但是比较流行，被 es6 所采纳的还是 Promises/A 上发展起来的 Promise/A+ 规范。</p>\n\n<p><a href=\"https://m2mbob.cn/2016/10/15/promise-a-gui-fan-fan-yi/\">Promise/A+ 规范翻译</a></p>\n\n<p>从 Promise/A+ 的翻译来看，Promise/A+ 仅仅规定了 <code>then</code> 方法以及 <code>resolve</code> 的行为，而对于 promise 对象的创建、如何 fulfill、reject 它是交给具体实现了做的。</p>\n\n<p>对于 Promise/A+，我特别要强调的一点就是 <code>onFulfilled</code> 和 <code>onRejected</code> 直到执行上下文栈只包含平台代码才能够执行这一点。这一点的意思实际上就是 <code>onFulfilled</code> 和 <code>onRejected</code> 是在事件循环阶段来执行的，也就是异步执行的。第三方的实现一般是用如 <code>setTimeout</code> 或 <code>process.nextTick</code> 等来达到类似的效果。</p>\n\n<p>那为什么是这样的呢？就来看看 Promise/A+ 大多数实现代码的整体执行过程吧。</p>\n\n<ol>\n<li><code>let promise = new Promise(fn(resolve, reject))</code>，这个 <code>fn</code> 一般是一个包含异步函数的函数，在 <code>new</code> 的时候实际上就会调用这个函数。  </li>\n<li><code>promise.then(onFulfilled,onRejected)</code>，<code>then</code> 可以调用多次，但是 <code>onFulfilled</code> 和 <code>onRejected</code> 只会调用一次。<code>then</code> 会在执行时形成一条 <code>promise</code> 链，前一个 <code>promise</code> 保存了后一个 <code>promise</code> 以及相关的 <code>onFulfilled</code> 和 <code>onRejected</code>，当前一个 <code>promise</code> 被 <code>resolve</code> 就会调用保存的 <code>onFulfilled</code> 或 <code>onRejected</code>。  </li>\n<li><code>promise.then(onFulfilled,onRejected)</code> 返回一个新的 <code>promise</code> 对象，为了链式调用。这个新的对象的行为根据规范来说，与上一个 <code>promise</code> 注册的 <code>onFulfilled</code>、<code>onRejected</code> 有关。如果 <code>onFulfilled</code>、<code>onRejected</code> 不是函数那么就会直接以前一个 <code>pormise</code> 的值进行相同的操作。如果出现异常，则以异常 <code>reject</code> 新的 <code>promise</code>。如果是函数，那么以返回值执行 <code>resolve</code>。也就是说进行链式调用时，后一个 <code>promise</code> 的值取决于前一个 <code>promise</code> 的 <code>onFulfilled</code>、<code>onRejected</code>。  </li>\n<li>对于返回 <code>onFulfilled</code> 返回 thenable 对象的时候，情况比较特殊，它会执行 thenable 的 <code>then</code> 方法，传入两个回调，回调会来调用外部的 <code>promise</code> 对象的 <code>resolve</code> 或 <code>reject</code>，达到链式向下传递的目的。</li>\n</ol>\n\n<p><a href=\"https://github.com/xxn520/PromiseA-CN/blob/master/ccPromise.js\">简化版的 Promise/A+ 实现</a>这个是我参考<a href=\"https://github.com/calvinmetcalf/lie\">lie</a>实现的一个。</p>\n\n<h5 id=\"es6promise\">es6 Promise</h5>\n\n<p>看完了规范和执行过程，最后来看看 es6 Promise，目前来看各个环境原生的 Promise 的性能比起 Bluebird 这类原生库来说还差不少。但是随着原生 Promise 之后性能的改进，使用它还是大势所趋吧！</p>\n\n<h6 id=\"promiseprototypethen\"><code>Promise.prototype.then</code></h6>\n\n<p><code>then</code> 的行为在上面已经讲得差不多了。</p>\n\n<h6 id=\"promiseprototypecatch\"><code>Promise.prototype.catch</code></h6>\n\n<p>等价于 <code>then(null, onRejected)</code>，因此 <code>catch</code> 返回的还是个 <code>promise</code> 对象，并不是链的终点。错误在 <code>promise</code> 内部会被捕获，而不会抛到全局环境，如果需要抛出错误到全局环境：</p>\n\n<pre><code>//...\n.catch(function (reason) {\n     setTimeout(() =&gt; { throw reason }, 0);\n});\n</code></pre>\n\n<p>一些使用的注意点看前面<a href=\"https://m2mbob.cn/2016/08/12/liu-lan-qi-xia-zai-google-playde-apk/\">另一篇文章</a></p>\n\n<h6 id=\"promiseresolvevalue\"><code>Promise.resolve(value)</code></h6>\n\n<ul>\n<li><code>value</code> 是 <code>promise</code> 对象，则直接返回。</li>\n<li><code>value</code> 是 <code>thenable</code>，执行 <code>then</code> 方法，新建一个空 <code>promise</code>，然后当 <code>then</code> 方法返回时，去修改新建的 <code>promise</code> 的状态，然后返回。</li>\n<li><code>value</code> 是其它的或者没有，那么会直接返回一个 <code>resolve(value)</code> 的空 <code>promise</code></li>\n</ul>\n\n<p>这个方法可以快速创建一个 fulfilled 状态的 <code>promise</code> 对象，只不过 <code>resolve</code> 是在本轮事件循环结束调用的。</p>\n\n<h6 id=\"promiserejectvalue\"><code>Promise.reject(value)</code></h6>\n\n<p>和 <code>Promise.resolve(value)</code> 类似。</p>\n\n<h6 id=\"promiseall\"><code>Promise.all()</code></h6>\n\n<p>用于将多个 Promise 实例，包装成一个新的 Promise 实例。只有这多个 Promise 实例状态都为 fulfilled 或 rejected 时，才会调用所包装新 Promise 实例的 <code>resolve</code> 方法。</p>\n\n<p>参数不一定是数组，但必须有 <code>Iterator</code> 接口。另外如果传入的不是 <code>promise</code> 对象，会使用上面的 <code>Promise.resolve</code> 来转化成 <code>promise</code> 对象。</p>\n\n<h6 id=\"promiserace\"><code>Promise.race()</code></h6>\n\n<p>和上面的 <code>Promise.all</code> 类似，但是这个方法只要有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p>\n\n<h6 id=\"\">扩展</h6>\n\n<p>大多数 Promise 的实现都会扩展很多有用的方法，下面介绍两个比较有用的：</p>\n\n<p><code>done()</code></p>\n\n<p>Promise 对象的回调链，不管以 <code>then</code> 方法或 <code>catch</code> 方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个 <code>done</code> 方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>\n\n<pre><code>Promise.prototype.done = function (onFulfilled, onRejected) {  \n  this.then(onFulfilled, onRejected)\n    .catch(function (reason) {\n      // 抛出一个全局错误\n      setTimeout(() =&gt; { throw reason }, 0);\n    });\n};\n</code></pre>\n\n<p><code>finally</code></p>\n\n<p><code>finally</code> 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。它与 <code>done</code> 方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>\n\n<pre><code>Promise.prototype.finally = function (callback) {  \n  let P = this.constructor;\n  return this.then(\n    value  =&gt; P.resolve(callback()).then(() =&gt; value),\n    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })\n  );\n};\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476184607426,"created_by":1,"updated_at":1476757912166,"updated_by":1,"published_at":1476668407553,"published_by":1},{"id":114,"uuid":"ea251acb-9970-4566-b300-bbefafde12c8","title":"阮一峰、朴灵事件有感","slug":"ruan-yi-feng-po-ling-shi-jian-you-gan","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=29775264&auto=1&height=66\"></iframe>\n\n晚上给自己开了一个新坑，《js 的异步小结》。之前只是会写各种异步的代码，但是对于其机制和内部原理理解不深，所以就去找文章看了。首先想到的还是阮老师的文章，虽然说不是科班专业出生，但是文章一般都比较易懂。\n\n说到异步，必须了解 js 并发模型和 Event Loop，然后就读起了[JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)一文。这篇看下来感觉逻辑没有以前那么好，很多东西讲得不是很清楚，然后开始翻起评论来，看到下面同学们问题也不少，并且还有人提到朴灵老师（《深入浅出nodejs》作者）特地批注了这篇文章。\n\n于是找来了朴灵老师的批注。批注有些言语有些过了，如“等价个屁”，但整体来看朴灵确实在这个领域是很专业的。阮老师也很大度，在这篇文章上面特地加上了朴灵的这篇批注的链接。\n\n这个事件让我想到什么呢？\n\n首先，同样是非计算机专业出身的我，也存在着阮老师一样的问题，对于很多问题无法从操作系统、编译原理等更专业的角度去理解。没有学好操作系统，就很难真正地理解同步异步、cpu/io 等等，没有学好编译原理也就没有办法对语言本身有更加深入的理解。这是我在以前做项目时所没有意识到的，当时的我觉得可能把功能实现或是效果做出来就不错了。\n\n那么应该怎么做，当然是多读书咯。\n\n其次是，我的博客质量，说实话大多文章用心程度不够，大多只是自己能看懂吧，比起阮老师差很多。这也是我很佩服阮老师的一点，它能够很有耐心地去组织一篇文章，对很多刚刚入门的同学来说是相当好的资源。所以自己的博客质量也需要提高。\n\n最后要说的是，这件事其实没有谁对谁错。阮老师处于学习分享的目的我这种非科班的同学科普了不少知识，而朴灵老师则考虑到其文章受众相对广，对其中一些严重的错误给出指正确实也对我有所帮助（虽然表达方式个人觉得有些不妥）。\n\n奥还有一点，就是学习过程中如何辨别真伪？这是知乎上讨论这个问题时，朴灵提到的。但是对于很多自学者来说很难一开始就能够辨别真伪，对于知识往往是循序渐进地去接受。况且有些时候官方都不一定能够保证是正确的。所以这个其实很难界定，只有有了一定的知识储备以及学习能力，才能够更好地面对这个问题吧。\n\n好了，差不多就这么多！回去洗澡了，傍晚打球都臭了。明天开始研究异步模型和 Event Loop，得把操作系统什么的借来看看了。\n\n","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=29775264&auto=1&height=66\"></iframe>\n\n<p>晚上给自己开了一个新坑，《js 的异步小结》。之前只是会写各种异步的代码，但是对于其机制和内部原理理解不深，所以就去找文章看了。首先想到的还是阮老师的文章，虽然说不是科班专业出生，但是文章一般都比较易懂。</p>\n\n<p>说到异步，必须了解 js 并发模型和 Event Loop，然后就读起了<a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\">JavaScript 运行机制详解：再谈Event Loop</a>一文。这篇看下来感觉逻辑没有以前那么好，很多东西讲得不是很清楚，然后开始翻起评论来，看到下面同学们问题也不少，并且还有人提到朴灵老师（《深入浅出nodejs》作者）特地批注了这篇文章。</p>\n\n<p>于是找来了朴灵老师的批注。批注有些言语有些过了，如“等价个屁”，但整体来看朴灵确实在这个领域是很专业的。阮老师也很大度，在这篇文章上面特地加上了朴灵的这篇批注的链接。</p>\n\n<p>这个事件让我想到什么呢？</p>\n\n<p>首先，同样是非计算机专业出身的我，也存在着阮老师一样的问题，对于很多问题无法从操作系统、编译原理等更专业的角度去理解。没有学好操作系统，就很难真正地理解同步异步、cpu/io 等等，没有学好编译原理也就没有办法对语言本身有更加深入的理解。这是我在以前做项目时所没有意识到的，当时的我觉得可能把功能实现或是效果做出来就不错了。</p>\n\n<p>那么应该怎么做，当然是多读书咯。</p>\n\n<p>其次是，我的博客质量，说实话大多文章用心程度不够，大多只是自己能看懂吧，比起阮老师差很多。这也是我很佩服阮老师的一点，它能够很有耐心地去组织一篇文章，对很多刚刚入门的同学来说是相当好的资源。所以自己的博客质量也需要提高。</p>\n\n<p>最后要说的是，这件事其实没有谁对谁错。阮老师处于学习分享的目的我这种非科班的同学科普了不少知识，而朴灵老师则考虑到其文章受众相对广，对其中一些严重的错误给出指正确实也对我有所帮助（虽然表达方式个人觉得有些不妥）。</p>\n\n<p>奥还有一点，就是学习过程中如何辨别真伪？这是知乎上讨论这个问题时，朴灵提到的。但是对于很多自学者来说很难一开始就能够辨别真伪，对于知识往往是循序渐进地去接受。况且有些时候官方都不一定能够保证是正确的。所以这个其实很难界定，只有有了一定的知识储备以及学习能力，才能够更好地面对这个问题吧。</p>\n\n<p>好了，差不多就这么多！回去洗澡了，傍晚打球都臭了。明天开始研究异步模型和 Event Loop，得把操作系统什么的借来看看了。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476189407080,"created_by":1,"updated_at":1476191725089,"updated_by":1,"published_at":1476191267943,"published_by":1},{"id":115,"uuid":"a45ad8a6-b941-475c-8278-bd7d190689ef","title":"js 异步 I/O","slug":"js-yi-bu-i-o","markdown":"#### 单线程的 js\n\n讲 js 的单线程之前，先讲讲为什么操作系统要引入线程？这有助于后面的理解。\n\n早期的操作系统，如 Dos，早期的 Unix 都是只有进程的，DOS是单进程，早期的 Unix 是多进程。单进程的情况比较简单，这里就不写了。多进程的有两个互相制约的特点：独立、限制。\n\n独立性指的是进程之间是隔离的相互之间不会影响，限制性是指进程之间共享数据及状态同步比较困难。这两个特性是相互影响的。\n\n当一个进程内部同时存在耗时的 I/O 和 Cpu 操作时是无法并发的，但是如果把 I/O 和 Cpu 操作分到多个进程是可以并发执行的，只不过此时又存在信息共享的问题，并且开销较大。\n\n为了解决上面这个问题，Unix 系统在后面引入了线程的概念，它是为了提高进程内的并发性而出现的。一个进程内的多个线程能够共享内部的信息，并且像多进程那样由 Cpu 调度并发地执行。\n\n那么再来看看为什么 js 是单线程的？\n\n假定 js 同时有两个线程，一个线程在某个 dom 节点上添加内容，另一个线程删除了这个节点，该怎么办？其实这就是线程同步的问题，为了保持简单， js 在开始就设计为单线程，并且目前来看也不会改变，只会做出有限制的增强。例如为了利用多核 Cpu 的计算能力，HTML5 提出 Web Worker 标准，允许 js 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM 。所以，这个新标准并没有改变 js 单线程的本质。\n\n#### 同步异步、阻塞非阻塞\n\n这四个概念很容易混淆。\n\n同步异步和阻塞非阻塞的关注点不同，前者关注的是消息通信机制，后者关注的是程序在等待调用结果（消息，返回值）时的状态。\n\n操作系统内核对于 I/O 来说只有阻塞和非阻塞的说法。调用阻塞 I/O 时，必须等到 I/O 完成才返回结果，这会导致 Cpu 等待，浪费时间。而非阻塞 I/O 在调用之后会立即返回，非阻塞 I/O 返回之后，Cpu 可以用来处理其它事务。\n\n非阻塞 I/O 的问题在于第一次返回的内容并不是期望的数据，为了解决这个问题，一般的做法是反复轮询（read、select）或者 I/O 事件通知（Epoll）。以上的谈到的本质上都是同步 I/O，同步阻塞和同步非阻塞的区别。\n\n下面讲一下真正的异步非阻塞 I/O，Linux 下的 AIO 以及 Windows 下的 IOCP。以 IOCP 为例，在 I/O 完成以后通知然后触发回调，而同步非阻塞的 Epoll 的做法是在资源满足时通知，最后还需要去获取资源。用一句话来说就是‘同步非阻塞是半托管，异步非阻塞是全托管’。[详细介绍](https://yq.aliyun.com/articles/53621)\n\n上面对于同步异步、阻塞非阻塞的讨论都是基于单线程的，但是实际上不管是 Node 还是浏览器，实现异步 I/O 都是通过多个线程的。让多个 I/O 线程配合 js 主线程，通过线程间通信传递 I/O 得到的数据，这样做比较轻松，虽然只是种模拟。\n\n#### 为什么需要异步 I/O ？\n\n上面主要讲了异步 I/O 相关的一些概念。这一小节讲一下为什么需要异步 I/O？\n\n对于浏览器来说，因为 js 是单线程的并且和 ui 线程互斥，那么如果是同步 I/O，会造成浏览器卡死的情况，所以在浏览器端异步 I/O 是必须的。\n\n而对于服务端的 Node 来说：服务端程序中真正最耗时间的不是 Cpu 计算，而是 I/O 所耗的时间。如下图：\n\n![](https://ws3.sinaimg.cn/large/006bH5BKgw1f8qcek2vo9j30e50a2dga.jpg) \n\n传统的服务器语言，通常是通过多线程的方式，来提高并发的数量，线程创建、切换对服务器资源的消耗会很大。而单线程的 Node，有了异步 I/O 的能力，它能够同时处理多个请求而不会被 I/O 操作阻塞。（前面讲过对于操作系统来说 Cpu 和 I/O 不在同一个进程内时是可以并行进行的）同时资源的利用效率也较高。\n\n#### 异步 I/O 实现 \n\n首先区分两个概念：js 运行引擎（engine）和 js 运行环境（runtime）。\n\njs 引擎始终只有一个线程，它维护一个消息队列，当前函数栈执行完成之后就去不断地取消息队列中的消息（回调），取到了就执行。\n\njs 运行环境（存在多个线程），就负责给 js 引擎线程发送消息。比如浏览器 dom 事件发送一条鼠标点击的消息(浏览器子线程和 js 引擎线程的 IPC 通信)，那么 js 引擎在执行完函数栈之后就会取到这条鼠标点击信息，执行消息（即回调）。\n\n本小节要将的是两个运行环境：浏览器（Chrome 为例）和 Node。\n\n###### 浏览器（Chrome 为例）\n\nChrome 是一个多进程多线程的模型。\n\nChrome 有一个主进程，称为 Browser 进程，管理 Chrome 大部分的日常事务；其次，会有很多 Renderer 进程，各管理一组站点的显示和通信（简单理解一个tab对应一个进程），它们彼此互不搭理，只和 Browser 进程说话，由 Browser 进程负责权衡各方利益。进程间沟通的方式，称做IPC（Inter-Process Communication），这是 Google 搭的一套进程间通信的机制。\n\n对于 Renderer 进程，它们通常有两个线程，一个是 Main thread，它负责与老大进行联系；另一个是 Render thread，它们负责页面的渲染和交互。相比之下，Browser 进程负责的要多一些，除了 Main thread ，和负责与进程间通讯（IPC）的消息分发，以及网络资源请求的分发的 IO thread，还有负责文件读写的 file_thread， 负责访问本地的 SQLite 数据库的 db_thread 等等，它们各尽其责。它们和各 Renderer 进程的之间的关系不一样，同一个进程内的线程，往往需要很多的协同工作，这一坨线程间的并发管理，是 Chrome 最出彩的地方之一了。\n\nChrome 异步 I/O 就是基于多线程实现的。每一个 Chrome 的线程，入口函数都差不多，都是启动一个消息循环（这个消息循环应当就是我们平时讲的事件循环），等待并执行任务。\n\n![](https://ws2.sinaimg.cn/large/006bH5BKgw1f8qehih1qjj307j0c4mxa.jpg)\n\n图示将线程的消息循环处理描述的非常清楚，基本思路和 windows 的消息循环非常相似。当然，不同类型的线程并不会处理所有的事件，但所有的消息循环都会处理 Task。线程消息循环分为 MessageLoop 和 MessagePump，其中 MessageLoop 专门处理 Task，而 MessagePump 处理其他消息，发现 Task 时交给 MessageLoop。\n\n如果 A 线程想让 B 线程处理一个事务，A 只需创建一个 Task，将事务处理代码封装好，找到 B 线程的 MessageLoop 对象，调用 PostTask 方法将 Task 插入消息队列。PostTask 将立即返回，A 线程继续处理自己的消息循环。B 线程消息循环处理到 Task 时，调用其 Run 方法完成事务处理。\n\n看了上面一段，我大致意淫了一下 Chrome 是如何实现异步 I/O 的。js 线程调用 Ajax Api，此时会封装一个 Task 对象，调用 Ajax 线程（这个线程应该是从线程池中获取）的 PostTask 方法将 Task 插入消息队列。PostTask 将立即返回（立即返回哦），然后继续处理自己事务。Ajax 线程此时会读取消息队列中的 Task，调用其 Run 方法完成事务处理。调用完成以后，会封装一个 Task 对象插入 js 线程的消息队列，然后 js 线程的消息循环会读取消息队列中的 Task 并执行。\n\n抛开线程，它最后的表现就如下图：（但是要注意的一点是，消息循环和消息队列都是 Chrome 的实现机制，和 V8 引擎没有关系）\n\n![](https://ws4.sinaimg.cn/large/006bH5BKgw1f8qf29jdswj30gp0enq58.jpg)\n\n###### Node\n\n关于 Node 的异步 I/O 的实现，朴灵大大在《深入浅出 NodeJs》中写得很详细了，不过有些地方我还是表示有些怀疑的。这里主要讲一下和 Chrome 实现的异同。\n\n在 Node 中 js 启动时，会创建一个事件循环（不知道该不该说消息循环），这个循环在 Windows 下基于 IOCP，在 *nix 下基于多线程（LIBEIO 负责线程池，LIBEV 负责事件循环）。\n\n然后执行的过程主要如下，js 线程发起异步调用，封装请求对象，应该类似于 Chrome 中的 Task，从线程池中获取可用线程，执行异步任务，执行完成会向 js 线程的事件循环发出消息，然后执行回调。具体过程还是看朴灵大大的《深入浅出 NodeJs》\n\n###### 小结\n\n个人认为，Chrome 和 Node 本质上都是利用了线程池 + 消息循环的方式，使用多线程来模拟异步 I/O 的。更深入的研究就需要更多操作系统的知识，以及看源码了，对于目前还没有这个必要，循序渐进地来嘛。下面会写 js 的异步编程，敬请期待。\n\n参考资料：\n\n1. [chromium源码学习笔记](http://blog.sina.com.cn/s/articlelist_1224293203_4_1.html)\n2. 《深入浅出NodeJs》朴灵\n3. 《操作系统原理》清华大学\n4. [JavaScript：彻底理解同步、异步和事件循环(Event Loop)](https://segmentfault.com/a/1190000004322358)\n5. [为什么javascript是单线程的却能让AJAX异步调用？](http://www.cnblogs.com/yasmi/articles/5064588.html)\n6. [【朴灵评注】JavaScript 运行机制详解：再谈Event Loop](http://blog.csdn.net/lin_credible/article/details/40143961)\n7. [Node.JS Core explanation – 原理解释](http://geekblog.zhaoyan.me/node-js-core-explanation-%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A/#.V_41zZN95E4)\n8. [Philip Roberts: Help, I’m stuck in an event-loop.](https://vimeo.com/96425312)\n\n\n\n\n\n\n\n\n\n\n","html":"<h4 id=\"js\">单线程的 js</h4>\n\n<p>讲 js 的单线程之前，先讲讲为什么操作系统要引入线程？这有助于后面的理解。</p>\n\n<p>早期的操作系统，如 Dos，早期的 Unix 都是只有进程的，DOS是单进程，早期的 Unix 是多进程。单进程的情况比较简单，这里就不写了。多进程的有两个互相制约的特点：独立、限制。</p>\n\n<p>独立性指的是进程之间是隔离的相互之间不会影响，限制性是指进程之间共享数据及状态同步比较困难。这两个特性是相互影响的。</p>\n\n<p>当一个进程内部同时存在耗时的 I/O 和 Cpu 操作时是无法并发的，但是如果把 I/O 和 Cpu 操作分到多个进程是可以并发执行的，只不过此时又存在信息共享的问题，并且开销较大。</p>\n\n<p>为了解决上面这个问题，Unix 系统在后面引入了线程的概念，它是为了提高进程内的并发性而出现的。一个进程内的多个线程能够共享内部的信息，并且像多进程那样由 Cpu 调度并发地执行。</p>\n\n<p>那么再来看看为什么 js 是单线程的？</p>\n\n<p>假定 js 同时有两个线程，一个线程在某个 dom 节点上添加内容，另一个线程删除了这个节点，该怎么办？其实这就是线程同步的问题，为了保持简单， js 在开始就设计为单线程，并且目前来看也不会改变，只会做出有限制的增强。例如为了利用多核 Cpu 的计算能力，HTML5 提出 Web Worker 标准，允许 js 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM 。所以，这个新标准并没有改变 js 单线程的本质。</p>\n\n<h4 id=\"\">同步异步、阻塞非阻塞</h4>\n\n<p>这四个概念很容易混淆。</p>\n\n<p>同步异步和阻塞非阻塞的关注点不同，前者关注的是消息通信机制，后者关注的是程序在等待调用结果（消息，返回值）时的状态。</p>\n\n<p>操作系统内核对于 I/O 来说只有阻塞和非阻塞的说法。调用阻塞 I/O 时，必须等到 I/O 完成才返回结果，这会导致 Cpu 等待，浪费时间。而非阻塞 I/O 在调用之后会立即返回，非阻塞 I/O 返回之后，Cpu 可以用来处理其它事务。</p>\n\n<p>非阻塞 I/O 的问题在于第一次返回的内容并不是期望的数据，为了解决这个问题，一般的做法是反复轮询（read、select）或者 I/O 事件通知（Epoll）。以上的谈到的本质上都是同步 I/O，同步阻塞和同步非阻塞的区别。</p>\n\n<p>下面讲一下真正的异步非阻塞 I/O，Linux 下的 AIO 以及 Windows 下的 IOCP。以 IOCP 为例，在 I/O 完成以后通知然后触发回调，而同步非阻塞的 Epoll 的做法是在资源满足时通知，最后还需要去获取资源。用一句话来说就是‘同步非阻塞是半托管，异步非阻塞是全托管’。<a href=\"https://yq.aliyun.com/articles/53621\">详细介绍</a></p>\n\n<p>上面对于同步异步、阻塞非阻塞的讨论都是基于单线程的，但是实际上不管是 Node 还是浏览器，实现异步 I/O 都是通过多个线程的。让多个 I/O 线程配合 js 主线程，通过线程间通信传递 I/O 得到的数据，这样做比较轻松，虽然只是种模拟。</p>\n\n<h4 id=\"io\">为什么需要异步 I/O ？</h4>\n\n<p>上面主要讲了异步 I/O 相关的一些概念。这一小节讲一下为什么需要异步 I/O？</p>\n\n<p>对于浏览器来说，因为 js 是单线程的并且和 ui 线程互斥，那么如果是同步 I/O，会造成浏览器卡死的情况，所以在浏览器端异步 I/O 是必须的。</p>\n\n<p>而对于服务端的 Node 来说：服务端程序中真正最耗时间的不是 Cpu 计算，而是 I/O 所耗的时间。如下图：</p>\n\n<p><img src=\"https://ws3.sinaimg.cn/large/006bH5BKgw1f8qcek2vo9j30e50a2dga.jpg\" alt=\"\" title=\"\" /> </p>\n\n<p>传统的服务器语言，通常是通过多线程的方式，来提高并发的数量，线程创建、切换对服务器资源的消耗会很大。而单线程的 Node，有了异步 I/O 的能力，它能够同时处理多个请求而不会被 I/O 操作阻塞。（前面讲过对于操作系统来说 Cpu 和 I/O 不在同一个进程内时是可以并行进行的）同时资源的利用效率也较高。</p>\n\n<h4 id=\"io\">异步 I/O 实现</h4>\n\n<p>首先区分两个概念：js 运行引擎（engine）和 js 运行环境（runtime）。</p>\n\n<p>js 引擎始终只有一个线程，它维护一个消息队列，当前函数栈执行完成之后就去不断地取消息队列中的消息（回调），取到了就执行。</p>\n\n<p>js 运行环境（存在多个线程），就负责给 js 引擎线程发送消息。比如浏览器 dom 事件发送一条鼠标点击的消息(浏览器子线程和 js 引擎线程的 IPC 通信)，那么 js 引擎在执行完函数栈之后就会取到这条鼠标点击信息，执行消息（即回调）。</p>\n\n<p>本小节要将的是两个运行环境：浏览器（Chrome 为例）和 Node。</p>\n\n<h6 id=\"chrome\">浏览器（Chrome 为例）</h6>\n\n<p>Chrome 是一个多进程多线程的模型。</p>\n\n<p>Chrome 有一个主进程，称为 Browser 进程，管理 Chrome 大部分的日常事务；其次，会有很多 Renderer 进程，各管理一组站点的显示和通信（简单理解一个tab对应一个进程），它们彼此互不搭理，只和 Browser 进程说话，由 Browser 进程负责权衡各方利益。进程间沟通的方式，称做IPC（Inter-Process Communication），这是 Google 搭的一套进程间通信的机制。</p>\n\n<p>对于 Renderer 进程，它们通常有两个线程，一个是 Main thread，它负责与老大进行联系；另一个是 Render thread，它们负责页面的渲染和交互。相比之下，Browser 进程负责的要多一些，除了 Main thread ，和负责与进程间通讯（IPC）的消息分发，以及网络资源请求的分发的 IO thread，还有负责文件读写的 file<em>thread， 负责访问本地的 SQLite 数据库的 db</em>thread 等等，它们各尽其责。它们和各 Renderer 进程的之间的关系不一样，同一个进程内的线程，往往需要很多的协同工作，这一坨线程间的并发管理，是 Chrome 最出彩的地方之一了。</p>\n\n<p>Chrome 异步 I/O 就是基于多线程实现的。每一个 Chrome 的线程，入口函数都差不多，都是启动一个消息循环（这个消息循环应当就是我们平时讲的事件循环），等待并执行任务。</p>\n\n<p><img src=\"https://ws2.sinaimg.cn/large/006bH5BKgw1f8qehih1qjj307j0c4mxa.jpg\" alt=\"\" /></p>\n\n<p>图示将线程的消息循环处理描述的非常清楚，基本思路和 windows 的消息循环非常相似。当然，不同类型的线程并不会处理所有的事件，但所有的消息循环都会处理 Task。线程消息循环分为 MessageLoop 和 MessagePump，其中 MessageLoop 专门处理 Task，而 MessagePump 处理其他消息，发现 Task 时交给 MessageLoop。</p>\n\n<p>如果 A 线程想让 B 线程处理一个事务，A 只需创建一个 Task，将事务处理代码封装好，找到 B 线程的 MessageLoop 对象，调用 PostTask 方法将 Task 插入消息队列。PostTask 将立即返回，A 线程继续处理自己的消息循环。B 线程消息循环处理到 Task 时，调用其 Run 方法完成事务处理。</p>\n\n<p>看了上面一段，我大致意淫了一下 Chrome 是如何实现异步 I/O 的。js 线程调用 Ajax Api，此时会封装一个 Task 对象，调用 Ajax 线程（这个线程应该是从线程池中获取）的 PostTask 方法将 Task 插入消息队列。PostTask 将立即返回（立即返回哦），然后继续处理自己事务。Ajax 线程此时会读取消息队列中的 Task，调用其 Run 方法完成事务处理。调用完成以后，会封装一个 Task 对象插入 js 线程的消息队列，然后 js 线程的消息循环会读取消息队列中的 Task 并执行。</p>\n\n<p>抛开线程，它最后的表现就如下图：（但是要注意的一点是，消息循环和消息队列都是 Chrome 的实现机制，和 V8 引擎没有关系）</p>\n\n<p><img src=\"https://ws4.sinaimg.cn/large/006bH5BKgw1f8qf29jdswj30gp0enq58.jpg\" alt=\"\" /></p>\n\n<h6 id=\"node\">Node</h6>\n\n<p>关于 Node 的异步 I/O 的实现，朴灵大大在《深入浅出 NodeJs》中写得很详细了，不过有些地方我还是表示有些怀疑的。这里主要讲一下和 Chrome 实现的异同。</p>\n\n<p>在 Node 中 js 启动时，会创建一个事件循环（不知道该不该说消息循环），这个循环在 Windows 下基于 IOCP，在 *nix 下基于多线程（LIBEIO 负责线程池，LIBEV 负责事件循环）。</p>\n\n<p>然后执行的过程主要如下，js 线程发起异步调用，封装请求对象，应该类似于 Chrome 中的 Task，从线程池中获取可用线程，执行异步任务，执行完成会向 js 线程的事件循环发出消息，然后执行回调。具体过程还是看朴灵大大的《深入浅出 NodeJs》</p>\n\n<h6 id=\"\">小结</h6>\n\n<p>个人认为，Chrome 和 Node 本质上都是利用了线程池 + 消息循环的方式，使用多线程来模拟异步 I/O 的。更深入的研究就需要更多操作系统的知识，以及看源码了，对于目前还没有这个必要，循序渐进地来嘛。下面会写 js 的异步编程，敬请期待。</p>\n\n<p>参考资料：</p>\n\n<ol>\n<li><a href=\"http://blog.sina.com.cn/s/articlelist_1224293203_4_1.html\">chromium源码学习笔记</a>  </li>\n<li>《深入浅出NodeJs》朴灵  </li>\n<li>《操作系统原理》清华大学  </li>\n<li><a href=\"https://segmentfault.com/a/1190000004322358\">JavaScript：彻底理解同步、异步和事件循环(Event Loop)</a>  </li>\n<li><a href=\"http://www.cnblogs.com/yasmi/articles/5064588.html\">为什么javascript是单线程的却能让AJAX异步调用？</a>  </li>\n<li><a href=\"http://blog.csdn.net/lin_credible/article/details/40143961\">【朴灵评注】JavaScript 运行机制详解：再谈Event Loop</a>  </li>\n<li><a href=\"http://geekblog.zhaoyan.me/node-js-core-explanation-%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A/#.V_41zZN95E4\">Node.JS Core explanation – 原理解释</a>  </li>\n<li><a href=\"https://vimeo.com/96425312\">Philip Roberts: Help, I’m stuck in an event-loop.</a></li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476257582448,"created_by":1,"updated_at":1476326498473,"updated_by":1,"published_at":1476275326651,"published_by":1},{"id":116,"uuid":"de56250e-80e6-4316-80bb-f6a486e9d6b2","title":"对不起青春","slug":"dui-bu-qi-qing-chun","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=29775287&auto=1&height=66\"></iframe>\n\n先吐槽一下公安备案，真是效率低下，已经过去那么多天了，一个简单的网上审核都没有完成。光棍节那天如果还没有完成公安备案，阿里云就要把这个博客关了，真是一口老血。效率低怪我咯！\n\n好了收回坏情绪，写写这部剧，第二次看了，昨天中午忍不住刷完了最后两集。\n\n不剧透，讲讲为什么喜欢这部剧。\n\n第一是很多笑点，但是真正该认真、深情的时候，却真得能够触动观众，不做作。就像是一个段子手，认真讲起内心话的时候，很有魅力的样子，想到了薛之谦哈哈。\n\n第二点是人物的塑造，剧中的大多数人都存在着错误，但内心都是温柔善良的，所以都会在那档叫做《对不起青春》的电台节目上对别人说一声对不起。\n\n于是我也在想，如果我要说对不起是会对谁呢？想了很久，我也不知道，可能是无法直视自己真正的内心吧！现在的我能够想到的是对自己说对不起。\n\n第三是青春，青春有很多很多的样子，但是我挺喜欢《对不起青春》中所描述的这种。存在错误、失败、遗憾，但是仍能够开心地去面对。\n\n本以为有很多能写的，但是好像写不下去了，那就不写了，吃饭去。😳\n\n","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=29775287&auto=1&height=66\"></iframe>\n\n<p>先吐槽一下公安备案，真是效率低下，已经过去那么多天了，一个简单的网上审核都没有完成。光棍节那天如果还没有完成公安备案，阿里云就要把这个博客关了，真是一口老血。效率低怪我咯！</p>\n\n<p>好了收回坏情绪，写写这部剧，第二次看了，昨天中午忍不住刷完了最后两集。</p>\n\n<p>不剧透，讲讲为什么喜欢这部剧。</p>\n\n<p>第一是很多笑点，但是真正该认真、深情的时候，却真得能够触动观众，不做作。就像是一个段子手，认真讲起内心话的时候，很有魅力的样子，想到了薛之谦哈哈。</p>\n\n<p>第二点是人物的塑造，剧中的大多数人都存在着错误，但内心都是温柔善良的，所以都会在那档叫做《对不起青春》的电台节目上对别人说一声对不起。</p>\n\n<p>于是我也在想，如果我要说对不起是会对谁呢？想了很久，我也不知道，可能是无法直视自己真正的内心吧！现在的我能够想到的是对自己说对不起。</p>\n\n<p>第三是青春，青春有很多很多的样子，但是我挺喜欢《对不起青春》中所描述的这种。存在错误、失败、遗憾，但是仍能够开心地去面对。</p>\n\n<p>本以为有很多能写的，但是好像写不下去了，那就不写了，吃饭去。😳</p>","image":"/content/images/2016/10/704_1505115_268985-1.jpg","featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476275727115,"created_by":1,"updated_at":1476330194532,"updated_by":1,"published_at":1476329506409,"published_by":1},{"id":117,"uuid":"1a9ad12b-11d9-40ae-8193-df9b8d693687","title":"《WebKit 技术内幕》读书笔记","slug":"webkit-ji-zhu-nei-mu-du-shu-bi-ji","markdown":"昨天下午到今天下午图书馆没网，只好乖乖看看书，写了一些读书笔记，建了一个[仓库](https://github.com/xxn520/WebKit-Book-Reading-Notes)。\n\n####《WebKit 技术内幕》读书笔记\n\n作为一个 web 开发者，有必要更多地了解浏览器相关的知识。\n\n出于这个目的，阅读了这本《WebKit 技术内幕》，并做了读书笔记与大家分享。\n\n虽然是 14 年的书，可能有些内容已经过时了，但是还是很值得一读的。\n\n（话外音：主要是图书馆 wifi 信号没了，只能乖乖看看书，坐坐笔记！）\n\n后面考虑会做成 gitbook 的形式。\n\n[仓库地址](https://github.com/xxn520/WebKit-Book-Reading-Notes)","html":"<p>昨天下午到今天下午图书馆没网，只好乖乖看看书，写了一些读书笔记，建了一个<a href=\"https://github.com/xxn520/WebKit-Book-Reading-Notes\">仓库</a>。</p>\n\n<h4 id=\"webkit\">《WebKit 技术内幕》读书笔记</h4>\n\n<p>作为一个 web 开发者，有必要更多地了解浏览器相关的知识。</p>\n\n<p>出于这个目的，阅读了这本《WebKit 技术内幕》，并做了读书笔记与大家分享。</p>\n\n<p>虽然是 14 年的书，可能有些内容已经过时了，但是还是很值得一读的。</p>\n\n<p>（话外音：主要是图书馆 wifi 信号没了，只能乖乖看看书，坐坐笔记！）</p>\n\n<p>后面考虑会做成 gitbook 的形式。</p>\n\n<p><a href=\"https://github.com/xxn520/WebKit-Book-Reading-Notes\">仓库地址</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476430902832,"created_by":1,"updated_at":1476431126812,"updated_by":1,"published_at":1476431057160,"published_by":1},{"id":118,"uuid":"10f4d4fe-f5e2-4d59-aab0-19c9f2b49c68","title":"es6 Class&React","slug":"es6-class-react","markdown":"本文前半段简要地介绍 es6 Class 的用法以及一些扩展，后半部分将对 React 中 Mixin 为何在 es6 class 下无法使用、有什么替代方案等话题做深入的探讨。\n\nes6 Class 也是一个语法糖，它让 Js 面向对象的写法更加接近传统语言。\n\n#### 语法\n\n##### 基本语法\n\n1. 用 `class` 关键字定义类。\n2. 用 `constructor` 定义构造函数，是类的默认方法，`new` 的时候自动调用该方法，该默认返回实例对象。\n3. 类内部定义的所有方法都定义在类的 `prototype` 对象上，不可枚举，在 es5 `prototype` 上定义的方法是可以枚举的。\n4. 目前貌似是不支持在类内部定义属性，但是有提案已经提出，babel 已支持。\n5. Class 表达式，类似于函数表达式，还可以立即执行。 \n6. 不存在变量提升。\n7. 类内部默认为严格模式。\n\n##### 继承语法\n\n1. `extends` 实现继承。\n2. `super` 指代父类，子类必须在 `constructor` 中调用 `super` 方法，因为子类没有自己的 `this` 对象而是继承了父类的 `this` 对象进行加工，也是这个原因，`this` 只能在调用 `super` 之后才能使用。\n> es5 继承是先创造子类的实例，再把父类的方法添加上去；es6 相反是先创造父类的实例，然后再用子类的构造函数修改 `this`。\n\n3. 子类的 `__proto__` 指向父类；子类的 `prototype` 的 `__proto__` 指向父类的 `protorype`，实现了构造函数和构造函数原型的继承。\n4. es6 允许继承原生构造函数。\n5. 支持 get、set，但是不能有同名属性。\n\n##### 静态方法和属性\n\n`static` 关键字定义的方法不会被实例继承，而是直接通过类调用。但是子类可以调用父类的静态方法，因为 `Child.__proto__ = Parent`。\n\n而对于静态属性来说，es6 只支持下面的写法：\n\n```\nFoo.prop = 1\t\t// 有效\nclass Foo {\n\tprop: 1\t\t// 无效\n\t\n\tstatic: 1\t\t// 无效\n}\n```\n\n但是在写 React 时我们经常可以看到下面这种写法：\n\n```\nstatic propTypes = {\n        title: PropTypes.string,\n        type: PropTypes.string\n    };\n```\n\n这是因为 babel 支持 `static` 属性的写法，虽然目前这还只是一个提案。这个提案规定了实例属性和静态属性的新写法。\n\n```\nclass Foo {\n\tprop = 1;\t\t// 新的实例属性写法，定义在 `prototype` 上。\n\tstatic staticProp = 1;\t\t// 新的静态属性的写法。\n}\n```\n\n##### `new.target` 属性\n\n`new.target` 属性用来在构造函数中返回 `new` 命令所作用的构造函数，如果没有使用 `new` 命令则返回 `undefined`。挺有用的，它能够保证构造函数只能被 `new` 调用。\n\n因为子类会调用父类的构造函数，此时 `new.target` 的值是子类，那么父类中就可以根据这点来进行判断，这样就能够写出必须被继承才能使用的类。\n\n```\nclass Point {\n\tconstructor() {\n\t\tif (new.target === Point) {\n\t\t\tthrow new Error('我不能被实例化')\n\t\t}\n\t}\n}\n```\n\n##### 装饰器\n\n装饰器是一个表达式，用来修改类的行为。目前处于提案阶段，babel 已支持。\n\n装饰器本质上是编译时执行的函数。长期来看，它将是静态分析的重要工具。\n\n###### 类的装饰\n\n```\nfunction mixins(...list) {\n\treturn function(target) {\n\t\tObject.assign(target.prototype, ...list)\n\t}\n}\n\n@mixins(Foo) \nclass MyClass {}\n\nlet Foo = {\n\tfoo() { console.log('foo') }\n}\n```\n\n###### 方法的装饰\n\n```\nfunction readonly(target, name, descriptor) {\n\tdescriptor.writeable = true\n\treturn descriptor\n}\n\nclass Person() {\n\t@readonly\n\tname() {\n\t\tconsole.log('name')\n\t}\n}\n```\n\n###### 装饰器的应用\n\ncore-decorators.js 是一个第三方模块，提供了常见的装饰器。\n\nPostal.js 实现了自动事件发布，有点 AOP 的味道，确实 Js 的装饰器可以用来实现简单的 AOP（在编译阶段向指向的方法前加一些公共的逻辑）。\n\nMixin 是将一个对象的方法混入另一个对象，来替代继承，上面类装饰器的例子就是简单的用装饰器实现了 Mixin。\n\ntrait-decorator 类似于 Mixin，但是提供更多的功能。\n\n#### React Mixins 和 Decorators\n\n在使用 React 过程中，我们肯定会有是使用 es5 写法还是 es6 class 写法的疑问，有一种常见的说法就是使用 es6 class 无法使用 Mixin，如 TimeMixin 等等。那么背后的原理是什么，有什么好的解决方案（比如高阶组件），最后一小节就将对这些相关的话题进行深入的探讨。\n\n先从 Mixin 讲起，上面已经简单提到了 Mixin，这里就详细讲一下。[React Mixin 的前世今生](https://segmentfault.com/a/1190000004034031)一文中讲到，Mixin 是为了实现 C++ 中多重继承类似的效果，提高抽象能力而被一些语言引入的。在 Js 中的 Mixin 的主要表现就是上文讲的将 mixins 对象里的方法都挂载到原对象上，就实现了对对象的混入。\n\n但是在 React 中，Mixin 不仅仅是拷贝对象的方法那么简单，主要的区别在于对于生命周期方法，React 的 Mixin 会帮我们合并 `props` 和 `state`。如果有很多 Mixin 来定义 `componentDidMount` 这个周期，那 React 会非常智能的将它们都合并起来执行。\n同样地，Mixin 也可以作用在 `getInitialState` 的结果上，作 `state` 的合并，同时 `props` 也是这样合并。\n\n不过不幸的是对于 es6 class，facebook 并没有像 es5 的 `createClass` 那样为我们提供类似的机制。那么下面我们就来探索 es6 class 下有什么能够代替 es5 写法下 Mixin 的东西。\n\n###### Decorator\n\n针对普通的 Mixin（也就是不提供生命周期方法合并），我们可以使用上面提到的 Decorator 来实现。下面是 core-decorators.js 为我们提供的 `@mixin` 装饰器：\n\n```\nfunction handleClass(target, mixins) {\n  if (!mixins.length) {\n    throw new SyntaxError(`@mixin() class ${target.name} requires at least one mixin as an argument`);\n  }\n\n  for (let i = 0, l = mixins.length; i < l; i++) {\n    // 获取属性描述符\n    const descs = getOwnPropertyDescriptors(mixins[i]);\n\n    for (const key of getOwnKeys(descs)) {\n      // 如果属性已经存在则不定义，否则将其定义到目标对象的原型对象上\n      if (!(hasProperty(key, target.prototype))) {\n        defineProperty(target.prototype, key, descs[key]);\n      }\n    }\n  }\n}\n\nexport default function mixin(...mixins) {\n  if (typeof mixins[0] === 'function') {\n    return handleClass(mixins[0], []);\n  } else {\n    return target => {\n      return handleClass(target, mixins);\n    };\n  }\n}\n``` \n\n其实和我上面写的那个用 `Object.assign` 实现的类似。对于普通的工具方法，我们完全可以使用上面的方法，但是针对生命周期方法，还要想别的办法。\n\n###### Higher-Order Component\n\nReact 核心开发成员 Sebastian Markbåge 在 GitHub 提出了 Higher-Order Component（高阶组件）的概念。它借鉴了 FP（函数式编程）中 Higher-Order function（高阶函数）的思路。高阶函数就是我们平时用的 `map`、`reduce` 这类把函数作为参数传入的函数。而高阶组件本质上就是把组件作为参数传入函数，封装新的组件返回。\n\n```\nimport React, { Component } from 'React';\n\nconst PopupContainer = (Wrapper) =>\n  class WrapperComponent extends Component {\n    componentDidMount() {\n      console.log('HOC did mount')\n    }\n\n    componentWillUnmount() {\n      console.log('HOC will unmount')\n    }\n\n    render() {\n      return <Wrapper {...this.props} />;\n    }\n  }\n```\n\n```\nimport React, { Component } from 'React';\n\nclass MyComponent extends Component {\n  render() {}\n}\n\nexport default PopupContainer(MyStatelessComponent);\n// 或\nimport React, { Component } from 'React';\n\n@PopupContainer\nclass MyComponent extends Component {\n  render() {}\n}\n\nexport default MyComponent;\n``` \n\n而对于嵌套的高阶组件，除了可以使用嵌套和多个装饰器外，还可以用函数式编程的方式来处理：\n\n```\nimport React, { Component } from 'React';\n\n// 来自 https://gist.github.com/jmurzy/f5b339d6d4b694dc36dd\nlet as = T => (...traits) => traits.reverse().reduce((T, M) => M(T), T);\n\nclass MyComponent extends as(Component)(Mixin1, Mixin2, Mixin3(param)) { }\n\n// 或\n\nimport React, { Component } from 'React';\nimport R from 'ramda';\n\nconst mixins = R.compose(Mixin3(param), Mixin2, Mixin1);\n\nclass MyComponent extends mixins(Component) {}\n```\n\n再回到生命周期的问题，首先这里生命周期不存在覆盖的情况，并且会按照一定的顺序执行，执行的顺序大致如下：`didmount` -> `HOC didmount` -> `(HOCs didmount)` -> `(HOCs will unmount)` -> `HOC will unmount` -> `unmount`。经测试是正确的。\n\n那么接下来要看的是是否能够实现 `props` 以及 `state` 的组合呢？当然是可以的，高阶组件可以把它的 `props` 以及 `state` 都传给内部组件的，从外向内的传递，来达到组合的目的。\n\n除了上面的写法，我们也可以用继承的方式来写高阶组件，此处略。\n\n目前来看，高阶函数可以代替 Mixin 的大部分场景，不过更具体的以及实践性的内容到使用的时候 React 部分再进行吧！\n\n\n\n\n\n\n","html":"<p>本文前半段简要地介绍 es6 Class 的用法以及一些扩展，后半部分将对 React 中 Mixin 为何在 es6 class 下无法使用、有什么替代方案等话题做深入的探讨。</p>\n\n<p>es6 Class 也是一个语法糖，它让 Js 面向对象的写法更加接近传统语言。</p>\n\n<h4 id=\"\">语法</h4>\n\n<h5 id=\"\">基本语法</h5>\n\n<ol>\n<li>用 <code>class</code> 关键字定义类。  </li>\n<li>用 <code>constructor</code> 定义构造函数，是类的默认方法，<code>new</code> 的时候自动调用该方法，该默认返回实例对象。  </li>\n<li>类内部定义的所有方法都定义在类的 <code>prototype</code> 对象上，不可枚举，在 es5 <code>prototype</code> 上定义的方法是可以枚举的。  </li>\n<li>目前貌似是不支持在类内部定义属性，但是有提案已经提出，babel 已支持。  </li>\n<li>Class 表达式，类似于函数表达式，还可以立即执行。  </li>\n<li>不存在变量提升。  </li>\n<li>类内部默认为严格模式。</li>\n</ol>\n\n<h5 id=\"\">继承语法</h5>\n\n<ol>\n<li><code>extends</code> 实现继承。  </li>\n<li><p><code>super</code> 指代父类，子类必须在 <code>constructor</code> 中调用 <code>super</code> 方法，因为子类没有自己的 <code>this</code> 对象而是继承了父类的 <code>this</code> 对象进行加工，也是这个原因，<code>this</code> 只能在调用 <code>super</code> 之后才能使用。  </p>\n\n<blockquote>\n  <p>es5 继承是先创造子类的实例，再把父类的方法添加上去；es6 相反是先创造父类的实例，然后再用子类的构造函数修改 <code>this</code>。</p>\n</blockquote></li>\n<li><p>子类的 <code>__proto__</code> 指向父类；子类的 <code>prototype</code> 的 <code>__proto__</code> 指向父类的 <code>protorype</code>，实现了构造函数和构造函数原型的继承。  </p></li>\n<li>es6 允许继承原生构造函数。  </li>\n<li>支持 get、set，但是不能有同名属性。</li>\n</ol>\n\n<h5 id=\"\">静态方法和属性</h5>\n\n<p><code>static</code> 关键字定义的方法不会被实例继承，而是直接通过类调用。但是子类可以调用父类的静态方法，因为 <code>Child.__proto__ = Parent</code>。</p>\n\n<p>而对于静态属性来说，es6 只支持下面的写法：</p>\n\n<pre><code>Foo.prop = 1        // 有效  \nclass Foo {  \n    prop: 1     // 无效\n\n    static: 1       // 无效\n}\n</code></pre>\n\n<p>但是在写 React 时我们经常可以看到下面这种写法：</p>\n\n<pre><code>static propTypes = {  \n        title: PropTypes.string,\n        type: PropTypes.string\n    };\n</code></pre>\n\n<p>这是因为 babel 支持 <code>static</code> 属性的写法，虽然目前这还只是一个提案。这个提案规定了实例属性和静态属性的新写法。</p>\n\n<pre><code>class Foo {  \n    prop = 1;       // 新的实例属性写法，定义在 `prototype` 上。\n    static staticProp = 1;      // 新的静态属性的写法。\n}\n</code></pre>\n\n<h5 id=\"newtarget\"><code>new.target</code> 属性</h5>\n\n<p><code>new.target</code> 属性用来在构造函数中返回 <code>new</code> 命令所作用的构造函数，如果没有使用 <code>new</code> 命令则返回 <code>undefined</code>。挺有用的，它能够保证构造函数只能被 <code>new</code> 调用。</p>\n\n<p>因为子类会调用父类的构造函数，此时 <code>new.target</code> 的值是子类，那么父类中就可以根据这点来进行判断，这样就能够写出必须被继承才能使用的类。</p>\n\n<pre><code>class Point {  \n    constructor() {\n        if (new.target === Point) {\n            throw new Error('我不能被实例化')\n        }\n    }\n}\n</code></pre>\n\n<h5 id=\"\">装饰器</h5>\n\n<p>装饰器是一个表达式，用来修改类的行为。目前处于提案阶段，babel 已支持。</p>\n\n<p>装饰器本质上是编译时执行的函数。长期来看，它将是静态分析的重要工具。</p>\n\n<h6 id=\"\">类的装饰</h6>\n\n<pre><code>function mixins(...list) {  \n    return function(target) {\n        Object.assign(target.prototype, ...list)\n    }\n}\n\n@mixins(Foo) \nclass MyClass {}\n\nlet Foo = {  \n    foo() { console.log('foo') }\n}\n</code></pre>\n\n<h6 id=\"\">方法的装饰</h6>\n\n<pre><code>function readonly(target, name, descriptor) {  \n    descriptor.writeable = true\n    return descriptor\n}\n\nclass Person() {  \n    @readonly\n    name() {\n        console.log('name')\n    }\n}\n</code></pre>\n\n<h6 id=\"\">装饰器的应用</h6>\n\n<p>core-decorators.js 是一个第三方模块，提供了常见的装饰器。</p>\n\n<p>Postal.js 实现了自动事件发布，有点 AOP 的味道，确实 Js 的装饰器可以用来实现简单的 AOP（在编译阶段向指向的方法前加一些公共的逻辑）。</p>\n\n<p>Mixin 是将一个对象的方法混入另一个对象，来替代继承，上面类装饰器的例子就是简单的用装饰器实现了 Mixin。</p>\n\n<p>trait-decorator 类似于 Mixin，但是提供更多的功能。</p>\n\n<h4 id=\"reactmixinsdecorators\">React Mixins 和 Decorators</h4>\n\n<p>在使用 React 过程中，我们肯定会有是使用 es5 写法还是 es6 class 写法的疑问，有一种常见的说法就是使用 es6 class 无法使用 Mixin，如 TimeMixin 等等。那么背后的原理是什么，有什么好的解决方案（比如高阶组件），最后一小节就将对这些相关的话题进行深入的探讨。</p>\n\n<p>先从 Mixin 讲起，上面已经简单提到了 Mixin，这里就详细讲一下。<a href=\"https://segmentfault.com/a/1190000004034031\">React Mixin 的前世今生</a>一文中讲到，Mixin 是为了实现 C++ 中多重继承类似的效果，提高抽象能力而被一些语言引入的。在 Js 中的 Mixin 的主要表现就是上文讲的将 mixins 对象里的方法都挂载到原对象上，就实现了对对象的混入。</p>\n\n<p>但是在 React 中，Mixin 不仅仅是拷贝对象的方法那么简单，主要的区别在于对于生命周期方法，React 的 Mixin 会帮我们合并 <code>props</code> 和 <code>state</code>。如果有很多 Mixin 来定义 <code>componentDidMount</code> 这个周期，那 React 会非常智能的将它们都合并起来执行。\n同样地，Mixin 也可以作用在 <code>getInitialState</code> 的结果上，作 <code>state</code> 的合并，同时 <code>props</code> 也是这样合并。</p>\n\n<p>不过不幸的是对于 es6 class，facebook 并没有像 es5 的 <code>createClass</code> 那样为我们提供类似的机制。那么下面我们就来探索 es6 class 下有什么能够代替 es5 写法下 Mixin 的东西。</p>\n\n<h6 id=\"decorator\">Decorator</h6>\n\n<p>针对普通的 Mixin（也就是不提供生命周期方法合并），我们可以使用上面提到的 Decorator 来实现。下面是 core-decorators.js 为我们提供的 <code>@mixin</code> 装饰器：</p>\n\n<pre><code>function handleClass(target, mixins) {  \n  if (!mixins.length) {\n    throw new SyntaxError(`@mixin() class ${target.name} requires at least one mixin as an argument`);\n  }\n\n  for (let i = 0, l = mixins.length; i &lt; l; i++) {\n    // 获取属性描述符\n    const descs = getOwnPropertyDescriptors(mixins[i]);\n\n    for (const key of getOwnKeys(descs)) {\n      // 如果属性已经存在则不定义，否则将其定义到目标对象的原型对象上\n      if (!(hasProperty(key, target.prototype))) {\n        defineProperty(target.prototype, key, descs[key]);\n      }\n    }\n  }\n}\n\nexport default function mixin(...mixins) {  \n  if (typeof mixins[0] === 'function') {\n    return handleClass(mixins[0], []);\n  } else {\n    return target =&gt; {\n      return handleClass(target, mixins);\n    };\n  }\n}\n</code></pre>\n\n<p>其实和我上面写的那个用 <code>Object.assign</code> 实现的类似。对于普通的工具方法，我们完全可以使用上面的方法，但是针对生命周期方法，还要想别的办法。</p>\n\n<h6 id=\"higherordercomponent\">Higher-Order Component</h6>\n\n<p>React 核心开发成员 Sebastian Markbåge 在 GitHub 提出了 Higher-Order Component（高阶组件）的概念。它借鉴了 FP（函数式编程）中 Higher-Order function（高阶函数）的思路。高阶函数就是我们平时用的 <code>map</code>、<code>reduce</code> 这类把函数作为参数传入的函数。而高阶组件本质上就是把组件作为参数传入函数，封装新的组件返回。</p>\n\n<pre><code>import React, { Component } from 'React';\n\nconst PopupContainer = (Wrapper) =&gt;  \n  class WrapperComponent extends Component {\n    componentDidMount() {\n      console.log('HOC did mount')\n    }\n\n    componentWillUnmount() {\n      console.log('HOC will unmount')\n    }\n\n    render() {\n      return &lt;Wrapper {...this.props} /&gt;;\n    }\n  }\n</code></pre>\n\n<pre><code>import React, { Component } from 'React';\n\nclass MyComponent extends Component {  \n  render() {}\n}\n\nexport default PopupContainer(MyStatelessComponent);  \n// 或\nimport React, { Component } from 'React';\n\n@PopupContainer\nclass MyComponent extends Component {  \n  render() {}\n}\n\nexport default MyComponent;  \n</code></pre>\n\n<p>而对于嵌套的高阶组件，除了可以使用嵌套和多个装饰器外，还可以用函数式编程的方式来处理：</p>\n\n<pre><code>import React, { Component } from 'React';\n\n// 来自 https://gist.github.com/jmurzy/f5b339d6d4b694dc36dd\nlet as = T =&gt; (...traits) =&gt; traits.reverse().reduce((T, M) =&gt; M(T), T);\n\nclass MyComponent extends as(Component)(Mixin1, Mixin2, Mixin3(param)) { }\n\n// 或\n\nimport React, { Component } from 'React';  \nimport R from 'ramda';\n\nconst mixins = R.compose(Mixin3(param), Mixin2, Mixin1);\n\nclass MyComponent extends mixins(Component) {}  \n</code></pre>\n\n<p>再回到生命周期的问题，首先这里生命周期不存在覆盖的情况，并且会按照一定的顺序执行，执行的顺序大致如下：<code>didmount</code> -> <code>HOC didmount</code> -> <code>(HOCs didmount)</code> -> <code>(HOCs will unmount)</code> -> <code>HOC will unmount</code> -> <code>unmount</code>。经测试是正确的。</p>\n\n<p>那么接下来要看的是是否能够实现 <code>props</code> 以及 <code>state</code> 的组合呢？当然是可以的，高阶组件可以把它的 <code>props</code> 以及 <code>state</code> 都传给内部组件的，从外向内的传递，来达到组合的目的。</p>\n\n<p>除了上面的写法，我们也可以用继承的方式来写高阶组件，此处略。</p>\n\n<p>目前来看，高阶函数可以代替 Mixin 的大部分场景，不过更具体的以及实践性的内容到使用的时候 React 部分再进行吧！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476442754347,"created_by":1,"updated_at":1476883772614,"updated_by":1,"published_at":1476859315753,"published_by":1},{"id":119,"uuid":"173f8dd8-1699-467d-91d5-c3f6fa3479c2","title":"Promise/A+ 规范翻译","slug":"promise-a-gui-fan-fan-yi","markdown":"一个 promise 对象代表了一个异步操作的最终结果。我们主要通过 `then` 方法来跟 promise 对象打交道，这里讲的 `then` 方法可以注册两个回调，第一个回调接收异步操作的最终结果，第二个回调接收无法 promise 对象转变为 fulfilled 状态的原因。\n\n这个规范详细地规定了 `then` 方法的行为，提供了一个所有 Promises/A+ 的实现能够依赖的具有一致性的交互基础。因此，这个规范被认为是十分稳定的。此外虽然 Promises/A+ 组织偶尔会针对一些新发现做一些向后兼容的修正，但是我们只会在经过仔细地考虑、讨论、测试后整合大的或者向后兼容的改动。\n\n从历史来看，Promise/A+ 建立在先前 [Promises/A proposal](http://wiki.commonjs.org/wiki/Promises/A) 规范的行为之上，并且加入了一些非规范的事实标准，去除了一些错误的部分。\n\n最终，核心的 Promises/A+ 规范不处理如何创建、fulfill 或者 reject promises 对象，而是选择来关注提供一个交互性的 `then` 方法。未来对于相关规范的工作可能也会触及这些主题。\n\n### 1. 术语\n\n1. “promise” 是一个带有 `then` 方法的对象或者函数，`then` 方法的行为符合这个规范。\n2. “thenable” 是一个定义了 `then` 方法的对象或者函数，但是不要求 `then` 方法的行为符合这个规范。\n3. “value” 是任何合法的 JavaScript 值（包括 `undefined`、一个 thenable、一个 promise）。\n4. “exception” 是一个被 `throw` 表达式抛出的错误值。\n5. “reason” 是一个表明 promise 对象变为 rejected 状态原因的值。\n\n### 2. 要求\n\n#### Promise 状态\n\n一个 promise 必须是下面三个状态之一：pending、fulfilled、rejected。\n\n- 当处于 pending 状态：\n - 也许被转变为 fulfilled 或 rejected 状态。\n- 当处于 fulfilled 状态：\n - 不能再转变为任何其它状态。\n - 必须有一个不可变的 value。\n- 当处于 rejected 状态：\n - 不能再转变为任何其它状态。\n - 必须有一个不可变的 reason。\n\n这里的不可变值得是引用的不可变，而不保证引用内部的变化，类似于 `===`。\n \n#### `then` 方法\n\n一个 promise 必须提供一个 `then` 方法来访问它自身或者最终结果或则 reason。\n\n一个 promise 的 `then` 方法接受两个参数：\n\n```\npromise.then(onFulfilled, onRejected)\n```\n\n1. `onFulfilled` 和 `onRejected` 都是可选的参数：\n 1. 如果 `onFulfilled` 不是函数，必须被忽略。\n 2. 如果 `onRejected` 不是函数，必须被忽略。\n2. 如果 `onFulfilled` 是一个函数：\n 1. 在 `promise` 变为 fulfilled 状态后，必须被调用，并把 `promise` 的 value 作为第一个参数传递。\n 2. 不能够在 `promise` 变为 fulfilled 状态前被调用。\n 3. 不能够被多次调用。\n3. 如果 `onRejected` 是一个函数：\n 1. 在 `promise` 变为 rejected 状态后，必须被调用，并把 `promise` 的 reason 作为第一个参数传递。\n 2. 不能够在 `promise` 变为 rejected 状态前被调用。\n 3. 不能够被多次调用。\n4. `onFulfilled` 和 `onRejected` 直到执行上下文栈只包含平台代码（见注意点 3.1）才能够执行。\n5. `onFulfilled` 和 `onRejected` 必须作为函数被调用（即没有 `this`，注意点 3.2）\n6. 在同一个 promise 上，`then` 可能会被调用多次。\n 1. 当 `promise` fulfilled，所有的 `onFulfilled` 将被执行按 `then` 被调用位置的顺序。\n 2. 当 `promise` rejected，所有的 `onRejected` 将被执行按 `then` 被调用位置的顺序。\n7. `then` 必须返回一个 promise（见注意点 3.3） \n```\npromise2 = promise1.then(onFulfilled, onRejected);\n```\n 1. 如果 `onFulfilled` 或 `onRejected` 返回了值 `x`，则运行 Promise Resolve 过程 `[[Resolve]](promise2, x)`。\n 2. 如果 `onFulfilled` 或 `onRejected` 抛出了异常 `e`，则 `promise2` 应当以 `e` 为 reason 被拒绝。\n 3. 如果 `onFulfilled` 不是一个函数并且 `promise1` 已经 fulfilled，`promise2` 必须被用 `promise1` 同样的 value fulfilled。\n 4. 如果 `onRejected ` 不是一个函数并且 `promise1` 已经 rejected，`promise2` 必须被用 `promise1` 同样的 value rejected。\n\n#### Promise Resolve 过程\n\nPromise Resolve 过程是一个抽象操作，输入一个 promise 和一个 value，表示成 `[[Resolve]](promise, value)`。如果 `x` 是一个 thenable，若 `x`的行为与 promise 类似，则使 `promise` 采用 `x` 的状态。否则，用 `x` 覆盖 `promise`。\n\n运行 `[[Resolve]](promise, x)`，表现为如下步骤：\n\n1. 如果 `promise` 和 `x` 是同一个对象，那么用一个 `TypeError` 为 reason reject `promise`。\n2. 如果 `x` 是一个 promise，采用它的状态（见注意点 3.4）：\n 1. 如果 `x` 是 pending 状态, promise 必须保持 pending 直到 `x` 变为 fulfilled 或 rejected 状态。\n 2. 如果 `x` 是 fulfilled 状态，用相同的 value fulfill promise。\n 3. 如果 `x` 是 rejected 状态，用相同的 reason reject promise。\n3. 否则 `x` 是一个对象或者函数。\n 1. 把 `x.then` 赋值给 `then`。（见注意点 3.5）\n 2. 如果此时 `x.then` 导致了异常，那么就把 `e` 作为 reason reject promise。\n 3. 如果 `then` 是一个函数，以 `x` 为 `this`，第一个参数是 `resolvePromise`，第二个参数是 `rejectPromise`。\n     1. 当 `resolvePromise` 被以 y 为参数调用，执行 `[[Resolve]](promise, y)`\n     2. 当 `rejectPromise` 被以 `r` 为参数调用，则以 `r` 为 reason reject `promise`。\n     3. 如果 `resolvePromise` 和 `rejectPromise` 都被调用，或者多个调用同属在一个参数上触发，第一个调用具有优先权，并且其它的调用都被忽略。\n     4. 如果调用 `then` 抛出了异常 `e`：\n         1. 如果 `resolvePromise` 或 `rejectPromise` 已经被调用了，则忽略它。\n         2. 否则，用 `e` 为 reason reject `promise`。\n 4. 如果 `then` 不是一个函数，则 以 `x` 为值 fulfill promise。\n4. 如果 `x` 不是对象也不是函数，则以 `x` 为值 fulfill promise。\n\n如果一个 promise 用一个 thenable 来 resolve，会带来循环的 thenable 链，`[[Resolve]](promise, thenable)` 的递归性质最终会造成 `[[Resolve]](promise, thenable)` 被再次调用，按照上面的算法将会导致无穷递归。对于实现来说检测这种递归然后用 `TypeError` 作为 reason reject `promise` 是鼓励的做法，但不是必须的。\n\n### 3. 注意点     \n\n1. 这里的平台代码指的是引擎、环境以及 promise 的实现代码。在实践中，这个要求可以保证 `onFulfilled` 和 `onRejected` 被异步地执行，`then` 是在事件循环中被调用的，它有一个新鲜的调用栈。这可以使用如 `setTimeout` 或者 `setImmediate` 这类 “macro-task” 机制来实现，也可以使用 `MutationObserver` 或 `process.nextTick` 这类 “micro-task” 机制来实现。当 promise 的实现在考虑平台代码的时候，也可以自己包含一个任务调度队列，在队列内部处理器被调用。\n2. 在严格模式下 `this` 将是 `undefined`，宽松模式下，将是全局对象。\n3. 实现也许允许 `promise2 === promise1`，这使得实现能够满足所有的要求。但是每一个实现应当注明是否能够产生 `promise2 === promise1` 以及在什么情况下可以。\n4. 通常情况下，他只会被认为 `x` 是一个真的 promise，如果它来自当前的实现。这个条款允许特定实现有办法接受来自已知一致性 promises 的状态。\n5. 把 `x.then` 赋值给 `then`，主要是为了防止多次访问 `x.then`，而 `x.then` 在多次访问中可能会被改变，导致不一致的情况出现。 \n\n","html":"<p>一个 promise 对象代表了一个异步操作的最终结果。我们主要通过 <code>then</code> 方法来跟 promise 对象打交道，这里讲的 <code>then</code> 方法可以注册两个回调，第一个回调接收异步操作的最终结果，第二个回调接收无法 promise 对象转变为 fulfilled 状态的原因。</p>\n\n<p>这个规范详细地规定了 <code>then</code> 方法的行为，提供了一个所有 Promises/A+ 的实现能够依赖的具有一致性的交互基础。因此，这个规范被认为是十分稳定的。此外虽然 Promises/A+ 组织偶尔会针对一些新发现做一些向后兼容的修正，但是我们只会在经过仔细地考虑、讨论、测试后整合大的或者向后兼容的改动。</p>\n\n<p>从历史来看，Promise/A+ 建立在先前 <a href=\"http://wiki.commonjs.org/wiki/Promises/A\">Promises/A proposal</a> 规范的行为之上，并且加入了一些非规范的事实标准，去除了一些错误的部分。</p>\n\n<p>最终，核心的 Promises/A+ 规范不处理如何创建、fulfill 或者 reject promises 对象，而是选择来关注提供一个交互性的 <code>then</code> 方法。未来对于相关规范的工作可能也会触及这些主题。</p>\n\n<h3 id=\"1\">1. 术语</h3>\n\n<ol>\n<li>“promise” 是一个带有 <code>then</code> 方法的对象或者函数，<code>then</code> 方法的行为符合这个规范。  </li>\n<li>“thenable” 是一个定义了 <code>then</code> 方法的对象或者函数，但是不要求 <code>then</code> 方法的行为符合这个规范。  </li>\n<li>“value” 是任何合法的 JavaScript 值（包括 <code>undefined</code>、一个 thenable、一个 promise）。  </li>\n<li>“exception” 是一个被 <code>throw</code> 表达式抛出的错误值。  </li>\n<li>“reason” 是一个表明 promise 对象变为 rejected 状态原因的值。</li>\n</ol>\n\n<h3 id=\"2\">2. 要求</h3>\n\n<h4 id=\"promise\">Promise 状态</h4>\n\n<p>一个 promise 必须是下面三个状态之一：pending、fulfilled、rejected。</p>\n\n<ul>\n<li>当处于 pending 状态：\n<ul><li>也许被转变为 fulfilled 或 rejected 状态。</li></ul></li>\n<li>当处于 fulfilled 状态：\n<ul><li>不能再转变为任何其它状态。</li>\n<li>必须有一个不可变的 value。</li></ul></li>\n<li>当处于 rejected 状态：\n<ul><li>不能再转变为任何其它状态。</li>\n<li>必须有一个不可变的 reason。</li></ul></li>\n</ul>\n\n<p>这里的不可变值得是引用的不可变，而不保证引用内部的变化，类似于 <code>===</code>。</p>\n\n<h4 id=\"then\"><code>then</code> 方法</h4>\n\n<p>一个 promise 必须提供一个 <code>then</code> 方法来访问它自身或者最终结果或则 reason。</p>\n\n<p>一个 promise 的 <code>then</code> 方法接受两个参数：</p>\n\n<pre><code>promise.then(onFulfilled, onRejected)  \n</code></pre>\n\n<ol>\n<li><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选的参数： <br />\n<ol><li>如果 <code>onFulfilled</code> 不是函数，必须被忽略。</li>\n<li>如果 <code>onRejected</code> 不是函数，必须被忽略。</li></ol></li>\n<li>如果 <code>onFulfilled</code> 是一个函数： <br />\n<ol><li>在 <code>promise</code> 变为 fulfilled 状态后，必须被调用，并把 <code>promise</code> 的 value 作为第一个参数传递。</li>\n<li>不能够在 <code>promise</code> 变为 fulfilled 状态前被调用。</li>\n<li>不能够被多次调用。</li></ol></li>\n<li>如果 <code>onRejected</code> 是一个函数： <br />\n<ol><li>在 <code>promise</code> 变为 rejected 状态后，必须被调用，并把 <code>promise</code> 的 reason 作为第一个参数传递。</li>\n<li>不能够在 <code>promise</code> 变为 rejected 状态前被调用。</li>\n<li>不能够被多次调用。</li></ol></li>\n<li><code>onFulfilled</code> 和 <code>onRejected</code> 直到执行上下文栈只包含平台代码（见注意点 3.1）才能够执行。  </li>\n<li><code>onFulfilled</code> 和 <code>onRejected</code> 必须作为函数被调用（即没有 <code>this</code>，注意点 3.2）  </li>\n<li>在同一个 promise 上，<code>then</code> 可能会被调用多次。 <br />\n<ol><li>当 <code>promise</code> fulfilled，所有的 <code>onFulfilled</code> 将被执行按 <code>then</code> 被调用位置的顺序。</li>\n<li>当 <code>promise</code> rejected，所有的 <code>onRejected</code> 将被执行按 <code>then</code> 被调用位置的顺序。</li></ol></li>\n<li><code>then</code> 必须返回一个 promise（见注意点 3.3）  </li>\n</ol>\n\n<pre><code>promise2 = promise1.then(onFulfilled, onRejected);  \n</code></pre>\n\n<ol>\n<li>如果 <code>onFulfilled</code> 或 <code>onRejected</code> 返回了值 <code>x</code>，则运行 Promise Resolve 过程 <code>[[Resolve]](promise2, x)</code>。</li>\n<li>如果 <code>onFulfilled</code> 或 <code>onRejected</code> 抛出了异常 <code>e</code>，则 <code>promise2</code> 应当以 <code>e</code> 为 reason 被拒绝。</li>\n<li>如果 <code>onFulfilled</code> 不是一个函数并且 <code>promise1</code> 已经 fulfilled，<code>promise2</code> 必须被用 <code>promise1</code> 同样的 value fulfilled。</li>\n<li>如果 <code>onRejected</code> 不是一个函数并且 <code>promise1</code> 已经 rejected，<code>promise2</code> 必须被用 <code>promise1</code> 同样的 value rejected。</li>\n</ol>\n\n<h4 id=\"promiseresolve\">Promise Resolve 过程</h4>\n\n<p>Promise Resolve 过程是一个抽象操作，输入一个 promise 和一个 value，表示成 <code>[[Resolve]](promise, value)</code>。如果 <code>x</code> 是一个 thenable，若 <code>x</code>的行为与 promise 类似，则使 <code>promise</code> 采用 <code>x</code> 的状态。否则，用 <code>x</code> 覆盖 <code>promise</code>。</p>\n\n<p>运行 <code>[[Resolve]](promise, x)</code>，表现为如下步骤：</p>\n\n<ol>\n<li>如果 <code>promise</code> 和 <code>x</code> 是同一个对象，那么用一个 <code>TypeError</code> 为 reason reject <code>promise</code>。  </li>\n<li>如果 <code>x</code> 是一个 promise，采用它的状态（见注意点 3.4）： <br />\n<ol><li>如果 <code>x</code> 是 pending 状态, promise 必须保持 pending 直到 <code>x</code> 变为 fulfilled 或 rejected 状态。</li>\n<li>如果 <code>x</code> 是 fulfilled 状态，用相同的 value fulfill promise。</li>\n<li>如果 <code>x</code> 是 rejected 状态，用相同的 reason reject promise。</li></ol></li>\n<li>否则 <code>x</code> 是一个对象或者函数。 <br />\n<ol><li>把 <code>x.then</code> 赋值给 <code>then</code>。（见注意点 3.5）</li>\n<li>如果此时 <code>x.then</code> 导致了异常，那么就把 <code>e</code> 作为 reason reject promise。</li>\n<li>如果 <code>then</code> 是一个函数，以 <code>x</code> 为 <code>this</code>，第一个参数是 <code>resolvePromise</code>，第二个参数是 <code>rejectPromise</code>。\n<ol><li>当 <code>resolvePromise</code> 被以 y 为参数调用，执行 <code>[[Resolve]](promise, y)</code></li>\n<li>当 <code>rejectPromise</code> 被以 <code>r</code> 为参数调用，则以 <code>r</code> 为 reason reject <code>promise</code>。</li>\n<li>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 都被调用，或者多个调用同属在一个参数上触发，第一个调用具有优先权，并且其它的调用都被忽略。</li>\n<li>如果调用 <code>then</code> 抛出了异常 <code>e</code>：\n<ol><li>如果 <code>resolvePromise</code> 或 <code>rejectPromise</code> 已经被调用了，则忽略它。</li>\n<li>否则，用 <code>e</code> 为 reason reject <code>promise</code>。</li></ol></li></ol></li>\n<li>如果 <code>then</code> 不是一个函数，则 以 <code>x</code> 为值 fulfill promise。</li></ol></li>\n<li>如果 <code>x</code> 不是对象也不是函数，则以 <code>x</code> 为值 fulfill promise。</li>\n</ol>\n\n<p>如果一个 promise 用一个 thenable 来 resolve，会带来循环的 thenable 链，<code>[[Resolve]](promise, thenable)</code> 的递归性质最终会造成 <code>[[Resolve]](promise, thenable)</code> 被再次调用，按照上面的算法将会导致无穷递归。对于实现来说检测这种递归然后用 <code>TypeError</code> 作为 reason reject <code>promise</code> 是鼓励的做法，但不是必须的。</p>\n\n<h3 id=\"3\">3. 注意点</h3>\n\n<ol>\n<li>这里的平台代码指的是引擎、环境以及 promise 的实现代码。在实践中，这个要求可以保证 <code>onFulfilled</code> 和 <code>onRejected</code> 被异步地执行，<code>then</code> 是在事件循环中被调用的，它有一个新鲜的调用栈。这可以使用如 <code>setTimeout</code> 或者 <code>setImmediate</code> 这类 “macro-task” 机制来实现，也可以使用 <code>MutationObserver</code> 或 <code>process.nextTick</code> 这类 “micro-task” 机制来实现。当 promise 的实现在考虑平台代码的时候，也可以自己包含一个任务调度队列，在队列内部处理器被调用。  </li>\n<li>在严格模式下 <code>this</code> 将是 <code>undefined</code>，宽松模式下，将是全局对象。  </li>\n<li>实现也许允许 <code>promise2 === promise1</code>，这使得实现能够满足所有的要求。但是每一个实现应当注明是否能够产生 <code>promise2 === promise1</code> 以及在什么情况下可以。  </li>\n<li>通常情况下，他只会被认为 <code>x</code> 是一个真的 promise，如果它来自当前的实现。这个条款允许特定实现有办法接受来自已知一致性 promises 的状态。  </li>\n<li>把 <code>x.then</code> 赋值给 <code>then</code>，主要是为了防止多次访问 <code>x.then</code>，而 <code>x.then</code> 在多次访问中可能会被改变，导致不一致的情况出现。 </li>\n</ol>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476520008182,"created_by":1,"updated_at":1476521163357,"updated_by":1,"published_at":1476520037520,"published_by":1},{"id":120,"uuid":"29bf1d73-d5cf-4e96-beb1-38ea1caa9910","title":"随笔","slug":"sui-bi-6","markdown":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=86367&auto=1&height=66\"></iframe>\n\n这两天的感受：学习过程中知道怎么做是件相对来说很容易的事，但是要去了解内部的原理、怎么实现是件很费劲的事。\n\n当前大环境下大多数的学习都停留在前面这个层次，以前的我也是如此，但是经过这段时间的学习，虽然不知道做后面这件事是否有实际的价值，但是确实是有一定的必要的。\n\n平衡，我觉得在两种学习的姿态中间找到平衡是很当下的一个关注点，因为一直做后面这件事往往效率很低，在很多场景是不能接受的。当然现在的我每天泡图书馆是能够接受的。\n\n下一个话题是想到一个不错的 idea，因为在网易云音乐听歌时经常能够看到精彩的评论，所以想做一个根据精彩评论推荐歌曲的音乐社区系统。具体的模式还没有想好，但是确实是个不错的东西，因为 ST 被封以后就没有比较好的音乐社区了。而精彩评论作为切入点进行音乐的分享，是个不错的方式。\n\n下一个话题是关于前几天看的《花牌情缘-下之句》，和上之句不同，下之句把重点放在了个人与团队的微妙关系。个人赛也是团体赛。要相信团队中的人，而不是一个人大包大揽。这个虽然乍一看很美好，我也希望生活中都能这样，但是确实很难做到，可能我离一个好的领导者还差十万八千里吧！不过如果可能，我是愿意去分担和相信的。\n\n下一个话题《黑客与画家》，虽然才看了第一章，但是确实写得不错，不过有些在国内情况差别比较大。但是他给了我新的思路去思考这个世代的一些问题。等看完了要好好想想。\n\nover！昨天喝多了，今天状态好像不太好！！！\n\n\n\n","html":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=86367&auto=1&height=66\"></iframe>\n\n<p>这两天的感受：学习过程中知道怎么做是件相对来说很容易的事，但是要去了解内部的原理、怎么实现是件很费劲的事。</p>\n\n<p>当前大环境下大多数的学习都停留在前面这个层次，以前的我也是如此，但是经过这段时间的学习，虽然不知道做后面这件事是否有实际的价值，但是确实是有一定的必要的。</p>\n\n<p>平衡，我觉得在两种学习的姿态中间找到平衡是很当下的一个关注点，因为一直做后面这件事往往效率很低，在很多场景是不能接受的。当然现在的我每天泡图书馆是能够接受的。</p>\n\n<p>下一个话题是想到一个不错的 idea，因为在网易云音乐听歌时经常能够看到精彩的评论，所以想做一个根据精彩评论推荐歌曲的音乐社区系统。具体的模式还没有想好，但是确实是个不错的东西，因为 ST 被封以后就没有比较好的音乐社区了。而精彩评论作为切入点进行音乐的分享，是个不错的方式。</p>\n\n<p>下一个话题是关于前几天看的《花牌情缘-下之句》，和上之句不同，下之句把重点放在了个人与团队的微妙关系。个人赛也是团体赛。要相信团队中的人，而不是一个人大包大揽。这个虽然乍一看很美好，我也希望生活中都能这样，但是确实很难做到，可能我离一个好的领导者还差十万八千里吧！不过如果可能，我是愿意去分担和相信的。</p>\n\n<p>下一个话题《黑客与画家》，虽然才看了第一章，但是确实写得不错，不过有些在国内情况差别比较大。但是他给了我新的思路去思考这个世代的一些问题。等看完了要好好想想。</p>\n\n<p>over！昨天喝多了，今天状态好像不太好！！！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476691722133,"created_by":1,"updated_at":1476700048684,"updated_by":1,"published_at":1476692668892,"published_by":1},{"id":121,"uuid":"897f77f5-ca27-4de8-bf41-4c1e5804b352","title":"js 异步编程之 Generator","slug":"js-yi-bu-bian-cheng-zhi-generator","markdown":"### 语法\n\n```\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloWorldGenerator();\n```\n\n拿例子来开头，Generator 函数的定义是在函数名前加 `*` 号，星号的位置建议上面例子中这种。\n\n调用 Generator 函数返回的是一个迭代器对象，但是函数是不会执行的，利用这个特点可以用来做惰性求值。另外可以使用 `for...of` 来进行遍历。\n\n既然返回的是迭代器对象，那么就可以调用 `next()` 方法来遍历 Generator 函数的内部状态。调用 `hw.next()`，此时会执行函数，直到遇到 `yield 'hello'`，`yield` 后的表达式的值作为 `next` 调用结果的 `value` 属性，另外还有一个 `done` 属性表示是否迭代是否结束。因此第一次调用的返回值是`{value:'hello',done:false}`。之后继续调用 `next` 会从上一次 `next()` 执行到的地方开始继续执行。直到 `return`，`return` 后的表达式也会作为结果的 `value` 属性，此时 `done` 为 `true`。从表现上来看，`yield` 就像是暂停了函数的执行，等到需要继续执行的时候可以继续执行。\n\n`yield` 还有以下几个注意点：\n\n- Generator 函数内可以没有，此时相当于一个延迟执行的函数。\n- 不能够在普通函数中使用。\n- 在表达式中使用需要加 `()`。\n- 函数参数或赋值时等号右边可以不用 `()`。 \n\n`next` 的注意点：\n\n- 可以接收参数，作为上一个 `yield` 表达式的返回值（默认为 `undefined`），这是很有用的特性，外部像内部注入值，可以对内部状态做简单地控制。\n- 由于 `next` 方法的参数表示上一个 `yield` 语句的返回值，所以第一次使用 `next` 方法时，不能带有参数。V8 引擎直接忽略第一次使用 `next` 方法时的参数，只有从第二次使用 `next` 方法开始，参数才是有效的。从语义上讲，第一个 `next` 方法用来启动遍历器对象，所以不用带有参数。\n\n#### `Generator.prototype.throw()`\n\n这可以让 Generator 函数返回的迭代器对象在外部 `throw`，并且可以在内部可以被捕获，而普通的全局 `throw` 只能在外部进行捕获。\n\n`throw` 方法被捕获以后，会附带执行下一条 `yield` 语句。也就是说，会附带执行一次`next` 方法。 \n\n在内部抛出的错误，如果内部没有捕获，可以在外部进行捕获，外部捕获后还调用 `next` 方法，将返回一个 `value` 属性等于 `undefined`、`done` 属性等于 `true` 的对象。如果都没有捕获，那么程序将报错终止。\n\n#### `Generator.prototype.return()`\n\n返回给定的值，并且终结遍历 Generator 函数。如果内部存在 `try...catch...finally` 语句，那么会延迟到 `finally` 执行以后。\n\n#### `yield*`\n\n`yield` 后面加一个 Generator 函数，此时返回的是一个迭代器对象，而 `yield*` 后面加一个 Generator 函数，则会去遍历这个迭代器对象。也就是达到使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。实际上，任何数据结构只要有 Iterator 接口，就可以被 `yield*` 遍历。\n\n看个例子帮助理解：\n\n```\nfunction* foo() {\n  yield 'a';\n  yield 'b';\n}\n\nfunction* bar() {\n  yield 'x';\n  yield* foo();\n  yield 'y';\n}\n\n// 等同于\n\nfunction* bar() {\n  yield 'x';\n  for (let v of foo()) {\n    yield v;\n  }\n  yield 'y';\n}\n\nfor (let v of bar()){\n  console.log(v);\n}\n// \"x\"\n// \"a\"\n// \"b\"\n// \"y\"\n```\n\n#### 作为对象属性\n\n```\nlet obj = {\n  * myGeneratorMethod() {\n    ···\n  }\n};\n//或\nlet obj = {\n  myGeneratorMethod: function* () {\n    // ···\n  }\n};\n```\n\n#### Generator 函数的 `this`\n\nGenerator 函数总是返回一个遍历器，es6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 `prototype` 对象上的方法。\n\nGenerator 函数不能够使用 `new`。下面有一种变通做法：\n\n```\nfunction* gen() {\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\n\nfunction F() {\n  return gen.call(gen.prototype);\n}\n\nvar f = new F();\n\nf.next();  // Object {value: 2, done: false}\nf.next();  // Object {value: 3, done: false}\nf.next();  // Object {value: undefined, done: true}\n\nf.a // 1\nf.b // 2\nf.c // 3\n```\n\n#### Generator 与 协程\n\n协程其实是一个比较老的东西了，通俗地讲就是用户态的线程，与平时所说的内核态线程不同，用户态线程一般是编译器实现的，很多语言都提供了对于协程的支持，如 `Lua`、`Python`。编译器可以为协程保存调用栈，这样可以使得函数恢复执行，看起来就像是把一个函数拆分成了多个子函数依次调用。（具体还是要去回顾一下操作系统的知识）\n\n协程本身其实不是“异步的”，但是它这种让函数暂停执行的特点，可以很好地封装控制多个异步任务串行地执行，也就是达到异步代码同步写法的目的。\n\n### Generator 与异步流程控制\n\n先来看一个例子：\n\n```\nvar fetch = require('node-fetch');\n\nfunction* gen(){\n  var url = 'https://api.github.com/users/github';\n  var result = yield fetch(url);\n  console.log(result.bio);\n}\n\nvar g = gen();\nvar result = g.next();\n\nresult.value.then(function(data){\n  return data.json();\n}).then(function(data){\n  g.next(data);\n});\n```\n\n从上面这个例子来看，单纯的 Generator 函数来进行异步流程管理很麻烦，每次还需要在 `then` 中调用 `next` 执行下一个任务，这比起直接用 Promise 的方案好不到哪里去。\n\n于是有人想到，对于不含异步任务的 Generator 函数，我们可以像下面一下自动执行：\n\n```\nfunction* gen() {\n  // ...\n}\n\nvar g = gen();\nvar res = g.next();\n\nwhile(!res.done){\n  console.log(res.value);\n  res = g.next();\n}\n```\n\n那么是否有办法能够对于存在异步任务的 Generator 函数也提供自动执行的方案呢？于是有人想到了 Thunk 函数，传统意义上的 Thunk 函数就是把参数的表达式放到函数内，来达到传名求值的目的。在 JavaScript 中稍微有些不同，它是用来替换多参数函数，而不是表达式，并且只有回调函数作为参数。\n\n在我看来其实本质上是偏函数的应用，把除了回调函数意外的参数确定，返回一个只接受回调函数的新函数，这个函数就是 Thunk 函数。\n\n任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单 Thunk 函数转换器：\n\n```\nvar Thunk = function(fn){\n  return function (){\n    var args = Array.prototype.slice.call(arguments);\n    return function (callback){\n      args.push(callback);\n      return fn.apply(this, args);\n    }\n  };\n};\n```\n\n在生产环境，推荐使用 TJ 大神的\n[node-thunkify](https://github.com/tj/node-thunkify)，里面有一些优化以及异常的处理。\n\n那么 Thunk 函数是如何运用到 Generator 自动流程管理中的呢？简单地将就是将 `next` 作为 Thunk 函数的回调函数传入，那么 Thunk 函数封装的异步操作结束之后就会自动调用 `next` 执行下一个异步操作，就是这么简单。下面是一个简单的自动执行器：\n\n```\nfunction run(fn) {\n  var gen = fn();\n  function next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value(next);\n  }\n  next();\n}\nfunction* g() {\n  // ...\n}\nrun(g);\n```\n\n然后来看看著名的[co 模块](https://github.com/tj/co)，同样也是 TJ 大神的作品。co 模块的作用也是自动执行 Generator，来进行流程控制。\n\nco 并不是使用 Thunk 的回调来进行流程控制的，而是利用了 `Promise.then`，它会在异步操作结束以后在，`onFulfilled` 方法中调用 `next` 来执行下一个任务。当然 co 也支持 Thunk、Array、Object 等，只不过它会在 `next` 中把它们转换成 `promise` 对象。co 最后返回一个 `promise` 还可以进行后续的操作。\n\nGenerator + co，我们已经可以用同步的写法来写异步代码了，除了有 `yield`。唯一的一点点缺陷就是语义化 `*`  和 `yield` 语义化差点，而且要加入自动执行器，这如果能够在语言层面提供岂不是更好。\n\n### 小结\n\nGenerator 本身不是异步的，但是其暂停执行的特点很适合来做异步流程的控制，于是结合Thunk 或 Promise 封装的异步操作，加上自动执行器，进行自动流程控制成为了一种不错的异步编程的写法。因为它相较于前面的任何写法都更加地同步化，易于阅读和编写。\n","html":"<h3 id=\"\">语法</h3>\n\n<pre><code>function* helloWorldGenerator() {  \n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloWorldGenerator();  \n</code></pre>\n\n<p>拿例子来开头，Generator 函数的定义是在函数名前加 <code>*</code> 号，星号的位置建议上面例子中这种。</p>\n\n<p>调用 Generator 函数返回的是一个迭代器对象，但是函数是不会执行的，利用这个特点可以用来做惰性求值。另外可以使用 <code>for...of</code> 来进行遍历。</p>\n\n<p>既然返回的是迭代器对象，那么就可以调用 <code>next()</code> 方法来遍历 Generator 函数的内部状态。调用 <code>hw.next()</code>，此时会执行函数，直到遇到 <code>yield 'hello'</code>，<code>yield</code> 后的表达式的值作为 <code>next</code> 调用结果的 <code>value</code> 属性，另外还有一个 <code>done</code> 属性表示是否迭代是否结束。因此第一次调用的返回值是<code>{value:'hello',done:false}</code>。之后继续调用 <code>next</code> 会从上一次 <code>next()</code> 执行到的地方开始继续执行。直到 <code>return</code>，<code>return</code> 后的表达式也会作为结果的 <code>value</code> 属性，此时 <code>done</code> 为 <code>true</code>。从表现上来看，<code>yield</code> 就像是暂停了函数的执行，等到需要继续执行的时候可以继续执行。</p>\n\n<p><code>yield</code> 还有以下几个注意点：</p>\n\n<ul>\n<li>Generator 函数内可以没有，此时相当于一个延迟执行的函数。</li>\n<li>不能够在普通函数中使用。</li>\n<li>在表达式中使用需要加 <code>()</code>。</li>\n<li>函数参数或赋值时等号右边可以不用 <code>()</code>。 </li>\n</ul>\n\n<p><code>next</code> 的注意点：</p>\n\n<ul>\n<li>可以接收参数，作为上一个 <code>yield</code> 表达式的返回值（默认为 <code>undefined</code>），这是很有用的特性，外部像内部注入值，可以对内部状态做简单地控制。</li>\n<li>由于 <code>next</code> 方法的参数表示上一个 <code>yield</code> 语句的返回值，所以第一次使用 <code>next</code> 方法时，不能带有参数。V8 引擎直接忽略第一次使用 <code>next</code> 方法时的参数，只有从第二次使用 <code>next</code> 方法开始，参数才是有效的。从语义上讲，第一个 <code>next</code> 方法用来启动遍历器对象，所以不用带有参数。</li>\n</ul>\n\n<h4 id=\"generatorprototypethrow\"><code>Generator.prototype.throw()</code></h4>\n\n<p>这可以让 Generator 函数返回的迭代器对象在外部 <code>throw</code>，并且可以在内部可以被捕获，而普通的全局 <code>throw</code> 只能在外部进行捕获。</p>\n\n<p><code>throw</code> 方法被捕获以后，会附带执行下一条 <code>yield</code> 语句。也就是说，会附带执行一次<code>next</code> 方法。 </p>\n\n<p>在内部抛出的错误，如果内部没有捕获，可以在外部进行捕获，外部捕获后还调用 <code>next</code> 方法，将返回一个 <code>value</code> 属性等于 <code>undefined</code>、<code>done</code> 属性等于 <code>true</code> 的对象。如果都没有捕获，那么程序将报错终止。</p>\n\n<h4 id=\"generatorprototypereturn\"><code>Generator.prototype.return()</code></h4>\n\n<p>返回给定的值，并且终结遍历 Generator 函数。如果内部存在 <code>try...catch...finally</code> 语句，那么会延迟到 <code>finally</code> 执行以后。</p>\n\n<h4 id=\"yield\"><code>yield*</code></h4>\n\n<p><code>yield</code> 后面加一个 Generator 函数，此时返回的是一个迭代器对象，而 <code>yield*</code> 后面加一个 Generator 函数，则会去遍历这个迭代器对象。也就是达到使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。实际上，任何数据结构只要有 Iterator 接口，就可以被 <code>yield*</code> 遍历。</p>\n\n<p>看个例子帮助理解：</p>\n\n<pre><code>function* foo() {  \n  yield 'a';\n  yield 'b';\n}\n\nfunction* bar() {  \n  yield 'x';\n  yield* foo();\n  yield 'y';\n}\n\n// 等同于\n\nfunction* bar() {  \n  yield 'x';\n  for (let v of foo()) {\n    yield v;\n  }\n  yield 'y';\n}\n\nfor (let v of bar()){  \n  console.log(v);\n}\n// \"x\"\n// \"a\"\n// \"b\"\n// \"y\"\n</code></pre>\n\n<h4 id=\"\">作为对象属性</h4>\n\n<pre><code>let obj = {  \n  * myGeneratorMethod() {\n    ···\n  }\n};\n//或\nlet obj = {  \n  myGeneratorMethod: function* () {\n    // ···\n  }\n};\n</code></pre>\n\n<h4 id=\"generatorthis\">Generator 函数的 <code>this</code></h4>\n\n<p>Generator 函数总是返回一个遍历器，es6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 <code>prototype</code> 对象上的方法。</p>\n\n<p>Generator 函数不能够使用 <code>new</code>。下面有一种变通做法：</p>\n\n<pre><code>function* gen() {  \n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n}\n\nfunction F() {  \n  return gen.call(gen.prototype);\n}\n\nvar f = new F();\n\nf.next();  // Object {value: 2, done: false}  \nf.next();  // Object {value: 3, done: false}  \nf.next();  // Object {value: undefined, done: true}\n\nf.a // 1  \nf.b // 2  \nf.c // 3  \n</code></pre>\n\n<h4 id=\"generator\">Generator 与 协程</h4>\n\n<p>协程其实是一个比较老的东西了，通俗地讲就是用户态的线程，与平时所说的内核态线程不同，用户态线程一般是编译器实现的，很多语言都提供了对于协程的支持，如 <code>Lua</code>、<code>Python</code>。编译器可以为协程保存调用栈，这样可以使得函数恢复执行，看起来就像是把一个函数拆分成了多个子函数依次调用。（具体还是要去回顾一下操作系统的知识）</p>\n\n<p>协程本身其实不是“异步的”，但是它这种让函数暂停执行的特点，可以很好地封装控制多个异步任务串行地执行，也就是达到异步代码同步写法的目的。</p>\n\n<h3 id=\"generator\">Generator 与异步流程控制</h3>\n\n<p>先来看一个例子：</p>\n\n<pre><code>var fetch = require('node-fetch');\n\nfunction* gen(){  \n  var url = 'https://api.github.com/users/github';\n  var result = yield fetch(url);\n  console.log(result.bio);\n}\n\nvar g = gen();  \nvar result = g.next();\n\nresult.value.then(function(data){  \n  return data.json();\n}).then(function(data){\n  g.next(data);\n});\n</code></pre>\n\n<p>从上面这个例子来看，单纯的 Generator 函数来进行异步流程管理很麻烦，每次还需要在 <code>then</code> 中调用 <code>next</code> 执行下一个任务，这比起直接用 Promise 的方案好不到哪里去。</p>\n\n<p>于是有人想到，对于不含异步任务的 Generator 函数，我们可以像下面一下自动执行：</p>\n\n<pre><code>function* gen() {  \n  // ...\n}\n\nvar g = gen();  \nvar res = g.next();\n\nwhile(!res.done){  \n  console.log(res.value);\n  res = g.next();\n}\n</code></pre>\n\n<p>那么是否有办法能够对于存在异步任务的 Generator 函数也提供自动执行的方案呢？于是有人想到了 Thunk 函数，传统意义上的 Thunk 函数就是把参数的表达式放到函数内，来达到传名求值的目的。在 JavaScript 中稍微有些不同，它是用来替换多参数函数，而不是表达式，并且只有回调函数作为参数。</p>\n\n<p>在我看来其实本质上是偏函数的应用，把除了回调函数意外的参数确定，返回一个只接受回调函数的新函数，这个函数就是 Thunk 函数。</p>\n\n<p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单 Thunk 函数转换器：</p>\n\n<pre><code>var Thunk = function(fn){  \n  return function (){\n    var args = Array.prototype.slice.call(arguments);\n    return function (callback){\n      args.push(callback);\n      return fn.apply(this, args);\n    }\n  };\n};\n</code></pre>\n\n<p>在生产环境，推荐使用 TJ 大神的\n<a href=\"https://github.com/tj/node-thunkify\">node-thunkify</a>，里面有一些优化以及异常的处理。</p>\n\n<p>那么 Thunk 函数是如何运用到 Generator 自动流程管理中的呢？简单地将就是将 <code>next</code> 作为 Thunk 函数的回调函数传入，那么 Thunk 函数封装的异步操作结束之后就会自动调用 <code>next</code> 执行下一个异步操作，就是这么简单。下面是一个简单的自动执行器：</p>\n\n<pre><code>function run(fn) {  \n  var gen = fn();\n  function next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value(next);\n  }\n  next();\n}\nfunction* g() {  \n  // ...\n}\nrun(g);  \n</code></pre>\n\n<p>然后来看看著名的<a href=\"https://github.com/tj/co\">co 模块</a>，同样也是 TJ 大神的作品。co 模块的作用也是自动执行 Generator，来进行流程控制。</p>\n\n<p>co 并不是使用 Thunk 的回调来进行流程控制的，而是利用了 <code>Promise.then</code>，它会在异步操作结束以后在，<code>onFulfilled</code> 方法中调用 <code>next</code> 来执行下一个任务。当然 co 也支持 Thunk、Array、Object 等，只不过它会在 <code>next</code> 中把它们转换成 <code>promise</code> 对象。co 最后返回一个 <code>promise</code> 还可以进行后续的操作。</p>\n\n<p>Generator + co，我们已经可以用同步的写法来写异步代码了，除了有 <code>yield</code>。唯一的一点点缺陷就是语义化 <code>*</code>  和 <code>yield</code> 语义化差点，而且要加入自动执行器，这如果能够在语言层面提供岂不是更好。</p>\n\n<h3 id=\"\">小结</h3>\n\n<p>Generator 本身不是异步的，但是其暂停执行的特点很适合来做异步流程的控制，于是结合Thunk 或 Promise 封装的异步操作，加上自动执行器，进行自动流程控制成为了一种不错的异步编程的写法。因为它相较于前面的任何写法都更加地同步化，易于阅读和编写。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476692940012,"created_by":1,"updated_at":1476757743686,"updated_by":1,"published_at":1476757451501,"published_by":1},{"id":122,"uuid":"5972af42-4a6a-4366-8094-219de90615e2","title":"js 异步编程之 Async 函数","slug":"js-yi-bu-bian-cheng-zhi-async-han-shu","markdown":"上面一篇讲到 Generator + co 的异步流程控制方案，在文章最后写到了这个方案的一些小瑕疵，而 Async 函数就是继续改进的一个方案，Node 7 已经支持了这个特性，而它在下一年也将正式进入 es 2017 的标准。那么就来看看这是个什么东西吧！\n\n```\nco(function* (){\n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n});\n\n// 等同于 async function 下面的写法\n\n(async function(){\n  var f1 = await readFile('/etc/fstab');\n  var f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n})()\n```\n\n对比一下两种写法：\n\n- async 函数内置了执行器，也就是说它不像 Generator 函数那样需要 co 来帮忙控制流程。\n- `async/await` 相比于 `*/yield` 来说语义更好。\n\n进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 `await` 命令就是内部 `then` 命令的语法糖。\n\n#### 语法\n\n- 返回一个 Promise 对象。\n- 只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。\n- 正常情况下，await 命令后面是一个 Promise 对象。如果不是，会被转成一个立即 resolve 的 Promise 对象。\n- 如果没有捕获异常，那么一个 Promise 的 reject 就会造成整个函数的中断。\n- 如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被 reject。\n- `await` 会等待异步操作完成，然后再回来继续执行，因为协程的原因，这里是不会阻塞其它代码的执行的。\n- 对于可以并发的异步操作，可以用 `Promise.all`。\n\n看过 co 源码的同学应该可以看出来，async 函数内部的行为和 co 模块十分地类似，可以说其实上就是 Generator + co 的一个语法糖。async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。\n\n#### 异步遍历器和异步 Generator 函数\n\n目前在提案第三阶段中有一个异步遍历器的特性，它是来干什么的呢？\n\n前面讲到的 `next` 都是同步执行的，因此我们使用了 Thunk 和 Promise 来在异步操作返回以后调用回调来做到异步流程管理。而异步遍历器不同，它的`next` 返回的是 Promise 对象。可以用 `for await...of` 来进行遍历。而异步 Generator 函数，就是用来返回异步遍历器的。\n\n不过个人认为这个有点累赘，把本身已经比较清晰的代码反而变得复杂了，所以这个特性就不深入做介绍了。\n\n#### 小结\n\nAsync 函数的内容不多，因为我们完全可以把它看做等同于 Generator + co 的东西。它的行为也与 Generator + co 基本一致。但是它为我们带来了更加清晰和简单的异步写法。至此异步编程就写完了，明白了很多东西，也知道了还有很多东西要去探索。\n\n","html":"<p>上面一篇讲到 Generator + co 的异步流程控制方案，在文章最后写到了这个方案的一些小瑕疵，而 Async 函数就是继续改进的一个方案，Node 7 已经支持了这个特性，而它在下一年也将正式进入 es 2017 的标准。那么就来看看这是个什么东西吧！</p>\n\n<pre><code>co(function* (){  \n  var f1 = yield readFile('/etc/fstab');\n  var f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n});\n\n// 等同于 async function 下面的写法\n\n(async function(){\n  var f1 = await readFile('/etc/fstab');\n  var f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n})()\n</code></pre>\n\n<p>对比一下两种写法：</p>\n\n<ul>\n<li>async 函数内置了执行器，也就是说它不像 Generator 函数那样需要 co 来帮忙控制流程。</li>\n<li><code>async/await</code> 相比于 <code>*/yield</code> 来说语义更好。</li>\n</ul>\n\n<p>进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 <code>await</code> 命令就是内部 <code>then</code> 命令的语法糖。</p>\n\n<h4 id=\"\">语法</h4>\n\n<ul>\n<li>返回一个 Promise 对象。</li>\n<li>只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。</li>\n<li>正常情况下，await 命令后面是一个 Promise 对象。如果不是，会被转成一个立即 resolve 的 Promise 对象。</li>\n<li>如果没有捕获异常，那么一个 Promise 的 reject 就会造成整个函数的中断。</li>\n<li>如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被 reject。</li>\n<li><code>await</code> 会等待异步操作完成，然后再回来继续执行，因为协程的原因，这里是不会阻塞其它代码的执行的。</li>\n<li>对于可以并发的异步操作，可以用 <code>Promise.all</code>。</li>\n</ul>\n\n<p>看过 co 源码的同学应该可以看出来，async 函数内部的行为和 co 模块十分地类似，可以说其实上就是 Generator + co 的一个语法糖。async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>\n\n<h4 id=\"generator\">异步遍历器和异步 Generator 函数</h4>\n\n<p>目前在提案第三阶段中有一个异步遍历器的特性，它是来干什么的呢？</p>\n\n<p>前面讲到的 <code>next</code> 都是同步执行的，因此我们使用了 Thunk 和 Promise 来在异步操作返回以后调用回调来做到异步流程管理。而异步遍历器不同，它的<code>next</code> 返回的是 Promise 对象。可以用 <code>for await...of</code> 来进行遍历。而异步 Generator 函数，就是用来返回异步遍历器的。</p>\n\n<p>不过个人认为这个有点累赘，把本身已经比较清晰的代码反而变得复杂了，所以这个特性就不深入做介绍了。</p>\n\n<h4 id=\"\">小结</h4>\n\n<p>Async 函数的内容不多，因为我们完全可以把它看做等同于 Generator + co 的东西。它的行为也与 Generator + co 基本一致。但是它为我们带来了更加清晰和简单的异步写法。至此异步编程就写完了，明白了很多东西，也知道了还有很多东西要去探索。</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476757891895,"created_by":1,"updated_at":1476760676946,"updated_by":1,"published_at":1476760676948,"published_by":1},{"id":123,"uuid":"7ad2f39e-b4e6-40ca-80aa-fa9449b24804","title":"公安备案？","slug":"gong-an-bei-an","markdown":"公安备案20天没有消息，打电话过去也没人接，不打算和备案耗下去了，准备在下个月无法访问前搞个国外的 vps。\n\n真是服了这群官老爷了！有些话不能说，心知肚明就好了！","html":"<p>公安备案20天没有消息，打电话过去也没人接，不打算和备案耗下去了，准备在下个月无法访问前搞个国外的 vps。</p>\n\n<p>真是服了这群官老爷了！有些话不能说，心知肚明就好了！</p>","image":null,"featured":0,"page":0,"status":"published","language":"zh_CN","meta_title":null,"meta_description":null,"author_id":1,"created_at":1476884660438,"created_by":1,"updated_at":1476885016075,"updated_by":1,"published_at":1476885016076,"published_by":1}],"users":[{"id":1,"uuid":"f183c222-672a-47e1-80a4-561830ba1d27","name":"m2mbob","slug":"m2mbob","password":"$2a$10$Xcdj.QcZXVRWoWmvgQTC/.QvFXigb4CHjfLM0kE.44gNKy/j0Z6oq","email":"2844870322@qq.com","image":"/content/images/2016/05/113.jpeg","cover":null,"bio":"","website":"https://xxn520.github.io/jiayi520/","location":"杭州","accessibility":null,"status":"active","language":"en_US","meta_title":null,"meta_description":null,"tour":null,"last_login":1476669248288,"created_at":1463567133080,"created_by":1,"updated_at":1476669248289,"updated_by":1}],"roles":[{"id":1,"uuid":"a205663c-0051-448b-8d64-c083afc8cd1f","name":"Administrator","description":"Administrators","created_at":1463567128189,"created_by":1,"updated_at":1463567128189,"updated_by":1},{"id":2,"uuid":"f3c3f834-15cf-4992-b37e-9fc241cce9ea","name":"Editor","description":"Editors","created_at":1463567128217,"created_by":1,"updated_at":1463567128217,"updated_by":1},{"id":3,"uuid":"974b0d0e-2a8c-4c45-9932-dbb233bc9cc8","name":"Author","description":"Authors","created_at":1463567128243,"created_by":1,"updated_at":1463567128243,"updated_by":1},{"id":4,"uuid":"e1e437c2-a08b-4152-bb91-130ff9670e31","name":"Owner","description":"Blog Owner","created_at":1463567128271,"created_by":1,"updated_at":1463567128271,"updated_by":1}],"roles_users":[{"id":1,"role_id":4,"user_id":1},{"id":2,"role_id":3,"user_id":2},{"id":3,"role_id":3,"user_id":3},{"id":4,"role_id":3,"user_id":4},{"id":5,"role_id":3,"user_id":5}],"permissions":[{"id":1,"uuid":"17ffb52c-5e47-4520-bb3a-923eee539fae","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":1463567128298,"created_by":1,"updated_at":1463567128298,"updated_by":1},{"id":2,"uuid":"0b603a34-66db-4290-9f1c-17411a32d5af","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":1463567128326,"created_by":1,"updated_at":1463567128326,"updated_by":1},{"id":3,"uuid":"63d14f73-132e-4504-9f3c-a5496e529604","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":1463567128351,"created_by":1,"updated_at":1463567128351,"updated_by":1},{"id":4,"uuid":"4b3cd8a9-e96e-45f1-8746-ba36e61d837b","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":1463567128379,"created_by":1,"updated_at":1463567128379,"updated_by":1},{"id":5,"uuid":"b3a9c3fe-26ef-4f19-895a-bb6b09cfa07a","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":1463567128407,"created_by":1,"updated_at":1463567128407,"updated_by":1},{"id":6,"uuid":"7d1c64de-07c8-49e8-87cf-eef785bd3500","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":1463567128431,"created_by":1,"updated_at":1463567128431,"updated_by":1},{"id":7,"uuid":"d490cd6d-e086-4e27-86f0-4a4638f020b0","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":1463567128456,"created_by":1,"updated_at":1463567128456,"updated_by":1},{"id":8,"uuid":"e00cf85a-7d10-4908-9952-164dbb7e76d5","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":1463567128480,"created_by":1,"updated_at":1463567128480,"updated_by":1},{"id":9,"uuid":"388edf22-9724-4936-840b-4972018c83f5","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":1463567128506,"created_by":1,"updated_at":1463567128506,"updated_by":1},{"id":10,"uuid":"8cafbddb-afdb-4ce8-82be-17dd7dab9b39","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":1463567128534,"created_by":1,"updated_at":1463567128534,"updated_by":1},{"id":11,"uuid":"2f54798f-05bc-45b4-a477-0cae3a8c15fb","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":1463567128556,"created_by":1,"updated_at":1463567128556,"updated_by":1},{"id":12,"uuid":"b85480a8-ff4d-4ed1-baad-595ea2452fca","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":1463567128578,"created_by":1,"updated_at":1463567128578,"updated_by":1},{"id":13,"uuid":"4760b85c-cc79-4ee4-87c1-643bc500136e","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":1463567128602,"created_by":1,"updated_at":1463567128602,"updated_by":1},{"id":14,"uuid":"b60aa8d7-8605-4c2e-84bb-35fd98b9e05b","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":1463567128631,"created_by":1,"updated_at":1463567128631,"updated_by":1},{"id":15,"uuid":"a7437212-afe7-4df4-9370-9e4cb8507d64","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":1463567128655,"created_by":1,"updated_at":1463567128655,"updated_by":1},{"id":16,"uuid":"c334e5b6-c398-4b0b-ad00-9b3c747aa564","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":1463567128688,"created_by":1,"updated_at":1463567128688,"updated_by":1},{"id":17,"uuid":"3338699f-c4e5-41b8-9ca4-4d22be830633","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":1463567128719,"created_by":1,"updated_at":1463567128719,"updated_by":1},{"id":18,"uuid":"b58d136d-763d-4cfc-bcc3-ab32fdc2d4d1","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":1463567128746,"created_by":1,"updated_at":1463567128746,"updated_by":1},{"id":19,"uuid":"76384049-8ad7-4233-9259-f7b511018001","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":1463567128770,"created_by":1,"updated_at":1463567128770,"updated_by":1},{"id":20,"uuid":"2c117ad5-76ab-438a-9e2e-2a707d15b2fa","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":1463567128795,"created_by":1,"updated_at":1463567128795,"updated_by":1},{"id":21,"uuid":"94bf77cf-2356-47ba-be2b-6e51ff3b4e0b","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":1463567128820,"created_by":1,"updated_at":1463567128820,"updated_by":1},{"id":22,"uuid":"6f3064f3-7109-4049-807b-0b5986a00077","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":1463567128848,"created_by":1,"updated_at":1463567128848,"updated_by":1},{"id":23,"uuid":"589fe891-4edb-4504-bcdd-443950122687","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":1463567128876,"created_by":1,"updated_at":1463567128876,"updated_by":1},{"id":24,"uuid":"91e1d531-9886-4cf5-ab90-868e851150ee","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":1463567128903,"created_by":1,"updated_at":1463567128903,"updated_by":1},{"id":25,"uuid":"f898d0b8-7a24-4da8-9ae0-d2d71082c0fe","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":1463567128926,"created_by":1,"updated_at":1463567128926,"updated_by":1},{"id":26,"uuid":"69769fb8-0707-41d9-a941-108e78458828","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":1463567128950,"created_by":1,"updated_at":1463567128950,"updated_by":1},{"id":27,"uuid":"f077887e-a6bb-4d7e-a5a2-669f2c709db7","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":1463567128976,"created_by":1,"updated_at":1463567128976,"updated_by":1},{"id":28,"uuid":"1a13365e-a47e-4355-92fd-5ca74fa7259e","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":1463567129004,"created_by":1,"updated_at":1463567129004,"updated_by":1},{"id":29,"uuid":"d331b27f-cd04-43f2-8e13-4cc90a9fe017","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":1463567129036,"created_by":1,"updated_at":1463567129036,"updated_by":1},{"id":30,"uuid":"d6a8f870-d4aa-4565-bbb9-08274700fcd7","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":1463567129059,"created_by":1,"updated_at":1463567129059,"updated_by":1}],"permissions_users":[],"permissions_roles":[{"id":1,"role_id":1,"permission_id":1},{"id":2,"role_id":1,"permission_id":2},{"id":3,"role_id":1,"permission_id":3},{"id":4,"role_id":1,"permission_id":4},{"id":5,"role_id":1,"permission_id":5},{"id":6,"role_id":1,"permission_id":6},{"id":7,"role_id":1,"permission_id":7},{"id":8,"role_id":1,"permission_id":8},{"id":9,"role_id":1,"permission_id":9},{"id":10,"role_id":1,"permission_id":10},{"id":11,"role_id":1,"permission_id":11},{"id":12,"role_id":1,"permission_id":12},{"id":13,"role_id":1,"permission_id":13},{"id":14,"role_id":1,"permission_id":14},{"id":15,"role_id":1,"permission_id":15},{"id":16,"role_id":1,"permission_id":16},{"id":17,"role_id":1,"permission_id":17},{"id":18,"role_id":1,"permission_id":18},{"id":19,"role_id":1,"permission_id":19},{"id":20,"role_id":1,"permission_id":20},{"id":21,"role_id":1,"permission_id":21},{"id":22,"role_id":1,"permission_id":22},{"id":23,"role_id":1,"permission_id":23},{"id":24,"role_id":1,"permission_id":24},{"id":25,"role_id":1,"permission_id":25},{"id":26,"role_id":1,"permission_id":26},{"id":27,"role_id":1,"permission_id":27},{"id":28,"role_id":1,"permission_id":28},{"id":29,"role_id":1,"permission_id":29},{"id":30,"role_id":1,"permission_id":30},{"id":31,"role_id":2,"permission_id":8},{"id":32,"role_id":2,"permission_id":9},{"id":33,"role_id":2,"permission_id":10},{"id":34,"role_id":2,"permission_id":11},{"id":35,"role_id":2,"permission_id":12},{"id":36,"role_id":2,"permission_id":13},{"id":37,"role_id":2,"permission_id":14},{"id":38,"role_id":2,"permission_id":16},{"id":39,"role_id":2,"permission_id":17},{"id":40,"role_id":2,"permission_id":18},{"id":41,"role_id":2,"permission_id":19},{"id":42,"role_id":2,"permission_id":20},{"id":43,"role_id":2,"permission_id":21},{"id":44,"role_id":2,"permission_id":24},{"id":45,"role_id":2,"permission_id":25},{"id":46,"role_id":2,"permission_id":26},{"id":47,"role_id":2,"permission_id":27},{"id":48,"role_id":2,"permission_id":28},{"id":49,"role_id":2,"permission_id":29},{"id":50,"role_id":2,"permission_id":30},{"id":51,"role_id":3,"permission_id":8},{"id":52,"role_id":3,"permission_id":9},{"id":53,"role_id":3,"permission_id":11},{"id":54,"role_id":3,"permission_id":13},{"id":55,"role_id":3,"permission_id":14},{"id":56,"role_id":3,"permission_id":16},{"id":57,"role_id":3,"permission_id":17},{"id":58,"role_id":3,"permission_id":18},{"id":59,"role_id":3,"permission_id":20},{"id":60,"role_id":3,"permission_id":24},{"id":61,"role_id":3,"permission_id":25},{"id":62,"role_id":3,"permission_id":30}],"permissions_apps":[],"settings":[{"id":1,"uuid":"07767b0a-31a8-4f7c-9089-0cac6be45867","key":"databaseVersion","value":"004","type":"core","created_at":1463567133162,"created_by":1,"updated_at":1463567133162,"updated_by":1},{"id":2,"uuid":"64a07b8e-9ca6-4464-940a-985f4241f6e7","key":"dbHash","value":"e00711f4-02e7-4f60-a9c5-b870666a2a83","type":"core","created_at":1463567133162,"created_by":1,"updated_at":1463567133836,"updated_by":1},{"id":3,"uuid":"d57d0b4c-9dbf-4810-a010-651b42825bf5","key":"nextUpdateCheck","value":"1476945511","type":"core","created_at":1463567133163,"created_by":1,"updated_at":1476859108381,"updated_by":1},{"id":4,"uuid":"b43fd992-cc8f-4f1e-bc47-c060dfdcae3f","key":"displayUpdateNotification","value":"0.7.0","type":"core","created_at":1463567133163,"created_by":1,"updated_at":1476859108384,"updated_by":1},{"id":5,"uuid":"0b0d23f5-c9f3-4a41-9c47-ba9170f1cec5","key":"title","value":"金色梦乡","type":"blog","created_at":1463567133163,"created_by":1,"updated_at":1475408407243,"updated_by":1},{"id":6,"uuid":"e53b4cef-36a8-4208-9605-9dd6062e7407","key":"description","value":"Thoughts, stories and ideas.","type":"blog","created_at":1463567133163,"created_by":1,"updated_at":1475408407245,"updated_by":1},{"id":7,"uuid":"adccbe11-7283-472b-b363-b517530d874c","key":"logo","value":"","type":"blog","created_at":1463567133163,"created_by":1,"updated_at":1475408407246,"updated_by":1},{"id":8,"uuid":"9ef9dbff-161f-45db-921e-4857f9d617b3","key":"cover","value":"/content/images/2016/08/f1a79dc7f4573842399295901c16baa8.jpg","type":"blog","created_at":1463567133164,"created_by":1,"updated_at":1475408407248,"updated_by":1},{"id":9,"uuid":"c205e750-b7b4-4a65-be94-e33aa231e523","key":"defaultLang","value":"en_US","type":"blog","created_at":1463567133164,"created_by":1,"updated_at":1475408407249,"updated_by":1},{"id":10,"uuid":"d7917f90-456e-42d0-a6fe-429f84898f0b","key":"postsPerPage","value":"10","type":"blog","created_at":1463567133164,"created_by":1,"updated_at":1475408407250,"updated_by":1},{"id":11,"uuid":"66503e4a-acf0-4aca-8dbc-0e36ae39bcdd","key":"forceI18n","value":"true","type":"blog","created_at":1463567133165,"created_by":1,"updated_at":1475408407251,"updated_by":1},{"id":12,"uuid":"8755c9a1-7e8c-42c6-a665-df37701f6072","key":"permalinks","value":"/:year/:month/:day/:slug/","type":"blog","created_at":1463567133165,"created_by":1,"updated_at":1475408407253,"updated_by":1},{"id":13,"uuid":"1b0a112b-d8b5-47b6-8b13-56c323eaa83e","key":"ghost_head","value":"","type":"blog","created_at":1463567133165,"created_by":1,"updated_at":1475408407255,"updated_by":1},{"id":14,"uuid":"9675e29f-a962-49a0-ad3a-f15533d0f7dc","key":"ghost_foot","value":"","type":"blog","created_at":1463567133165,"created_by":1,"updated_at":1475408407257,"updated_by":1},{"id":15,"uuid":"6d4ab5d5-75d4-4b1e-b5ec-6435f411cb3a","key":"labs","value":"{}","type":"blog","created_at":1463567133165,"created_by":1,"updated_at":1475408407258,"updated_by":1},{"id":16,"uuid":"a10d0aed-69e5-4de0-899c-8ad0fbc6c955","key":"navigation","value":"[{\"label\":\"Home\",\"url\":\"/\"},{\"label\":\"admin\",\"url\":\"/ghost/\"},{\"label\":\"mail\",\"url\":\"http://mail.m2mbob.cn/\"},{\"label\":\"github\",\"url\":\"https://github.com/xxn520\"},{\"label\":\"gitosc\",\"url\":\"http://git.oschina.net/m2mbob\"},{\"label\":\"es标准系列文章\",\"url\":\"/tag/esbiao-zhun-xi-lie/\"},{\"label\":\"js系列文章\",\"url\":\"/tag/js/\"},{\"label\":\"生活随笔\",\"url\":\"/tag/life/\"},{\"label\":\"react native\",\"url\":\"/tag/react-native/\"},{\"label\":\"es6 系列\",\"url\":\"/tag/es6\"},{\"label\":\"翻译系列\",\"url\":\"/tag/fan-yi/\"},{\"label\":\"关于我\",\"url\":\"/2016/05/18/about/\"}]","type":"blog","created_at":1463567133166,"created_by":1,"updated_at":1475408407259,"updated_by":1},{"id":17,"uuid":"821e540b-22d6-49b5-acb5-bc963b77100f","key":"activeApps","value":"[]","type":"app","created_at":1463567133166,"created_by":1,"updated_at":1463567133166,"updated_by":1},{"id":18,"uuid":"2a154f41-dcc1-4035-bbe9-886d2f715d8e","key":"installedApps","value":"[]","type":"app","created_at":1463567133167,"created_by":1,"updated_at":1475388698310,"updated_by":1},{"id":19,"uuid":"96f6c4a2-30d4-4490-968d-449261420d65","key":"isPrivate","value":"false","type":"private","created_at":1463567133167,"created_by":1,"updated_at":1475408407260,"updated_by":1},{"id":20,"uuid":"90857a68-2fe1-4798-9654-88a635a54ddb","key":"password","value":"null","type":"private","created_at":1463567133167,"created_by":1,"updated_at":1475408407262,"updated_by":1},{"id":21,"uuid":"fcd59843-2747-411c-8ab4-7e97a1c9c3b4","key":"activeTheme","value":"casper","type":"theme","created_at":1463567133166,"created_by":1,"updated_at":1475408407254,"updated_by":1}],"tags":[{"id":2,"uuid":"f73b4d4f-12cc-498c-a159-be13b472fec7","name":"redux源码分析系列","slug":"redux","description":"","image":"/content/images/2016/05/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67-1.png","hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1463754046804,"created_by":1,"updated_at":1463817817169,"updated_by":1},{"id":3,"uuid":"2ce8db62-0a14-47c4-b1b8-1e3b920c420a","name":"life","slug":"life","description":"关于生活","image":"/content/images/2016/05/u-1687420627-4175839764-fm-21-gp-0.jpg","hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1463817797112,"created_by":1,"updated_at":1463817887321,"updated_by":1},{"id":4,"uuid":"495550a6-a385-4ff4-8e4f-afb9870f94fa","name":"乱七八糟","slug":"digression","description":"杂谈","image":"/content/images/2016/05/u-1468361829-4039309630-fm-116-gp-0.jpg","hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1463834283409,"created_by":1,"updated_at":1463834926309,"updated_by":1},{"id":5,"uuid":"4723a273-0582-4a37-842d-c771a73f85f8","name":"mongodb","slug":"mongodb","description":"","image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1463838088406,"created_by":1,"updated_at":1463838094311,"updated_by":1},{"id":6,"uuid":"31ada047-4501-406d-917f-488e23b03f36","name":"mac","slug":"mac","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1463838131596,"created_by":1,"updated_at":1463838131596,"updated_by":1},{"id":7,"uuid":"91b7d980-5ce6-4340-aaf1-9a6b5dc80667","name":"koa","slug":"koa","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1463838270749,"created_by":1,"updated_at":1463838270749,"updated_by":1},{"id":8,"uuid":"be14e3b0-fb8f-4924-81b5-0924b220508c","name":"nodejs","slug":"nodejs","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1463838276529,"created_by":1,"updated_at":1463838283586,"updated_by":1},{"id":9,"uuid":"c332f075-6919-4dd1-9b6e-cdd1b93e86db","name":"react","slug":"react","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1464247836082,"created_by":1,"updated_at":1464247836082,"updated_by":1},{"id":10,"uuid":"5d8a3fba-d4a7-4e50-856f-2b3034b30d5d","name":"git","slug":"git","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1464335179221,"created_by":1,"updated_at":1464335179221,"updated_by":1},{"id":11,"uuid":"3dc60c76-7ce0-44e2-93eb-da3879afc085","name":"eslint","slug":"eslint","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1464346513640,"created_by":1,"updated_at":1464346513640,"updated_by":1},{"id":12,"uuid":"5f5ac01a-3d8d-4fde-bf30-52f04398df03","name":"react native","slug":"react-native","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1466558983520,"created_by":1,"updated_at":1466558983520,"updated_by":1},{"id":14,"uuid":"985d4ca6-c298-4e23-83d8-93dac19d7987","name":"有趣视频","slug":"you-qu-shi-pin","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1467111340949,"created_by":1,"updated_at":1467111340949,"updated_by":1},{"id":15,"uuid":"768f7c77-48fa-40ee-9b14-b8dd4d8e7393","name":"翻译","slug":"fan-yi","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1467688909351,"created_by":1,"updated_at":1467688909351,"updated_by":1},{"id":16,"uuid":"f3ad56e4-023f-45ee-bdd1-2bd05ea6f8d2","name":"随笔","slug":"sui-bi","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1468460842999,"created_by":1,"updated_at":1468460842999,"updated_by":1},{"id":17,"uuid":"a3c86f17-4e46-41f9-b79e-e8f12c534a1b","name":"常识","slug":"chang-shi","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1468469618360,"created_by":1,"updated_at":1468469618360,"updated_by":1},{"id":18,"uuid":"257fd3de-50cc-4358-a378-78a6e7d561d0","name":"js","slug":"js","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1468896571000,"created_by":1,"updated_at":1468896571000,"updated_by":1},{"id":19,"uuid":"052b64f0-5ab2-4dad-a3a7-63351c98ff62","name":"策略模式","slug":"ce-lue-mo-shi","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1469029769238,"created_by":1,"updated_at":1469029769238,"updated_by":1},{"id":20,"uuid":"cbb3738c-77e3-43ac-bb21-cc594f49b866","name":"android","slug":"android","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1469436760798,"created_by":1,"updated_at":1469436760798,"updated_by":1},{"id":21,"uuid":"edc646b2-0dd0-4190-b271-7f3ed0b0ee6e","name":"mobx","slug":"mobx","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1470231894998,"created_by":1,"updated_at":1470231894998,"updated_by":1},{"id":22,"uuid":"7d673880-09c5-477c-86a3-67dedc86dea9","name":"业务","slug":"ye-wu","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1470842891947,"created_by":1,"updated_at":1470842891947,"updated_by":1},{"id":23,"uuid":"db41c8ca-827a-46d9-9e20-aaeca92b8431","name":"jersey","slug":"jersey","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1470999361155,"created_by":1,"updated_at":1470999361155,"updated_by":1},{"id":24,"uuid":"b6597668-99d0-4422-9119-85a2d695b7a7","name":"fetch","slug":"fetch","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1471011841089,"created_by":1,"updated_at":1471011841089,"updated_by":1},{"id":25,"uuid":"66f8d61d-43bc-4967-9ab3-3a185db4bf8a","name":"web","slug":"web","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1471071283575,"created_by":1,"updated_at":1471071283575,"updated_by":1},{"id":26,"uuid":"6b8cc1f3-e78a-4b21-8f5c-8c9c4db8e4fb","name":"http","slug":"http","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1471164888580,"created_by":1,"updated_at":1471164888580,"updated_by":1},{"id":27,"uuid":"b7239a66-063e-417f-b648-34a7a3d5c222","name":"缓存","slug":"huan-cun","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1471164888585,"created_by":1,"updated_at":1471164888585,"updated_by":1},{"id":28,"uuid":"279f3c3e-ec4b-4f0d-b919-d2455ac963f9","name":"电影","slug":"dian-ying","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1471365183357,"created_by":1,"updated_at":1471365183357,"updated_by":1},{"id":29,"uuid":"20d5dbf8-355b-4d34-8268-8f7ceb664174","name":"centos","slug":"centos","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1472051602556,"created_by":1,"updated_at":1472051602556,"updated_by":1},{"id":30,"uuid":"60bd7479-a26e-4d5e-a04f-10f4c98c26fd","name":"nginx","slug":"nginx","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1472051602566,"created_by":1,"updated_at":1472051602566,"updated_by":1},{"id":31,"uuid":"5d8b3007-0add-40c2-b757-30a3bfe60f94","name":"正则","slug":"zheng-ze","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1473748641758,"created_by":1,"updated_at":1473748641758,"updated_by":1},{"id":32,"uuid":"a3fe9f4c-c6b1-4c43-8bad-1f724b0293a9","name":"编译原理","slug":"bian-yi-yuan-li","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1474176633919,"created_by":1,"updated_at":1474176633919,"updated_by":1},{"id":33,"uuid":"be306d32-5729-4be5-bc2c-917f7dc2f50f","name":"日剧","slug":"ri-ju","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1474242547574,"created_by":1,"updated_at":1474242547574,"updated_by":1},{"id":34,"uuid":"ae5dbc31-4c5d-475d-9e9d-5d98092a5238","name":"读书笔记","slug":"du-shu-bi-ji","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1474763827093,"created_by":1,"updated_at":1474763827093,"updated_by":1},{"id":35,"uuid":"d48206a4-43b6-4970-a21f-3b6ee881513c","name":"es标准系列","slug":"esbiao-zhun-xi-lie","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1475051001970,"created_by":1,"updated_at":1475051001970,"updated_by":1},{"id":36,"uuid":"3db74973-f723-4e51-b80f-916f9c50c141","name":"es6","slug":"es6","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1475057515118,"created_by":1,"updated_at":1475057515118,"updated_by":1},{"id":37,"uuid":"b6187dc1-044c-4889-8943-4c3338e4729e","name":"babel","slug":"babel","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1475057515125,"created_by":1,"updated_at":1475057515125,"updated_by":1}],"posts_tags":[{"id":2,"post_id":2,"tag_id":2,"sort_order":0},{"id":3,"post_id":3,"tag_id":4,"sort_order":0},{"id":4,"post_id":3,"tag_id":6,"sort_order":1},{"id":5,"post_id":4,"tag_id":5,"sort_order":0},{"id":6,"post_id":4,"tag_id":6,"sort_order":1},{"id":7,"post_id":5,"tag_id":7,"sort_order":0},{"id":8,"post_id":5,"tag_id":8,"sort_order":1},{"id":9,"post_id":6,"tag_id":4,"sort_order":0},{"id":10,"post_id":9,"tag_id":4,"sort_order":0},{"id":11,"post_id":8,"tag_id":9,"sort_order":0},{"id":12,"post_id":10,"tag_id":10,"sort_order":0},{"id":13,"post_id":11,"tag_id":11,"sort_order":0},{"id":14,"post_id":13,"tag_id":12,"sort_order":0},{"id":15,"post_id":15,"tag_id":12,"sort_order":0},{"id":17,"post_id":19,"tag_id":14,"sort_order":1},{"id":18,"post_id":23,"tag_id":12,"sort_order":0},{"id":19,"post_id":12,"tag_id":9,"sort_order":0},{"id":20,"post_id":12,"tag_id":15,"sort_order":1},{"id":21,"post_id":24,"tag_id":9,"sort_order":0},{"id":22,"post_id":24,"tag_id":15,"sort_order":1},{"id":23,"post_id":27,"tag_id":16,"sort_order":0},{"id":24,"post_id":28,"tag_id":17,"sort_order":0},{"id":25,"post_id":30,"tag_id":18,"sort_order":0},{"id":26,"post_id":31,"tag_id":12,"sort_order":0},{"id":27,"post_id":31,"tag_id":18,"sort_order":1},{"id":28,"post_id":31,"tag_id":19,"sort_order":2},{"id":29,"post_id":34,"tag_id":20,"sort_order":1},{"id":30,"post_id":34,"tag_id":10,"sort_order":0},{"id":31,"post_id":33,"tag_id":12,"sort_order":0},{"id":32,"post_id":33,"tag_id":20,"sort_order":1},{"id":33,"post_id":35,"tag_id":12,"sort_order":0},{"id":34,"post_id":35,"tag_id":20,"sort_order":1},{"id":35,"post_id":37,"tag_id":12,"sort_order":0},{"id":36,"post_id":37,"tag_id":20,"sort_order":1},{"id":37,"post_id":39,"tag_id":16,"sort_order":0},{"id":38,"post_id":39,"tag_id":3,"sort_order":1},{"id":40,"post_id":32,"tag_id":14,"sort_order":1},{"id":41,"post_id":42,"tag_id":9,"sort_order":0},{"id":42,"post_id":42,"tag_id":21,"sort_order":1},{"id":44,"post_id":44,"tag_id":16,"sort_order":1},{"id":45,"post_id":44,"tag_id":3,"sort_order":2},{"id":46,"post_id":45,"tag_id":3,"sort_order":0},{"id":48,"post_id":45,"tag_id":16,"sort_order":2},{"id":49,"post_id":36,"tag_id":22,"sort_order":0},{"id":50,"post_id":46,"tag_id":12,"sort_order":0},{"id":51,"post_id":26,"tag_id":23,"sort_order":0},{"id":52,"post_id":7,"tag_id":24,"sort_order":0},{"id":53,"post_id":7,"tag_id":12,"sort_order":1},{"id":55,"post_id":29,"tag_id":3,"sort_order":1},{"id":56,"post_id":29,"tag_id":14,"sort_order":2},{"id":57,"post_id":47,"tag_id":25,"sort_order":0},{"id":58,"post_id":48,"tag_id":3,"sort_order":0},{"id":60,"post_id":49,"tag_id":26,"sort_order":0},{"id":61,"post_id":49,"tag_id":27,"sort_order":1},{"id":62,"post_id":51,"tag_id":3,"sort_order":0},{"id":64,"post_id":51,"tag_id":28,"sort_order":2},{"id":65,"post_id":52,"tag_id":10,"sort_order":0},{"id":66,"post_id":54,"tag_id":26,"sort_order":0},{"id":67,"post_id":54,"tag_id":29,"sort_order":1},{"id":68,"post_id":54,"tag_id":30,"sort_order":2},{"id":69,"post_id":55,"tag_id":26,"sort_order":0},{"id":70,"post_id":55,"tag_id":30,"sort_order":1},{"id":71,"post_id":55,"tag_id":29,"sort_order":2},{"id":72,"post_id":56,"tag_id":30,"sort_order":0},{"id":73,"post_id":56,"tag_id":26,"sort_order":1},{"id":74,"post_id":56,"tag_id":29,"sort_order":2},{"id":75,"post_id":50,"tag_id":16,"sort_order":0},{"id":76,"post_id":50,"tag_id":3,"sort_order":1},{"id":78,"post_id":57,"tag_id":18,"sort_order":0},{"id":79,"post_id":60,"tag_id":18,"sort_order":0},{"id":80,"post_id":62,"tag_id":18,"sort_order":0},{"id":81,"post_id":62,"tag_id":31,"sort_order":1},{"id":82,"post_id":63,"tag_id":18,"sort_order":0},{"id":83,"post_id":58,"tag_id":18,"sort_order":0},{"id":85,"post_id":64,"tag_id":3,"sort_order":2},{"id":86,"post_id":64,"tag_id":16,"sort_order":3},{"id":87,"post_id":65,"tag_id":16,"sort_order":0},{"id":89,"post_id":65,"tag_id":3,"sort_order":2},{"id":90,"post_id":66,"tag_id":18,"sort_order":0},{"id":91,"post_id":68,"tag_id":32,"sort_order":0},{"id":92,"post_id":69,"tag_id":32,"sort_order":0},{"id":93,"post_id":67,"tag_id":33,"sort_order":0},{"id":94,"post_id":64,"tag_id":33,"sort_order":0},{"id":95,"post_id":70,"tag_id":33,"sort_order":0},{"id":96,"post_id":71,"tag_id":32,"sort_order":0},{"id":97,"post_id":72,"tag_id":18,"sort_order":0},{"id":98,"post_id":73,"tag_id":18,"sort_order":0},{"id":99,"post_id":74,"tag_id":18,"sort_order":0},{"id":100,"post_id":75,"tag_id":16,"sort_order":0},{"id":102,"post_id":75,"tag_id":3,"sort_order":2},{"id":103,"post_id":75,"tag_id":33,"sort_order":3},{"id":104,"post_id":77,"tag_id":18,"sort_order":0},{"id":105,"post_id":76,"tag_id":18,"sort_order":0},{"id":106,"post_id":79,"tag_id":18,"sort_order":0},{"id":107,"post_id":80,"tag_id":18,"sort_order":0},{"id":108,"post_id":78,"tag_id":16,"sort_order":0},{"id":110,"post_id":78,"tag_id":3,"sort_order":2},{"id":111,"post_id":81,"tag_id":16,"sort_order":0},{"id":113,"post_id":81,"tag_id":3,"sort_order":2},{"id":114,"post_id":82,"tag_id":18,"sort_order":0},{"id":115,"post_id":83,"tag_id":16,"sort_order":0},{"id":116,"post_id":83,"tag_id":34,"sort_order":3},{"id":118,"post_id":83,"tag_id":3,"sort_order":2},{"id":119,"post_id":84,"tag_id":18,"sort_order":0},{"id":120,"post_id":85,"tag_id":18,"sort_order":0},{"id":121,"post_id":86,"tag_id":18,"sort_order":0},{"id":122,"post_id":87,"tag_id":18,"sort_order":0},{"id":123,"post_id":88,"tag_id":18,"sort_order":0},{"id":124,"post_id":89,"tag_id":33,"sort_order":0},{"id":125,"post_id":89,"tag_id":16,"sort_order":1},{"id":127,"post_id":89,"tag_id":3,"sort_order":3},{"id":128,"post_id":90,"tag_id":18,"sort_order":0},{"id":129,"post_id":91,"tag_id":18,"sort_order":0},{"id":130,"post_id":92,"tag_id":18,"sort_order":0},{"id":131,"post_id":93,"tag_id":18,"sort_order":0},{"id":132,"post_id":94,"tag_id":18,"sort_order":0},{"id":133,"post_id":95,"tag_id":18,"sort_order":0},{"id":134,"post_id":95,"tag_id":35,"sort_order":1},{"id":135,"post_id":94,"tag_id":35,"sort_order":1},{"id":136,"post_id":93,"tag_id":35,"sort_order":1},{"id":137,"post_id":92,"tag_id":35,"sort_order":1},{"id":138,"post_id":90,"tag_id":35,"sort_order":1},{"id":139,"post_id":88,"tag_id":35,"sort_order":1},{"id":140,"post_id":87,"tag_id":35,"sort_order":1},{"id":141,"post_id":82,"tag_id":35,"sort_order":1},{"id":142,"post_id":80,"tag_id":35,"sort_order":1},{"id":143,"post_id":79,"tag_id":35,"sort_order":1},{"id":144,"post_id":76,"tag_id":35,"sort_order":1},{"id":145,"post_id":74,"tag_id":35,"sort_order":1},{"id":146,"post_id":73,"tag_id":35,"sort_order":1},{"id":147,"post_id":72,"tag_id":35,"sort_order":1},{"id":148,"post_id":58,"tag_id":35,"sort_order":1},{"id":149,"post_id":16,"tag_id":35,"sort_order":0},{"id":150,"post_id":96,"tag_id":35,"sort_order":0},{"id":151,"post_id":96,"tag_id":36,"sort_order":1},{"id":152,"post_id":96,"tag_id":37,"sort_order":2},{"id":153,"post_id":97,"tag_id":16,"sort_order":0},{"id":154,"post_id":97,"tag_id":3,"sort_order":1},{"id":155,"post_id":97,"tag_id":33,"sort_order":2},{"id":156,"post_id":98,"tag_id":37,"sort_order":0},{"id":157,"post_id":98,"tag_id":36,"sort_order":1},{"id":158,"post_id":98,"tag_id":35,"sort_order":2},{"id":159,"post_id":99,"tag_id":36,"sort_order":0},{"id":160,"post_id":99,"tag_id":35,"sort_order":1},{"id":161,"post_id":99,"tag_id":37,"sort_order":2},{"id":162,"post_id":99,"tag_id":18,"sort_order":3},{"id":163,"post_id":98,"tag_id":18,"sort_order":3},{"id":164,"post_id":96,"tag_id":18,"sort_order":3},{"id":165,"post_id":42,"tag_id":15,"sort_order":2},{"id":166,"post_id":11,"tag_id":15,"sort_order":1},{"id":167,"post_id":101,"tag_id":36,"sort_order":0},{"id":168,"post_id":101,"tag_id":35,"sort_order":1},{"id":169,"post_id":101,"tag_id":18,"sort_order":2},{"id":170,"post_id":102,"tag_id":3,"sort_order":0},{"id":171,"post_id":102,"tag_id":16,"sort_order":1},{"id":172,"post_id":104,"tag_id":36,"sort_order":0},{"id":173,"post_id":104,"tag_id":35,"sort_order":1},{"id":174,"post_id":104,"tag_id":18,"sort_order":2},{"id":175,"post_id":103,"tag_id":18,"sort_order":0},{"id":176,"post_id":103,"tag_id":36,"sort_order":1},{"id":177,"post_id":103,"tag_id":35,"sort_order":2},{"id":178,"post_id":105,"tag_id":18,"sort_order":0},{"id":179,"post_id":106,"tag_id":36,"sort_order":0},{"id":180,"post_id":106,"tag_id":35,"sort_order":1},{"id":181,"post_id":106,"tag_id":18,"sort_order":2},{"id":182,"post_id":100,"tag_id":3,"sort_order":0},{"id":183,"post_id":100,"tag_id":16,"sort_order":1},{"id":184,"post_id":107,"tag_id":12,"sort_order":0},{"id":185,"post_id":108,"tag_id":33,"sort_order":0},{"id":186,"post_id":108,"tag_id":3,"sort_order":1},{"id":187,"post_id":108,"tag_id":16,"sort_order":2},{"id":188,"post_id":109,"tag_id":36,"sort_order":0},{"id":189,"post_id":109,"tag_id":35,"sort_order":1},{"id":190,"post_id":109,"tag_id":18,"sort_order":2},{"id":191,"post_id":110,"tag_id":36,"sort_order":0},{"id":192,"post_id":110,"tag_id":35,"sort_order":1},{"id":193,"post_id":110,"tag_id":18,"sort_order":2},{"id":194,"post_id":111,"tag_id":3,"sort_order":0},{"id":195,"post_id":111,"tag_id":16,"sort_order":1},{"id":196,"post_id":114,"tag_id":16,"sort_order":0},{"id":197,"post_id":115,"tag_id":18,"sort_order":0},{"id":198,"post_id":116,"tag_id":16,"sort_order":0},{"id":199,"post_id":116,"tag_id":3,"sort_order":1},{"id":200,"post_id":116,"tag_id":33,"sort_order":2},{"id":201,"post_id":117,"tag_id":34,"sort_order":0},{"id":202,"post_id":119,"tag_id":15,"sort_order":0},{"id":203,"post_id":119,"tag_id":18,"sort_order":1},{"id":204,"post_id":120,"tag_id":16,"sort_order":0},{"id":205,"post_id":120,"tag_id":3,"sort_order":1},{"id":206,"post_id":113,"tag_id":18,"sort_order":0},{"id":207,"post_id":121,"tag_id":18,"sort_order":0},{"id":208,"post_id":122,"tag_id":18,"sort_order":0},{"id":209,"post_id":112,"tag_id":36,"sort_order":0},{"id":210,"post_id":112,"tag_id":35,"sort_order":1},{"id":211,"post_id":112,"tag_id":18,"sort_order":2},{"id":212,"post_id":118,"tag_id":36,"sort_order":0},{"id":213,"post_id":118,"tag_id":35,"sort_order":1},{"id":214,"post_id":118,"tag_id":18,"sort_order":2},{"id":215,"post_id":118,"tag_id":9,"sort_order":3}],"apps":[],"app_settings":[],"app_fields":[],"client_trusted_domains":[]}}]}